diff -uNr cs550-16s-proj1-base/bio.c cs550-16s-proj1-working/bio.c
--- cs550-16s-proj1-base/bio.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/bio.c	2016-03-04 14:36:37.000000000 -0500
@@ -24,7 +24,6 @@
 #include "defs.h"
 #include "param.h"
 #include "spinlock.h"
-#include "fs.h"
 #include "buf.h"
 
 struct {
@@ -56,20 +55,20 @@
   }
 }
 
-// Look through buffer cache for block on device dev.
+// Look through buffer cache for sector on device dev.
 // If not found, allocate a buffer.
 // In either case, return B_BUSY buffer.
 static struct buf*
-bget(uint dev, uint blockno)
+bget(uint dev, uint sector)
 {
   struct buf *b;
 
   acquire(&bcache.lock);
 
  loop:
-  // Is the block already cached?
+  // Is the sector already cached?
   for(b = bcache.head.next; b != &bcache.head; b = b->next){
-    if(b->dev == dev && b->blockno == blockno){
+    if(b->dev == dev && b->sector == sector){
       if(!(b->flags & B_BUSY)){
         b->flags |= B_BUSY;
         release(&bcache.lock);
@@ -86,7 +85,7 @@
   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
       b->dev = dev;
-      b->blockno = blockno;
+      b->sector = sector;
       b->flags = B_BUSY;
       release(&bcache.lock);
       return b;
@@ -95,16 +94,15 @@
   panic("bget: no buffers");
 }
 
-// Return a B_BUSY buf with the contents of the indicated block.
+// Return a B_BUSY buf with the contents of the indicated disk sector.
 struct buf*
-bread(uint dev, uint blockno)
+bread(uint dev, uint sector)
 {
   struct buf *b;
 
-  b = bget(dev, blockno);
-  if(!(b->flags & B_VALID)) {
+  b = bget(dev, sector);
+  if(!(b->flags & B_VALID))
     iderw(b);
-  }
   return b;
 }
 
diff -uNr cs550-16s-proj1-base/bio.d cs550-16s-proj1-working/bio.d
--- cs550-16s-proj1-base/bio.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/bio.d	2016-03-04 14:37:16.000000000 -0500
@@ -0,0 +1 @@
+bio.o: bio.c types.h defs.h param.h spinlock.h buf.h
Binary files cs550-16s-proj1-base/bio.o and cs550-16s-proj1-working/bio.o differ
diff -uNr cs550-16s-proj1-base/bootasm.d cs550-16s-proj1-working/bootasm.d
--- cs550-16s-proj1-base/bootasm.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/bootasm.d	2016-03-04 14:37:14.000000000 -0500
@@ -0,0 +1 @@
+bootasm.o: bootasm.S asm.h memlayout.h mmu.h
Binary files cs550-16s-proj1-base/bootasm.o and cs550-16s-proj1-working/bootasm.o differ
Binary files cs550-16s-proj1-base/bootblock and cs550-16s-proj1-working/bootblock differ
diff -uNr cs550-16s-proj1-base/bootblock.asm cs550-16s-proj1-working/bootblock.asm
--- cs550-16s-proj1-base/bootblock.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/bootblock.asm	2016-03-04 14:37:15.000000000 -0500
@@ -0,0 +1,403 @@
+
+bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+# with %cs=0 %ip=7c00.
+
+.code16                       # Assemble for 16-bit mode
+.globl start
+start:
+  cli                         # BIOS enabled interrupts; disable
+    7c00:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax             # Set %ax to zero
+    7c01:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds             # -> Data Segment
+    7c03:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es             # -> Extra Segment
+    7c05:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss             # -> Stack Segment
+    7c07:	8e d0                	mov    %eax,%ss
+
+00007c09 <seta20.1>:
+
+  # Physical address line A20 is tied to zero so that the first PCs 
+  # with 2 MB would run software that assumed 1 MB.  Undo that.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+    7c09:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c0b:	a8 02                	test   $0x2,%al
+  jnz     seta20.1
+    7c0d:	75 fa                	jne    7c09 <seta20.1>
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+    7c0f:	b0 d1                	mov    $0xd1,%al
+  outb    %al,$0x64
+    7c11:	e6 64                	out    %al,$0x64
+
+00007c13 <seta20.2>:
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+    7c13:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c15:	a8 02                	test   $0x2,%al
+  jnz     seta20.2
+    7c17:	75 fa                	jne    7c13 <seta20.2>
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+    7c19:	b0 df                	mov    $0xdf,%al
+  outb    %al,$0x60
+    7c1b:	e6 60                	out    %al,$0x60
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7c1d:	0f 01 16             	lgdtl  (%esi)
+    7c20:	78 7c                	js     7c9e <readsect+0xc>
+  movl    %cr0, %eax
+    7c22:	0f 20 c0             	mov    %cr0,%eax
+  orl     $CR0_PE, %eax
+    7c25:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7c29:	0f 22 c0             	mov    %eax,%cr0
+
+//PAGEBREAK!
+  # Complete transition to 32-bit protected mode by using long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmp    $(SEG_KCODE<<3), $start32
+    7c2c:	ea 31 7c 08 00 66 b8 	ljmp   $0xb866,$0x87c31
+
+00007c31 <start32>:
+
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7c31:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7c35:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7c37:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7c39:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    7c3b:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    7c3f:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7c41:	8e e8                	mov    %eax,%gs
+
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+  call    bootmain
+    7c48:	e8 e9 00 00 00       	call   7d36 <bootmain>
+
+  # If bootmain returns (it shouldn't), trigger a Bochs
+  # breakpoint if running under Bochs, then loop.
+  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    7c51:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7c54:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7c5a:	66 ef                	out    %ax,(%dx)
+
+00007c5c <spin>:
+spin:
+  jmp     spin
+    7c5c:	eb fe                	jmp    7c5c <spin>
+    7c5e:	66 90                	xchg   %ax,%ax
+
+00007c60 <gdt>:
+	...
+    7c68:	ff                   	(bad)  
+    7c69:	ff 00                	incl   (%eax)
+    7c6b:	00 00                	add    %al,(%eax)
+    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c74:	00 92 cf 00 17 00    	add    %dl,0x1700cf(%edx)
+
+00007c78 <gdtdesc>:
+    7c78:	17                   	pop    %ss
+    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
+    7c7c:	00 00                	add    %al,(%eax)
+    7c7e:	90                   	nop
+    7c7f:	90                   	nop
+
+00007c80 <waitdisk>:
+  entry();
+}
+
+void
+waitdisk(void)
+{
+    7c80:	55                   	push   %ebp
+    7c81:	89 e5                	mov    %esp,%ebp
+static inline uchar
+inb(ushort port)
+{
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+    7c83:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c88:	ec                   	in     (%dx),%al
+  // Wait for disk ready.
+  while((inb(0x1F7) & 0xC0) != 0x40)
+    7c89:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c8c:	3c 40                	cmp    $0x40,%al
+    7c8e:	75 f8                	jne    7c88 <waitdisk+0x8>
+    ;
+}
+    7c90:	5d                   	pop    %ebp
+    7c91:	c3                   	ret    
+
+00007c92 <readsect>:
+
+// Read a single sector at offset into dst.
+void
+readsect(void *dst, uint offset)
+{
+    7c92:	55                   	push   %ebp
+    7c93:	89 e5                	mov    %esp,%ebp
+    7c95:	57                   	push   %edi
+    7c96:	53                   	push   %ebx
+    7c97:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  // Issue command.
+  waitdisk();
+    7c9a:	e8 e1 ff ff ff       	call   7c80 <waitdisk>
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+    7c9f:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7ca4:	b8 01 00 00 00       	mov    $0x1,%eax
+    7ca9:	ee                   	out    %al,(%dx)
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    readsect(pa, offset);
+}
+    7caa:	0f b6 c3             	movzbl %bl,%eax
+    7cad:	b2 f3                	mov    $0xf3,%dl
+    7caf:	ee                   	out    %al,(%dx)
+    7cb0:	0f b6 c7             	movzbl %bh,%eax
+    7cb3:	b2 f4                	mov    $0xf4,%dl
+    7cb5:	ee                   	out    %al,(%dx)
+  // Issue command.
+  waitdisk();
+  outb(0x1F2, 1);   // count = 1
+  outb(0x1F3, offset);
+  outb(0x1F4, offset >> 8);
+  outb(0x1F5, offset >> 16);
+    7cb6:	89 d8                	mov    %ebx,%eax
+    7cb8:	c1 e8 10             	shr    $0x10,%eax
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    readsect(pa, offset);
+}
+    7cbb:	25 ff 00 00 00       	and    $0xff,%eax
+    7cc0:	b2 f5                	mov    $0xf5,%dl
+    7cc2:	ee                   	out    %al,(%dx)
+    7cc3:	c1 eb 18             	shr    $0x18,%ebx
+    7cc6:	89 d8                	mov    %ebx,%eax
+    7cc8:	0c e0                	or     $0xe0,%al
+    7cca:	b2 f6                	mov    $0xf6,%dl
+    7ccc:	ee                   	out    %al,(%dx)
+    7ccd:	b2 f7                	mov    $0xf7,%dl
+    7ccf:	b8 20 00 00 00       	mov    $0x20,%eax
+    7cd4:	ee                   	out    %al,(%dx)
+  outb(0x1F5, offset >> 16);
+  outb(0x1F6, (offset >> 24) | 0xE0);
+  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+
+  // Read data.
+  waitdisk();
+    7cd5:	e8 a6 ff ff ff       	call   7c80 <waitdisk>
+}
+
+static inline void
+insl(int port, void *addr, int cnt)
+{
+  asm volatile("cld; rep insl" :
+    7cda:	8b 7d 08             	mov    0x8(%ebp),%edi
+    7cdd:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7ce2:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7ce7:	fc                   	cld    
+    7ce8:	f3 6d                	rep insl (%dx),%es:(%edi)
+  insl(0x1F0, dst, SECTSIZE/4);
+}
+    7cea:	5b                   	pop    %ebx
+    7ceb:	5f                   	pop    %edi
+    7cec:	5d                   	pop    %ebp
+    7ced:	c3                   	ret    
+
+00007cee <readseg>:
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked.
+void
+readseg(uchar* pa, uint count, uint offset)
+{
+    7cee:	55                   	push   %ebp
+    7cef:	89 e5                	mov    %esp,%ebp
+    7cf1:	57                   	push   %edi
+    7cf2:	56                   	push   %esi
+    7cf3:	53                   	push   %ebx
+    7cf4:	83 ec 08             	sub    $0x8,%esp
+    7cf7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    7cfa:	8b 75 10             	mov    0x10(%ebp),%esi
+  uchar* epa;
+
+  epa = pa + count;
+    7cfd:	89 df                	mov    %ebx,%edi
+    7cff:	03 7d 0c             	add    0xc(%ebp),%edi
+
+  // Round down to sector boundary.
+  pa -= offset % SECTSIZE;
+    7d02:	89 f0                	mov    %esi,%eax
+    7d04:	25 ff 01 00 00       	and    $0x1ff,%eax
+    7d09:	29 c3                	sub    %eax,%ebx
+
+  // Translate from bytes to sectors; kernel starts at sector 1.
+  offset = (offset / SECTSIZE) + 1;
+    7d0b:	c1 ee 09             	shr    $0x9,%esi
+    7d0e:	83 c6 01             	add    $0x1,%esi
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d11:	39 df                	cmp    %ebx,%edi
+    7d13:	76 19                	jbe    7d2e <readseg+0x40>
+    readsect(pa, offset);
+    7d15:	89 74 24 04          	mov    %esi,0x4(%esp)
+    7d19:	89 1c 24             	mov    %ebx,(%esp)
+    7d1c:	e8 71 ff ff ff       	call   7c92 <readsect>
+  offset = (offset / SECTSIZE) + 1;
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d21:	81 c3 00 02 00 00    	add    $0x200,%ebx
+    7d27:	83 c6 01             	add    $0x1,%esi
+    7d2a:	39 df                	cmp    %ebx,%edi
+    7d2c:	77 e7                	ja     7d15 <readseg+0x27>
+    readsect(pa, offset);
+}
+    7d2e:	83 c4 08             	add    $0x8,%esp
+    7d31:	5b                   	pop    %ebx
+    7d32:	5e                   	pop    %esi
+    7d33:	5f                   	pop    %edi
+    7d34:	5d                   	pop    %ebp
+    7d35:	c3                   	ret    
+
+00007d36 <bootmain>:
+
+void readseg(uchar*, uint, uint);
+
+void
+bootmain(void)
+{
+    7d36:	55                   	push   %ebp
+    7d37:	89 e5                	mov    %esp,%ebp
+    7d39:	57                   	push   %edi
+    7d3a:	56                   	push   %esi
+    7d3b:	53                   	push   %ebx
+    7d3c:	83 ec 1c             	sub    $0x1c,%esp
+  uchar* pa;
+
+  elf = (struct elfhdr*)0x10000;  // scratch space
+
+  // Read 1st page off disk
+  readseg((uchar*)elf, 4096, 0);
+    7d3f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    7d46:	00 
+    7d47:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+    7d4e:	00 
+    7d4f:	c7 04 24 00 00 01 00 	movl   $0x10000,(%esp)
+    7d56:	e8 93 ff ff ff       	call   7cee <readseg>
+
+  // Is this an ELF executable?
+  if(elf->magic != ELF_MAGIC)
+    7d5b:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d62:	45 4c 46 
+    7d65:	75 58                	jne    7dbf <bootmain+0x89>
+    return;  // let bootasm.S handle error
+
+  // Load each program segment (ignores ph flags).
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+    7d67:	8b 1d 1c 00 01 00    	mov    0x1001c,%ebx
+    7d6d:	81 c3 00 00 01 00    	add    $0x10000,%ebx
+  eph = ph + elf->phnum;
+    7d73:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    7d7a:	c1 e6 05             	shl    $0x5,%esi
+    7d7d:	01 de                	add    %ebx,%esi
+  for(; ph < eph; ph++){
+    7d7f:	39 f3                	cmp    %esi,%ebx
+    7d81:	73 36                	jae    7db9 <bootmain+0x83>
+    pa = (uchar*)ph->paddr;
+    7d83:	8b 7b 0c             	mov    0xc(%ebx),%edi
+    readseg(pa, ph->filesz, ph->off);
+    7d86:	8b 43 04             	mov    0x4(%ebx),%eax
+    7d89:	89 44 24 08          	mov    %eax,0x8(%esp)
+    7d8d:	8b 43 10             	mov    0x10(%ebx),%eax
+    7d90:	89 44 24 04          	mov    %eax,0x4(%esp)
+    7d94:	89 3c 24             	mov    %edi,(%esp)
+    7d97:	e8 52 ff ff ff       	call   7cee <readseg>
+    if(ph->memsz > ph->filesz)
+    7d9c:	8b 4b 14             	mov    0x14(%ebx),%ecx
+    7d9f:	8b 43 10             	mov    0x10(%ebx),%eax
+    7da2:	39 c1                	cmp    %eax,%ecx
+    7da4:	76 0c                	jbe    7db2 <bootmain+0x7c>
+      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+    7da6:	01 c7                	add    %eax,%edi
+    7da8:	29 c1                	sub    %eax,%ecx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    7daa:	b8 00 00 00 00       	mov    $0x0,%eax
+    7daf:	fc                   	cld    
+    7db0:	f3 aa                	rep stos %al,%es:(%edi)
+    return;  // let bootasm.S handle error
+
+  // Load each program segment (ignores ph flags).
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+  eph = ph + elf->phnum;
+  for(; ph < eph; ph++){
+    7db2:	83 c3 20             	add    $0x20,%ebx
+    7db5:	39 de                	cmp    %ebx,%esi
+    7db7:	77 ca                	ja     7d83 <bootmain+0x4d>
+  }
+
+  // Call the entry point from the ELF header.
+  // Does not return!
+  entry = (void(*)(void))(elf->entry);
+  entry();
+    7db9:	ff 15 18 00 01 00    	call   *0x10018
+}
+    7dbf:	83 c4 1c             	add    $0x1c,%esp
+    7dc2:	5b                   	pop    %ebx
+    7dc3:	5e                   	pop    %esi
+    7dc4:	5f                   	pop    %edi
+    7dc5:	5d                   	pop    %ebp
+    7dc6:	c3                   	ret    
Binary files cs550-16s-proj1-base/bootblock.o and cs550-16s-proj1-working/bootblock.o differ
Binary files cs550-16s-proj1-base/bootblockother.o and cs550-16s-proj1-working/bootblockother.o differ
diff -uNr cs550-16s-proj1-base/bootmain.c cs550-16s-proj1-working/bootmain.c
--- cs550-16s-proj1-base/bootmain.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/bootmain.c	2016-03-04 14:36:38.000000000 -0500
@@ -1,6 +1,6 @@
 // Boot loader.
 // 
-// Part of the boot block, along with bootasm.S, which calls bootmain().
+// Part of the boot sector, along with bootasm.S, which calls bootmain().
 // bootasm.S has put the processor into protected 32-bit mode.
 // bootmain() loads an ELF kernel image from the disk starting at
 // sector 1 and then jumps to the kernel entry routine.
diff -uNr cs550-16s-proj1-base/bootmain.d cs550-16s-proj1-working/bootmain.d
--- cs550-16s-proj1-base/bootmain.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/bootmain.d	2016-03-04 14:37:14.000000000 -0500
@@ -0,0 +1 @@
+bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
Binary files cs550-16s-proj1-base/bootmain.o and cs550-16s-proj1-working/bootmain.o differ
diff -uNr cs550-16s-proj1-base/buf.h cs550-16s-proj1-working/buf.h
--- cs550-16s-proj1-base/buf.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/buf.h	2016-03-04 14:36:38.000000000 -0500
@@ -1,11 +1,11 @@
 struct buf {
   int flags;
   uint dev;
-  uint blockno;
+  uint sector;
   struct buf *prev; // LRU cache list
   struct buf *next;
   struct buf *qnext; // disk queue
-  uchar data[BSIZE];
+  uchar data[512];
 };
 #define B_BUSY  0x1  // buffer is locked by some process
 #define B_VALID 0x2  // buffer has been read from disk
Binary files cs550-16s-proj1-base/_cat and cs550-16s-proj1-working/_cat differ
diff -uNr cs550-16s-proj1-base/cat.asm cs550-16s-proj1-working/cat.asm
--- cs550-16s-proj1-base/cat.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/cat.asm	2016-03-04 14:36:53.000000000 -0500
@@ -0,0 +1,1295 @@
+
+_cat:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <cat>:
+
+char buf[512];
+
+void
+cat(int fd)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 ec 28             	sub    $0x28,%esp
+  int n;
+
+  while((n = read(fd, buf, sizeof(buf))) > 0)
+   6:	eb 1b                	jmp    23 <cat+0x23>
+    write(1, buf, n);
+   8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+   b:	89 44 24 08          	mov    %eax,0x8(%esp)
+   f:	c7 44 24 04 c0 0b 00 	movl   $0xbc0,0x4(%esp)
+  16:	00 
+  17:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1e:	e8 85 03 00 00       	call   3a8 <write>
+void
+cat(int fd)
+{
+  int n;
+
+  while((n = read(fd, buf, sizeof(buf))) > 0)
+  23:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+  2a:	00 
+  2b:	c7 44 24 04 c0 0b 00 	movl   $0xbc0,0x4(%esp)
+  32:	00 
+  33:	8b 45 08             	mov    0x8(%ebp),%eax
+  36:	89 04 24             	mov    %eax,(%esp)
+  39:	e8 62 03 00 00       	call   3a0 <read>
+  3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  45:	7f c1                	jg     8 <cat+0x8>
+    write(1, buf, n);
+  if(n < 0){
+  47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  4b:	79 19                	jns    66 <cat+0x66>
+    printf(1, "cat: read error\n");
+  4d:	c7 44 24 04 fd 08 00 	movl   $0x8fd,0x4(%esp)
+  54:	00 
+  55:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  5c:	e8 cc 04 00 00       	call   52d <printf>
+    exit();
+  61:	e8 22 03 00 00       	call   388 <exit>
+  }
+}
+  66:	c9                   	leave  
+  67:	c3                   	ret    
+
+00000068 <main>:
+
+int
+main(int argc, char *argv[])
+{
+  68:	55                   	push   %ebp
+  69:	89 e5                	mov    %esp,%ebp
+  6b:	83 e4 f0             	and    $0xfffffff0,%esp
+  6e:	83 ec 20             	sub    $0x20,%esp
+  int fd, i;
+
+  if(argc <= 1){
+  71:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+  75:	7f 11                	jg     88 <main+0x20>
+    cat(0);
+  77:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  7e:	e8 7d ff ff ff       	call   0 <cat>
+    exit();
+  83:	e8 00 03 00 00       	call   388 <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+  88:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+  8f:	00 
+  90:	eb 79                	jmp    10b <main+0xa3>
+    if((fd = open(argv[i], 0)) < 0){
+  92:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  96:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  9d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  a0:	01 d0                	add    %edx,%eax
+  a2:	8b 00                	mov    (%eax),%eax
+  a4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  ab:	00 
+  ac:	89 04 24             	mov    %eax,(%esp)
+  af:	e8 14 03 00 00       	call   3c8 <open>
+  b4:	89 44 24 18          	mov    %eax,0x18(%esp)
+  b8:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
+  bd:	79 2f                	jns    ee <main+0x86>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+  bf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+  cd:	01 d0                	add    %edx,%eax
+  cf:	8b 00                	mov    (%eax),%eax
+  d1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  d5:	c7 44 24 04 0e 09 00 	movl   $0x90e,0x4(%esp)
+  dc:	00 
+  dd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  e4:	e8 44 04 00 00       	call   52d <printf>
+      exit();
+  e9:	e8 9a 02 00 00       	call   388 <exit>
+    }
+    cat(fd);
+  ee:	8b 44 24 18          	mov    0x18(%esp),%eax
+  f2:	89 04 24             	mov    %eax,(%esp)
+  f5:	e8 06 ff ff ff       	call   0 <cat>
+    close(fd);
+  fa:	8b 44 24 18          	mov    0x18(%esp),%eax
+  fe:	89 04 24             	mov    %eax,(%esp)
+ 101:	e8 aa 02 00 00       	call   3b0 <close>
+  if(argc <= 1){
+    cat(0);
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+ 106:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+ 10b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 10f:	3b 45 08             	cmp    0x8(%ebp),%eax
+ 112:	0f 8c 7a ff ff ff    	jl     92 <main+0x2a>
+      exit();
+    }
+    cat(fd);
+    close(fd);
+  }
+  exit();
+ 118:	e8 6b 02 00 00       	call   388 <exit>
+ 11d:	90                   	nop
+ 11e:	90                   	nop
+ 11f:	90                   	nop
+
+00000120 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 120:	55                   	push   %ebp
+ 121:	89 e5                	mov    %esp,%ebp
+ 123:	57                   	push   %edi
+ 124:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 125:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 128:	8b 55 10             	mov    0x10(%ebp),%edx
+ 12b:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 12e:	89 cb                	mov    %ecx,%ebx
+ 130:	89 df                	mov    %ebx,%edi
+ 132:	89 d1                	mov    %edx,%ecx
+ 134:	fc                   	cld    
+ 135:	f3 aa                	rep stos %al,%es:(%edi)
+ 137:	89 ca                	mov    %ecx,%edx
+ 139:	89 fb                	mov    %edi,%ebx
+ 13b:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 13e:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 141:	5b                   	pop    %ebx
+ 142:	5f                   	pop    %edi
+ 143:	5d                   	pop    %ebp
+ 144:	c3                   	ret    
+
+00000145 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 145:	55                   	push   %ebp
+ 146:	89 e5                	mov    %esp,%ebp
+ 148:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 14b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 14e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 151:	90                   	nop
+ 152:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 155:	0f b6 10             	movzbl (%eax),%edx
+ 158:	8b 45 08             	mov    0x8(%ebp),%eax
+ 15b:	88 10                	mov    %dl,(%eax)
+ 15d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 160:	0f b6 00             	movzbl (%eax),%eax
+ 163:	84 c0                	test   %al,%al
+ 165:	0f 95 c0             	setne  %al
+ 168:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 16c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 170:	84 c0                	test   %al,%al
+ 172:	75 de                	jne    152 <strcpy+0xd>
+    ;
+  return os;
+ 174:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 177:	c9                   	leave  
+ 178:	c3                   	ret    
+
+00000179 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 179:	55                   	push   %ebp
+ 17a:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 17c:	eb 08                	jmp    186 <strcmp+0xd>
+    p++, q++;
+ 17e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 182:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 186:	8b 45 08             	mov    0x8(%ebp),%eax
+ 189:	0f b6 00             	movzbl (%eax),%eax
+ 18c:	84 c0                	test   %al,%al
+ 18e:	74 10                	je     1a0 <strcmp+0x27>
+ 190:	8b 45 08             	mov    0x8(%ebp),%eax
+ 193:	0f b6 10             	movzbl (%eax),%edx
+ 196:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 199:	0f b6 00             	movzbl (%eax),%eax
+ 19c:	38 c2                	cmp    %al,%dl
+ 19e:	74 de                	je     17e <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 1a0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1a3:	0f b6 00             	movzbl (%eax),%eax
+ 1a6:	0f b6 d0             	movzbl %al,%edx
+ 1a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1ac:	0f b6 00             	movzbl (%eax),%eax
+ 1af:	0f b6 c0             	movzbl %al,%eax
+ 1b2:	89 d1                	mov    %edx,%ecx
+ 1b4:	29 c1                	sub    %eax,%ecx
+ 1b6:	89 c8                	mov    %ecx,%eax
+}
+ 1b8:	5d                   	pop    %ebp
+ 1b9:	c3                   	ret    
+
+000001ba <strlen>:
+
+uint
+strlen(char *s)
+{
+ 1ba:	55                   	push   %ebp
+ 1bb:	89 e5                	mov    %esp,%ebp
+ 1bd:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1c0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 1c7:	eb 04                	jmp    1cd <strlen+0x13>
+ 1c9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 1cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1d0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1d3:	01 d0                	add    %edx,%eax
+ 1d5:	0f b6 00             	movzbl (%eax),%eax
+ 1d8:	84 c0                	test   %al,%al
+ 1da:	75 ed                	jne    1c9 <strlen+0xf>
+    ;
+  return n;
+ 1dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1df:	c9                   	leave  
+ 1e0:	c3                   	ret    
+
+000001e1 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1e1:	55                   	push   %ebp
+ 1e2:	89 e5                	mov    %esp,%ebp
+ 1e4:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 1e7:	8b 45 10             	mov    0x10(%ebp),%eax
+ 1ea:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 1ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1f8:	89 04 24             	mov    %eax,(%esp)
+ 1fb:	e8 20 ff ff ff       	call   120 <stosb>
+  return dst;
+ 200:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 203:	c9                   	leave  
+ 204:	c3                   	ret    
+
+00000205 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 205:	55                   	push   %ebp
+ 206:	89 e5                	mov    %esp,%ebp
+ 208:	83 ec 04             	sub    $0x4,%esp
+ 20b:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 20e:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 211:	eb 14                	jmp    227 <strchr+0x22>
+    if(*s == c)
+ 213:	8b 45 08             	mov    0x8(%ebp),%eax
+ 216:	0f b6 00             	movzbl (%eax),%eax
+ 219:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 21c:	75 05                	jne    223 <strchr+0x1e>
+      return (char*)s;
+ 21e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 221:	eb 13                	jmp    236 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 223:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 227:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22a:	0f b6 00             	movzbl (%eax),%eax
+ 22d:	84 c0                	test   %al,%al
+ 22f:	75 e2                	jne    213 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 231:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 236:	c9                   	leave  
+ 237:	c3                   	ret    
+
+00000238 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 238:	55                   	push   %ebp
+ 239:	89 e5                	mov    %esp,%ebp
+ 23b:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 23e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 245:	eb 46                	jmp    28d <gets+0x55>
+    cc = read(0, &c, 1);
+ 247:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 24e:	00 
+ 24f:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 252:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 256:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 25d:	e8 3e 01 00 00       	call   3a0 <read>
+ 262:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 265:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 269:	7e 2f                	jle    29a <gets+0x62>
+      break;
+    buf[i++] = c;
+ 26b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 26e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 271:	01 c2                	add    %eax,%edx
+ 273:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 277:	88 02                	mov    %al,(%edx)
+ 279:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 27d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 281:	3c 0a                	cmp    $0xa,%al
+ 283:	74 16                	je     29b <gets+0x63>
+ 285:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 289:	3c 0d                	cmp    $0xd,%al
+ 28b:	74 0e                	je     29b <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 28d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 290:	83 c0 01             	add    $0x1,%eax
+ 293:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 296:	7c af                	jl     247 <gets+0xf>
+ 298:	eb 01                	jmp    29b <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 29a:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 29b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 29e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2a1:	01 d0                	add    %edx,%eax
+ 2a3:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 2a6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2a9:	c9                   	leave  
+ 2aa:	c3                   	ret    
+
+000002ab <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 2ab:	55                   	push   %ebp
+ 2ac:	89 e5                	mov    %esp,%ebp
+ 2ae:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2b1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 2b8:	00 
+ 2b9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2bc:	89 04 24             	mov    %eax,(%esp)
+ 2bf:	e8 04 01 00 00       	call   3c8 <open>
+ 2c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 2c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 2cb:	79 07                	jns    2d4 <stat+0x29>
+    return -1;
+ 2cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 2d2:	eb 23                	jmp    2f7 <stat+0x4c>
+  r = fstat(fd, st);
+ 2d4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2de:	89 04 24             	mov    %eax,(%esp)
+ 2e1:	e8 fa 00 00 00       	call   3e0 <fstat>
+ 2e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 2e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2ec:	89 04 24             	mov    %eax,(%esp)
+ 2ef:	e8 bc 00 00 00       	call   3b0 <close>
+  return r;
+ 2f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 2f7:	c9                   	leave  
+ 2f8:	c3                   	ret    
+
+000002f9 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2f9:	55                   	push   %ebp
+ 2fa:	89 e5                	mov    %esp,%ebp
+ 2fc:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 2ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 306:	eb 23                	jmp    32b <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 308:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 30b:	89 d0                	mov    %edx,%eax
+ 30d:	c1 e0 02             	shl    $0x2,%eax
+ 310:	01 d0                	add    %edx,%eax
+ 312:	01 c0                	add    %eax,%eax
+ 314:	89 c2                	mov    %eax,%edx
+ 316:	8b 45 08             	mov    0x8(%ebp),%eax
+ 319:	0f b6 00             	movzbl (%eax),%eax
+ 31c:	0f be c0             	movsbl %al,%eax
+ 31f:	01 d0                	add    %edx,%eax
+ 321:	83 e8 30             	sub    $0x30,%eax
+ 324:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 327:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 32b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 32e:	0f b6 00             	movzbl (%eax),%eax
+ 331:	3c 2f                	cmp    $0x2f,%al
+ 333:	7e 0a                	jle    33f <atoi+0x46>
+ 335:	8b 45 08             	mov    0x8(%ebp),%eax
+ 338:	0f b6 00             	movzbl (%eax),%eax
+ 33b:	3c 39                	cmp    $0x39,%al
+ 33d:	7e c9                	jle    308 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 33f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 342:	c9                   	leave  
+ 343:	c3                   	ret    
+
+00000344 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 344:	55                   	push   %ebp
+ 345:	89 e5                	mov    %esp,%ebp
+ 347:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 34a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 34d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 350:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 353:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 356:	eb 13                	jmp    36b <memmove+0x27>
+    *dst++ = *src++;
+ 358:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 35b:	0f b6 10             	movzbl (%eax),%edx
+ 35e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 361:	88 10                	mov    %dl,(%eax)
+ 363:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 367:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 36b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 36f:	0f 9f c0             	setg   %al
+ 372:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 376:	84 c0                	test   %al,%al
+ 378:	75 de                	jne    358 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 37a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 37d:	c9                   	leave  
+ 37e:	c3                   	ret    
+ 37f:	90                   	nop
+
+00000380 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 380:	b8 01 00 00 00       	mov    $0x1,%eax
+ 385:	cd 40                	int    $0x40
+ 387:	c3                   	ret    
+
+00000388 <exit>:
+SYSCALL(exit)
+ 388:	b8 02 00 00 00       	mov    $0x2,%eax
+ 38d:	cd 40                	int    $0x40
+ 38f:	c3                   	ret    
+
+00000390 <wait>:
+SYSCALL(wait)
+ 390:	b8 03 00 00 00       	mov    $0x3,%eax
+ 395:	cd 40                	int    $0x40
+ 397:	c3                   	ret    
+
+00000398 <pipe>:
+SYSCALL(pipe)
+ 398:	b8 04 00 00 00       	mov    $0x4,%eax
+ 39d:	cd 40                	int    $0x40
+ 39f:	c3                   	ret    
+
+000003a0 <read>:
+SYSCALL(read)
+ 3a0:	b8 05 00 00 00       	mov    $0x5,%eax
+ 3a5:	cd 40                	int    $0x40
+ 3a7:	c3                   	ret    
+
+000003a8 <write>:
+SYSCALL(write)
+ 3a8:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3ad:	cd 40                	int    $0x40
+ 3af:	c3                   	ret    
+
+000003b0 <close>:
+SYSCALL(close)
+ 3b0:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3b5:	cd 40                	int    $0x40
+ 3b7:	c3                   	ret    
+
+000003b8 <kill>:
+SYSCALL(kill)
+ 3b8:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3bd:	cd 40                	int    $0x40
+ 3bf:	c3                   	ret    
+
+000003c0 <exec>:
+SYSCALL(exec)
+ 3c0:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3c5:	cd 40                	int    $0x40
+ 3c7:	c3                   	ret    
+
+000003c8 <open>:
+SYSCALL(open)
+ 3c8:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3cd:	cd 40                	int    $0x40
+ 3cf:	c3                   	ret    
+
+000003d0 <mknod>:
+SYSCALL(mknod)
+ 3d0:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3d5:	cd 40                	int    $0x40
+ 3d7:	c3                   	ret    
+
+000003d8 <unlink>:
+SYSCALL(unlink)
+ 3d8:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3dd:	cd 40                	int    $0x40
+ 3df:	c3                   	ret    
+
+000003e0 <fstat>:
+SYSCALL(fstat)
+ 3e0:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3e5:	cd 40                	int    $0x40
+ 3e7:	c3                   	ret    
+
+000003e8 <link>:
+SYSCALL(link)
+ 3e8:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3ed:	cd 40                	int    $0x40
+ 3ef:	c3                   	ret    
+
+000003f0 <mkdir>:
+SYSCALL(mkdir)
+ 3f0:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3f5:	cd 40                	int    $0x40
+ 3f7:	c3                   	ret    
+
+000003f8 <chdir>:
+SYSCALL(chdir)
+ 3f8:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3fd:	cd 40                	int    $0x40
+ 3ff:	c3                   	ret    
+
+00000400 <dup>:
+SYSCALL(dup)
+ 400:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 405:	cd 40                	int    $0x40
+ 407:	c3                   	ret    
+
+00000408 <getpid>:
+SYSCALL(getpid)
+ 408:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 40d:	cd 40                	int    $0x40
+ 40f:	c3                   	ret    
+
+00000410 <sbrk>:
+SYSCALL(sbrk)
+ 410:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 415:	cd 40                	int    $0x40
+ 417:	c3                   	ret    
+
+00000418 <sleep>:
+SYSCALL(sleep)
+ 418:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 41d:	cd 40                	int    $0x40
+ 41f:	c3                   	ret    
+
+00000420 <uptime>:
+SYSCALL(uptime)
+ 420:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 425:	cd 40                	int    $0x40
+ 427:	c3                   	ret    
+
+00000428 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 428:	b8 16 00 00 00       	mov    $0x16,%eax
+ 42d:	cd 40                	int    $0x40
+ 42f:	c3                   	ret    
+
+00000430 <shutdown>:
+SYSCALL(shutdown)
+ 430:	b8 17 00 00 00       	mov    $0x17,%eax
+ 435:	cd 40                	int    $0x40
+ 437:	c3                   	ret    
+
+00000438 <fork_winner>:
+SYSCALL(fork_winner)
+ 438:	b8 18 00 00 00       	mov    $0x18,%eax
+ 43d:	cd 40                	int    $0x40
+ 43f:	c3                   	ret    
+
+00000440 <set_sched>:
+SYSCALL(set_sched)
+ 440:	b8 19 00 00 00       	mov    $0x19,%eax
+ 445:	cd 40                	int    $0x40
+ 447:	c3                   	ret    
+
+00000448 <set_priority>:
+SYSCALL(set_priority)
+ 448:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 44d:	cd 40                	int    $0x40
+ 44f:	c3                   	ret    
+
+00000450 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 450:	55                   	push   %ebp
+ 451:	89 e5                	mov    %esp,%ebp
+ 453:	83 ec 28             	sub    $0x28,%esp
+ 456:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 459:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 45c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 463:	00 
+ 464:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 467:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 46b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 46e:	89 04 24             	mov    %eax,(%esp)
+ 471:	e8 32 ff ff ff       	call   3a8 <write>
+}
+ 476:	c9                   	leave  
+ 477:	c3                   	ret    
+
+00000478 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 478:	55                   	push   %ebp
+ 479:	89 e5                	mov    %esp,%ebp
+ 47b:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 47e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 485:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 489:	74 17                	je     4a2 <printint+0x2a>
+ 48b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 48f:	79 11                	jns    4a2 <printint+0x2a>
+    neg = 1;
+ 491:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 498:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 49b:	f7 d8                	neg    %eax
+ 49d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4a0:	eb 06                	jmp    4a8 <printint+0x30>
+  } else {
+    x = xx;
+ 4a2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 4a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 4af:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4b5:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4ba:	f7 f1                	div    %ecx
+ 4bc:	89 d0                	mov    %edx,%eax
+ 4be:	0f b6 80 88 0b 00 00 	movzbl 0xb88(%eax),%eax
+ 4c5:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 4c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4cb:	01 ca                	add    %ecx,%edx
+ 4cd:	88 02                	mov    %al,(%edx)
+ 4cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 4d3:	8b 55 10             	mov    0x10(%ebp),%edx
+ 4d6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 4d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4dc:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4e1:	f7 75 d4             	divl   -0x2c(%ebp)
+ 4e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4eb:	75 c2                	jne    4af <printint+0x37>
+  if(neg)
+ 4ed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 4f1:	74 2e                	je     521 <printint+0xa9>
+    buf[i++] = '-';
+ 4f3:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 4f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4f9:	01 d0                	add    %edx,%eax
+ 4fb:	c6 00 2d             	movb   $0x2d,(%eax)
+ 4fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 502:	eb 1d                	jmp    521 <printint+0xa9>
+    putc(fd, buf[i]);
+ 504:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 507:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 50a:	01 d0                	add    %edx,%eax
+ 50c:	0f b6 00             	movzbl (%eax),%eax
+ 50f:	0f be c0             	movsbl %al,%eax
+ 512:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 516:	8b 45 08             	mov    0x8(%ebp),%eax
+ 519:	89 04 24             	mov    %eax,(%esp)
+ 51c:	e8 2f ff ff ff       	call   450 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 521:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 525:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 529:	79 d9                	jns    504 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 52b:	c9                   	leave  
+ 52c:	c3                   	ret    
+
+0000052d <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 52d:	55                   	push   %ebp
+ 52e:	89 e5                	mov    %esp,%ebp
+ 530:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 533:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 53a:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 53d:	83 c0 04             	add    $0x4,%eax
+ 540:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 543:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 54a:	e9 7d 01 00 00       	jmp    6cc <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 54f:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 552:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 555:	01 d0                	add    %edx,%eax
+ 557:	0f b6 00             	movzbl (%eax),%eax
+ 55a:	0f be c0             	movsbl %al,%eax
+ 55d:	25 ff 00 00 00       	and    $0xff,%eax
+ 562:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 565:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 569:	75 2c                	jne    597 <printf+0x6a>
+      if(c == '%'){
+ 56b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 56f:	75 0c                	jne    57d <printf+0x50>
+        state = '%';
+ 571:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 578:	e9 4b 01 00 00       	jmp    6c8 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 57d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 580:	0f be c0             	movsbl %al,%eax
+ 583:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 587:	8b 45 08             	mov    0x8(%ebp),%eax
+ 58a:	89 04 24             	mov    %eax,(%esp)
+ 58d:	e8 be fe ff ff       	call   450 <putc>
+ 592:	e9 31 01 00 00       	jmp    6c8 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 597:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 59b:	0f 85 27 01 00 00    	jne    6c8 <printf+0x19b>
+      if(c == 'd'){
+ 5a1:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 5a5:	75 2d                	jne    5d4 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 5a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5aa:	8b 00                	mov    (%eax),%eax
+ 5ac:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 5b3:	00 
+ 5b4:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 5bb:	00 
+ 5bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5c0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5c3:	89 04 24             	mov    %eax,(%esp)
+ 5c6:	e8 ad fe ff ff       	call   478 <printint>
+        ap++;
+ 5cb:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5cf:	e9 ed 00 00 00       	jmp    6c1 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 5d4:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 5d8:	74 06                	je     5e0 <printf+0xb3>
+ 5da:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 5de:	75 2d                	jne    60d <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 5e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5e3:	8b 00                	mov    (%eax),%eax
+ 5e5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 5ec:	00 
+ 5ed:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 5f4:	00 
+ 5f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5f9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5fc:	89 04 24             	mov    %eax,(%esp)
+ 5ff:	e8 74 fe ff ff       	call   478 <printint>
+        ap++;
+ 604:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 608:	e9 b4 00 00 00       	jmp    6c1 <printf+0x194>
+      } else if(c == 's'){
+ 60d:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 611:	75 46                	jne    659 <printf+0x12c>
+        s = (char*)*ap;
+ 613:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 616:	8b 00                	mov    (%eax),%eax
+ 618:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 61b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 61f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 623:	75 27                	jne    64c <printf+0x11f>
+          s = "(null)";
+ 625:	c7 45 f4 23 09 00 00 	movl   $0x923,-0xc(%ebp)
+        while(*s != 0){
+ 62c:	eb 1e                	jmp    64c <printf+0x11f>
+          putc(fd, *s);
+ 62e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 631:	0f b6 00             	movzbl (%eax),%eax
+ 634:	0f be c0             	movsbl %al,%eax
+ 637:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 63b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 63e:	89 04 24             	mov    %eax,(%esp)
+ 641:	e8 0a fe ff ff       	call   450 <putc>
+          s++;
+ 646:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 64a:	eb 01                	jmp    64d <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 64c:	90                   	nop
+ 64d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 650:	0f b6 00             	movzbl (%eax),%eax
+ 653:	84 c0                	test   %al,%al
+ 655:	75 d7                	jne    62e <printf+0x101>
+ 657:	eb 68                	jmp    6c1 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 659:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 65d:	75 1d                	jne    67c <printf+0x14f>
+        putc(fd, *ap);
+ 65f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 662:	8b 00                	mov    (%eax),%eax
+ 664:	0f be c0             	movsbl %al,%eax
+ 667:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 66b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 66e:	89 04 24             	mov    %eax,(%esp)
+ 671:	e8 da fd ff ff       	call   450 <putc>
+        ap++;
+ 676:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 67a:	eb 45                	jmp    6c1 <printf+0x194>
+      } else if(c == '%'){
+ 67c:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 680:	75 17                	jne    699 <printf+0x16c>
+        putc(fd, c);
+ 682:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 685:	0f be c0             	movsbl %al,%eax
+ 688:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 68c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 68f:	89 04 24             	mov    %eax,(%esp)
+ 692:	e8 b9 fd ff ff       	call   450 <putc>
+ 697:	eb 28                	jmp    6c1 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 699:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 6a0:	00 
+ 6a1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6a4:	89 04 24             	mov    %eax,(%esp)
+ 6a7:	e8 a4 fd ff ff       	call   450 <putc>
+        putc(fd, c);
+ 6ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 6af:	0f be c0             	movsbl %al,%eax
+ 6b2:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6b6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6b9:	89 04 24             	mov    %eax,(%esp)
+ 6bc:	e8 8f fd ff ff       	call   450 <putc>
+      }
+      state = 0;
+ 6c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 6c8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 6cc:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 6cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6d2:	01 d0                	add    %edx,%eax
+ 6d4:	0f b6 00             	movzbl (%eax),%eax
+ 6d7:	84 c0                	test   %al,%al
+ 6d9:	0f 85 70 fe ff ff    	jne    54f <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 6df:	c9                   	leave  
+ 6e0:	c3                   	ret    
+ 6e1:	90                   	nop
+ 6e2:	90                   	nop
+ 6e3:	90                   	nop
+
+000006e4 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6e4:	55                   	push   %ebp
+ 6e5:	89 e5                	mov    %esp,%ebp
+ 6e7:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 6ea:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6ed:	83 e8 08             	sub    $0x8,%eax
+ 6f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6f3:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 6f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 6fb:	eb 24                	jmp    721 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 700:	8b 00                	mov    (%eax),%eax
+ 702:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 705:	77 12                	ja     719 <free+0x35>
+ 707:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 70a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 70d:	77 24                	ja     733 <free+0x4f>
+ 70f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 712:	8b 00                	mov    (%eax),%eax
+ 714:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 717:	77 1a                	ja     733 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 719:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71c:	8b 00                	mov    (%eax),%eax
+ 71e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 721:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 724:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 727:	76 d4                	jbe    6fd <free+0x19>
+ 729:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 72c:	8b 00                	mov    (%eax),%eax
+ 72e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 731:	76 ca                	jbe    6fd <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 733:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 736:	8b 40 04             	mov    0x4(%eax),%eax
+ 739:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 740:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 743:	01 c2                	add    %eax,%edx
+ 745:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 748:	8b 00                	mov    (%eax),%eax
+ 74a:	39 c2                	cmp    %eax,%edx
+ 74c:	75 24                	jne    772 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 74e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 751:	8b 50 04             	mov    0x4(%eax),%edx
+ 754:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 757:	8b 00                	mov    (%eax),%eax
+ 759:	8b 40 04             	mov    0x4(%eax),%eax
+ 75c:	01 c2                	add    %eax,%edx
+ 75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 761:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 764:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 767:	8b 00                	mov    (%eax),%eax
+ 769:	8b 10                	mov    (%eax),%edx
+ 76b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 76e:	89 10                	mov    %edx,(%eax)
+ 770:	eb 0a                	jmp    77c <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 772:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 775:	8b 10                	mov    (%eax),%edx
+ 777:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 77a:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 77c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 77f:	8b 40 04             	mov    0x4(%eax),%eax
+ 782:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 789:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 78c:	01 d0                	add    %edx,%eax
+ 78e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 791:	75 20                	jne    7b3 <free+0xcf>
+    p->s.size += bp->s.size;
+ 793:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 796:	8b 50 04             	mov    0x4(%eax),%edx
+ 799:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 79c:	8b 40 04             	mov    0x4(%eax),%eax
+ 79f:	01 c2                	add    %eax,%edx
+ 7a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7a4:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 7a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7aa:	8b 10                	mov    (%eax),%edx
+ 7ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7af:	89 10                	mov    %edx,(%eax)
+ 7b1:	eb 08                	jmp    7bb <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 7b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b6:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 7b9:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 7bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7be:	a3 a8 0b 00 00       	mov    %eax,0xba8
+}
+ 7c3:	c9                   	leave  
+ 7c4:	c3                   	ret    
+
+000007c5 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 7c5:	55                   	push   %ebp
+ 7c6:	89 e5                	mov    %esp,%ebp
+ 7c8:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 7cb:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 7d2:	77 07                	ja     7db <morecore+0x16>
+    nu = 4096;
+ 7d4:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 7db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7de:	c1 e0 03             	shl    $0x3,%eax
+ 7e1:	89 04 24             	mov    %eax,(%esp)
+ 7e4:	e8 27 fc ff ff       	call   410 <sbrk>
+ 7e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 7ec:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 7f0:	75 07                	jne    7f9 <morecore+0x34>
+    return 0;
+ 7f2:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7f7:	eb 22                	jmp    81b <morecore+0x56>
+  hp = (Header*)p;
+ 7f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 7ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 802:	8b 55 08             	mov    0x8(%ebp),%edx
+ 805:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 808:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 80b:	83 c0 08             	add    $0x8,%eax
+ 80e:	89 04 24             	mov    %eax,(%esp)
+ 811:	e8 ce fe ff ff       	call   6e4 <free>
+  return freep;
+ 816:	a1 a8 0b 00 00       	mov    0xba8,%eax
+}
+ 81b:	c9                   	leave  
+ 81c:	c3                   	ret    
+
+0000081d <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 81d:	55                   	push   %ebp
+ 81e:	89 e5                	mov    %esp,%ebp
+ 820:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 823:	8b 45 08             	mov    0x8(%ebp),%eax
+ 826:	83 c0 07             	add    $0x7,%eax
+ 829:	c1 e8 03             	shr    $0x3,%eax
+ 82c:	83 c0 01             	add    $0x1,%eax
+ 82f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 832:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 837:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 83a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 83e:	75 23                	jne    863 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 840:	c7 45 f0 a0 0b 00 00 	movl   $0xba0,-0x10(%ebp)
+ 847:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 84a:	a3 a8 0b 00 00       	mov    %eax,0xba8
+ 84f:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 854:	a3 a0 0b 00 00       	mov    %eax,0xba0
+    base.s.size = 0;
+ 859:	c7 05 a4 0b 00 00 00 	movl   $0x0,0xba4
+ 860:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 863:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 866:	8b 00                	mov    (%eax),%eax
+ 868:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 86b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86e:	8b 40 04             	mov    0x4(%eax),%eax
+ 871:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 874:	72 4d                	jb     8c3 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 876:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 879:	8b 40 04             	mov    0x4(%eax),%eax
+ 87c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 87f:	75 0c                	jne    88d <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 881:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 884:	8b 10                	mov    (%eax),%edx
+ 886:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 889:	89 10                	mov    %edx,(%eax)
+ 88b:	eb 26                	jmp    8b3 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 88d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 890:	8b 40 04             	mov    0x4(%eax),%eax
+ 893:	89 c2                	mov    %eax,%edx
+ 895:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 898:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 89b:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 89e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8a1:	8b 40 04             	mov    0x4(%eax),%eax
+ 8a4:	c1 e0 03             	shl    $0x3,%eax
+ 8a7:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 8aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8ad:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 8b0:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 8b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8b6:	a3 a8 0b 00 00       	mov    %eax,0xba8
+      return (void*)(p + 1);
+ 8bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8be:	83 c0 08             	add    $0x8,%eax
+ 8c1:	eb 38                	jmp    8fb <malloc+0xde>
+    }
+    if(p == freep)
+ 8c3:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 8c8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 8cb:	75 1b                	jne    8e8 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 8cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 8d0:	89 04 24             	mov    %eax,(%esp)
+ 8d3:	e8 ed fe ff ff       	call   7c5 <morecore>
+ 8d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 8db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 8df:	75 07                	jne    8e8 <malloc+0xcb>
+        return 0;
+ 8e1:	b8 00 00 00 00       	mov    $0x0,%eax
+ 8e6:	eb 13                	jmp    8fb <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8f1:	8b 00                	mov    (%eax),%eax
+ 8f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 8f6:	e9 70 ff ff ff       	jmp    86b <malloc+0x4e>
+}
+ 8fb:	c9                   	leave  
+ 8fc:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/cat.d cs550-16s-proj1-working/cat.d
--- cs550-16s-proj1-base/cat.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/cat.d	2016-03-04 14:36:51.000000000 -0500
@@ -0,0 +1 @@
+cat.o: cat.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/cat.o and cs550-16s-proj1-working/cat.o differ
diff -uNr cs550-16s-proj1-base/cat.sym cs550-16s-proj1-working/cat.sym
--- cs550-16s-proj1-base/cat.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/cat.sym	2016-03-04 14:36:54.000000000 -0500
@@ -0,0 +1,67 @@
+00000000 .text
+000008fd .rodata
+0000092c .eh_frame
+00000b88 .data
+00000ba0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 cat.c
+00000000 ulib.c
+00000120 stosb
+00000000 printf.c
+00000450 putc
+00000478 printint
+00000b88 digits.1028
+00000000 umalloc.c
+00000ba0 base
+00000ba8 freep
+000007c5 morecore
+00000145 strcpy
+0000052d printf
+00000344 memmove
+000003d0 mknod
+00000238 gets
+00000408 getpid
+00000000 cat
+0000081d malloc
+00000418 sleep
+00000448 set_priority
+00000398 pipe
+000003a8 write
+000003e0 fstat
+000003b8 kill
+000003f8 chdir
+000003c0 exec
+00000390 wait
+000003a0 read
+000003d8 unlink
+00000380 fork
+00000410 sbrk
+00000420 uptime
+00000b9c __bss_start
+000001e1 memset
+00000068 main
+00000428 enable_sched_trace
+00000179 strcmp
+00000430 shutdown
+00000400 dup
+00000bc0 buf
+00000440 set_sched
+000002ab stat
+00000b9c _edata
+00000dc0 _end
+000003e8 link
+00000388 exit
+000002f9 atoi
+00000438 fork_winner
+000001ba strlen
+000003c8 open
+00000205 strchr
+000003f0 mkdir
+000003b0 close
+000006e4 free
diff -uNr cs550-16s-proj1-base/console.c cs550-16s-proj1-working/console.c
--- cs550-16s-proj1-base/console.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/console.c	2016-03-04 14:36:38.000000000 -0500
@@ -143,9 +143,6 @@
     if(pos > 0) --pos;
   } else
     crt[pos++] = (c&0xff) | 0x0700;  // black on white
-
-  if(pos < 0 || pos > 25*80)
-    panic("pos under/overflow");
   
   if((pos/80) >= 24){  // Scroll up.
     memmove(crt, crt+80, sizeof(crt[0])*23*80);
@@ -178,6 +175,7 @@
 
 #define INPUT_BUF 128
 struct {
+  struct spinlock lock;
   char buf[INPUT_BUF];
   uint r;  // Read index
   uint w;  // Write index
@@ -189,13 +187,13 @@
 void
 consoleintr(int (*getc)(void))
 {
-  int c, doprocdump = 0;
+  int c;
 
-  acquire(&cons.lock);
+  acquire(&input.lock);
   while((c = getc()) >= 0){
     switch(c){
     case C('P'):  // Process listing.
-      doprocdump = 1;   // procdump() locks cons.lock indirectly; invoke later
+      procdump();
       break;
     case C('U'):  // Kill line.
       while(input.e != input.w &&
@@ -223,10 +221,7 @@
       break;
     }
   }
-  release(&cons.lock);
-  if(doprocdump) {
-    procdump();  // now call procdump() wo. cons.lock held
-  }
+  release(&input.lock);
 }
 
 int
@@ -237,15 +232,15 @@
 
   iunlock(ip);
   target = n;
-  acquire(&cons.lock);
+  acquire(&input.lock);
   while(n > 0){
     while(input.r == input.w){
       if(proc->killed){
-        release(&cons.lock);
+        release(&input.lock);
         ilock(ip);
         return -1;
       }
-      sleep(&input.r, &cons.lock);
+      sleep(&input.r, &input.lock);
     }
     c = input.buf[input.r++ % INPUT_BUF];
     if(c == C('D')){  // EOF
@@ -261,7 +256,7 @@
     if(c == '\n')
       break;
   }
-  release(&cons.lock);
+  release(&input.lock);
   ilock(ip);
 
   return target - n;
@@ -286,6 +281,7 @@
 consoleinit(void)
 {
   initlock(&cons.lock, "console");
+  initlock(&input.lock, "input");
 
   devsw[CONSOLE].write = consolewrite;
   devsw[CONSOLE].read = consoleread;
diff -uNr cs550-16s-proj1-base/console.d cs550-16s-proj1-working/console.d
--- cs550-16s-proj1-base/console.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/console.d	2016-03-04 15:49:53.741008059 -0500
@@ -0,0 +1,2 @@
+console.o: console.c types.h defs.h param.h traps.h spinlock.h fs.h \
+ file.h memlayout.h mmu.h proc.h x86.h
Binary files cs550-16s-proj1-base/console.o and cs550-16s-proj1-working/console.o differ
diff -uNr cs550-16s-proj1-base/date.h cs550-16s-proj1-working/date.h
--- cs550-16s-proj1-base/date.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/date.h	2016-03-04 14:36:38.000000000 -0500
@@ -1,8 +1,8 @@
 struct rtcdate {
-  uint second;
-  uint minute;
-  uint hour;
-  uint day;
-  uint month;
-  uint year;
+	uint second;
+	uint minute;
+	uint hour;
+	uint day;
+	uint month;
+	uint year;
 };
diff -uNr cs550-16s-proj1-base/defs.h cs550-16s-proj1-working/defs.h
--- cs550-16s-proj1-base/defs.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/defs.h	2016-03-04 14:36:38.000000000 -0500
@@ -39,7 +39,7 @@
 struct inode*   dirlookup(struct inode*, char*, uint*);
 struct inode*   ialloc(uint, short);
 struct inode*   idup(struct inode*);
-void            iinit(int dev);
+void            iinit(void);
 void            ilock(struct inode*);
 void            iput(struct inode*);
 void            iunlock(struct inode*);
@@ -81,7 +81,7 @@
 void            microdelay(int);
 
 // log.c
-void            initlog(int dev);
+void            initlog(void);
 void            log_write(struct buf*);
 void            begin_op();
 void            end_op();
Binary files cs550-16s-proj1-base/_echo and cs550-16s-proj1-working/_echo differ
diff -uNr cs550-16s-proj1-base/echo.asm cs550-16s-proj1-working/echo.asm
--- cs550-16s-proj1-base/echo.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/echo.asm	2016-03-04 14:36:55.000000000 -0500
@@ -0,0 +1,1211 @@
+
+_echo:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 20             	sub    $0x20,%esp
+  int i;
+
+  for(i = 1; i < argc; i++)
+   9:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+  10:	00 
+  11:	eb 4b                	jmp    5e <main+0x5e>
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  17:	83 c0 01             	add    $0x1,%eax
+  1a:	3b 45 08             	cmp    0x8(%ebp),%eax
+  1d:	7d 07                	jge    26 <main+0x26>
+  1f:	b8 49 08 00 00       	mov    $0x849,%eax
+  24:	eb 05                	jmp    2b <main+0x2b>
+  26:	b8 4b 08 00 00       	mov    $0x84b,%eax
+  2b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
+  2f:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
+  36:	8b 55 0c             	mov    0xc(%ebp),%edx
+  39:	01 ca                	add    %ecx,%edx
+  3b:	8b 12                	mov    (%edx),%edx
+  3d:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  41:	89 54 24 08          	mov    %edx,0x8(%esp)
+  45:	c7 44 24 04 4d 08 00 	movl   $0x84d,0x4(%esp)
+  4c:	00 
+  4d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  54:	e8 20 04 00 00       	call   479 <printf>
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  for(i = 1; i < argc; i++)
+  59:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+  5e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  62:	3b 45 08             	cmp    0x8(%ebp),%eax
+  65:	7c ac                	jl     13 <main+0x13>
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  exit();
+  67:	e8 68 02 00 00       	call   2d4 <exit>
+
+0000006c <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  6c:	55                   	push   %ebp
+  6d:	89 e5                	mov    %esp,%ebp
+  6f:	57                   	push   %edi
+  70:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  71:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  74:	8b 55 10             	mov    0x10(%ebp),%edx
+  77:	8b 45 0c             	mov    0xc(%ebp),%eax
+  7a:	89 cb                	mov    %ecx,%ebx
+  7c:	89 df                	mov    %ebx,%edi
+  7e:	89 d1                	mov    %edx,%ecx
+  80:	fc                   	cld    
+  81:	f3 aa                	rep stos %al,%es:(%edi)
+  83:	89 ca                	mov    %ecx,%edx
+  85:	89 fb                	mov    %edi,%ebx
+  87:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  8a:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  8d:	5b                   	pop    %ebx
+  8e:	5f                   	pop    %edi
+  8f:	5d                   	pop    %ebp
+  90:	c3                   	ret    
+
+00000091 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  91:	55                   	push   %ebp
+  92:	89 e5                	mov    %esp,%ebp
+  94:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  97:	8b 45 08             	mov    0x8(%ebp),%eax
+  9a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  9d:	90                   	nop
+  9e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  a1:	0f b6 10             	movzbl (%eax),%edx
+  a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  a7:	88 10                	mov    %dl,(%eax)
+  a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  ac:	0f b6 00             	movzbl (%eax),%eax
+  af:	84 c0                	test   %al,%al
+  b1:	0f 95 c0             	setne  %al
+  b4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  b8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  bc:	84 c0                	test   %al,%al
+  be:	75 de                	jne    9e <strcpy+0xd>
+    ;
+  return os;
+  c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  c3:	c9                   	leave  
+  c4:	c3                   	ret    
+
+000000c5 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  c5:	55                   	push   %ebp
+  c6:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  c8:	eb 08                	jmp    d2 <strcmp+0xd>
+    p++, q++;
+  ca:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  ce:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  d2:	8b 45 08             	mov    0x8(%ebp),%eax
+  d5:	0f b6 00             	movzbl (%eax),%eax
+  d8:	84 c0                	test   %al,%al
+  da:	74 10                	je     ec <strcmp+0x27>
+  dc:	8b 45 08             	mov    0x8(%ebp),%eax
+  df:	0f b6 10             	movzbl (%eax),%edx
+  e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  e5:	0f b6 00             	movzbl (%eax),%eax
+  e8:	38 c2                	cmp    %al,%dl
+  ea:	74 de                	je     ca <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+  ec:	8b 45 08             	mov    0x8(%ebp),%eax
+  ef:	0f b6 00             	movzbl (%eax),%eax
+  f2:	0f b6 d0             	movzbl %al,%edx
+  f5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f8:	0f b6 00             	movzbl (%eax),%eax
+  fb:	0f b6 c0             	movzbl %al,%eax
+  fe:	89 d1                	mov    %edx,%ecx
+ 100:	29 c1                	sub    %eax,%ecx
+ 102:	89 c8                	mov    %ecx,%eax
+}
+ 104:	5d                   	pop    %ebp
+ 105:	c3                   	ret    
+
+00000106 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 106:	55                   	push   %ebp
+ 107:	89 e5                	mov    %esp,%ebp
+ 109:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 10c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 113:	eb 04                	jmp    119 <strlen+0x13>
+ 115:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 119:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 11c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11f:	01 d0                	add    %edx,%eax
+ 121:	0f b6 00             	movzbl (%eax),%eax
+ 124:	84 c0                	test   %al,%al
+ 126:	75 ed                	jne    115 <strlen+0xf>
+    ;
+  return n;
+ 128:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 12b:	c9                   	leave  
+ 12c:	c3                   	ret    
+
+0000012d <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 12d:	55                   	push   %ebp
+ 12e:	89 e5                	mov    %esp,%ebp
+ 130:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 133:	8b 45 10             	mov    0x10(%ebp),%eax
+ 136:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 13a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 13d:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 141:	8b 45 08             	mov    0x8(%ebp),%eax
+ 144:	89 04 24             	mov    %eax,(%esp)
+ 147:	e8 20 ff ff ff       	call   6c <stosb>
+  return dst;
+ 14c:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 14f:	c9                   	leave  
+ 150:	c3                   	ret    
+
+00000151 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 151:	55                   	push   %ebp
+ 152:	89 e5                	mov    %esp,%ebp
+ 154:	83 ec 04             	sub    $0x4,%esp
+ 157:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 15a:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 15d:	eb 14                	jmp    173 <strchr+0x22>
+    if(*s == c)
+ 15f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 162:	0f b6 00             	movzbl (%eax),%eax
+ 165:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 168:	75 05                	jne    16f <strchr+0x1e>
+      return (char*)s;
+ 16a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16d:	eb 13                	jmp    182 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 16f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 173:	8b 45 08             	mov    0x8(%ebp),%eax
+ 176:	0f b6 00             	movzbl (%eax),%eax
+ 179:	84 c0                	test   %al,%al
+ 17b:	75 e2                	jne    15f <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 17d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 182:	c9                   	leave  
+ 183:	c3                   	ret    
+
+00000184 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 184:	55                   	push   %ebp
+ 185:	89 e5                	mov    %esp,%ebp
+ 187:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 18a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 191:	eb 46                	jmp    1d9 <gets+0x55>
+    cc = read(0, &c, 1);
+ 193:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 19a:	00 
+ 19b:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 19e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1a2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 1a9:	e8 3e 01 00 00       	call   2ec <read>
+ 1ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1b1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1b5:	7e 2f                	jle    1e6 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1ba:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1bd:	01 c2                	add    %eax,%edx
+ 1bf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1c3:	88 02                	mov    %al,(%edx)
+ 1c5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 1c9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1cd:	3c 0a                	cmp    $0xa,%al
+ 1cf:	74 16                	je     1e7 <gets+0x63>
+ 1d1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d5:	3c 0d                	cmp    $0xd,%al
+ 1d7:	74 0e                	je     1e7 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1dc:	83 c0 01             	add    $0x1,%eax
+ 1df:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 1e2:	7c af                	jl     193 <gets+0xf>
+ 1e4:	eb 01                	jmp    1e7 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 1e6:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 1e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1ea:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ed:	01 d0                	add    %edx,%eax
+ 1ef:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 1f2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1f5:	c9                   	leave  
+ 1f6:	c3                   	ret    
+
+000001f7 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 1f7:	55                   	push   %ebp
+ 1f8:	89 e5                	mov    %esp,%ebp
+ 1fa:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1fd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 204:	00 
+ 205:	8b 45 08             	mov    0x8(%ebp),%eax
+ 208:	89 04 24             	mov    %eax,(%esp)
+ 20b:	e8 04 01 00 00       	call   314 <open>
+ 210:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 213:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 217:	79 07                	jns    220 <stat+0x29>
+    return -1;
+ 219:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 21e:	eb 23                	jmp    243 <stat+0x4c>
+  r = fstat(fd, st);
+ 220:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 223:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 227:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 22a:	89 04 24             	mov    %eax,(%esp)
+ 22d:	e8 fa 00 00 00       	call   32c <fstat>
+ 232:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 235:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 238:	89 04 24             	mov    %eax,(%esp)
+ 23b:	e8 bc 00 00 00       	call   2fc <close>
+  return r;
+ 240:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 243:	c9                   	leave  
+ 244:	c3                   	ret    
+
+00000245 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 245:	55                   	push   %ebp
+ 246:	89 e5                	mov    %esp,%ebp
+ 248:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 24b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 252:	eb 23                	jmp    277 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 254:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 257:	89 d0                	mov    %edx,%eax
+ 259:	c1 e0 02             	shl    $0x2,%eax
+ 25c:	01 d0                	add    %edx,%eax
+ 25e:	01 c0                	add    %eax,%eax
+ 260:	89 c2                	mov    %eax,%edx
+ 262:	8b 45 08             	mov    0x8(%ebp),%eax
+ 265:	0f b6 00             	movzbl (%eax),%eax
+ 268:	0f be c0             	movsbl %al,%eax
+ 26b:	01 d0                	add    %edx,%eax
+ 26d:	83 e8 30             	sub    $0x30,%eax
+ 270:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 273:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 277:	8b 45 08             	mov    0x8(%ebp),%eax
+ 27a:	0f b6 00             	movzbl (%eax),%eax
+ 27d:	3c 2f                	cmp    $0x2f,%al
+ 27f:	7e 0a                	jle    28b <atoi+0x46>
+ 281:	8b 45 08             	mov    0x8(%ebp),%eax
+ 284:	0f b6 00             	movzbl (%eax),%eax
+ 287:	3c 39                	cmp    $0x39,%al
+ 289:	7e c9                	jle    254 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 28b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 28e:	c9                   	leave  
+ 28f:	c3                   	ret    
+
+00000290 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 290:	55                   	push   %ebp
+ 291:	89 e5                	mov    %esp,%ebp
+ 293:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 296:	8b 45 08             	mov    0x8(%ebp),%eax
+ 299:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 29c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 29f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2a2:	eb 13                	jmp    2b7 <memmove+0x27>
+    *dst++ = *src++;
+ 2a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 2a7:	0f b6 10             	movzbl (%eax),%edx
+ 2aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2ad:	88 10                	mov    %dl,(%eax)
+ 2af:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 2b3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 2bb:	0f 9f c0             	setg   %al
+ 2be:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 2c2:	84 c0                	test   %al,%al
+ 2c4:	75 de                	jne    2a4 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 2c6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2c9:	c9                   	leave  
+ 2ca:	c3                   	ret    
+ 2cb:	90                   	nop
+
+000002cc <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2cc:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2d1:	cd 40                	int    $0x40
+ 2d3:	c3                   	ret    
+
+000002d4 <exit>:
+SYSCALL(exit)
+ 2d4:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2d9:	cd 40                	int    $0x40
+ 2db:	c3                   	ret    
+
+000002dc <wait>:
+SYSCALL(wait)
+ 2dc:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2e1:	cd 40                	int    $0x40
+ 2e3:	c3                   	ret    
+
+000002e4 <pipe>:
+SYSCALL(pipe)
+ 2e4:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2e9:	cd 40                	int    $0x40
+ 2eb:	c3                   	ret    
+
+000002ec <read>:
+SYSCALL(read)
+ 2ec:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2f1:	cd 40                	int    $0x40
+ 2f3:	c3                   	ret    
+
+000002f4 <write>:
+SYSCALL(write)
+ 2f4:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2f9:	cd 40                	int    $0x40
+ 2fb:	c3                   	ret    
+
+000002fc <close>:
+SYSCALL(close)
+ 2fc:	b8 15 00 00 00       	mov    $0x15,%eax
+ 301:	cd 40                	int    $0x40
+ 303:	c3                   	ret    
+
+00000304 <kill>:
+SYSCALL(kill)
+ 304:	b8 06 00 00 00       	mov    $0x6,%eax
+ 309:	cd 40                	int    $0x40
+ 30b:	c3                   	ret    
+
+0000030c <exec>:
+SYSCALL(exec)
+ 30c:	b8 07 00 00 00       	mov    $0x7,%eax
+ 311:	cd 40                	int    $0x40
+ 313:	c3                   	ret    
+
+00000314 <open>:
+SYSCALL(open)
+ 314:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 319:	cd 40                	int    $0x40
+ 31b:	c3                   	ret    
+
+0000031c <mknod>:
+SYSCALL(mknod)
+ 31c:	b8 11 00 00 00       	mov    $0x11,%eax
+ 321:	cd 40                	int    $0x40
+ 323:	c3                   	ret    
+
+00000324 <unlink>:
+SYSCALL(unlink)
+ 324:	b8 12 00 00 00       	mov    $0x12,%eax
+ 329:	cd 40                	int    $0x40
+ 32b:	c3                   	ret    
+
+0000032c <fstat>:
+SYSCALL(fstat)
+ 32c:	b8 08 00 00 00       	mov    $0x8,%eax
+ 331:	cd 40                	int    $0x40
+ 333:	c3                   	ret    
+
+00000334 <link>:
+SYSCALL(link)
+ 334:	b8 13 00 00 00       	mov    $0x13,%eax
+ 339:	cd 40                	int    $0x40
+ 33b:	c3                   	ret    
+
+0000033c <mkdir>:
+SYSCALL(mkdir)
+ 33c:	b8 14 00 00 00       	mov    $0x14,%eax
+ 341:	cd 40                	int    $0x40
+ 343:	c3                   	ret    
+
+00000344 <chdir>:
+SYSCALL(chdir)
+ 344:	b8 09 00 00 00       	mov    $0x9,%eax
+ 349:	cd 40                	int    $0x40
+ 34b:	c3                   	ret    
+
+0000034c <dup>:
+SYSCALL(dup)
+ 34c:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 351:	cd 40                	int    $0x40
+ 353:	c3                   	ret    
+
+00000354 <getpid>:
+SYSCALL(getpid)
+ 354:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 359:	cd 40                	int    $0x40
+ 35b:	c3                   	ret    
+
+0000035c <sbrk>:
+SYSCALL(sbrk)
+ 35c:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 361:	cd 40                	int    $0x40
+ 363:	c3                   	ret    
+
+00000364 <sleep>:
+SYSCALL(sleep)
+ 364:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 369:	cd 40                	int    $0x40
+ 36b:	c3                   	ret    
+
+0000036c <uptime>:
+SYSCALL(uptime)
+ 36c:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 371:	cd 40                	int    $0x40
+ 373:	c3                   	ret    
+
+00000374 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 374:	b8 16 00 00 00       	mov    $0x16,%eax
+ 379:	cd 40                	int    $0x40
+ 37b:	c3                   	ret    
+
+0000037c <shutdown>:
+SYSCALL(shutdown)
+ 37c:	b8 17 00 00 00       	mov    $0x17,%eax
+ 381:	cd 40                	int    $0x40
+ 383:	c3                   	ret    
+
+00000384 <fork_winner>:
+SYSCALL(fork_winner)
+ 384:	b8 18 00 00 00       	mov    $0x18,%eax
+ 389:	cd 40                	int    $0x40
+ 38b:	c3                   	ret    
+
+0000038c <set_sched>:
+SYSCALL(set_sched)
+ 38c:	b8 19 00 00 00       	mov    $0x19,%eax
+ 391:	cd 40                	int    $0x40
+ 393:	c3                   	ret    
+
+00000394 <set_priority>:
+SYSCALL(set_priority)
+ 394:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 399:	cd 40                	int    $0x40
+ 39b:	c3                   	ret    
+
+0000039c <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 39c:	55                   	push   %ebp
+ 39d:	89 e5                	mov    %esp,%ebp
+ 39f:	83 ec 28             	sub    $0x28,%esp
+ 3a2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3a5:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3a8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 3af:	00 
+ 3b0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3b3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 3b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3ba:	89 04 24             	mov    %eax,(%esp)
+ 3bd:	e8 32 ff ff ff       	call   2f4 <write>
+}
+ 3c2:	c9                   	leave  
+ 3c3:	c3                   	ret    
+
+000003c4 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3c4:	55                   	push   %ebp
+ 3c5:	89 e5                	mov    %esp,%ebp
+ 3c7:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3d1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3d5:	74 17                	je     3ee <printint+0x2a>
+ 3d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3db:	79 11                	jns    3ee <printint+0x2a>
+    neg = 1;
+ 3dd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 3e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3e7:	f7 d8                	neg    %eax
+ 3e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3ec:	eb 06                	jmp    3f4 <printint+0x30>
+  } else {
+    x = xx;
+ 3ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 3f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 3fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 3fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 401:	ba 00 00 00 00       	mov    $0x0,%edx
+ 406:	f7 f1                	div    %ecx
+ 408:	89 d0                	mov    %edx,%eax
+ 40a:	0f b6 80 98 0a 00 00 	movzbl 0xa98(%eax),%eax
+ 411:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 414:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 417:	01 ca                	add    %ecx,%edx
+ 419:	88 02                	mov    %al,(%edx)
+ 41b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 41f:	8b 55 10             	mov    0x10(%ebp),%edx
+ 422:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 425:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 428:	ba 00 00 00 00       	mov    $0x0,%edx
+ 42d:	f7 75 d4             	divl   -0x2c(%ebp)
+ 430:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 433:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 437:	75 c2                	jne    3fb <printint+0x37>
+  if(neg)
+ 439:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 43d:	74 2e                	je     46d <printint+0xa9>
+    buf[i++] = '-';
+ 43f:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 442:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 445:	01 d0                	add    %edx,%eax
+ 447:	c6 00 2d             	movb   $0x2d,(%eax)
+ 44a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 44e:	eb 1d                	jmp    46d <printint+0xa9>
+    putc(fd, buf[i]);
+ 450:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 453:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 456:	01 d0                	add    %edx,%eax
+ 458:	0f b6 00             	movzbl (%eax),%eax
+ 45b:	0f be c0             	movsbl %al,%eax
+ 45e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 462:	8b 45 08             	mov    0x8(%ebp),%eax
+ 465:	89 04 24             	mov    %eax,(%esp)
+ 468:	e8 2f ff ff ff       	call   39c <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 46d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 471:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 475:	79 d9                	jns    450 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 477:	c9                   	leave  
+ 478:	c3                   	ret    
+
+00000479 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 479:	55                   	push   %ebp
+ 47a:	89 e5                	mov    %esp,%ebp
+ 47c:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 47f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 486:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 489:	83 c0 04             	add    $0x4,%eax
+ 48c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 48f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 496:	e9 7d 01 00 00       	jmp    618 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 49b:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 49e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4a1:	01 d0                	add    %edx,%eax
+ 4a3:	0f b6 00             	movzbl (%eax),%eax
+ 4a6:	0f be c0             	movsbl %al,%eax
+ 4a9:	25 ff 00 00 00       	and    $0xff,%eax
+ 4ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4b5:	75 2c                	jne    4e3 <printf+0x6a>
+      if(c == '%'){
+ 4b7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4bb:	75 0c                	jne    4c9 <printf+0x50>
+        state = '%';
+ 4bd:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4c4:	e9 4b 01 00 00       	jmp    614 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 4c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4cc:	0f be c0             	movsbl %al,%eax
+ 4cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4d3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4d6:	89 04 24             	mov    %eax,(%esp)
+ 4d9:	e8 be fe ff ff       	call   39c <putc>
+ 4de:	e9 31 01 00 00       	jmp    614 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 4e3:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 4e7:	0f 85 27 01 00 00    	jne    614 <printf+0x19b>
+      if(c == 'd'){
+ 4ed:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 4f1:	75 2d                	jne    520 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 4f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4f6:	8b 00                	mov    (%eax),%eax
+ 4f8:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 4ff:	00 
+ 500:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 507:	00 
+ 508:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 50c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 50f:	89 04 24             	mov    %eax,(%esp)
+ 512:	e8 ad fe ff ff       	call   3c4 <printint>
+        ap++;
+ 517:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 51b:	e9 ed 00 00 00       	jmp    60d <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 520:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 524:	74 06                	je     52c <printf+0xb3>
+ 526:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 52a:	75 2d                	jne    559 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 52c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 52f:	8b 00                	mov    (%eax),%eax
+ 531:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 538:	00 
+ 539:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 540:	00 
+ 541:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 545:	8b 45 08             	mov    0x8(%ebp),%eax
+ 548:	89 04 24             	mov    %eax,(%esp)
+ 54b:	e8 74 fe ff ff       	call   3c4 <printint>
+        ap++;
+ 550:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 554:	e9 b4 00 00 00       	jmp    60d <printf+0x194>
+      } else if(c == 's'){
+ 559:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 55d:	75 46                	jne    5a5 <printf+0x12c>
+        s = (char*)*ap;
+ 55f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 562:	8b 00                	mov    (%eax),%eax
+ 564:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 567:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 56b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 56f:	75 27                	jne    598 <printf+0x11f>
+          s = "(null)";
+ 571:	c7 45 f4 52 08 00 00 	movl   $0x852,-0xc(%ebp)
+        while(*s != 0){
+ 578:	eb 1e                	jmp    598 <printf+0x11f>
+          putc(fd, *s);
+ 57a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 57d:	0f b6 00             	movzbl (%eax),%eax
+ 580:	0f be c0             	movsbl %al,%eax
+ 583:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 587:	8b 45 08             	mov    0x8(%ebp),%eax
+ 58a:	89 04 24             	mov    %eax,(%esp)
+ 58d:	e8 0a fe ff ff       	call   39c <putc>
+          s++;
+ 592:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 596:	eb 01                	jmp    599 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 598:	90                   	nop
+ 599:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59c:	0f b6 00             	movzbl (%eax),%eax
+ 59f:	84 c0                	test   %al,%al
+ 5a1:	75 d7                	jne    57a <printf+0x101>
+ 5a3:	eb 68                	jmp    60d <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5a5:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5a9:	75 1d                	jne    5c8 <printf+0x14f>
+        putc(fd, *ap);
+ 5ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5ae:	8b 00                	mov    (%eax),%eax
+ 5b0:	0f be c0             	movsbl %al,%eax
+ 5b3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ba:	89 04 24             	mov    %eax,(%esp)
+ 5bd:	e8 da fd ff ff       	call   39c <putc>
+        ap++;
+ 5c2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5c6:	eb 45                	jmp    60d <printf+0x194>
+      } else if(c == '%'){
+ 5c8:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5cc:	75 17                	jne    5e5 <printf+0x16c>
+        putc(fd, c);
+ 5ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5d1:	0f be c0             	movsbl %al,%eax
+ 5d4:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5d8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5db:	89 04 24             	mov    %eax,(%esp)
+ 5de:	e8 b9 fd ff ff       	call   39c <putc>
+ 5e3:	eb 28                	jmp    60d <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5e5:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 5ec:	00 
+ 5ed:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5f0:	89 04 24             	mov    %eax,(%esp)
+ 5f3:	e8 a4 fd ff ff       	call   39c <putc>
+        putc(fd, c);
+ 5f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5fb:	0f be c0             	movsbl %al,%eax
+ 5fe:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 602:	8b 45 08             	mov    0x8(%ebp),%eax
+ 605:	89 04 24             	mov    %eax,(%esp)
+ 608:	e8 8f fd ff ff       	call   39c <putc>
+      }
+      state = 0;
+ 60d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 614:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 618:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 61b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 61e:	01 d0                	add    %edx,%eax
+ 620:	0f b6 00             	movzbl (%eax),%eax
+ 623:	84 c0                	test   %al,%al
+ 625:	0f 85 70 fe ff ff    	jne    49b <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 62b:	c9                   	leave  
+ 62c:	c3                   	ret    
+ 62d:	90                   	nop
+ 62e:	90                   	nop
+ 62f:	90                   	nop
+
+00000630 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 630:	55                   	push   %ebp
+ 631:	89 e5                	mov    %esp,%ebp
+ 633:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 636:	8b 45 08             	mov    0x8(%ebp),%eax
+ 639:	83 e8 08             	sub    $0x8,%eax
+ 63c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 63f:	a1 b4 0a 00 00       	mov    0xab4,%eax
+ 644:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 647:	eb 24                	jmp    66d <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 649:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 64c:	8b 00                	mov    (%eax),%eax
+ 64e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 651:	77 12                	ja     665 <free+0x35>
+ 653:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 656:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 659:	77 24                	ja     67f <free+0x4f>
+ 65b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65e:	8b 00                	mov    (%eax),%eax
+ 660:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 663:	77 1a                	ja     67f <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 665:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 668:	8b 00                	mov    (%eax),%eax
+ 66a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 66d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 670:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 673:	76 d4                	jbe    649 <free+0x19>
+ 675:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 678:	8b 00                	mov    (%eax),%eax
+ 67a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 67d:	76 ca                	jbe    649 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 67f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 682:	8b 40 04             	mov    0x4(%eax),%eax
+ 685:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 68c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68f:	01 c2                	add    %eax,%edx
+ 691:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 694:	8b 00                	mov    (%eax),%eax
+ 696:	39 c2                	cmp    %eax,%edx
+ 698:	75 24                	jne    6be <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 69a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69d:	8b 50 04             	mov    0x4(%eax),%edx
+ 6a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a3:	8b 00                	mov    (%eax),%eax
+ 6a5:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a8:	01 c2                	add    %eax,%edx
+ 6aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ad:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b3:	8b 00                	mov    (%eax),%eax
+ 6b5:	8b 10                	mov    (%eax),%edx
+ 6b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ba:	89 10                	mov    %edx,(%eax)
+ 6bc:	eb 0a                	jmp    6c8 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6be:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c1:	8b 10                	mov    (%eax),%edx
+ 6c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c6:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6cb:	8b 40 04             	mov    0x4(%eax),%eax
+ 6ce:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d8:	01 d0                	add    %edx,%eax
+ 6da:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 6dd:	75 20                	jne    6ff <free+0xcf>
+    p->s.size += bp->s.size;
+ 6df:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e2:	8b 50 04             	mov    0x4(%eax),%edx
+ 6e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e8:	8b 40 04             	mov    0x4(%eax),%eax
+ 6eb:	01 c2                	add    %eax,%edx
+ 6ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f0:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f6:	8b 10                	mov    (%eax),%edx
+ 6f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fb:	89 10                	mov    %edx,(%eax)
+ 6fd:	eb 08                	jmp    707 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 6ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 702:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 705:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 707:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 70a:	a3 b4 0a 00 00       	mov    %eax,0xab4
+}
+ 70f:	c9                   	leave  
+ 710:	c3                   	ret    
+
+00000711 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 711:	55                   	push   %ebp
+ 712:	89 e5                	mov    %esp,%ebp
+ 714:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 717:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 71e:	77 07                	ja     727 <morecore+0x16>
+    nu = 4096;
+ 720:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 727:	8b 45 08             	mov    0x8(%ebp),%eax
+ 72a:	c1 e0 03             	shl    $0x3,%eax
+ 72d:	89 04 24             	mov    %eax,(%esp)
+ 730:	e8 27 fc ff ff       	call   35c <sbrk>
+ 735:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 738:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 73c:	75 07                	jne    745 <morecore+0x34>
+    return 0;
+ 73e:	b8 00 00 00 00       	mov    $0x0,%eax
+ 743:	eb 22                	jmp    767 <morecore+0x56>
+  hp = (Header*)p;
+ 745:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 748:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 74b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 74e:	8b 55 08             	mov    0x8(%ebp),%edx
+ 751:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 754:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 757:	83 c0 08             	add    $0x8,%eax
+ 75a:	89 04 24             	mov    %eax,(%esp)
+ 75d:	e8 ce fe ff ff       	call   630 <free>
+  return freep;
+ 762:	a1 b4 0a 00 00       	mov    0xab4,%eax
+}
+ 767:	c9                   	leave  
+ 768:	c3                   	ret    
+
+00000769 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 769:	55                   	push   %ebp
+ 76a:	89 e5                	mov    %esp,%ebp
+ 76c:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 76f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 772:	83 c0 07             	add    $0x7,%eax
+ 775:	c1 e8 03             	shr    $0x3,%eax
+ 778:	83 c0 01             	add    $0x1,%eax
+ 77b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 77e:	a1 b4 0a 00 00       	mov    0xab4,%eax
+ 783:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 786:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 78a:	75 23                	jne    7af <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 78c:	c7 45 f0 ac 0a 00 00 	movl   $0xaac,-0x10(%ebp)
+ 793:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 796:	a3 b4 0a 00 00       	mov    %eax,0xab4
+ 79b:	a1 b4 0a 00 00       	mov    0xab4,%eax
+ 7a0:	a3 ac 0a 00 00       	mov    %eax,0xaac
+    base.s.size = 0;
+ 7a5:	c7 05 b0 0a 00 00 00 	movl   $0x0,0xab0
+ 7ac:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7af:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7b2:	8b 00                	mov    (%eax),%eax
+ 7b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ba:	8b 40 04             	mov    0x4(%eax),%eax
+ 7bd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7c0:	72 4d                	jb     80f <malloc+0xa6>
+      if(p->s.size == nunits)
+ 7c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7c5:	8b 40 04             	mov    0x4(%eax),%eax
+ 7c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7cb:	75 0c                	jne    7d9 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 7cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d0:	8b 10                	mov    (%eax),%edx
+ 7d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7d5:	89 10                	mov    %edx,(%eax)
+ 7d7:	eb 26                	jmp    7ff <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 7d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7dc:	8b 40 04             	mov    0x4(%eax),%eax
+ 7df:	89 c2                	mov    %eax,%edx
+ 7e1:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 7e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e7:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ed:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f0:	c1 e0 03             	shl    $0x3,%eax
+ 7f3:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 7f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f9:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 7fc:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 7ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 802:	a3 b4 0a 00 00       	mov    %eax,0xab4
+      return (void*)(p + 1);
+ 807:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80a:	83 c0 08             	add    $0x8,%eax
+ 80d:	eb 38                	jmp    847 <malloc+0xde>
+    }
+    if(p == freep)
+ 80f:	a1 b4 0a 00 00       	mov    0xab4,%eax
+ 814:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 817:	75 1b                	jne    834 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 819:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 81c:	89 04 24             	mov    %eax,(%esp)
+ 81f:	e8 ed fe ff ff       	call   711 <morecore>
+ 824:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 827:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 82b:	75 07                	jne    834 <malloc+0xcb>
+        return 0;
+ 82d:	b8 00 00 00 00       	mov    $0x0,%eax
+ 832:	eb 13                	jmp    847 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 834:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 837:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 83a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 83d:	8b 00                	mov    (%eax),%eax
+ 83f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 842:	e9 70 ff ff ff       	jmp    7b7 <malloc+0x4e>
+}
+ 847:	c9                   	leave  
+ 848:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/echo.d cs550-16s-proj1-working/echo.d
--- cs550-16s-proj1-base/echo.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/echo.d	2016-03-04 14:36:54.000000000 -0500
@@ -0,0 +1 @@
+echo.o: echo.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/echo.o and cs550-16s-proj1-working/echo.o differ
diff -uNr cs550-16s-proj1-base/echo.sym cs550-16s-proj1-working/echo.sym
--- cs550-16s-proj1-base/echo.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/echo.sym	2016-03-04 14:36:55.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+00000849 .rodata
+0000085c .eh_frame
+00000a98 .data
+00000aac .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 echo.c
+00000000 ulib.c
+0000006c stosb
+00000000 printf.c
+0000039c putc
+000003c4 printint
+00000a98 digits.1028
+00000000 umalloc.c
+00000aac base
+00000ab4 freep
+00000711 morecore
+00000091 strcpy
+00000479 printf
+00000290 memmove
+0000031c mknod
+00000184 gets
+00000354 getpid
+00000769 malloc
+00000364 sleep
+00000394 set_priority
+000002e4 pipe
+000002f4 write
+0000032c fstat
+00000304 kill
+00000344 chdir
+0000030c exec
+000002dc wait
+000002ec read
+00000324 unlink
+000002cc fork
+0000035c sbrk
+0000036c uptime
+00000aac __bss_start
+0000012d memset
+00000000 main
+00000374 enable_sched_trace
+000000c5 strcmp
+0000037c shutdown
+0000034c dup
+0000038c set_sched
+000001f7 stat
+00000aac _edata
+00000ab8 _end
+00000334 link
+000002d4 exit
+00000245 atoi
+00000384 fork_winner
+00000106 strlen
+00000314 open
+00000151 strchr
+0000033c mkdir
+000002fc close
+00000630 free
Binary files cs550-16s-proj1-base/entry.o and cs550-16s-proj1-working/entry.o differ
Binary files cs550-16s-proj1-base/entryother and cs550-16s-proj1-working/entryother differ
diff -uNr cs550-16s-proj1-base/entryother.asm cs550-16s-proj1-working/entryother.asm
--- cs550-16s-proj1-base/entryother.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/entryother.asm	2016-03-04 14:37:30.000000000 -0500
@@ -0,0 +1,114 @@
+
+bootblockother.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007000 <start>:
+#   - it uses the address at start-4, start-8, and start-12
+
+.code16           
+.globl start
+start:
+  cli            
+    7000:	fa                   	cli    
+
+  xorw    %ax,%ax
+    7001:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds
+    7003:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es
+    7005:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss
+    7007:	8e d0                	mov    %eax,%ss
+
+  lgdt    gdtdesc
+    7009:	0f 01 16             	lgdtl  (%esi)
+    700c:	84 70 0f             	test   %dh,0xf(%eax)
+  movl    %cr0, %eax
+    700f:	20 c0                	and    %al,%al
+  orl     $CR0_PE, %eax
+    7011:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7015:	0f 22 c0             	mov    %eax,%cr0
+
+//PAGEBREAK!
+  ljmpl    $(SEG_KCODE<<3), $(start32)
+    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
+    701e:	08 00                	or     %al,(%eax)
+
+00007020 <start32>:
+
+.code32
+start32:
+  movw    $(SEG_KDATA<<3), %ax
+    7020:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds
+    7024:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es
+    7026:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss
+    7028:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax
+    702a:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs
+    702e:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs
+    7030:	8e e8                	mov    %eax,%gs
+
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+    7032:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+    7035:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+    7038:	0f 22 e0             	mov    %eax,%cr4
+  # Use enterpgdir as our initial page table
+  movl    (start-12), %eax
+    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
+  movl    %eax, %cr3
+    7040:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+    7043:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
+  movl    %eax, %cr0
+    704b:	0f 22 c0             	mov    %eax,%cr0
+
+  # Switch to the stack allocated by startothers()
+  movl    (start-4), %esp
+    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
+  # Call mpenter()
+  call	 *(start-8)
+    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
+
+  movw    $0x8a00, %ax
+    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    705e:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7061:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax
+    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7067:	66 ef                	out    %ax,(%dx)
+
+00007069 <spin>:
+spin:
+  jmp     spin
+    7069:	eb fe                	jmp    7069 <spin>
+    706b:	90                   	nop
+
+0000706c <gdt>:
+	...
+    7074:	ff                   	(bad)  
+    7075:	ff 00                	incl   (%eax)
+    7077:	00 00                	add    %al,(%eax)
+    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7080:	00 92 cf 00 17 00    	add    %dl,0x1700cf(%edx)
+
+00007084 <gdtdesc>:
+    7084:	17                   	pop    %ss
+    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
+	...
diff -uNr cs550-16s-proj1-base/entryother.d cs550-16s-proj1-working/entryother.d
--- cs550-16s-proj1-base/entryother.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/entryother.d	2016-03-04 14:37:29.000000000 -0500
@@ -0,0 +1 @@
+entryother.o: entryother.S asm.h memlayout.h mmu.h
Binary files cs550-16s-proj1-base/entryother.o and cs550-16s-proj1-working/entryother.o differ
diff -uNr cs550-16s-proj1-base/exec.d cs550-16s-proj1-working/exec.d
--- cs550-16s-proj1-base/exec.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/exec.d	2016-03-04 15:49:54.125002547 -0500
@@ -0,0 +1,2 @@
+exec.o: exec.c types.h param.h memlayout.h mmu.h proc.h defs.h x86.h \
+ elf.h
Binary files cs550-16s-proj1-base/exec.o and cs550-16s-proj1-working/exec.o differ
diff -uNr cs550-16s-proj1-base/file.d cs550-16s-proj1-working/file.d
--- cs550-16s-proj1-base/file.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/file.d	2016-03-04 14:37:17.000000000 -0500
@@ -0,0 +1 @@
+file.o: file.c types.h defs.h param.h fs.h file.h spinlock.h
Binary files cs550-16s-proj1-base/file.o and cs550-16s-proj1-working/file.o differ
Binary files cs550-16s-proj1-base/_forktest and cs550-16s-proj1-working/_forktest differ
diff -uNr cs550-16s-proj1-base/forktest.asm cs550-16s-proj1-working/forktest.asm
--- cs550-16s-proj1-base/forktest.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/forktest.asm	2016-03-04 14:36:56.000000000 -0500
@@ -0,0 +1,718 @@
+
+_forktest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <printf>:
+
+#define N  1000
+
+void
+printf(int fd, char *s, ...)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 ec 18             	sub    $0x18,%esp
+  write(fd, s, strlen(s));
+   6:	8b 45 0c             	mov    0xc(%ebp),%eax
+   9:	89 04 24             	mov    %eax,(%esp)
+   c:	e8 9d 01 00 00       	call   1ae <strlen>
+  11:	89 44 24 08          	mov    %eax,0x8(%esp)
+  15:	8b 45 0c             	mov    0xc(%ebp),%eax
+  18:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1c:	8b 45 08             	mov    0x8(%ebp),%eax
+  1f:	89 04 24             	mov    %eax,(%esp)
+  22:	e8 75 03 00 00       	call   39c <write>
+}
+  27:	c9                   	leave  
+  28:	c3                   	ret    
+
+00000029 <forktest>:
+
+void
+forktest(void)
+{
+  29:	55                   	push   %ebp
+  2a:	89 e5                	mov    %esp,%ebp
+  2c:	83 ec 28             	sub    $0x28,%esp
+  int n, pid;
+
+  printf(1, "fork test\n");
+  2f:	c7 44 24 04 44 04 00 	movl   $0x444,0x4(%esp)
+  36:	00 
+  37:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  3e:	e8 bd ff ff ff       	call   0 <printf>
+
+  for(n=0; n<N; n++){
+  43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  4a:	eb 1d                	jmp    69 <forktest+0x40>
+    pid = fork();
+  4c:	e8 23 03 00 00       	call   374 <fork>
+  51:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(pid < 0)
+  54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  58:	78 1a                	js     74 <forktest+0x4b>
+      break;
+    if(pid == 0)
+  5a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  5e:	75 05                	jne    65 <forktest+0x3c>
+      exit();
+  60:	e8 17 03 00 00       	call   37c <exit>
+{
+  int n, pid;
+
+  printf(1, "fork test\n");
+
+  for(n=0; n<N; n++){
+  65:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  69:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+  70:	7e da                	jle    4c <forktest+0x23>
+  72:	eb 01                	jmp    75 <forktest+0x4c>
+    pid = fork();
+    if(pid < 0)
+      break;
+  74:	90                   	nop
+    if(pid == 0)
+      exit();
+  }
+  
+  if(n == N){
+  75:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
+  7c:	75 47                	jne    c5 <forktest+0x9c>
+    printf(1, "fork claimed to work N times!\n", N);
+  7e:	c7 44 24 08 e8 03 00 	movl   $0x3e8,0x8(%esp)
+  85:	00 
+  86:	c7 44 24 04 50 04 00 	movl   $0x450,0x4(%esp)
+  8d:	00 
+  8e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  95:	e8 66 ff ff ff       	call   0 <printf>
+    exit();
+  9a:	e8 dd 02 00 00       	call   37c <exit>
+  }
+  
+  for(; n > 0; n--){
+    if(wait() < 0){
+  9f:	e8 e0 02 00 00       	call   384 <wait>
+  a4:	85 c0                	test   %eax,%eax
+  a6:	79 19                	jns    c1 <forktest+0x98>
+      printf(1, "wait stopped early\n");
+  a8:	c7 44 24 04 6f 04 00 	movl   $0x46f,0x4(%esp)
+  af:	00 
+  b0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  b7:	e8 44 ff ff ff       	call   0 <printf>
+      exit();
+  bc:	e8 bb 02 00 00       	call   37c <exit>
+  if(n == N){
+    printf(1, "fork claimed to work N times!\n", N);
+    exit();
+  }
+  
+  for(; n > 0; n--){
+  c1:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  c9:	7f d4                	jg     9f <forktest+0x76>
+      printf(1, "wait stopped early\n");
+      exit();
+    }
+  }
+  
+  if(wait() != -1){
+  cb:	e8 b4 02 00 00       	call   384 <wait>
+  d0:	83 f8 ff             	cmp    $0xffffffff,%eax
+  d3:	74 19                	je     ee <forktest+0xc5>
+    printf(1, "wait got too many\n");
+  d5:	c7 44 24 04 83 04 00 	movl   $0x483,0x4(%esp)
+  dc:	00 
+  dd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  e4:	e8 17 ff ff ff       	call   0 <printf>
+    exit();
+  e9:	e8 8e 02 00 00       	call   37c <exit>
+  }
+  
+  printf(1, "fork test OK\n");
+  ee:	c7 44 24 04 96 04 00 	movl   $0x496,0x4(%esp)
+  f5:	00 
+  f6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  fd:	e8 fe fe ff ff       	call   0 <printf>
+}
+ 102:	c9                   	leave  
+ 103:	c3                   	ret    
+
+00000104 <main>:
+
+int
+main(void)
+{
+ 104:	55                   	push   %ebp
+ 105:	89 e5                	mov    %esp,%ebp
+ 107:	83 e4 f0             	and    $0xfffffff0,%esp
+  forktest();
+ 10a:	e8 1a ff ff ff       	call   29 <forktest>
+  exit();
+ 10f:	e8 68 02 00 00       	call   37c <exit>
+
+00000114 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 114:	55                   	push   %ebp
+ 115:	89 e5                	mov    %esp,%ebp
+ 117:	57                   	push   %edi
+ 118:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 119:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 11c:	8b 55 10             	mov    0x10(%ebp),%edx
+ 11f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 122:	89 cb                	mov    %ecx,%ebx
+ 124:	89 df                	mov    %ebx,%edi
+ 126:	89 d1                	mov    %edx,%ecx
+ 128:	fc                   	cld    
+ 129:	f3 aa                	rep stos %al,%es:(%edi)
+ 12b:	89 ca                	mov    %ecx,%edx
+ 12d:	89 fb                	mov    %edi,%ebx
+ 12f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 132:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 135:	5b                   	pop    %ebx
+ 136:	5f                   	pop    %edi
+ 137:	5d                   	pop    %ebp
+ 138:	c3                   	ret    
+
+00000139 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 139:	55                   	push   %ebp
+ 13a:	89 e5                	mov    %esp,%ebp
+ 13c:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 13f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 142:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 145:	90                   	nop
+ 146:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 149:	0f b6 10             	movzbl (%eax),%edx
+ 14c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 14f:	88 10                	mov    %dl,(%eax)
+ 151:	8b 45 08             	mov    0x8(%ebp),%eax
+ 154:	0f b6 00             	movzbl (%eax),%eax
+ 157:	84 c0                	test   %al,%al
+ 159:	0f 95 c0             	setne  %al
+ 15c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 160:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 164:	84 c0                	test   %al,%al
+ 166:	75 de                	jne    146 <strcpy+0xd>
+    ;
+  return os;
+ 168:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 16b:	c9                   	leave  
+ 16c:	c3                   	ret    
+
+0000016d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 16d:	55                   	push   %ebp
+ 16e:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 170:	eb 08                	jmp    17a <strcmp+0xd>
+    p++, q++;
+ 172:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 176:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 17a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17d:	0f b6 00             	movzbl (%eax),%eax
+ 180:	84 c0                	test   %al,%al
+ 182:	74 10                	je     194 <strcmp+0x27>
+ 184:	8b 45 08             	mov    0x8(%ebp),%eax
+ 187:	0f b6 10             	movzbl (%eax),%edx
+ 18a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 18d:	0f b6 00             	movzbl (%eax),%eax
+ 190:	38 c2                	cmp    %al,%dl
+ 192:	74 de                	je     172 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 194:	8b 45 08             	mov    0x8(%ebp),%eax
+ 197:	0f b6 00             	movzbl (%eax),%eax
+ 19a:	0f b6 d0             	movzbl %al,%edx
+ 19d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1a0:	0f b6 00             	movzbl (%eax),%eax
+ 1a3:	0f b6 c0             	movzbl %al,%eax
+ 1a6:	89 d1                	mov    %edx,%ecx
+ 1a8:	29 c1                	sub    %eax,%ecx
+ 1aa:	89 c8                	mov    %ecx,%eax
+}
+ 1ac:	5d                   	pop    %ebp
+ 1ad:	c3                   	ret    
+
+000001ae <strlen>:
+
+uint
+strlen(char *s)
+{
+ 1ae:	55                   	push   %ebp
+ 1af:	89 e5                	mov    %esp,%ebp
+ 1b1:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 1bb:	eb 04                	jmp    1c1 <strlen+0x13>
+ 1bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 1c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1c4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1c7:	01 d0                	add    %edx,%eax
+ 1c9:	0f b6 00             	movzbl (%eax),%eax
+ 1cc:	84 c0                	test   %al,%al
+ 1ce:	75 ed                	jne    1bd <strlen+0xf>
+    ;
+  return n;
+ 1d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1d3:	c9                   	leave  
+ 1d4:	c3                   	ret    
+
+000001d5 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1d5:	55                   	push   %ebp
+ 1d6:	89 e5                	mov    %esp,%ebp
+ 1d8:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 1db:	8b 45 10             	mov    0x10(%ebp),%eax
+ 1de:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 1e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1e9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ec:	89 04 24             	mov    %eax,(%esp)
+ 1ef:	e8 20 ff ff ff       	call   114 <stosb>
+  return dst;
+ 1f4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1f7:	c9                   	leave  
+ 1f8:	c3                   	ret    
+
+000001f9 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1f9:	55                   	push   %ebp
+ 1fa:	89 e5                	mov    %esp,%ebp
+ 1fc:	83 ec 04             	sub    $0x4,%esp
+ 1ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 202:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 205:	eb 14                	jmp    21b <strchr+0x22>
+    if(*s == c)
+ 207:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20a:	0f b6 00             	movzbl (%eax),%eax
+ 20d:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 210:	75 05                	jne    217 <strchr+0x1e>
+      return (char*)s;
+ 212:	8b 45 08             	mov    0x8(%ebp),%eax
+ 215:	eb 13                	jmp    22a <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 217:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 21b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21e:	0f b6 00             	movzbl (%eax),%eax
+ 221:	84 c0                	test   %al,%al
+ 223:	75 e2                	jne    207 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 225:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 22a:	c9                   	leave  
+ 22b:	c3                   	ret    
+
+0000022c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 22c:	55                   	push   %ebp
+ 22d:	89 e5                	mov    %esp,%ebp
+ 22f:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 232:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 239:	eb 46                	jmp    281 <gets+0x55>
+    cc = read(0, &c, 1);
+ 23b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 242:	00 
+ 243:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 246:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 24a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 251:	e8 3e 01 00 00       	call   394 <read>
+ 256:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 259:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 25d:	7e 2f                	jle    28e <gets+0x62>
+      break;
+    buf[i++] = c;
+ 25f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 262:	8b 45 08             	mov    0x8(%ebp),%eax
+ 265:	01 c2                	add    %eax,%edx
+ 267:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 26b:	88 02                	mov    %al,(%edx)
+ 26d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 271:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 275:	3c 0a                	cmp    $0xa,%al
+ 277:	74 16                	je     28f <gets+0x63>
+ 279:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 27d:	3c 0d                	cmp    $0xd,%al
+ 27f:	74 0e                	je     28f <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 281:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 284:	83 c0 01             	add    $0x1,%eax
+ 287:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 28a:	7c af                	jl     23b <gets+0xf>
+ 28c:	eb 01                	jmp    28f <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 28e:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 28f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 292:	8b 45 08             	mov    0x8(%ebp),%eax
+ 295:	01 d0                	add    %edx,%eax
+ 297:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 29a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 29d:	c9                   	leave  
+ 29e:	c3                   	ret    
+
+0000029f <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 29f:	55                   	push   %ebp
+ 2a0:	89 e5                	mov    %esp,%ebp
+ 2a2:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2a5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 2ac:	00 
+ 2ad:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b0:	89 04 24             	mov    %eax,(%esp)
+ 2b3:	e8 04 01 00 00       	call   3bc <open>
+ 2b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 2bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 2bf:	79 07                	jns    2c8 <stat+0x29>
+    return -1;
+ 2c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 2c6:	eb 23                	jmp    2eb <stat+0x4c>
+  r = fstat(fd, st);
+ 2c8:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2d2:	89 04 24             	mov    %eax,(%esp)
+ 2d5:	e8 fa 00 00 00       	call   3d4 <fstat>
+ 2da:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 2dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2e0:	89 04 24             	mov    %eax,(%esp)
+ 2e3:	e8 bc 00 00 00       	call   3a4 <close>
+  return r;
+ 2e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 2eb:	c9                   	leave  
+ 2ec:	c3                   	ret    
+
+000002ed <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2ed:	55                   	push   %ebp
+ 2ee:	89 e5                	mov    %esp,%ebp
+ 2f0:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 2f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2fa:	eb 23                	jmp    31f <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 2fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 2ff:	89 d0                	mov    %edx,%eax
+ 301:	c1 e0 02             	shl    $0x2,%eax
+ 304:	01 d0                	add    %edx,%eax
+ 306:	01 c0                	add    %eax,%eax
+ 308:	89 c2                	mov    %eax,%edx
+ 30a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 30d:	0f b6 00             	movzbl (%eax),%eax
+ 310:	0f be c0             	movsbl %al,%eax
+ 313:	01 d0                	add    %edx,%eax
+ 315:	83 e8 30             	sub    $0x30,%eax
+ 318:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 31b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 31f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 322:	0f b6 00             	movzbl (%eax),%eax
+ 325:	3c 2f                	cmp    $0x2f,%al
+ 327:	7e 0a                	jle    333 <atoi+0x46>
+ 329:	8b 45 08             	mov    0x8(%ebp),%eax
+ 32c:	0f b6 00             	movzbl (%eax),%eax
+ 32f:	3c 39                	cmp    $0x39,%al
+ 331:	7e c9                	jle    2fc <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 333:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 336:	c9                   	leave  
+ 337:	c3                   	ret    
+
+00000338 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 338:	55                   	push   %ebp
+ 339:	89 e5                	mov    %esp,%ebp
+ 33b:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 33e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 341:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 344:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 347:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 34a:	eb 13                	jmp    35f <memmove+0x27>
+    *dst++ = *src++;
+ 34c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 34f:	0f b6 10             	movzbl (%eax),%edx
+ 352:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 355:	88 10                	mov    %dl,(%eax)
+ 357:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 35b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 35f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 363:	0f 9f c0             	setg   %al
+ 366:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 36a:	84 c0                	test   %al,%al
+ 36c:	75 de                	jne    34c <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 36e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 371:	c9                   	leave  
+ 372:	c3                   	ret    
+ 373:	90                   	nop
+
+00000374 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 374:	b8 01 00 00 00       	mov    $0x1,%eax
+ 379:	cd 40                	int    $0x40
+ 37b:	c3                   	ret    
+
+0000037c <exit>:
+SYSCALL(exit)
+ 37c:	b8 02 00 00 00       	mov    $0x2,%eax
+ 381:	cd 40                	int    $0x40
+ 383:	c3                   	ret    
+
+00000384 <wait>:
+SYSCALL(wait)
+ 384:	b8 03 00 00 00       	mov    $0x3,%eax
+ 389:	cd 40                	int    $0x40
+ 38b:	c3                   	ret    
+
+0000038c <pipe>:
+SYSCALL(pipe)
+ 38c:	b8 04 00 00 00       	mov    $0x4,%eax
+ 391:	cd 40                	int    $0x40
+ 393:	c3                   	ret    
+
+00000394 <read>:
+SYSCALL(read)
+ 394:	b8 05 00 00 00       	mov    $0x5,%eax
+ 399:	cd 40                	int    $0x40
+ 39b:	c3                   	ret    
+
+0000039c <write>:
+SYSCALL(write)
+ 39c:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3a1:	cd 40                	int    $0x40
+ 3a3:	c3                   	ret    
+
+000003a4 <close>:
+SYSCALL(close)
+ 3a4:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3a9:	cd 40                	int    $0x40
+ 3ab:	c3                   	ret    
+
+000003ac <kill>:
+SYSCALL(kill)
+ 3ac:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3b1:	cd 40                	int    $0x40
+ 3b3:	c3                   	ret    
+
+000003b4 <exec>:
+SYSCALL(exec)
+ 3b4:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3b9:	cd 40                	int    $0x40
+ 3bb:	c3                   	ret    
+
+000003bc <open>:
+SYSCALL(open)
+ 3bc:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3c1:	cd 40                	int    $0x40
+ 3c3:	c3                   	ret    
+
+000003c4 <mknod>:
+SYSCALL(mknod)
+ 3c4:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3c9:	cd 40                	int    $0x40
+ 3cb:	c3                   	ret    
+
+000003cc <unlink>:
+SYSCALL(unlink)
+ 3cc:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3d1:	cd 40                	int    $0x40
+ 3d3:	c3                   	ret    
+
+000003d4 <fstat>:
+SYSCALL(fstat)
+ 3d4:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3d9:	cd 40                	int    $0x40
+ 3db:	c3                   	ret    
+
+000003dc <link>:
+SYSCALL(link)
+ 3dc:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3e1:	cd 40                	int    $0x40
+ 3e3:	c3                   	ret    
+
+000003e4 <mkdir>:
+SYSCALL(mkdir)
+ 3e4:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3e9:	cd 40                	int    $0x40
+ 3eb:	c3                   	ret    
+
+000003ec <chdir>:
+SYSCALL(chdir)
+ 3ec:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3f1:	cd 40                	int    $0x40
+ 3f3:	c3                   	ret    
+
+000003f4 <dup>:
+SYSCALL(dup)
+ 3f4:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 3f9:	cd 40                	int    $0x40
+ 3fb:	c3                   	ret    
+
+000003fc <getpid>:
+SYSCALL(getpid)
+ 3fc:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 401:	cd 40                	int    $0x40
+ 403:	c3                   	ret    
+
+00000404 <sbrk>:
+SYSCALL(sbrk)
+ 404:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 409:	cd 40                	int    $0x40
+ 40b:	c3                   	ret    
+
+0000040c <sleep>:
+SYSCALL(sleep)
+ 40c:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 411:	cd 40                	int    $0x40
+ 413:	c3                   	ret    
+
+00000414 <uptime>:
+SYSCALL(uptime)
+ 414:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 419:	cd 40                	int    $0x40
+ 41b:	c3                   	ret    
+
+0000041c <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 41c:	b8 16 00 00 00       	mov    $0x16,%eax
+ 421:	cd 40                	int    $0x40
+ 423:	c3                   	ret    
+
+00000424 <shutdown>:
+SYSCALL(shutdown)
+ 424:	b8 17 00 00 00       	mov    $0x17,%eax
+ 429:	cd 40                	int    $0x40
+ 42b:	c3                   	ret    
+
+0000042c <fork_winner>:
+SYSCALL(fork_winner)
+ 42c:	b8 18 00 00 00       	mov    $0x18,%eax
+ 431:	cd 40                	int    $0x40
+ 433:	c3                   	ret    
+
+00000434 <set_sched>:
+SYSCALL(set_sched)
+ 434:	b8 19 00 00 00       	mov    $0x19,%eax
+ 439:	cd 40                	int    $0x40
+ 43b:	c3                   	ret    
+
+0000043c <set_priority>:
+SYSCALL(set_priority)
+ 43c:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 441:	cd 40                	int    $0x40
+ 443:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/forktest.d cs550-16s-proj1-working/forktest.d
--- cs550-16s-proj1-base/forktest.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/forktest.d	2016-03-04 14:36:55.000000000 -0500
@@ -0,0 +1 @@
+forktest.o: forktest.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/forktest.o and cs550-16s-proj1-working/forktest.o differ
diff -uNr cs550-16s-proj1-base/fs.c cs550-16s-proj1-working/fs.c
--- cs550-16s-proj1-base/fs.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/fs.c	2016-03-04 14:36:38.000000000 -0500
@@ -16,13 +16,12 @@
 #include "mmu.h"
 #include "proc.h"
 #include "spinlock.h"
-#include "fs.h"
 #include "buf.h"
+#include "fs.h"
 #include "file.h"
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
 static void itrunc(struct inode*);
-struct superblock sb;   // there should be one per dev, but we run with one dev
 
 // Read the super block.
 void
@@ -55,10 +54,12 @@
 {
   int b, bi, m;
   struct buf *bp;
+  struct superblock sb;
 
   bp = 0;
+  readsb(dev, &sb);
   for(b = 0; b < sb.size; b += BPB){
-    bp = bread(dev, BBLOCK(b, sb));
+    bp = bread(dev, BBLOCK(b, sb.ninodes));
     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
       m = 1 << (bi % 8);
       if((bp->data[bi/8] & m) == 0){  // Is block free?
@@ -79,10 +80,11 @@
 bfree(int dev, uint b)
 {
   struct buf *bp;
+  struct superblock sb;
   int bi, m;
 
   readsb(dev, &sb);
-  bp = bread(dev, BBLOCK(b, sb));
+  bp = bread(dev, BBLOCK(b, sb.ninodes));
   bi = b % BPB;
   m = 1 << (bi % 8);
   if((bp->data[bi/8] & m) == 0)
@@ -99,8 +101,8 @@
 // its size, the number of links referring to it, and the
 // list of blocks holding the file's content.
 //
-// The inodes are laid out sequentially on disk at
-// sb.startinode. Each inode has a number, indicating its
+// The inodes are laid out sequentially on disk immediately after
+// the superblock. Each inode has a number, indicating its
 // position on the disk.
 //
 // The kernel keeps a cache of in-use inodes in memory
@@ -160,12 +162,9 @@
 } icache;
 
 void
-iinit(int dev)
+iinit(void)
 {
   initlock(&icache.lock, "icache");
-  readsb(dev, &sb);
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
-          sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
 }
 
 static struct inode* iget(uint dev, uint inum);
@@ -179,9 +178,12 @@
   int inum;
   struct buf *bp;
   struct dinode *dip;
+  struct superblock sb;
+
+  readsb(dev, &sb);
 
   for(inum = 1; inum < sb.ninodes; inum++){
-    bp = bread(dev, IBLOCK(inum, sb));
+    bp = bread(dev, IBLOCK(inum));
     dip = (struct dinode*)bp->data + inum%IPB;
     if(dip->type == 0){  // a free inode
       memset(dip, 0, sizeof(*dip));
@@ -202,7 +204,7 @@
   struct buf *bp;
   struct dinode *dip;
 
-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+  bp = bread(ip->dev, IBLOCK(ip->inum));
   dip = (struct dinode*)bp->data + ip->inum%IPB;
   dip->type = ip->type;
   dip->major = ip->major;
@@ -279,7 +281,7 @@
   release(&icache.lock);
 
   if(!(ip->flags & I_VALID)){
-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+    bp = bread(ip->dev, IBLOCK(ip->inum));
     dip = (struct dinode*)bp->data + ip->inum%IPB;
     ip->type = dip->type;
     ip->major = dip->major;
diff -uNr cs550-16s-proj1-base/fs.d cs550-16s-proj1-working/fs.d
--- cs550-16s-proj1-base/fs.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/fs.d	2016-03-04 15:49:54.624995371 -0500
@@ -0,0 +1,2 @@
+fs.o: fs.c types.h defs.h param.h stat.h mmu.h proc.h spinlock.h buf.h \
+ fs.h file.h
diff -uNr cs550-16s-proj1-base/fs.h cs550-16s-proj1-working/fs.h
--- cs550-16s-proj1-base/fs.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/fs.h	2016-03-04 14:36:39.000000000 -0500
@@ -1,23 +1,22 @@
 // On-disk file system format. 
 // Both the kernel and user programs use this header file.
 
+// Block 0 is unused.
+// Block 1 is super block.
+// Blocks 2 through sb.ninodes/IPB hold inodes.
+// Then free bitmap blocks holding sb.size bits.
+// Then sb.nblocks data blocks.
+// Then sb.nlog log blocks.
 
 #define ROOTINO 1  // root i-number
 #define BSIZE 512  // block size
 
-// Disk layout:
-// [ boot block | super block | log | inode blocks | free bit map | data blocks ]
-//
-// mkfs computes the super block and builds an initial file system. The super describes
-// the disk layout:
+// File system super block
 struct superblock {
   uint size;         // Size of file system image (blocks)
   uint nblocks;      // Number of data blocks
   uint ninodes;      // Number of inodes.
   uint nlog;         // Number of log blocks
-  uint logstart;     // Block number of first log block
-  uint inodestart;   // Block number of first inode block
-  uint bmapstart;    // Block number of first free map block
 };
 
 #define NDIRECT 12
@@ -38,13 +37,13 @@
 #define IPB           (BSIZE / sizeof(struct dinode))
 
 // Block containing inode i
-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
+#define IBLOCK(i)     ((i) / IPB + 2)
 
 // Bitmap bits per block
 #define BPB           (BSIZE*8)
 
-// Block of free map containing bit for block b
-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
+// Block containing bit for block b
+#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
 
 // Directory is a file containing a sequence of dirent structures.
 #define DIRSIZ 14
Binary files cs550-16s-proj1-base/fs.img and cs550-16s-proj1-working/fs.img differ
Binary files cs550-16s-proj1-base/fs.o and cs550-16s-proj1-working/fs.o differ
Binary files cs550-16s-proj1-base/_grep and cs550-16s-proj1-working/_grep differ
diff -uNr cs550-16s-proj1-base/grep.asm cs550-16s-proj1-working/grep.asm
--- cs550-16s-proj1-base/grep.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/grep.asm	2016-03-04 14:36:57.000000000 -0500
@@ -0,0 +1,1562 @@
+
+_grep:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <grep>:
+char buf[1024];
+int match(char*, char*);
+
+void
+grep(char *pattern, int fd)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 ec 28             	sub    $0x28,%esp
+  int n, m;
+  char *p, *q;
+  
+  m = 0;
+   6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  while((n = read(fd, buf+m, sizeof(buf)-m)) > 0){
+   d:	e9 bf 00 00 00       	jmp    d1 <grep+0xd1>
+    m += n;
+  12:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  15:	01 45 f4             	add    %eax,-0xc(%ebp)
+    p = buf;
+  18:	c7 45 f0 80 0e 00 00 	movl   $0xe80,-0x10(%ebp)
+    while((q = strchr(p, '\n')) != 0){
+  1f:	eb 53                	jmp    74 <grep+0x74>
+      *q = 0;
+  21:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  24:	c6 00 00             	movb   $0x0,(%eax)
+      if(match(pattern, p)){
+  27:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  2a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  2e:	8b 45 08             	mov    0x8(%ebp),%eax
+  31:	89 04 24             	mov    %eax,(%esp)
+  34:	e8 c2 01 00 00       	call   1fb <match>
+  39:	85 c0                	test   %eax,%eax
+  3b:	74 2e                	je     6b <grep+0x6b>
+        *q = '\n';
+  3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  40:	c6 00 0a             	movb   $0xa,(%eax)
+        write(1, p, q+1 - p);
+  43:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  46:	83 c0 01             	add    $0x1,%eax
+  49:	89 c2                	mov    %eax,%edx
+  4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  4e:	89 d1                	mov    %edx,%ecx
+  50:	29 c1                	sub    %eax,%ecx
+  52:	89 c8                	mov    %ecx,%eax
+  54:	89 44 24 08          	mov    %eax,0x8(%esp)
+  58:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  5b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  5f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  66:	e8 81 05 00 00       	call   5ec <write>
+      }
+      p = q+1;
+  6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  6e:	83 c0 01             	add    $0x1,%eax
+  71:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  
+  m = 0;
+  while((n = read(fd, buf+m, sizeof(buf)-m)) > 0){
+    m += n;
+    p = buf;
+    while((q = strchr(p, '\n')) != 0){
+  74:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+  7b:	00 
+  7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  7f:	89 04 24             	mov    %eax,(%esp)
+  82:	e8 c2 03 00 00       	call   449 <strchr>
+  87:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  8a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  8e:	75 91                	jne    21 <grep+0x21>
+        *q = '\n';
+        write(1, p, q+1 - p);
+      }
+      p = q+1;
+    }
+    if(p == buf)
+  90:	81 7d f0 80 0e 00 00 	cmpl   $0xe80,-0x10(%ebp)
+  97:	75 07                	jne    a0 <grep+0xa0>
+      m = 0;
+  99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if(m > 0){
+  a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  a4:	7e 2b                	jle    d1 <grep+0xd1>
+      m -= p - buf;
+  a6:	ba 80 0e 00 00       	mov    $0xe80,%edx
+  ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  ae:	89 d1                	mov    %edx,%ecx
+  b0:	29 c1                	sub    %eax,%ecx
+  b2:	89 c8                	mov    %ecx,%eax
+  b4:	01 45 f4             	add    %eax,-0xc(%ebp)
+      memmove(buf, p, m);
+  b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  ba:	89 44 24 08          	mov    %eax,0x8(%esp)
+  be:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  c1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  c5:	c7 04 24 80 0e 00 00 	movl   $0xe80,(%esp)
+  cc:	e8 b7 04 00 00       	call   588 <memmove>
+{
+  int n, m;
+  char *p, *q;
+  
+  m = 0;
+  while((n = read(fd, buf+m, sizeof(buf)-m)) > 0){
+  d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  d4:	ba 00 04 00 00       	mov    $0x400,%edx
+  d9:	89 d1                	mov    %edx,%ecx
+  db:	29 c1                	sub    %eax,%ecx
+  dd:	89 c8                	mov    %ecx,%eax
+  df:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  e2:	81 c2 80 0e 00 00    	add    $0xe80,%edx
+  e8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  ec:	89 54 24 04          	mov    %edx,0x4(%esp)
+  f0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f3:	89 04 24             	mov    %eax,(%esp)
+  f6:	e8 e9 04 00 00       	call   5e4 <read>
+  fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 102:	0f 8f 0a ff ff ff    	jg     12 <grep+0x12>
+    if(m > 0){
+      m -= p - buf;
+      memmove(buf, p, m);
+    }
+  }
+}
+ 108:	c9                   	leave  
+ 109:	c3                   	ret    
+
+0000010a <main>:
+
+int
+main(int argc, char *argv[])
+{
+ 10a:	55                   	push   %ebp
+ 10b:	89 e5                	mov    %esp,%ebp
+ 10d:	83 e4 f0             	and    $0xfffffff0,%esp
+ 110:	83 ec 20             	sub    $0x20,%esp
+  int fd, i;
+  char *pattern;
+  
+  if(argc <= 1){
+ 113:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+ 117:	7f 19                	jg     132 <main+0x28>
+    printf(2, "usage: grep pattern [file ...]\n");
+ 119:	c7 44 24 04 44 0b 00 	movl   $0xb44,0x4(%esp)
+ 120:	00 
+ 121:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+ 128:	e8 44 06 00 00       	call   771 <printf>
+    exit();
+ 12d:	e8 9a 04 00 00       	call   5cc <exit>
+  }
+  pattern = argv[1];
+ 132:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 135:	8b 40 04             	mov    0x4(%eax),%eax
+ 138:	89 44 24 18          	mov    %eax,0x18(%esp)
+  
+  if(argc <= 2){
+ 13c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
+ 140:	7f 19                	jg     15b <main+0x51>
+    grep(pattern, 0);
+ 142:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 149:	00 
+ 14a:	8b 44 24 18          	mov    0x18(%esp),%eax
+ 14e:	89 04 24             	mov    %eax,(%esp)
+ 151:	e8 aa fe ff ff       	call   0 <grep>
+    exit();
+ 156:	e8 71 04 00 00       	call   5cc <exit>
+  }
+
+  for(i = 2; i < argc; i++){
+ 15b:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
+ 162:	00 
+ 163:	e9 81 00 00 00       	jmp    1e9 <main+0xdf>
+    if((fd = open(argv[i], 0)) < 0){
+ 168:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 16c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 173:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 176:	01 d0                	add    %edx,%eax
+ 178:	8b 00                	mov    (%eax),%eax
+ 17a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 181:	00 
+ 182:	89 04 24             	mov    %eax,(%esp)
+ 185:	e8 82 04 00 00       	call   60c <open>
+ 18a:	89 44 24 14          	mov    %eax,0x14(%esp)
+ 18e:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
+ 193:	79 2f                	jns    1c4 <main+0xba>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+ 195:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 199:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 1a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1a3:	01 d0                	add    %edx,%eax
+ 1a5:	8b 00                	mov    (%eax),%eax
+ 1a7:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 1ab:	c7 44 24 04 64 0b 00 	movl   $0xb64,0x4(%esp)
+ 1b2:	00 
+ 1b3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 1ba:	e8 b2 05 00 00       	call   771 <printf>
+      exit();
+ 1bf:	e8 08 04 00 00       	call   5cc <exit>
+    }
+    grep(pattern, fd);
+ 1c4:	8b 44 24 14          	mov    0x14(%esp),%eax
+ 1c8:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1cc:	8b 44 24 18          	mov    0x18(%esp),%eax
+ 1d0:	89 04 24             	mov    %eax,(%esp)
+ 1d3:	e8 28 fe ff ff       	call   0 <grep>
+    close(fd);
+ 1d8:	8b 44 24 14          	mov    0x14(%esp),%eax
+ 1dc:	89 04 24             	mov    %eax,(%esp)
+ 1df:	e8 10 04 00 00       	call   5f4 <close>
+  if(argc <= 2){
+    grep(pattern, 0);
+    exit();
+  }
+
+  for(i = 2; i < argc; i++){
+ 1e4:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+ 1e9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 1ed:	3b 45 08             	cmp    0x8(%ebp),%eax
+ 1f0:	0f 8c 72 ff ff ff    	jl     168 <main+0x5e>
+      exit();
+    }
+    grep(pattern, fd);
+    close(fd);
+  }
+  exit();
+ 1f6:	e8 d1 03 00 00       	call   5cc <exit>
+
+000001fb <match>:
+int matchhere(char*, char*);
+int matchstar(int, char*, char*);
+
+int
+match(char *re, char *text)
+{
+ 1fb:	55                   	push   %ebp
+ 1fc:	89 e5                	mov    %esp,%ebp
+ 1fe:	83 ec 18             	sub    $0x18,%esp
+  if(re[0] == '^')
+ 201:	8b 45 08             	mov    0x8(%ebp),%eax
+ 204:	0f b6 00             	movzbl (%eax),%eax
+ 207:	3c 5e                	cmp    $0x5e,%al
+ 209:	75 17                	jne    222 <match+0x27>
+    return matchhere(re+1, text);
+ 20b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20e:	8d 50 01             	lea    0x1(%eax),%edx
+ 211:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 214:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 218:	89 14 24             	mov    %edx,(%esp)
+ 21b:	e8 39 00 00 00       	call   259 <matchhere>
+ 220:	eb 35                	jmp    257 <match+0x5c>
+  do{  // must look at empty string
+    if(matchhere(re, text))
+ 222:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 225:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 229:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22c:	89 04 24             	mov    %eax,(%esp)
+ 22f:	e8 25 00 00 00       	call   259 <matchhere>
+ 234:	85 c0                	test   %eax,%eax
+ 236:	74 07                	je     23f <match+0x44>
+      return 1;
+ 238:	b8 01 00 00 00       	mov    $0x1,%eax
+ 23d:	eb 18                	jmp    257 <match+0x5c>
+  }while(*text++ != '\0');
+ 23f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 242:	0f b6 00             	movzbl (%eax),%eax
+ 245:	84 c0                	test   %al,%al
+ 247:	0f 95 c0             	setne  %al
+ 24a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 24e:	84 c0                	test   %al,%al
+ 250:	75 d0                	jne    222 <match+0x27>
+  return 0;
+ 252:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 257:	c9                   	leave  
+ 258:	c3                   	ret    
+
+00000259 <matchhere>:
+
+// matchhere: search for re at beginning of text
+int matchhere(char *re, char *text)
+{
+ 259:	55                   	push   %ebp
+ 25a:	89 e5                	mov    %esp,%ebp
+ 25c:	83 ec 18             	sub    $0x18,%esp
+  if(re[0] == '\0')
+ 25f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 262:	0f b6 00             	movzbl (%eax),%eax
+ 265:	84 c0                	test   %al,%al
+ 267:	75 0a                	jne    273 <matchhere+0x1a>
+    return 1;
+ 269:	b8 01 00 00 00       	mov    $0x1,%eax
+ 26e:	e9 9b 00 00 00       	jmp    30e <matchhere+0xb5>
+  if(re[1] == '*')
+ 273:	8b 45 08             	mov    0x8(%ebp),%eax
+ 276:	83 c0 01             	add    $0x1,%eax
+ 279:	0f b6 00             	movzbl (%eax),%eax
+ 27c:	3c 2a                	cmp    $0x2a,%al
+ 27e:	75 24                	jne    2a4 <matchhere+0x4b>
+    return matchstar(re[0], re+2, text);
+ 280:	8b 45 08             	mov    0x8(%ebp),%eax
+ 283:	8d 48 02             	lea    0x2(%eax),%ecx
+ 286:	8b 45 08             	mov    0x8(%ebp),%eax
+ 289:	0f b6 00             	movzbl (%eax),%eax
+ 28c:	0f be c0             	movsbl %al,%eax
+ 28f:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 292:	89 54 24 08          	mov    %edx,0x8(%esp)
+ 296:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+ 29a:	89 04 24             	mov    %eax,(%esp)
+ 29d:	e8 6e 00 00 00       	call   310 <matchstar>
+ 2a2:	eb 6a                	jmp    30e <matchhere+0xb5>
+  if(re[0] == '$' && re[1] == '\0')
+ 2a4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2a7:	0f b6 00             	movzbl (%eax),%eax
+ 2aa:	3c 24                	cmp    $0x24,%al
+ 2ac:	75 1d                	jne    2cb <matchhere+0x72>
+ 2ae:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b1:	83 c0 01             	add    $0x1,%eax
+ 2b4:	0f b6 00             	movzbl (%eax),%eax
+ 2b7:	84 c0                	test   %al,%al
+ 2b9:	75 10                	jne    2cb <matchhere+0x72>
+    return *text == '\0';
+ 2bb:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2be:	0f b6 00             	movzbl (%eax),%eax
+ 2c1:	84 c0                	test   %al,%al
+ 2c3:	0f 94 c0             	sete   %al
+ 2c6:	0f b6 c0             	movzbl %al,%eax
+ 2c9:	eb 43                	jmp    30e <matchhere+0xb5>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+ 2cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2ce:	0f b6 00             	movzbl (%eax),%eax
+ 2d1:	84 c0                	test   %al,%al
+ 2d3:	74 34                	je     309 <matchhere+0xb0>
+ 2d5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2d8:	0f b6 00             	movzbl (%eax),%eax
+ 2db:	3c 2e                	cmp    $0x2e,%al
+ 2dd:	74 10                	je     2ef <matchhere+0x96>
+ 2df:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2e2:	0f b6 10             	movzbl (%eax),%edx
+ 2e5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2e8:	0f b6 00             	movzbl (%eax),%eax
+ 2eb:	38 c2                	cmp    %al,%dl
+ 2ed:	75 1a                	jne    309 <matchhere+0xb0>
+    return matchhere(re+1, text+1);
+ 2ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2f2:	8d 50 01             	lea    0x1(%eax),%edx
+ 2f5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2f8:	83 c0 01             	add    $0x1,%eax
+ 2fb:	89 54 24 04          	mov    %edx,0x4(%esp)
+ 2ff:	89 04 24             	mov    %eax,(%esp)
+ 302:	e8 52 ff ff ff       	call   259 <matchhere>
+ 307:	eb 05                	jmp    30e <matchhere+0xb5>
+  return 0;
+ 309:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 30e:	c9                   	leave  
+ 30f:	c3                   	ret    
+
+00000310 <matchstar>:
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+ 310:	55                   	push   %ebp
+ 311:	89 e5                	mov    %esp,%ebp
+ 313:	83 ec 18             	sub    $0x18,%esp
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+ 316:	8b 45 10             	mov    0x10(%ebp),%eax
+ 319:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 31d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 320:	89 04 24             	mov    %eax,(%esp)
+ 323:	e8 31 ff ff ff       	call   259 <matchhere>
+ 328:	85 c0                	test   %eax,%eax
+ 32a:	74 07                	je     333 <matchstar+0x23>
+      return 1;
+ 32c:	b8 01 00 00 00       	mov    $0x1,%eax
+ 331:	eb 2c                	jmp    35f <matchstar+0x4f>
+  }while(*text!='\0' && (*text++==c || c=='.'));
+ 333:	8b 45 10             	mov    0x10(%ebp),%eax
+ 336:	0f b6 00             	movzbl (%eax),%eax
+ 339:	84 c0                	test   %al,%al
+ 33b:	74 1d                	je     35a <matchstar+0x4a>
+ 33d:	8b 45 10             	mov    0x10(%ebp),%eax
+ 340:	0f b6 00             	movzbl (%eax),%eax
+ 343:	0f be c0             	movsbl %al,%eax
+ 346:	3b 45 08             	cmp    0x8(%ebp),%eax
+ 349:	0f 94 c0             	sete   %al
+ 34c:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+ 350:	84 c0                	test   %al,%al
+ 352:	75 c2                	jne    316 <matchstar+0x6>
+ 354:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
+ 358:	74 bc                	je     316 <matchstar+0x6>
+  return 0;
+ 35a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 35f:	c9                   	leave  
+ 360:	c3                   	ret    
+ 361:	90                   	nop
+ 362:	90                   	nop
+ 363:	90                   	nop
+
+00000364 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 364:	55                   	push   %ebp
+ 365:	89 e5                	mov    %esp,%ebp
+ 367:	57                   	push   %edi
+ 368:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 369:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 36c:	8b 55 10             	mov    0x10(%ebp),%edx
+ 36f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 372:	89 cb                	mov    %ecx,%ebx
+ 374:	89 df                	mov    %ebx,%edi
+ 376:	89 d1                	mov    %edx,%ecx
+ 378:	fc                   	cld    
+ 379:	f3 aa                	rep stos %al,%es:(%edi)
+ 37b:	89 ca                	mov    %ecx,%edx
+ 37d:	89 fb                	mov    %edi,%ebx
+ 37f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 382:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 385:	5b                   	pop    %ebx
+ 386:	5f                   	pop    %edi
+ 387:	5d                   	pop    %ebp
+ 388:	c3                   	ret    
+
+00000389 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 389:	55                   	push   %ebp
+ 38a:	89 e5                	mov    %esp,%ebp
+ 38c:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 38f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 392:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 395:	90                   	nop
+ 396:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 399:	0f b6 10             	movzbl (%eax),%edx
+ 39c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 39f:	88 10                	mov    %dl,(%eax)
+ 3a1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3a4:	0f b6 00             	movzbl (%eax),%eax
+ 3a7:	84 c0                	test   %al,%al
+ 3a9:	0f 95 c0             	setne  %al
+ 3ac:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 3b0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 3b4:	84 c0                	test   %al,%al
+ 3b6:	75 de                	jne    396 <strcpy+0xd>
+    ;
+  return os;
+ 3b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3bb:	c9                   	leave  
+ 3bc:	c3                   	ret    
+
+000003bd <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 3bd:	55                   	push   %ebp
+ 3be:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 3c0:	eb 08                	jmp    3ca <strcmp+0xd>
+    p++, q++;
+ 3c2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 3c6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 3ca:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3cd:	0f b6 00             	movzbl (%eax),%eax
+ 3d0:	84 c0                	test   %al,%al
+ 3d2:	74 10                	je     3e4 <strcmp+0x27>
+ 3d4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3d7:	0f b6 10             	movzbl (%eax),%edx
+ 3da:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3dd:	0f b6 00             	movzbl (%eax),%eax
+ 3e0:	38 c2                	cmp    %al,%dl
+ 3e2:	74 de                	je     3c2 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 3e4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3e7:	0f b6 00             	movzbl (%eax),%eax
+ 3ea:	0f b6 d0             	movzbl %al,%edx
+ 3ed:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3f0:	0f b6 00             	movzbl (%eax),%eax
+ 3f3:	0f b6 c0             	movzbl %al,%eax
+ 3f6:	89 d1                	mov    %edx,%ecx
+ 3f8:	29 c1                	sub    %eax,%ecx
+ 3fa:	89 c8                	mov    %ecx,%eax
+}
+ 3fc:	5d                   	pop    %ebp
+ 3fd:	c3                   	ret    
+
+000003fe <strlen>:
+
+uint
+strlen(char *s)
+{
+ 3fe:	55                   	push   %ebp
+ 3ff:	89 e5                	mov    %esp,%ebp
+ 401:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 404:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 40b:	eb 04                	jmp    411 <strlen+0x13>
+ 40d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 411:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 414:	8b 45 08             	mov    0x8(%ebp),%eax
+ 417:	01 d0                	add    %edx,%eax
+ 419:	0f b6 00             	movzbl (%eax),%eax
+ 41c:	84 c0                	test   %al,%al
+ 41e:	75 ed                	jne    40d <strlen+0xf>
+    ;
+  return n;
+ 420:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 423:	c9                   	leave  
+ 424:	c3                   	ret    
+
+00000425 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 425:	55                   	push   %ebp
+ 426:	89 e5                	mov    %esp,%ebp
+ 428:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 42b:	8b 45 10             	mov    0x10(%ebp),%eax
+ 42e:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 432:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 435:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 439:	8b 45 08             	mov    0x8(%ebp),%eax
+ 43c:	89 04 24             	mov    %eax,(%esp)
+ 43f:	e8 20 ff ff ff       	call   364 <stosb>
+  return dst;
+ 444:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 447:	c9                   	leave  
+ 448:	c3                   	ret    
+
+00000449 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 449:	55                   	push   %ebp
+ 44a:	89 e5                	mov    %esp,%ebp
+ 44c:	83 ec 04             	sub    $0x4,%esp
+ 44f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 452:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 455:	eb 14                	jmp    46b <strchr+0x22>
+    if(*s == c)
+ 457:	8b 45 08             	mov    0x8(%ebp),%eax
+ 45a:	0f b6 00             	movzbl (%eax),%eax
+ 45d:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 460:	75 05                	jne    467 <strchr+0x1e>
+      return (char*)s;
+ 462:	8b 45 08             	mov    0x8(%ebp),%eax
+ 465:	eb 13                	jmp    47a <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 467:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 46b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 46e:	0f b6 00             	movzbl (%eax),%eax
+ 471:	84 c0                	test   %al,%al
+ 473:	75 e2                	jne    457 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 475:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 47a:	c9                   	leave  
+ 47b:	c3                   	ret    
+
+0000047c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 47c:	55                   	push   %ebp
+ 47d:	89 e5                	mov    %esp,%ebp
+ 47f:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 482:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 489:	eb 46                	jmp    4d1 <gets+0x55>
+    cc = read(0, &c, 1);
+ 48b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 492:	00 
+ 493:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 496:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 49a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 4a1:	e8 3e 01 00 00       	call   5e4 <read>
+ 4a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 4a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 4ad:	7e 2f                	jle    4de <gets+0x62>
+      break;
+    buf[i++] = c;
+ 4af:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4b2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4b5:	01 c2                	add    %eax,%edx
+ 4b7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4bb:	88 02                	mov    %al,(%edx)
+ 4bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 4c1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4c5:	3c 0a                	cmp    $0xa,%al
+ 4c7:	74 16                	je     4df <gets+0x63>
+ 4c9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4cd:	3c 0d                	cmp    $0xd,%al
+ 4cf:	74 0e                	je     4df <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 4d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4d4:	83 c0 01             	add    $0x1,%eax
+ 4d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 4da:	7c af                	jl     48b <gets+0xf>
+ 4dc:	eb 01                	jmp    4df <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 4de:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 4df:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4e2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4e5:	01 d0                	add    %edx,%eax
+ 4e7:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 4ea:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 4ed:	c9                   	leave  
+ 4ee:	c3                   	ret    
+
+000004ef <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 4ef:	55                   	push   %ebp
+ 4f0:	89 e5                	mov    %esp,%ebp
+ 4f2:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 4f5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 4fc:	00 
+ 4fd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 500:	89 04 24             	mov    %eax,(%esp)
+ 503:	e8 04 01 00 00       	call   60c <open>
+ 508:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 50b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 50f:	79 07                	jns    518 <stat+0x29>
+    return -1;
+ 511:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 516:	eb 23                	jmp    53b <stat+0x4c>
+  r = fstat(fd, st);
+ 518:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 51b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 51f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 522:	89 04 24             	mov    %eax,(%esp)
+ 525:	e8 fa 00 00 00       	call   624 <fstat>
+ 52a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 52d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 530:	89 04 24             	mov    %eax,(%esp)
+ 533:	e8 bc 00 00 00       	call   5f4 <close>
+  return r;
+ 538:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 53b:	c9                   	leave  
+ 53c:	c3                   	ret    
+
+0000053d <atoi>:
+
+int
+atoi(const char *s)
+{
+ 53d:	55                   	push   %ebp
+ 53e:	89 e5                	mov    %esp,%ebp
+ 540:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 543:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 54a:	eb 23                	jmp    56f <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 54c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 54f:	89 d0                	mov    %edx,%eax
+ 551:	c1 e0 02             	shl    $0x2,%eax
+ 554:	01 d0                	add    %edx,%eax
+ 556:	01 c0                	add    %eax,%eax
+ 558:	89 c2                	mov    %eax,%edx
+ 55a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 55d:	0f b6 00             	movzbl (%eax),%eax
+ 560:	0f be c0             	movsbl %al,%eax
+ 563:	01 d0                	add    %edx,%eax
+ 565:	83 e8 30             	sub    $0x30,%eax
+ 568:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 56b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 56f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 572:	0f b6 00             	movzbl (%eax),%eax
+ 575:	3c 2f                	cmp    $0x2f,%al
+ 577:	7e 0a                	jle    583 <atoi+0x46>
+ 579:	8b 45 08             	mov    0x8(%ebp),%eax
+ 57c:	0f b6 00             	movzbl (%eax),%eax
+ 57f:	3c 39                	cmp    $0x39,%al
+ 581:	7e c9                	jle    54c <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 583:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 586:	c9                   	leave  
+ 587:	c3                   	ret    
+
+00000588 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 588:	55                   	push   %ebp
+ 589:	89 e5                	mov    %esp,%ebp
+ 58b:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 58e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 591:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 594:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 597:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 59a:	eb 13                	jmp    5af <memmove+0x27>
+    *dst++ = *src++;
+ 59c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 59f:	0f b6 10             	movzbl (%eax),%edx
+ 5a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 5a5:	88 10                	mov    %dl,(%eax)
+ 5a7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 5ab:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 5af:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 5b3:	0f 9f c0             	setg   %al
+ 5b6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 5ba:	84 c0                	test   %al,%al
+ 5bc:	75 de                	jne    59c <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 5be:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5c1:	c9                   	leave  
+ 5c2:	c3                   	ret    
+ 5c3:	90                   	nop
+
+000005c4 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 5c4:	b8 01 00 00 00       	mov    $0x1,%eax
+ 5c9:	cd 40                	int    $0x40
+ 5cb:	c3                   	ret    
+
+000005cc <exit>:
+SYSCALL(exit)
+ 5cc:	b8 02 00 00 00       	mov    $0x2,%eax
+ 5d1:	cd 40                	int    $0x40
+ 5d3:	c3                   	ret    
+
+000005d4 <wait>:
+SYSCALL(wait)
+ 5d4:	b8 03 00 00 00       	mov    $0x3,%eax
+ 5d9:	cd 40                	int    $0x40
+ 5db:	c3                   	ret    
+
+000005dc <pipe>:
+SYSCALL(pipe)
+ 5dc:	b8 04 00 00 00       	mov    $0x4,%eax
+ 5e1:	cd 40                	int    $0x40
+ 5e3:	c3                   	ret    
+
+000005e4 <read>:
+SYSCALL(read)
+ 5e4:	b8 05 00 00 00       	mov    $0x5,%eax
+ 5e9:	cd 40                	int    $0x40
+ 5eb:	c3                   	ret    
+
+000005ec <write>:
+SYSCALL(write)
+ 5ec:	b8 10 00 00 00       	mov    $0x10,%eax
+ 5f1:	cd 40                	int    $0x40
+ 5f3:	c3                   	ret    
+
+000005f4 <close>:
+SYSCALL(close)
+ 5f4:	b8 15 00 00 00       	mov    $0x15,%eax
+ 5f9:	cd 40                	int    $0x40
+ 5fb:	c3                   	ret    
+
+000005fc <kill>:
+SYSCALL(kill)
+ 5fc:	b8 06 00 00 00       	mov    $0x6,%eax
+ 601:	cd 40                	int    $0x40
+ 603:	c3                   	ret    
+
+00000604 <exec>:
+SYSCALL(exec)
+ 604:	b8 07 00 00 00       	mov    $0x7,%eax
+ 609:	cd 40                	int    $0x40
+ 60b:	c3                   	ret    
+
+0000060c <open>:
+SYSCALL(open)
+ 60c:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 611:	cd 40                	int    $0x40
+ 613:	c3                   	ret    
+
+00000614 <mknod>:
+SYSCALL(mknod)
+ 614:	b8 11 00 00 00       	mov    $0x11,%eax
+ 619:	cd 40                	int    $0x40
+ 61b:	c3                   	ret    
+
+0000061c <unlink>:
+SYSCALL(unlink)
+ 61c:	b8 12 00 00 00       	mov    $0x12,%eax
+ 621:	cd 40                	int    $0x40
+ 623:	c3                   	ret    
+
+00000624 <fstat>:
+SYSCALL(fstat)
+ 624:	b8 08 00 00 00       	mov    $0x8,%eax
+ 629:	cd 40                	int    $0x40
+ 62b:	c3                   	ret    
+
+0000062c <link>:
+SYSCALL(link)
+ 62c:	b8 13 00 00 00       	mov    $0x13,%eax
+ 631:	cd 40                	int    $0x40
+ 633:	c3                   	ret    
+
+00000634 <mkdir>:
+SYSCALL(mkdir)
+ 634:	b8 14 00 00 00       	mov    $0x14,%eax
+ 639:	cd 40                	int    $0x40
+ 63b:	c3                   	ret    
+
+0000063c <chdir>:
+SYSCALL(chdir)
+ 63c:	b8 09 00 00 00       	mov    $0x9,%eax
+ 641:	cd 40                	int    $0x40
+ 643:	c3                   	ret    
+
+00000644 <dup>:
+SYSCALL(dup)
+ 644:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 649:	cd 40                	int    $0x40
+ 64b:	c3                   	ret    
+
+0000064c <getpid>:
+SYSCALL(getpid)
+ 64c:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 651:	cd 40                	int    $0x40
+ 653:	c3                   	ret    
+
+00000654 <sbrk>:
+SYSCALL(sbrk)
+ 654:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 659:	cd 40                	int    $0x40
+ 65b:	c3                   	ret    
+
+0000065c <sleep>:
+SYSCALL(sleep)
+ 65c:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 661:	cd 40                	int    $0x40
+ 663:	c3                   	ret    
+
+00000664 <uptime>:
+SYSCALL(uptime)
+ 664:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 669:	cd 40                	int    $0x40
+ 66b:	c3                   	ret    
+
+0000066c <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 66c:	b8 16 00 00 00       	mov    $0x16,%eax
+ 671:	cd 40                	int    $0x40
+ 673:	c3                   	ret    
+
+00000674 <shutdown>:
+SYSCALL(shutdown)
+ 674:	b8 17 00 00 00       	mov    $0x17,%eax
+ 679:	cd 40                	int    $0x40
+ 67b:	c3                   	ret    
+
+0000067c <fork_winner>:
+SYSCALL(fork_winner)
+ 67c:	b8 18 00 00 00       	mov    $0x18,%eax
+ 681:	cd 40                	int    $0x40
+ 683:	c3                   	ret    
+
+00000684 <set_sched>:
+SYSCALL(set_sched)
+ 684:	b8 19 00 00 00       	mov    $0x19,%eax
+ 689:	cd 40                	int    $0x40
+ 68b:	c3                   	ret    
+
+0000068c <set_priority>:
+SYSCALL(set_priority)
+ 68c:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 691:	cd 40                	int    $0x40
+ 693:	c3                   	ret    
+
+00000694 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 694:	55                   	push   %ebp
+ 695:	89 e5                	mov    %esp,%ebp
+ 697:	83 ec 28             	sub    $0x28,%esp
+ 69a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 69d:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 6a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 6a7:	00 
+ 6a8:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 6ab:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6af:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6b2:	89 04 24             	mov    %eax,(%esp)
+ 6b5:	e8 32 ff ff ff       	call   5ec <write>
+}
+ 6ba:	c9                   	leave  
+ 6bb:	c3                   	ret    
+
+000006bc <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 6bc:	55                   	push   %ebp
+ 6bd:	89 e5                	mov    %esp,%ebp
+ 6bf:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 6c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 6c9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 6cd:	74 17                	je     6e6 <printint+0x2a>
+ 6cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 6d3:	79 11                	jns    6e6 <printint+0x2a>
+    neg = 1;
+ 6d5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 6dc:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6df:	f7 d8                	neg    %eax
+ 6e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 6e4:	eb 06                	jmp    6ec <printint+0x30>
+  } else {
+    x = xx;
+ 6e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 6ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 6f3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 6f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 6f9:	ba 00 00 00 00       	mov    $0x0,%edx
+ 6fe:	f7 f1                	div    %ecx
+ 700:	89 d0                	mov    %edx,%eax
+ 702:	0f b6 80 40 0e 00 00 	movzbl 0xe40(%eax),%eax
+ 709:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 70c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 70f:	01 ca                	add    %ecx,%edx
+ 711:	88 02                	mov    %al,(%edx)
+ 713:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 717:	8b 55 10             	mov    0x10(%ebp),%edx
+ 71a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 71d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 720:	ba 00 00 00 00       	mov    $0x0,%edx
+ 725:	f7 75 d4             	divl   -0x2c(%ebp)
+ 728:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 72b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 72f:	75 c2                	jne    6f3 <printint+0x37>
+  if(neg)
+ 731:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 735:	74 2e                	je     765 <printint+0xa9>
+    buf[i++] = '-';
+ 737:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 73a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 73d:	01 d0                	add    %edx,%eax
+ 73f:	c6 00 2d             	movb   $0x2d,(%eax)
+ 742:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 746:	eb 1d                	jmp    765 <printint+0xa9>
+    putc(fd, buf[i]);
+ 748:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 74b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 74e:	01 d0                	add    %edx,%eax
+ 750:	0f b6 00             	movzbl (%eax),%eax
+ 753:	0f be c0             	movsbl %al,%eax
+ 756:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 75a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 75d:	89 04 24             	mov    %eax,(%esp)
+ 760:	e8 2f ff ff ff       	call   694 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 765:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 769:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 76d:	79 d9                	jns    748 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 76f:	c9                   	leave  
+ 770:	c3                   	ret    
+
+00000771 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 771:	55                   	push   %ebp
+ 772:	89 e5                	mov    %esp,%ebp
+ 774:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 777:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 77e:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 781:	83 c0 04             	add    $0x4,%eax
+ 784:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 787:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 78e:	e9 7d 01 00 00       	jmp    910 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 793:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 796:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 799:	01 d0                	add    %edx,%eax
+ 79b:	0f b6 00             	movzbl (%eax),%eax
+ 79e:	0f be c0             	movsbl %al,%eax
+ 7a1:	25 ff 00 00 00       	and    $0xff,%eax
+ 7a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 7a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 7ad:	75 2c                	jne    7db <printf+0x6a>
+      if(c == '%'){
+ 7af:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 7b3:	75 0c                	jne    7c1 <printf+0x50>
+        state = '%';
+ 7b5:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 7bc:	e9 4b 01 00 00       	jmp    90c <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 7c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 7c4:	0f be c0             	movsbl %al,%eax
+ 7c7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 7cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7ce:	89 04 24             	mov    %eax,(%esp)
+ 7d1:	e8 be fe ff ff       	call   694 <putc>
+ 7d6:	e9 31 01 00 00       	jmp    90c <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 7db:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 7df:	0f 85 27 01 00 00    	jne    90c <printf+0x19b>
+      if(c == 'd'){
+ 7e5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 7e9:	75 2d                	jne    818 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 7eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 7ee:	8b 00                	mov    (%eax),%eax
+ 7f0:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 7f7:	00 
+ 7f8:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 7ff:	00 
+ 800:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 804:	8b 45 08             	mov    0x8(%ebp),%eax
+ 807:	89 04 24             	mov    %eax,(%esp)
+ 80a:	e8 ad fe ff ff       	call   6bc <printint>
+        ap++;
+ 80f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 813:	e9 ed 00 00 00       	jmp    905 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 818:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 81c:	74 06                	je     824 <printf+0xb3>
+ 81e:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 822:	75 2d                	jne    851 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 824:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 827:	8b 00                	mov    (%eax),%eax
+ 829:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 830:	00 
+ 831:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 838:	00 
+ 839:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 83d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 840:	89 04 24             	mov    %eax,(%esp)
+ 843:	e8 74 fe ff ff       	call   6bc <printint>
+        ap++;
+ 848:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 84c:	e9 b4 00 00 00       	jmp    905 <printf+0x194>
+      } else if(c == 's'){
+ 851:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 855:	75 46                	jne    89d <printf+0x12c>
+        s = (char*)*ap;
+ 857:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 85a:	8b 00                	mov    (%eax),%eax
+ 85c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 85f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 863:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 867:	75 27                	jne    890 <printf+0x11f>
+          s = "(null)";
+ 869:	c7 45 f4 7a 0b 00 00 	movl   $0xb7a,-0xc(%ebp)
+        while(*s != 0){
+ 870:	eb 1e                	jmp    890 <printf+0x11f>
+          putc(fd, *s);
+ 872:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 875:	0f b6 00             	movzbl (%eax),%eax
+ 878:	0f be c0             	movsbl %al,%eax
+ 87b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 87f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 882:	89 04 24             	mov    %eax,(%esp)
+ 885:	e8 0a fe ff ff       	call   694 <putc>
+          s++;
+ 88a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 88e:	eb 01                	jmp    891 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 890:	90                   	nop
+ 891:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 894:	0f b6 00             	movzbl (%eax),%eax
+ 897:	84 c0                	test   %al,%al
+ 899:	75 d7                	jne    872 <printf+0x101>
+ 89b:	eb 68                	jmp    905 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 89d:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 8a1:	75 1d                	jne    8c0 <printf+0x14f>
+        putc(fd, *ap);
+ 8a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 8a6:	8b 00                	mov    (%eax),%eax
+ 8a8:	0f be c0             	movsbl %al,%eax
+ 8ab:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8af:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8b2:	89 04 24             	mov    %eax,(%esp)
+ 8b5:	e8 da fd ff ff       	call   694 <putc>
+        ap++;
+ 8ba:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 8be:	eb 45                	jmp    905 <printf+0x194>
+      } else if(c == '%'){
+ 8c0:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 8c4:	75 17                	jne    8dd <printf+0x16c>
+        putc(fd, c);
+ 8c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8c9:	0f be c0             	movsbl %al,%eax
+ 8cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8d0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8d3:	89 04 24             	mov    %eax,(%esp)
+ 8d6:	e8 b9 fd ff ff       	call   694 <putc>
+ 8db:	eb 28                	jmp    905 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 8dd:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 8e4:	00 
+ 8e5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8e8:	89 04 24             	mov    %eax,(%esp)
+ 8eb:	e8 a4 fd ff ff       	call   694 <putc>
+        putc(fd, c);
+ 8f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8f3:	0f be c0             	movsbl %al,%eax
+ 8f6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8fa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8fd:	89 04 24             	mov    %eax,(%esp)
+ 900:	e8 8f fd ff ff       	call   694 <putc>
+      }
+      state = 0;
+ 905:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 90c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 910:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 913:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 916:	01 d0                	add    %edx,%eax
+ 918:	0f b6 00             	movzbl (%eax),%eax
+ 91b:	84 c0                	test   %al,%al
+ 91d:	0f 85 70 fe ff ff    	jne    793 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 923:	c9                   	leave  
+ 924:	c3                   	ret    
+ 925:	90                   	nop
+ 926:	90                   	nop
+ 927:	90                   	nop
+
+00000928 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 928:	55                   	push   %ebp
+ 929:	89 e5                	mov    %esp,%ebp
+ 92b:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 92e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 931:	83 e8 08             	sub    $0x8,%eax
+ 934:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 937:	a1 68 0e 00 00       	mov    0xe68,%eax
+ 93c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 93f:	eb 24                	jmp    965 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 941:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 944:	8b 00                	mov    (%eax),%eax
+ 946:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 949:	77 12                	ja     95d <free+0x35>
+ 94b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 94e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 951:	77 24                	ja     977 <free+0x4f>
+ 953:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 956:	8b 00                	mov    (%eax),%eax
+ 958:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 95b:	77 1a                	ja     977 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 95d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 960:	8b 00                	mov    (%eax),%eax
+ 962:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 965:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 968:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 96b:	76 d4                	jbe    941 <free+0x19>
+ 96d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 970:	8b 00                	mov    (%eax),%eax
+ 972:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 975:	76 ca                	jbe    941 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 977:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 97a:	8b 40 04             	mov    0x4(%eax),%eax
+ 97d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 984:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 987:	01 c2                	add    %eax,%edx
+ 989:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 98c:	8b 00                	mov    (%eax),%eax
+ 98e:	39 c2                	cmp    %eax,%edx
+ 990:	75 24                	jne    9b6 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 992:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 995:	8b 50 04             	mov    0x4(%eax),%edx
+ 998:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 99b:	8b 00                	mov    (%eax),%eax
+ 99d:	8b 40 04             	mov    0x4(%eax),%eax
+ 9a0:	01 c2                	add    %eax,%edx
+ 9a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9a5:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 9a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9ab:	8b 00                	mov    (%eax),%eax
+ 9ad:	8b 10                	mov    (%eax),%edx
+ 9af:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9b2:	89 10                	mov    %edx,(%eax)
+ 9b4:	eb 0a                	jmp    9c0 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 9b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9b9:	8b 10                	mov    (%eax),%edx
+ 9bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9be:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 9c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9c3:	8b 40 04             	mov    0x4(%eax),%eax
+ 9c6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 9cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9d0:	01 d0                	add    %edx,%eax
+ 9d2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 9d5:	75 20                	jne    9f7 <free+0xcf>
+    p->s.size += bp->s.size;
+ 9d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9da:	8b 50 04             	mov    0x4(%eax),%edx
+ 9dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9e0:	8b 40 04             	mov    0x4(%eax),%eax
+ 9e3:	01 c2                	add    %eax,%edx
+ 9e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9e8:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 9eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9ee:	8b 10                	mov    (%eax),%edx
+ 9f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9f3:	89 10                	mov    %edx,(%eax)
+ 9f5:	eb 08                	jmp    9ff <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 9f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9fa:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 9fd:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 9ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a02:	a3 68 0e 00 00       	mov    %eax,0xe68
+}
+ a07:	c9                   	leave  
+ a08:	c3                   	ret    
+
+00000a09 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ a09:	55                   	push   %ebp
+ a0a:	89 e5                	mov    %esp,%ebp
+ a0c:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ a0f:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ a16:	77 07                	ja     a1f <morecore+0x16>
+    nu = 4096;
+ a18:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ a1f:	8b 45 08             	mov    0x8(%ebp),%eax
+ a22:	c1 e0 03             	shl    $0x3,%eax
+ a25:	89 04 24             	mov    %eax,(%esp)
+ a28:	e8 27 fc ff ff       	call   654 <sbrk>
+ a2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ a30:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ a34:	75 07                	jne    a3d <morecore+0x34>
+    return 0;
+ a36:	b8 00 00 00 00       	mov    $0x0,%eax
+ a3b:	eb 22                	jmp    a5f <morecore+0x56>
+  hp = (Header*)p;
+ a3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a40:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ a43:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a46:	8b 55 08             	mov    0x8(%ebp),%edx
+ a49:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ a4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a4f:	83 c0 08             	add    $0x8,%eax
+ a52:	89 04 24             	mov    %eax,(%esp)
+ a55:	e8 ce fe ff ff       	call   928 <free>
+  return freep;
+ a5a:	a1 68 0e 00 00       	mov    0xe68,%eax
+}
+ a5f:	c9                   	leave  
+ a60:	c3                   	ret    
+
+00000a61 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ a61:	55                   	push   %ebp
+ a62:	89 e5                	mov    %esp,%ebp
+ a64:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ a67:	8b 45 08             	mov    0x8(%ebp),%eax
+ a6a:	83 c0 07             	add    $0x7,%eax
+ a6d:	c1 e8 03             	shr    $0x3,%eax
+ a70:	83 c0 01             	add    $0x1,%eax
+ a73:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ a76:	a1 68 0e 00 00       	mov    0xe68,%eax
+ a7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ a7e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ a82:	75 23                	jne    aa7 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ a84:	c7 45 f0 60 0e 00 00 	movl   $0xe60,-0x10(%ebp)
+ a8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a8e:	a3 68 0e 00 00       	mov    %eax,0xe68
+ a93:	a1 68 0e 00 00       	mov    0xe68,%eax
+ a98:	a3 60 0e 00 00       	mov    %eax,0xe60
+    base.s.size = 0;
+ a9d:	c7 05 64 0e 00 00 00 	movl   $0x0,0xe64
+ aa4:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ aa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ aaa:	8b 00                	mov    (%eax),%eax
+ aac:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ab2:	8b 40 04             	mov    0x4(%eax),%eax
+ ab5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ ab8:	72 4d                	jb     b07 <malloc+0xa6>
+      if(p->s.size == nunits)
+ aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ abd:	8b 40 04             	mov    0x4(%eax),%eax
+ ac0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ ac3:	75 0c                	jne    ad1 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ ac5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ac8:	8b 10                	mov    (%eax),%edx
+ aca:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ acd:	89 10                	mov    %edx,(%eax)
+ acf:	eb 26                	jmp    af7 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ ad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ad4:	8b 40 04             	mov    0x4(%eax),%eax
+ ad7:	89 c2                	mov    %eax,%edx
+ ad9:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ adc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ adf:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ ae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ae5:	8b 40 04             	mov    0x4(%eax),%eax
+ ae8:	c1 e0 03             	shl    $0x3,%eax
+ aeb:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ aee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ af1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ af4:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ af7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ afa:	a3 68 0e 00 00       	mov    %eax,0xe68
+      return (void*)(p + 1);
+ aff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b02:	83 c0 08             	add    $0x8,%eax
+ b05:	eb 38                	jmp    b3f <malloc+0xde>
+    }
+    if(p == freep)
+ b07:	a1 68 0e 00 00       	mov    0xe68,%eax
+ b0c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ b0f:	75 1b                	jne    b2c <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ b11:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ b14:	89 04 24             	mov    %eax,(%esp)
+ b17:	e8 ed fe ff ff       	call   a09 <morecore>
+ b1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ b1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ b23:	75 07                	jne    b2c <malloc+0xcb>
+        return 0;
+ b25:	b8 00 00 00 00       	mov    $0x0,%eax
+ b2a:	eb 13                	jmp    b3f <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ b32:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b35:	8b 00                	mov    (%eax),%eax
+ b37:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ b3a:	e9 70 ff ff ff       	jmp    aaf <malloc+0x4e>
+}
+ b3f:	c9                   	leave  
+ b40:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/grep.c cs550-16s-proj1-working/grep.c
--- cs550-16s-proj1-base/grep.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/grep.c	2016-03-04 14:36:39.000000000 -0500
@@ -14,9 +14,8 @@
   char *p, *q;
   
   m = 0;
-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+  while((n = read(fd, buf+m, sizeof(buf)-m)) > 0){
     m += n;
-    buf[m] = '\0';
     p = buf;
     while((q = strchr(p, '\n')) != 0){
       *q = 0;
diff -uNr cs550-16s-proj1-base/grep.d cs550-16s-proj1-working/grep.d
--- cs550-16s-proj1-base/grep.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/grep.d	2016-03-04 14:36:56.000000000 -0500
@@ -0,0 +1 @@
+grep.o: grep.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/grep.o and cs550-16s-proj1-working/grep.o differ
diff -uNr cs550-16s-proj1-base/grep.sym cs550-16s-proj1-working/grep.sym
--- cs550-16s-proj1-base/grep.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/grep.sym	2016-03-04 14:36:57.000000000 -0500
@@ -0,0 +1,70 @@
+00000000 .text
+00000b44 .rodata
+00000b84 .eh_frame
+00000e40 .data
+00000e60 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 grep.c
+00000000 ulib.c
+00000364 stosb
+00000000 printf.c
+00000694 putc
+000006bc printint
+00000e40 digits.1028
+00000000 umalloc.c
+00000e60 base
+00000e68 freep
+00000a09 morecore
+00000389 strcpy
+00000771 printf
+00000588 memmove
+00000259 matchhere
+00000614 mknod
+0000047c gets
+0000064c getpid
+00000000 grep
+00000a61 malloc
+0000065c sleep
+0000068c set_priority
+000005dc pipe
+000005ec write
+00000624 fstat
+000005fc kill
+0000063c chdir
+00000604 exec
+000005d4 wait
+000005e4 read
+0000061c unlink
+000005c4 fork
+00000654 sbrk
+00000664 uptime
+00000e54 __bss_start
+00000425 memset
+0000010a main
+00000310 matchstar
+0000066c enable_sched_trace
+000003bd strcmp
+00000674 shutdown
+00000644 dup
+00000e80 buf
+00000684 set_sched
+000004ef stat
+00000e54 _edata
+00001280 _end
+000001fb match
+0000062c link
+000005cc exit
+0000053d atoi
+0000067c fork_winner
+000003fe strlen
+0000060c open
+00000449 strchr
+00000634 mkdir
+000005f4 close
+00000928 free
diff -uNr cs550-16s-proj1-base/ide.c cs550-16s-proj1-working/ide.c
--- cs550-16s-proj1-base/ide.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/ide.c	2016-03-04 14:36:39.000000000 -0500
@@ -9,10 +9,8 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "fs.h"
 #include "buf.h"
 
-#define SECTOR_SIZE   512
 #define IDE_BSY       0x80
 #define IDE_DRDY      0x40
 #define IDE_DF        0x20
@@ -48,7 +46,7 @@
 ideinit(void)
 {
   int i;
-  
+
   initlock(&idelock, "ide");
   picenable(IRQ_IDE);
   ioapicenable(IRQ_IDE, ncpu - 1);
@@ -73,23 +71,17 @@
 {
   if(b == 0)
     panic("idestart");
-  if(b->blockno >= FSSIZE)
-    panic("incorrect blockno");
-  int sector_per_block =  BSIZE/SECTOR_SIZE;
-  int sector = b->blockno * sector_per_block;
 
-  if (sector_per_block > 7) panic("idestart");
-  
   idewait(0);
   outb(0x3f6, 0);  // generate interrupt
-  outb(0x1f2, sector_per_block);  // number of sectors
-  outb(0x1f3, sector & 0xff);
-  outb(0x1f4, (sector >> 8) & 0xff);
-  outb(0x1f5, (sector >> 16) & 0xff);
-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+  outb(0x1f2, 1);  // number of sectors
+  outb(0x1f3, b->sector & 0xff);
+  outb(0x1f4, (b->sector >> 8) & 0xff);
+  outb(0x1f5, (b->sector >> 16) & 0xff);
+  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
   if(b->flags & B_DIRTY){
     outb(0x1f7, IDE_CMD_WRITE);
-    outsl(0x1f0, b->data, BSIZE/4);
+    outsl(0x1f0, b->data, 512/4);
   } else {
     outb(0x1f7, IDE_CMD_READ);
   }
@@ -112,7 +104,7 @@
 
   // Read data if needed.
   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
-    insl(0x1f0, b->data, BSIZE/4);
+    insl(0x1f0, b->data, 512/4);
   
   // Wake process waiting for this buf.
   b->flags |= B_VALID;
diff -uNr cs550-16s-proj1-base/ide.d cs550-16s-proj1-working/ide.d
--- cs550-16s-proj1-base/ide.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ide.d	2016-03-04 15:49:55.052989228 -0500
@@ -0,0 +1,2 @@
+ide.o: ide.c types.h defs.h param.h memlayout.h mmu.h proc.h x86.h \
+ traps.h spinlock.h buf.h
Binary files cs550-16s-proj1-base/ide.o and cs550-16s-proj1-working/ide.o differ
Binary files cs550-16s-proj1-base/_init and cs550-16s-proj1-working/_init differ
diff -uNr cs550-16s-proj1-base/init.asm cs550-16s-proj1-working/init.asm
--- cs550-16s-proj1-base/init.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/init.asm	2016-03-04 14:36:59.000000000 -0500
@@ -0,0 +1,1271 @@
+
+_init:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 20             	sub    $0x20,%esp
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+   9:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+  10:	00 
+  11:	c7 04 24 f4 08 00 00 	movl   $0x8f4,(%esp)
+  18:	e8 9f 03 00 00       	call   3bc <open>
+  1d:	85 c0                	test   %eax,%eax
+  1f:	79 30                	jns    51 <main+0x51>
+    mknod("console", 1, 1);
+  21:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+  28:	00 
+  29:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  30:	00 
+  31:	c7 04 24 f4 08 00 00 	movl   $0x8f4,(%esp)
+  38:	e8 87 03 00 00       	call   3c4 <mknod>
+    open("console", O_RDWR);
+  3d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+  44:	00 
+  45:	c7 04 24 f4 08 00 00 	movl   $0x8f4,(%esp)
+  4c:	e8 6b 03 00 00       	call   3bc <open>
+  }
+  dup(0);  // stdout
+  51:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  58:	e8 97 03 00 00       	call   3f4 <dup>
+  dup(0);  // stderr
+  5d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  64:	e8 8b 03 00 00       	call   3f4 <dup>
+  69:	eb 01                	jmp    6c <main+0x6c>
+      printf(1, "init: exec sh failed\n");
+      exit();
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+      printf(1, "zombie!\n");
+  }
+  6b:	90                   	nop
+  }
+  dup(0);  // stdout
+  dup(0);  // stderr
+
+  for(;;){
+    printf(1, "init: starting sh\n");
+  6c:	c7 44 24 04 fc 08 00 	movl   $0x8fc,0x4(%esp)
+  73:	00 
+  74:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  7b:	e8 a1 04 00 00       	call   521 <printf>
+    pid = fork();
+  80:	e8 ef 02 00 00       	call   374 <fork>
+  85:	89 44 24 1c          	mov    %eax,0x1c(%esp)
+    if(pid < 0){
+  89:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
+  8e:	79 19                	jns    a9 <main+0xa9>
+      printf(1, "init: fork failed\n");
+  90:	c7 44 24 04 0f 09 00 	movl   $0x90f,0x4(%esp)
+  97:	00 
+  98:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  9f:	e8 7d 04 00 00       	call   521 <printf>
+      exit();
+  a4:	e8 d3 02 00 00       	call   37c <exit>
+    }
+    if(pid == 0){
+  a9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
+  ae:	75 41                	jne    f1 <main+0xf1>
+      exec("sh", argv);
+  b0:	c7 44 24 04 84 0b 00 	movl   $0xb84,0x4(%esp)
+  b7:	00 
+  b8:	c7 04 24 f1 08 00 00 	movl   $0x8f1,(%esp)
+  bf:	e8 f0 02 00 00       	call   3b4 <exec>
+      printf(1, "init: exec sh failed\n");
+  c4:	c7 44 24 04 22 09 00 	movl   $0x922,0x4(%esp)
+  cb:	00 
+  cc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  d3:	e8 49 04 00 00       	call   521 <printf>
+      exit();
+  d8:	e8 9f 02 00 00       	call   37c <exit>
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+      printf(1, "zombie!\n");
+  dd:	c7 44 24 04 38 09 00 	movl   $0x938,0x4(%esp)
+  e4:	00 
+  e5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  ec:	e8 30 04 00 00       	call   521 <printf>
+    if(pid == 0){
+      exec("sh", argv);
+      printf(1, "init: exec sh failed\n");
+      exit();
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+  f1:	e8 8e 02 00 00       	call   384 <wait>
+  f6:	89 44 24 18          	mov    %eax,0x18(%esp)
+  fa:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
+  ff:	0f 88 66 ff ff ff    	js     6b <main+0x6b>
+ 105:	8b 44 24 18          	mov    0x18(%esp),%eax
+ 109:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
+ 10d:	75 ce                	jne    dd <main+0xdd>
+      printf(1, "zombie!\n");
+  }
+ 10f:	e9 57 ff ff ff       	jmp    6b <main+0x6b>
+
+00000114 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 114:	55                   	push   %ebp
+ 115:	89 e5                	mov    %esp,%ebp
+ 117:	57                   	push   %edi
+ 118:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 119:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 11c:	8b 55 10             	mov    0x10(%ebp),%edx
+ 11f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 122:	89 cb                	mov    %ecx,%ebx
+ 124:	89 df                	mov    %ebx,%edi
+ 126:	89 d1                	mov    %edx,%ecx
+ 128:	fc                   	cld    
+ 129:	f3 aa                	rep stos %al,%es:(%edi)
+ 12b:	89 ca                	mov    %ecx,%edx
+ 12d:	89 fb                	mov    %edi,%ebx
+ 12f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 132:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 135:	5b                   	pop    %ebx
+ 136:	5f                   	pop    %edi
+ 137:	5d                   	pop    %ebp
+ 138:	c3                   	ret    
+
+00000139 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 139:	55                   	push   %ebp
+ 13a:	89 e5                	mov    %esp,%ebp
+ 13c:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 13f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 142:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 145:	90                   	nop
+ 146:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 149:	0f b6 10             	movzbl (%eax),%edx
+ 14c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 14f:	88 10                	mov    %dl,(%eax)
+ 151:	8b 45 08             	mov    0x8(%ebp),%eax
+ 154:	0f b6 00             	movzbl (%eax),%eax
+ 157:	84 c0                	test   %al,%al
+ 159:	0f 95 c0             	setne  %al
+ 15c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 160:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 164:	84 c0                	test   %al,%al
+ 166:	75 de                	jne    146 <strcpy+0xd>
+    ;
+  return os;
+ 168:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 16b:	c9                   	leave  
+ 16c:	c3                   	ret    
+
+0000016d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 16d:	55                   	push   %ebp
+ 16e:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 170:	eb 08                	jmp    17a <strcmp+0xd>
+    p++, q++;
+ 172:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 176:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 17a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17d:	0f b6 00             	movzbl (%eax),%eax
+ 180:	84 c0                	test   %al,%al
+ 182:	74 10                	je     194 <strcmp+0x27>
+ 184:	8b 45 08             	mov    0x8(%ebp),%eax
+ 187:	0f b6 10             	movzbl (%eax),%edx
+ 18a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 18d:	0f b6 00             	movzbl (%eax),%eax
+ 190:	38 c2                	cmp    %al,%dl
+ 192:	74 de                	je     172 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 194:	8b 45 08             	mov    0x8(%ebp),%eax
+ 197:	0f b6 00             	movzbl (%eax),%eax
+ 19a:	0f b6 d0             	movzbl %al,%edx
+ 19d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1a0:	0f b6 00             	movzbl (%eax),%eax
+ 1a3:	0f b6 c0             	movzbl %al,%eax
+ 1a6:	89 d1                	mov    %edx,%ecx
+ 1a8:	29 c1                	sub    %eax,%ecx
+ 1aa:	89 c8                	mov    %ecx,%eax
+}
+ 1ac:	5d                   	pop    %ebp
+ 1ad:	c3                   	ret    
+
+000001ae <strlen>:
+
+uint
+strlen(char *s)
+{
+ 1ae:	55                   	push   %ebp
+ 1af:	89 e5                	mov    %esp,%ebp
+ 1b1:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 1bb:	eb 04                	jmp    1c1 <strlen+0x13>
+ 1bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 1c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1c4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1c7:	01 d0                	add    %edx,%eax
+ 1c9:	0f b6 00             	movzbl (%eax),%eax
+ 1cc:	84 c0                	test   %al,%al
+ 1ce:	75 ed                	jne    1bd <strlen+0xf>
+    ;
+  return n;
+ 1d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1d3:	c9                   	leave  
+ 1d4:	c3                   	ret    
+
+000001d5 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1d5:	55                   	push   %ebp
+ 1d6:	89 e5                	mov    %esp,%ebp
+ 1d8:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 1db:	8b 45 10             	mov    0x10(%ebp),%eax
+ 1de:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 1e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1e9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ec:	89 04 24             	mov    %eax,(%esp)
+ 1ef:	e8 20 ff ff ff       	call   114 <stosb>
+  return dst;
+ 1f4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1f7:	c9                   	leave  
+ 1f8:	c3                   	ret    
+
+000001f9 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1f9:	55                   	push   %ebp
+ 1fa:	89 e5                	mov    %esp,%ebp
+ 1fc:	83 ec 04             	sub    $0x4,%esp
+ 1ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 202:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 205:	eb 14                	jmp    21b <strchr+0x22>
+    if(*s == c)
+ 207:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20a:	0f b6 00             	movzbl (%eax),%eax
+ 20d:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 210:	75 05                	jne    217 <strchr+0x1e>
+      return (char*)s;
+ 212:	8b 45 08             	mov    0x8(%ebp),%eax
+ 215:	eb 13                	jmp    22a <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 217:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 21b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21e:	0f b6 00             	movzbl (%eax),%eax
+ 221:	84 c0                	test   %al,%al
+ 223:	75 e2                	jne    207 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 225:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 22a:	c9                   	leave  
+ 22b:	c3                   	ret    
+
+0000022c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 22c:	55                   	push   %ebp
+ 22d:	89 e5                	mov    %esp,%ebp
+ 22f:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 232:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 239:	eb 46                	jmp    281 <gets+0x55>
+    cc = read(0, &c, 1);
+ 23b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 242:	00 
+ 243:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 246:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 24a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 251:	e8 3e 01 00 00       	call   394 <read>
+ 256:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 259:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 25d:	7e 2f                	jle    28e <gets+0x62>
+      break;
+    buf[i++] = c;
+ 25f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 262:	8b 45 08             	mov    0x8(%ebp),%eax
+ 265:	01 c2                	add    %eax,%edx
+ 267:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 26b:	88 02                	mov    %al,(%edx)
+ 26d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 271:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 275:	3c 0a                	cmp    $0xa,%al
+ 277:	74 16                	je     28f <gets+0x63>
+ 279:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 27d:	3c 0d                	cmp    $0xd,%al
+ 27f:	74 0e                	je     28f <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 281:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 284:	83 c0 01             	add    $0x1,%eax
+ 287:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 28a:	7c af                	jl     23b <gets+0xf>
+ 28c:	eb 01                	jmp    28f <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 28e:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 28f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 292:	8b 45 08             	mov    0x8(%ebp),%eax
+ 295:	01 d0                	add    %edx,%eax
+ 297:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 29a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 29d:	c9                   	leave  
+ 29e:	c3                   	ret    
+
+0000029f <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 29f:	55                   	push   %ebp
+ 2a0:	89 e5                	mov    %esp,%ebp
+ 2a2:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2a5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 2ac:	00 
+ 2ad:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b0:	89 04 24             	mov    %eax,(%esp)
+ 2b3:	e8 04 01 00 00       	call   3bc <open>
+ 2b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 2bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 2bf:	79 07                	jns    2c8 <stat+0x29>
+    return -1;
+ 2c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 2c6:	eb 23                	jmp    2eb <stat+0x4c>
+  r = fstat(fd, st);
+ 2c8:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2d2:	89 04 24             	mov    %eax,(%esp)
+ 2d5:	e8 fa 00 00 00       	call   3d4 <fstat>
+ 2da:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 2dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2e0:	89 04 24             	mov    %eax,(%esp)
+ 2e3:	e8 bc 00 00 00       	call   3a4 <close>
+  return r;
+ 2e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 2eb:	c9                   	leave  
+ 2ec:	c3                   	ret    
+
+000002ed <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2ed:	55                   	push   %ebp
+ 2ee:	89 e5                	mov    %esp,%ebp
+ 2f0:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 2f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2fa:	eb 23                	jmp    31f <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 2fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 2ff:	89 d0                	mov    %edx,%eax
+ 301:	c1 e0 02             	shl    $0x2,%eax
+ 304:	01 d0                	add    %edx,%eax
+ 306:	01 c0                	add    %eax,%eax
+ 308:	89 c2                	mov    %eax,%edx
+ 30a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 30d:	0f b6 00             	movzbl (%eax),%eax
+ 310:	0f be c0             	movsbl %al,%eax
+ 313:	01 d0                	add    %edx,%eax
+ 315:	83 e8 30             	sub    $0x30,%eax
+ 318:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 31b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 31f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 322:	0f b6 00             	movzbl (%eax),%eax
+ 325:	3c 2f                	cmp    $0x2f,%al
+ 327:	7e 0a                	jle    333 <atoi+0x46>
+ 329:	8b 45 08             	mov    0x8(%ebp),%eax
+ 32c:	0f b6 00             	movzbl (%eax),%eax
+ 32f:	3c 39                	cmp    $0x39,%al
+ 331:	7e c9                	jle    2fc <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 333:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 336:	c9                   	leave  
+ 337:	c3                   	ret    
+
+00000338 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 338:	55                   	push   %ebp
+ 339:	89 e5                	mov    %esp,%ebp
+ 33b:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 33e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 341:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 344:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 347:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 34a:	eb 13                	jmp    35f <memmove+0x27>
+    *dst++ = *src++;
+ 34c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 34f:	0f b6 10             	movzbl (%eax),%edx
+ 352:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 355:	88 10                	mov    %dl,(%eax)
+ 357:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 35b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 35f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 363:	0f 9f c0             	setg   %al
+ 366:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 36a:	84 c0                	test   %al,%al
+ 36c:	75 de                	jne    34c <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 36e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 371:	c9                   	leave  
+ 372:	c3                   	ret    
+ 373:	90                   	nop
+
+00000374 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 374:	b8 01 00 00 00       	mov    $0x1,%eax
+ 379:	cd 40                	int    $0x40
+ 37b:	c3                   	ret    
+
+0000037c <exit>:
+SYSCALL(exit)
+ 37c:	b8 02 00 00 00       	mov    $0x2,%eax
+ 381:	cd 40                	int    $0x40
+ 383:	c3                   	ret    
+
+00000384 <wait>:
+SYSCALL(wait)
+ 384:	b8 03 00 00 00       	mov    $0x3,%eax
+ 389:	cd 40                	int    $0x40
+ 38b:	c3                   	ret    
+
+0000038c <pipe>:
+SYSCALL(pipe)
+ 38c:	b8 04 00 00 00       	mov    $0x4,%eax
+ 391:	cd 40                	int    $0x40
+ 393:	c3                   	ret    
+
+00000394 <read>:
+SYSCALL(read)
+ 394:	b8 05 00 00 00       	mov    $0x5,%eax
+ 399:	cd 40                	int    $0x40
+ 39b:	c3                   	ret    
+
+0000039c <write>:
+SYSCALL(write)
+ 39c:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3a1:	cd 40                	int    $0x40
+ 3a3:	c3                   	ret    
+
+000003a4 <close>:
+SYSCALL(close)
+ 3a4:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3a9:	cd 40                	int    $0x40
+ 3ab:	c3                   	ret    
+
+000003ac <kill>:
+SYSCALL(kill)
+ 3ac:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3b1:	cd 40                	int    $0x40
+ 3b3:	c3                   	ret    
+
+000003b4 <exec>:
+SYSCALL(exec)
+ 3b4:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3b9:	cd 40                	int    $0x40
+ 3bb:	c3                   	ret    
+
+000003bc <open>:
+SYSCALL(open)
+ 3bc:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3c1:	cd 40                	int    $0x40
+ 3c3:	c3                   	ret    
+
+000003c4 <mknod>:
+SYSCALL(mknod)
+ 3c4:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3c9:	cd 40                	int    $0x40
+ 3cb:	c3                   	ret    
+
+000003cc <unlink>:
+SYSCALL(unlink)
+ 3cc:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3d1:	cd 40                	int    $0x40
+ 3d3:	c3                   	ret    
+
+000003d4 <fstat>:
+SYSCALL(fstat)
+ 3d4:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3d9:	cd 40                	int    $0x40
+ 3db:	c3                   	ret    
+
+000003dc <link>:
+SYSCALL(link)
+ 3dc:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3e1:	cd 40                	int    $0x40
+ 3e3:	c3                   	ret    
+
+000003e4 <mkdir>:
+SYSCALL(mkdir)
+ 3e4:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3e9:	cd 40                	int    $0x40
+ 3eb:	c3                   	ret    
+
+000003ec <chdir>:
+SYSCALL(chdir)
+ 3ec:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3f1:	cd 40                	int    $0x40
+ 3f3:	c3                   	ret    
+
+000003f4 <dup>:
+SYSCALL(dup)
+ 3f4:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 3f9:	cd 40                	int    $0x40
+ 3fb:	c3                   	ret    
+
+000003fc <getpid>:
+SYSCALL(getpid)
+ 3fc:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 401:	cd 40                	int    $0x40
+ 403:	c3                   	ret    
+
+00000404 <sbrk>:
+SYSCALL(sbrk)
+ 404:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 409:	cd 40                	int    $0x40
+ 40b:	c3                   	ret    
+
+0000040c <sleep>:
+SYSCALL(sleep)
+ 40c:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 411:	cd 40                	int    $0x40
+ 413:	c3                   	ret    
+
+00000414 <uptime>:
+SYSCALL(uptime)
+ 414:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 419:	cd 40                	int    $0x40
+ 41b:	c3                   	ret    
+
+0000041c <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 41c:	b8 16 00 00 00       	mov    $0x16,%eax
+ 421:	cd 40                	int    $0x40
+ 423:	c3                   	ret    
+
+00000424 <shutdown>:
+SYSCALL(shutdown)
+ 424:	b8 17 00 00 00       	mov    $0x17,%eax
+ 429:	cd 40                	int    $0x40
+ 42b:	c3                   	ret    
+
+0000042c <fork_winner>:
+SYSCALL(fork_winner)
+ 42c:	b8 18 00 00 00       	mov    $0x18,%eax
+ 431:	cd 40                	int    $0x40
+ 433:	c3                   	ret    
+
+00000434 <set_sched>:
+SYSCALL(set_sched)
+ 434:	b8 19 00 00 00       	mov    $0x19,%eax
+ 439:	cd 40                	int    $0x40
+ 43b:	c3                   	ret    
+
+0000043c <set_priority>:
+SYSCALL(set_priority)
+ 43c:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 441:	cd 40                	int    $0x40
+ 443:	c3                   	ret    
+
+00000444 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 444:	55                   	push   %ebp
+ 445:	89 e5                	mov    %esp,%ebp
+ 447:	83 ec 28             	sub    $0x28,%esp
+ 44a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 44d:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 450:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 457:	00 
+ 458:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 45b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 45f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 462:	89 04 24             	mov    %eax,(%esp)
+ 465:	e8 32 ff ff ff       	call   39c <write>
+}
+ 46a:	c9                   	leave  
+ 46b:	c3                   	ret    
+
+0000046c <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 46c:	55                   	push   %ebp
+ 46d:	89 e5                	mov    %esp,%ebp
+ 46f:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 472:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 479:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 47d:	74 17                	je     496 <printint+0x2a>
+ 47f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 483:	79 11                	jns    496 <printint+0x2a>
+    neg = 1;
+ 485:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 48c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 48f:	f7 d8                	neg    %eax
+ 491:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 494:	eb 06                	jmp    49c <printint+0x30>
+  } else {
+    x = xx;
+ 496:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 499:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 49c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 4a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4a9:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4ae:	f7 f1                	div    %ecx
+ 4b0:	89 d0                	mov    %edx,%eax
+ 4b2:	0f b6 80 8c 0b 00 00 	movzbl 0xb8c(%eax),%eax
+ 4b9:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 4bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4bf:	01 ca                	add    %ecx,%edx
+ 4c1:	88 02                	mov    %al,(%edx)
+ 4c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 4c7:	8b 55 10             	mov    0x10(%ebp),%edx
+ 4ca:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 4cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4d0:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4d5:	f7 75 d4             	divl   -0x2c(%ebp)
+ 4d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4db:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4df:	75 c2                	jne    4a3 <printint+0x37>
+  if(neg)
+ 4e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 4e5:	74 2e                	je     515 <printint+0xa9>
+    buf[i++] = '-';
+ 4e7:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 4ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4ed:	01 d0                	add    %edx,%eax
+ 4ef:	c6 00 2d             	movb   $0x2d,(%eax)
+ 4f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 4f6:	eb 1d                	jmp    515 <printint+0xa9>
+    putc(fd, buf[i]);
+ 4f8:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 4fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4fe:	01 d0                	add    %edx,%eax
+ 500:	0f b6 00             	movzbl (%eax),%eax
+ 503:	0f be c0             	movsbl %al,%eax
+ 506:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 50a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 50d:	89 04 24             	mov    %eax,(%esp)
+ 510:	e8 2f ff ff ff       	call   444 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 515:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 519:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 51d:	79 d9                	jns    4f8 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 51f:	c9                   	leave  
+ 520:	c3                   	ret    
+
+00000521 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 521:	55                   	push   %ebp
+ 522:	89 e5                	mov    %esp,%ebp
+ 524:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 527:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 52e:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 531:	83 c0 04             	add    $0x4,%eax
+ 534:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 537:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 53e:	e9 7d 01 00 00       	jmp    6c0 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 543:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 546:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 549:	01 d0                	add    %edx,%eax
+ 54b:	0f b6 00             	movzbl (%eax),%eax
+ 54e:	0f be c0             	movsbl %al,%eax
+ 551:	25 ff 00 00 00       	and    $0xff,%eax
+ 556:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 559:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 55d:	75 2c                	jne    58b <printf+0x6a>
+      if(c == '%'){
+ 55f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 563:	75 0c                	jne    571 <printf+0x50>
+        state = '%';
+ 565:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 56c:	e9 4b 01 00 00       	jmp    6bc <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 571:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 574:	0f be c0             	movsbl %al,%eax
+ 577:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 57b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 57e:	89 04 24             	mov    %eax,(%esp)
+ 581:	e8 be fe ff ff       	call   444 <putc>
+ 586:	e9 31 01 00 00       	jmp    6bc <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 58b:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 58f:	0f 85 27 01 00 00    	jne    6bc <printf+0x19b>
+      if(c == 'd'){
+ 595:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 599:	75 2d                	jne    5c8 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 59b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 59e:	8b 00                	mov    (%eax),%eax
+ 5a0:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 5a7:	00 
+ 5a8:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 5af:	00 
+ 5b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5b4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5b7:	89 04 24             	mov    %eax,(%esp)
+ 5ba:	e8 ad fe ff ff       	call   46c <printint>
+        ap++;
+ 5bf:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5c3:	e9 ed 00 00 00       	jmp    6b5 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 5c8:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 5cc:	74 06                	je     5d4 <printf+0xb3>
+ 5ce:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 5d2:	75 2d                	jne    601 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 5d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5d7:	8b 00                	mov    (%eax),%eax
+ 5d9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 5e0:	00 
+ 5e1:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 5e8:	00 
+ 5e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5ed:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5f0:	89 04 24             	mov    %eax,(%esp)
+ 5f3:	e8 74 fe ff ff       	call   46c <printint>
+        ap++;
+ 5f8:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5fc:	e9 b4 00 00 00       	jmp    6b5 <printf+0x194>
+      } else if(c == 's'){
+ 601:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 605:	75 46                	jne    64d <printf+0x12c>
+        s = (char*)*ap;
+ 607:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 60a:	8b 00                	mov    (%eax),%eax
+ 60c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 60f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 613:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 617:	75 27                	jne    640 <printf+0x11f>
+          s = "(null)";
+ 619:	c7 45 f4 41 09 00 00 	movl   $0x941,-0xc(%ebp)
+        while(*s != 0){
+ 620:	eb 1e                	jmp    640 <printf+0x11f>
+          putc(fd, *s);
+ 622:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 625:	0f b6 00             	movzbl (%eax),%eax
+ 628:	0f be c0             	movsbl %al,%eax
+ 62b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 62f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 632:	89 04 24             	mov    %eax,(%esp)
+ 635:	e8 0a fe ff ff       	call   444 <putc>
+          s++;
+ 63a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 63e:	eb 01                	jmp    641 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 640:	90                   	nop
+ 641:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 644:	0f b6 00             	movzbl (%eax),%eax
+ 647:	84 c0                	test   %al,%al
+ 649:	75 d7                	jne    622 <printf+0x101>
+ 64b:	eb 68                	jmp    6b5 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 64d:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 651:	75 1d                	jne    670 <printf+0x14f>
+        putc(fd, *ap);
+ 653:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 656:	8b 00                	mov    (%eax),%eax
+ 658:	0f be c0             	movsbl %al,%eax
+ 65b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 65f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 662:	89 04 24             	mov    %eax,(%esp)
+ 665:	e8 da fd ff ff       	call   444 <putc>
+        ap++;
+ 66a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 66e:	eb 45                	jmp    6b5 <printf+0x194>
+      } else if(c == '%'){
+ 670:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 674:	75 17                	jne    68d <printf+0x16c>
+        putc(fd, c);
+ 676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 679:	0f be c0             	movsbl %al,%eax
+ 67c:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 680:	8b 45 08             	mov    0x8(%ebp),%eax
+ 683:	89 04 24             	mov    %eax,(%esp)
+ 686:	e8 b9 fd ff ff       	call   444 <putc>
+ 68b:	eb 28                	jmp    6b5 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 68d:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 694:	00 
+ 695:	8b 45 08             	mov    0x8(%ebp),%eax
+ 698:	89 04 24             	mov    %eax,(%esp)
+ 69b:	e8 a4 fd ff ff       	call   444 <putc>
+        putc(fd, c);
+ 6a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 6a3:	0f be c0             	movsbl %al,%eax
+ 6a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6aa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6ad:	89 04 24             	mov    %eax,(%esp)
+ 6b0:	e8 8f fd ff ff       	call   444 <putc>
+      }
+      state = 0;
+ 6b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 6bc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 6c0:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 6c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6c6:	01 d0                	add    %edx,%eax
+ 6c8:	0f b6 00             	movzbl (%eax),%eax
+ 6cb:	84 c0                	test   %al,%al
+ 6cd:	0f 85 70 fe ff ff    	jne    543 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 6d3:	c9                   	leave  
+ 6d4:	c3                   	ret    
+ 6d5:	90                   	nop
+ 6d6:	90                   	nop
+ 6d7:	90                   	nop
+
+000006d8 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6d8:	55                   	push   %ebp
+ 6d9:	89 e5                	mov    %esp,%ebp
+ 6db:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 6de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6e1:	83 e8 08             	sub    $0x8,%eax
+ 6e4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6e7:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 6ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 6ef:	eb 24                	jmp    715 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f4:	8b 00                	mov    (%eax),%eax
+ 6f6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 6f9:	77 12                	ja     70d <free+0x35>
+ 6fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6fe:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 701:	77 24                	ja     727 <free+0x4f>
+ 703:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 706:	8b 00                	mov    (%eax),%eax
+ 708:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 70b:	77 1a                	ja     727 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 70d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 710:	8b 00                	mov    (%eax),%eax
+ 712:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 715:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 718:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 71b:	76 d4                	jbe    6f1 <free+0x19>
+ 71d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 720:	8b 00                	mov    (%eax),%eax
+ 722:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 725:	76 ca                	jbe    6f1 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 727:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 72a:	8b 40 04             	mov    0x4(%eax),%eax
+ 72d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 734:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 737:	01 c2                	add    %eax,%edx
+ 739:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 73c:	8b 00                	mov    (%eax),%eax
+ 73e:	39 c2                	cmp    %eax,%edx
+ 740:	75 24                	jne    766 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 742:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 745:	8b 50 04             	mov    0x4(%eax),%edx
+ 748:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 74b:	8b 00                	mov    (%eax),%eax
+ 74d:	8b 40 04             	mov    0x4(%eax),%eax
+ 750:	01 c2                	add    %eax,%edx
+ 752:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 755:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 758:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 75b:	8b 00                	mov    (%eax),%eax
+ 75d:	8b 10                	mov    (%eax),%edx
+ 75f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 762:	89 10                	mov    %edx,(%eax)
+ 764:	eb 0a                	jmp    770 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 766:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 769:	8b 10                	mov    (%eax),%edx
+ 76b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 76e:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 770:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 773:	8b 40 04             	mov    0x4(%eax),%eax
+ 776:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 77d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 780:	01 d0                	add    %edx,%eax
+ 782:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 785:	75 20                	jne    7a7 <free+0xcf>
+    p->s.size += bp->s.size;
+ 787:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 78a:	8b 50 04             	mov    0x4(%eax),%edx
+ 78d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 790:	8b 40 04             	mov    0x4(%eax),%eax
+ 793:	01 c2                	add    %eax,%edx
+ 795:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 798:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 79b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 79e:	8b 10                	mov    (%eax),%edx
+ 7a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7a3:	89 10                	mov    %edx,(%eax)
+ 7a5:	eb 08                	jmp    7af <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 7a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 7ad:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 7af:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b2:	a3 a8 0b 00 00       	mov    %eax,0xba8
+}
+ 7b7:	c9                   	leave  
+ 7b8:	c3                   	ret    
+
+000007b9 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 7b9:	55                   	push   %ebp
+ 7ba:	89 e5                	mov    %esp,%ebp
+ 7bc:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 7bf:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 7c6:	77 07                	ja     7cf <morecore+0x16>
+    nu = 4096;
+ 7c8:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 7cf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7d2:	c1 e0 03             	shl    $0x3,%eax
+ 7d5:	89 04 24             	mov    %eax,(%esp)
+ 7d8:	e8 27 fc ff ff       	call   404 <sbrk>
+ 7dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 7e0:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 7e4:	75 07                	jne    7ed <morecore+0x34>
+    return 0;
+ 7e6:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7eb:	eb 22                	jmp    80f <morecore+0x56>
+  hp = (Header*)p;
+ 7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 7f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7f6:	8b 55 08             	mov    0x8(%ebp),%edx
+ 7f9:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 7fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7ff:	83 c0 08             	add    $0x8,%eax
+ 802:	89 04 24             	mov    %eax,(%esp)
+ 805:	e8 ce fe ff ff       	call   6d8 <free>
+  return freep;
+ 80a:	a1 a8 0b 00 00       	mov    0xba8,%eax
+}
+ 80f:	c9                   	leave  
+ 810:	c3                   	ret    
+
+00000811 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 811:	55                   	push   %ebp
+ 812:	89 e5                	mov    %esp,%ebp
+ 814:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 817:	8b 45 08             	mov    0x8(%ebp),%eax
+ 81a:	83 c0 07             	add    $0x7,%eax
+ 81d:	c1 e8 03             	shr    $0x3,%eax
+ 820:	83 c0 01             	add    $0x1,%eax
+ 823:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 826:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 82b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 82e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 832:	75 23                	jne    857 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 834:	c7 45 f0 a0 0b 00 00 	movl   $0xba0,-0x10(%ebp)
+ 83b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 83e:	a3 a8 0b 00 00       	mov    %eax,0xba8
+ 843:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 848:	a3 a0 0b 00 00       	mov    %eax,0xba0
+    base.s.size = 0;
+ 84d:	c7 05 a4 0b 00 00 00 	movl   $0x0,0xba4
+ 854:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 857:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 85a:	8b 00                	mov    (%eax),%eax
+ 85c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 85f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 862:	8b 40 04             	mov    0x4(%eax),%eax
+ 865:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 868:	72 4d                	jb     8b7 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 86a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86d:	8b 40 04             	mov    0x4(%eax),%eax
+ 870:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 873:	75 0c                	jne    881 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 875:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 878:	8b 10                	mov    (%eax),%edx
+ 87a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 87d:	89 10                	mov    %edx,(%eax)
+ 87f:	eb 26                	jmp    8a7 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 881:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 884:	8b 40 04             	mov    0x4(%eax),%eax
+ 887:	89 c2                	mov    %eax,%edx
+ 889:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 88c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 88f:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 892:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 895:	8b 40 04             	mov    0x4(%eax),%eax
+ 898:	c1 e0 03             	shl    $0x3,%eax
+ 89b:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 89e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 8a4:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 8a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8aa:	a3 a8 0b 00 00       	mov    %eax,0xba8
+      return (void*)(p + 1);
+ 8af:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8b2:	83 c0 08             	add    $0x8,%eax
+ 8b5:	eb 38                	jmp    8ef <malloc+0xde>
+    }
+    if(p == freep)
+ 8b7:	a1 a8 0b 00 00       	mov    0xba8,%eax
+ 8bc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 8bf:	75 1b                	jne    8dc <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 8c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 8c4:	89 04 24             	mov    %eax,(%esp)
+ 8c7:	e8 ed fe ff ff       	call   7b9 <morecore>
+ 8cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 8cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 8d3:	75 07                	jne    8dc <malloc+0xcb>
+        return 0;
+ 8d5:	b8 00 00 00 00       	mov    $0x0,%eax
+ 8da:	eb 13                	jmp    8ef <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8df:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8e5:	8b 00                	mov    (%eax),%eax
+ 8e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 8ea:	e9 70 ff ff ff       	jmp    85f <malloc+0x4e>
+}
+ 8ef:	c9                   	leave  
+ 8f0:	c3                   	ret    
Binary files cs550-16s-proj1-base/initcode and cs550-16s-proj1-working/initcode differ
diff -uNr cs550-16s-proj1-base/initcode.asm cs550-16s-proj1-working/initcode.asm
--- cs550-16s-proj1-base/initcode.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/initcode.asm	2016-03-04 14:37:31.000000000 -0500
@@ -0,0 +1,43 @@
+
+initcode.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <start>:
+
+
+# exec(init, argv)
+.globl start
+start:
+  pushl $argv
+   0:	68 24 00 00 00       	push   $0x24
+  pushl $init
+   5:	68 1c 00 00 00       	push   $0x1c
+  pushl $0  // where caller pc would be
+   a:	6a 00                	push   $0x0
+  movl $SYS_exec, %eax
+   c:	b8 07 00 00 00       	mov    $0x7,%eax
+  int $T_SYSCALL
+  11:	cd 40                	int    $0x40
+
+00000013 <exit>:
+
+# for(;;) exit();
+exit:
+  movl $SYS_exit, %eax
+  13:	b8 02 00 00 00       	mov    $0x2,%eax
+  int $T_SYSCALL
+  18:	cd 40                	int    $0x40
+  jmp exit
+  1a:	eb f7                	jmp    13 <exit>
+
+0000001c <init>:
+  1c:	2f                   	das    
+  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
+
+00000024 <argv>:
+  24:	1c 00                	sbb    $0x0,%al
+  26:	00 00                	add    %al,(%eax)
+  28:	00 00                	add    %al,(%eax)
+	...
diff -uNr cs550-16s-proj1-base/initcode.d cs550-16s-proj1-working/initcode.d
--- cs550-16s-proj1-base/initcode.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/initcode.d	2016-03-04 14:37:30.000000000 -0500
@@ -0,0 +1 @@
+initcode.o: initcode.S syscall.h traps.h
Binary files cs550-16s-proj1-base/initcode.o and cs550-16s-proj1-working/initcode.o differ
Binary files cs550-16s-proj1-base/initcode.out and cs550-16s-proj1-working/initcode.out differ
diff -uNr cs550-16s-proj1-base/init.d cs550-16s-proj1-working/init.d
--- cs550-16s-proj1-base/init.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/init.d	2016-03-04 14:36:58.000000000 -0500
@@ -0,0 +1 @@
+init.o: init.c types.h stat.h user.h fcntl.h
Binary files cs550-16s-proj1-base/init.o and cs550-16s-proj1-working/init.o differ
diff -uNr cs550-16s-proj1-base/init.sym cs550-16s-proj1-working/init.sym
--- cs550-16s-proj1-base/init.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/init.sym	2016-03-04 14:36:59.000000000 -0500
@@ -0,0 +1,66 @@
+00000000 .text
+000008f1 .rodata
+00000948 .eh_frame
+00000b84 .data
+00000ba0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 init.c
+00000000 ulib.c
+00000114 stosb
+00000000 printf.c
+00000444 putc
+0000046c printint
+00000b8c digits.1028
+00000000 umalloc.c
+00000ba0 base
+00000ba8 freep
+000007b9 morecore
+00000139 strcpy
+00000521 printf
+00000b84 argv
+00000338 memmove
+000003c4 mknod
+0000022c gets
+000003fc getpid
+00000811 malloc
+0000040c sleep
+0000043c set_priority
+0000038c pipe
+0000039c write
+000003d4 fstat
+000003ac kill
+000003ec chdir
+000003b4 exec
+00000384 wait
+00000394 read
+000003cc unlink
+00000374 fork
+00000404 sbrk
+00000414 uptime
+00000ba0 __bss_start
+000001d5 memset
+00000000 main
+0000041c enable_sched_trace
+0000016d strcmp
+00000424 shutdown
+000003f4 dup
+00000434 set_sched
+0000029f stat
+00000ba0 _edata
+00000bac _end
+000003dc link
+0000037c exit
+000002ed atoi
+0000042c fork_winner
+000001ae strlen
+000003bc open
+000001f9 strchr
+000003e4 mkdir
+000003a4 close
+000006d8 free
diff -uNr cs550-16s-proj1-base/ioapic.d cs550-16s-proj1-working/ioapic.d
--- cs550-16s-proj1-base/ioapic.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ioapic.d	2016-03-04 14:37:19.000000000 -0500
@@ -0,0 +1 @@
+ioapic.o: ioapic.c types.h defs.h traps.h
Binary files cs550-16s-proj1-base/ioapic.o and cs550-16s-proj1-working/ioapic.o differ
diff -uNr cs550-16s-proj1-base/kalloc.d cs550-16s-proj1-working/kalloc.d
--- cs550-16s-proj1-base/kalloc.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kalloc.d	2016-03-04 14:37:19.000000000 -0500
@@ -0,0 +1 @@
+kalloc.o: kalloc.c types.h defs.h param.h memlayout.h mmu.h spinlock.h
Binary files cs550-16s-proj1-base/kalloc.o and cs550-16s-proj1-working/kalloc.o differ
diff -uNr cs550-16s-proj1-base/kbd.d cs550-16s-proj1-working/kbd.d
--- cs550-16s-proj1-base/kbd.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kbd.d	2016-03-04 14:37:20.000000000 -0500
@@ -0,0 +1 @@
+kbd.o: kbd.c types.h x86.h defs.h kbd.h
Binary files cs550-16s-proj1-base/kbd.o and cs550-16s-proj1-working/kbd.o differ
Binary files cs550-16s-proj1-base/kernel and cs550-16s-proj1-working/kernel differ
diff -uNr cs550-16s-proj1-base/kernel.asm cs550-16s-proj1-working/kernel.asm
--- cs550-16s-proj1-base/kernel.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kernel.asm	2016-03-04 15:55:05.664520545 -0500
@@ -0,0 +1,17903 @@
+
+kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+80100000 <multiboot_header>:
+80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
+80100006:	00 00                	add    %al,(%eax)
+80100008:	fe 4f 52             	decb   0x52(%edi)
+8010000b:	e4 0f                	in     $0xf,%al
+
+8010000c <entry>:
+
+# Entering xv6 on boot processor, with paging off.
+.globl entry
+entry:
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+8010000c:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+8010000f:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+80100012:	0f 22 e0             	mov    %eax,%cr4
+  # Set page directory
+  movl    $(V2P_WO(entrypgdir)), %eax
+80100015:	b8 00 a0 10 00       	mov    $0x10a000,%eax
+  movl    %eax, %cr3
+8010001a:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+8010001d:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PG|CR0_WP), %eax
+80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
+  movl    %eax, %cr0
+80100025:	0f 22 c0             	mov    %eax,%cr0
+
+  # Set up the stack pointer.
+  movl $(stack + KSTACKSIZE), %esp
+80100028:	bc 80 c6 10 80       	mov    $0x8010c680,%esp
+
+  # Jump to main(), and switch to executing at
+  # high addresses. The indirect call is needed because
+  # the assembler produces a PC-relative instruction
+  # for a direct jump.
+  mov $main, %eax
+8010002d:	b8 a3 37 10 80       	mov    $0x801037a3,%eax
+  jmp *%eax
+80100032:	ff e0                	jmp    *%eax
+
+80100034 <binit>:
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+80100034:	55                   	push   %ebp
+80100035:	89 e5                	mov    %esp,%ebp
+80100037:	83 ec 28             	sub    $0x28,%esp
+  struct buf *b;
+
+  initlock(&bcache.lock, "bcache");
+8010003a:	c7 44 24 04 3c 87 10 	movl   $0x8010873c,0x4(%esp)
+80100041:	80 
+80100042:	c7 04 24 80 c6 10 80 	movl   $0x8010c680,(%esp)
+80100049:	e8 84 4f 00 00       	call   80104fd2 <initlock>
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+8010004e:	c7 05 90 05 11 80 84 	movl   $0x80110584,0x80110590
+80100055:	05 11 80 
+  bcache.head.next = &bcache.head;
+80100058:	c7 05 94 05 11 80 84 	movl   $0x80110584,0x80110594
+8010005f:	05 11 80 
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100062:	c7 45 f4 b4 c6 10 80 	movl   $0x8010c6b4,-0xc(%ebp)
+80100069:	eb 3a                	jmp    801000a5 <binit+0x71>
+    b->next = bcache.head.next;
+8010006b:	8b 15 94 05 11 80    	mov    0x80110594,%edx
+80100071:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100074:	89 50 10             	mov    %edx,0x10(%eax)
+    b->prev = &bcache.head;
+80100077:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010007a:	c7 40 0c 84 05 11 80 	movl   $0x80110584,0xc(%eax)
+    b->dev = -1;
+80100081:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100084:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
+    bcache.head.next->prev = b;
+8010008b:	a1 94 05 11 80       	mov    0x80110594,%eax
+80100090:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80100093:	89 50 0c             	mov    %edx,0xc(%eax)
+    bcache.head.next = b;
+80100096:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100099:	a3 94 05 11 80       	mov    %eax,0x80110594
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+  bcache.head.next = &bcache.head;
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+8010009e:	81 45 f4 18 02 00 00 	addl   $0x218,-0xc(%ebp)
+801000a5:	81 7d f4 84 05 11 80 	cmpl   $0x80110584,-0xc(%ebp)
+801000ac:	72 bd                	jb     8010006b <binit+0x37>
+    b->prev = &bcache.head;
+    b->dev = -1;
+    bcache.head.next->prev = b;
+    bcache.head.next = b;
+  }
+}
+801000ae:	c9                   	leave  
+801000af:	c3                   	ret    
+
+801000b0 <bget>:
+// Look through buffer cache for sector on device dev.
+// If not found, allocate a buffer.
+// In either case, return B_BUSY buffer.
+static struct buf*
+bget(uint dev, uint sector)
+{
+801000b0:	55                   	push   %ebp
+801000b1:	89 e5                	mov    %esp,%ebp
+801000b3:	83 ec 28             	sub    $0x28,%esp
+  struct buf *b;
+
+  acquire(&bcache.lock);
+801000b6:	c7 04 24 80 c6 10 80 	movl   $0x8010c680,(%esp)
+801000bd:	e8 31 4f 00 00       	call   80104ff3 <acquire>
+
+ loop:
+  // Is the sector already cached?
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+801000c2:	a1 94 05 11 80       	mov    0x80110594,%eax
+801000c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801000ca:	eb 63                	jmp    8010012f <bget+0x7f>
+    if(b->dev == dev && b->sector == sector){
+801000cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000cf:	8b 40 04             	mov    0x4(%eax),%eax
+801000d2:	3b 45 08             	cmp    0x8(%ebp),%eax
+801000d5:	75 4f                	jne    80100126 <bget+0x76>
+801000d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000da:	8b 40 08             	mov    0x8(%eax),%eax
+801000dd:	3b 45 0c             	cmp    0xc(%ebp),%eax
+801000e0:	75 44                	jne    80100126 <bget+0x76>
+      if(!(b->flags & B_BUSY)){
+801000e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000e5:	8b 00                	mov    (%eax),%eax
+801000e7:	83 e0 01             	and    $0x1,%eax
+801000ea:	85 c0                	test   %eax,%eax
+801000ec:	75 23                	jne    80100111 <bget+0x61>
+        b->flags |= B_BUSY;
+801000ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000f1:	8b 00                	mov    (%eax),%eax
+801000f3:	89 c2                	mov    %eax,%edx
+801000f5:	83 ca 01             	or     $0x1,%edx
+801000f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000fb:	89 10                	mov    %edx,(%eax)
+        release(&bcache.lock);
+801000fd:	c7 04 24 80 c6 10 80 	movl   $0x8010c680,(%esp)
+80100104:	e8 4c 4f 00 00       	call   80105055 <release>
+        return b;
+80100109:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010010c:	e9 93 00 00 00       	jmp    801001a4 <bget+0xf4>
+      }
+      sleep(b, &bcache.lock);
+80100111:	c7 44 24 04 80 c6 10 	movl   $0x8010c680,0x4(%esp)
+80100118:	80 
+80100119:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010011c:	89 04 24             	mov    %eax,(%esp)
+8010011f:	e8 f1 4b 00 00       	call   80104d15 <sleep>
+      goto loop;
+80100124:	eb 9c                	jmp    801000c2 <bget+0x12>
+
+  acquire(&bcache.lock);
+
+ loop:
+  // Is the sector already cached?
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+80100126:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100129:	8b 40 10             	mov    0x10(%eax),%eax
+8010012c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010012f:	81 7d f4 84 05 11 80 	cmpl   $0x80110584,-0xc(%ebp)
+80100136:	75 94                	jne    801000cc <bget+0x1c>
+  }
+
+  // Not cached; recycle some non-busy and clean buffer.
+  // "clean" because B_DIRTY and !B_BUSY means log.c
+  // hasn't yet committed the changes to the buffer.
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+80100138:	a1 90 05 11 80       	mov    0x80110590,%eax
+8010013d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80100140:	eb 4d                	jmp    8010018f <bget+0xdf>
+    if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
+80100142:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100145:	8b 00                	mov    (%eax),%eax
+80100147:	83 e0 01             	and    $0x1,%eax
+8010014a:	85 c0                	test   %eax,%eax
+8010014c:	75 38                	jne    80100186 <bget+0xd6>
+8010014e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100151:	8b 00                	mov    (%eax),%eax
+80100153:	83 e0 04             	and    $0x4,%eax
+80100156:	85 c0                	test   %eax,%eax
+80100158:	75 2c                	jne    80100186 <bget+0xd6>
+      b->dev = dev;
+8010015a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010015d:	8b 55 08             	mov    0x8(%ebp),%edx
+80100160:	89 50 04             	mov    %edx,0x4(%eax)
+      b->sector = sector;
+80100163:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100166:	8b 55 0c             	mov    0xc(%ebp),%edx
+80100169:	89 50 08             	mov    %edx,0x8(%eax)
+      b->flags = B_BUSY;
+8010016c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010016f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+      release(&bcache.lock);
+80100175:	c7 04 24 80 c6 10 80 	movl   $0x8010c680,(%esp)
+8010017c:	e8 d4 4e 00 00       	call   80105055 <release>
+      return b;
+80100181:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100184:	eb 1e                	jmp    801001a4 <bget+0xf4>
+  }
+
+  // Not cached; recycle some non-busy and clean buffer.
+  // "clean" because B_DIRTY and !B_BUSY means log.c
+  // hasn't yet committed the changes to the buffer.
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+80100186:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100189:	8b 40 0c             	mov    0xc(%eax),%eax
+8010018c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010018f:	81 7d f4 84 05 11 80 	cmpl   $0x80110584,-0xc(%ebp)
+80100196:	75 aa                	jne    80100142 <bget+0x92>
+      b->flags = B_BUSY;
+      release(&bcache.lock);
+      return b;
+    }
+  }
+  panic("bget: no buffers");
+80100198:	c7 04 24 43 87 10 80 	movl   $0x80108743,(%esp)
+8010019f:	e8 a2 03 00 00       	call   80100546 <panic>
+}
+801001a4:	c9                   	leave  
+801001a5:	c3                   	ret    
+
+801001a6 <bread>:
+
+// Return a B_BUSY buf with the contents of the indicated disk sector.
+struct buf*
+bread(uint dev, uint sector)
+{
+801001a6:	55                   	push   %ebp
+801001a7:	89 e5                	mov    %esp,%ebp
+801001a9:	83 ec 28             	sub    $0x28,%esp
+  struct buf *b;
+
+  b = bget(dev, sector);
+801001ac:	8b 45 0c             	mov    0xc(%ebp),%eax
+801001af:	89 44 24 04          	mov    %eax,0x4(%esp)
+801001b3:	8b 45 08             	mov    0x8(%ebp),%eax
+801001b6:	89 04 24             	mov    %eax,(%esp)
+801001b9:	e8 f2 fe ff ff       	call   801000b0 <bget>
+801001be:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(!(b->flags & B_VALID))
+801001c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801001c4:	8b 00                	mov    (%eax),%eax
+801001c6:	83 e0 02             	and    $0x2,%eax
+801001c9:	85 c0                	test   %eax,%eax
+801001cb:	75 0b                	jne    801001d8 <bread+0x32>
+    iderw(b);
+801001cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801001d0:	89 04 24             	mov    %eax,(%esp)
+801001d3:	e8 28 26 00 00       	call   80102800 <iderw>
+  return b;
+801001d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+801001db:	c9                   	leave  
+801001dc:	c3                   	ret    
+
+801001dd <bwrite>:
+
+// Write b's contents to disk.  Must be B_BUSY.
+void
+bwrite(struct buf *b)
+{
+801001dd:	55                   	push   %ebp
+801001de:	89 e5                	mov    %esp,%ebp
+801001e0:	83 ec 18             	sub    $0x18,%esp
+  if((b->flags & B_BUSY) == 0)
+801001e3:	8b 45 08             	mov    0x8(%ebp),%eax
+801001e6:	8b 00                	mov    (%eax),%eax
+801001e8:	83 e0 01             	and    $0x1,%eax
+801001eb:	85 c0                	test   %eax,%eax
+801001ed:	75 0c                	jne    801001fb <bwrite+0x1e>
+    panic("bwrite");
+801001ef:	c7 04 24 54 87 10 80 	movl   $0x80108754,(%esp)
+801001f6:	e8 4b 03 00 00       	call   80100546 <panic>
+  b->flags |= B_DIRTY;
+801001fb:	8b 45 08             	mov    0x8(%ebp),%eax
+801001fe:	8b 00                	mov    (%eax),%eax
+80100200:	89 c2                	mov    %eax,%edx
+80100202:	83 ca 04             	or     $0x4,%edx
+80100205:	8b 45 08             	mov    0x8(%ebp),%eax
+80100208:	89 10                	mov    %edx,(%eax)
+  iderw(b);
+8010020a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010020d:	89 04 24             	mov    %eax,(%esp)
+80100210:	e8 eb 25 00 00       	call   80102800 <iderw>
+}
+80100215:	c9                   	leave  
+80100216:	c3                   	ret    
+
+80100217 <brelse>:
+
+// Release a B_BUSY buffer.
+// Move to the head of the MRU list.
+void
+brelse(struct buf *b)
+{
+80100217:	55                   	push   %ebp
+80100218:	89 e5                	mov    %esp,%ebp
+8010021a:	83 ec 18             	sub    $0x18,%esp
+  if((b->flags & B_BUSY) == 0)
+8010021d:	8b 45 08             	mov    0x8(%ebp),%eax
+80100220:	8b 00                	mov    (%eax),%eax
+80100222:	83 e0 01             	and    $0x1,%eax
+80100225:	85 c0                	test   %eax,%eax
+80100227:	75 0c                	jne    80100235 <brelse+0x1e>
+    panic("brelse");
+80100229:	c7 04 24 5b 87 10 80 	movl   $0x8010875b,(%esp)
+80100230:	e8 11 03 00 00       	call   80100546 <panic>
+
+  acquire(&bcache.lock);
+80100235:	c7 04 24 80 c6 10 80 	movl   $0x8010c680,(%esp)
+8010023c:	e8 b2 4d 00 00       	call   80104ff3 <acquire>
+
+  b->next->prev = b->prev;
+80100241:	8b 45 08             	mov    0x8(%ebp),%eax
+80100244:	8b 40 10             	mov    0x10(%eax),%eax
+80100247:	8b 55 08             	mov    0x8(%ebp),%edx
+8010024a:	8b 52 0c             	mov    0xc(%edx),%edx
+8010024d:	89 50 0c             	mov    %edx,0xc(%eax)
+  b->prev->next = b->next;
+80100250:	8b 45 08             	mov    0x8(%ebp),%eax
+80100253:	8b 40 0c             	mov    0xc(%eax),%eax
+80100256:	8b 55 08             	mov    0x8(%ebp),%edx
+80100259:	8b 52 10             	mov    0x10(%edx),%edx
+8010025c:	89 50 10             	mov    %edx,0x10(%eax)
+  b->next = bcache.head.next;
+8010025f:	8b 15 94 05 11 80    	mov    0x80110594,%edx
+80100265:	8b 45 08             	mov    0x8(%ebp),%eax
+80100268:	89 50 10             	mov    %edx,0x10(%eax)
+  b->prev = &bcache.head;
+8010026b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010026e:	c7 40 0c 84 05 11 80 	movl   $0x80110584,0xc(%eax)
+  bcache.head.next->prev = b;
+80100275:	a1 94 05 11 80       	mov    0x80110594,%eax
+8010027a:	8b 55 08             	mov    0x8(%ebp),%edx
+8010027d:	89 50 0c             	mov    %edx,0xc(%eax)
+  bcache.head.next = b;
+80100280:	8b 45 08             	mov    0x8(%ebp),%eax
+80100283:	a3 94 05 11 80       	mov    %eax,0x80110594
+
+  b->flags &= ~B_BUSY;
+80100288:	8b 45 08             	mov    0x8(%ebp),%eax
+8010028b:	8b 00                	mov    (%eax),%eax
+8010028d:	89 c2                	mov    %eax,%edx
+8010028f:	83 e2 fe             	and    $0xfffffffe,%edx
+80100292:	8b 45 08             	mov    0x8(%ebp),%eax
+80100295:	89 10                	mov    %edx,(%eax)
+  wakeup(b);
+80100297:	8b 45 08             	mov    0x8(%ebp),%eax
+8010029a:	89 04 24             	mov    %eax,(%esp)
+8010029d:	e8 4c 4b 00 00       	call   80104dee <wakeup>
+
+  release(&bcache.lock);
+801002a2:	c7 04 24 80 c6 10 80 	movl   $0x8010c680,(%esp)
+801002a9:	e8 a7 4d 00 00       	call   80105055 <release>
+}
+801002ae:	c9                   	leave  
+801002af:	c3                   	ret    
+
+801002b0 <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+801002b0:	55                   	push   %ebp
+801002b1:	89 e5                	mov    %esp,%ebp
+801002b3:	53                   	push   %ebx
+801002b4:	83 ec 14             	sub    $0x14,%esp
+801002b7:	8b 45 08             	mov    0x8(%ebp),%eax
+801002ba:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801002be:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+801002c2:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+801002c6:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+801002ca:	ec                   	in     (%dx),%al
+801002cb:	89 c3                	mov    %eax,%ebx
+801002cd:	88 5d fb             	mov    %bl,-0x5(%ebp)
+  return data;
+801002d0:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+}
+801002d4:	83 c4 14             	add    $0x14,%esp
+801002d7:	5b                   	pop    %ebx
+801002d8:	5d                   	pop    %ebp
+801002d9:	c3                   	ret    
+
+801002da <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+801002da:	55                   	push   %ebp
+801002db:	89 e5                	mov    %esp,%ebp
+801002dd:	83 ec 08             	sub    $0x8,%esp
+801002e0:	8b 55 08             	mov    0x8(%ebp),%edx
+801002e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+801002e6:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+801002ea:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801002ed:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+801002f1:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+801002f5:	ee                   	out    %al,(%dx)
+}
+801002f6:	c9                   	leave  
+801002f7:	c3                   	ret    
+
+801002f8 <cli>:
+  asm volatile("movw %0, %%gs" : : "r" (v));
+}
+
+static inline void
+cli(void)
+{
+801002f8:	55                   	push   %ebp
+801002f9:	89 e5                	mov    %esp,%ebp
+  asm volatile("cli");
+801002fb:	fa                   	cli    
+}
+801002fc:	5d                   	pop    %ebp
+801002fd:	c3                   	ret    
+
+801002fe <printint>:
+  int locking;
+} cons;
+
+static void
+printint(int xx, int base, int sign)
+{
+801002fe:	55                   	push   %ebp
+801002ff:	89 e5                	mov    %esp,%ebp
+80100301:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789abcdef";
+  char buf[16];
+  int i;
+  uint x;
+
+  if(sign && (sign = xx < 0))
+80100304:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80100308:	74 1c                	je     80100326 <printint+0x28>
+8010030a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010030d:	c1 e8 1f             	shr    $0x1f,%eax
+80100310:	0f b6 c0             	movzbl %al,%eax
+80100313:	89 45 10             	mov    %eax,0x10(%ebp)
+80100316:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010031a:	74 0a                	je     80100326 <printint+0x28>
+    x = -xx;
+8010031c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010031f:	f7 d8                	neg    %eax
+80100321:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80100324:	eb 06                	jmp    8010032c <printint+0x2e>
+  else
+    x = xx;
+80100326:	8b 45 08             	mov    0x8(%ebp),%eax
+80100329:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  i = 0;
+8010032c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+80100333:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80100336:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80100339:	ba 00 00 00 00       	mov    $0x0,%edx
+8010033e:	f7 f1                	div    %ecx
+80100340:	89 d0                	mov    %edx,%eax
+80100342:	0f b6 80 04 90 10 80 	movzbl -0x7fef6ffc(%eax),%eax
+80100349:	8d 4d e0             	lea    -0x20(%ebp),%ecx
+8010034c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010034f:	01 ca                	add    %ecx,%edx
+80100351:	88 02                	mov    %al,(%edx)
+80100353:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+80100357:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010035a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+8010035d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80100360:	ba 00 00 00 00       	mov    $0x0,%edx
+80100365:	f7 75 d4             	divl   -0x2c(%ebp)
+80100368:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010036b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010036f:	75 c2                	jne    80100333 <printint+0x35>
+
+  if(sign)
+80100371:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80100375:	74 27                	je     8010039e <printint+0xa0>
+    buf[i++] = '-';
+80100377:	8d 55 e0             	lea    -0x20(%ebp),%edx
+8010037a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010037d:	01 d0                	add    %edx,%eax
+8010037f:	c6 00 2d             	movb   $0x2d,(%eax)
+80100382:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+80100386:	eb 16                	jmp    8010039e <printint+0xa0>
+    consputc(buf[i]);
+80100388:	8d 55 e0             	lea    -0x20(%ebp),%edx
+8010038b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010038e:	01 d0                	add    %edx,%eax
+80100390:	0f b6 00             	movzbl (%eax),%eax
+80100393:	0f be c0             	movsbl %al,%eax
+80100396:	89 04 24             	mov    %eax,(%esp)
+80100399:	e8 bb 03 00 00       	call   80100759 <consputc>
+  }while((x /= base) != 0);
+
+  if(sign)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+8010039e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+801003a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801003a6:	79 e0                	jns    80100388 <printint+0x8a>
+    consputc(buf[i]);
+}
+801003a8:	c9                   	leave  
+801003a9:	c3                   	ret    
+
+801003aa <cprintf>:
+//PAGEBREAK: 50
+
+// Print to the console. only understands %d, %x, %p, %s.
+void
+cprintf(char *fmt, ...)
+{
+801003aa:	55                   	push   %ebp
+801003ab:	89 e5                	mov    %esp,%ebp
+801003ad:	83 ec 38             	sub    $0x38,%esp
+  int i, c, locking;
+  uint *argp;
+  char *s;
+
+  locking = cons.locking;
+801003b0:	a1 14 b6 10 80       	mov    0x8010b614,%eax
+801003b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(locking)
+801003b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+801003bc:	74 0c                	je     801003ca <cprintf+0x20>
+    acquire(&cons.lock);
+801003be:	c7 04 24 e0 b5 10 80 	movl   $0x8010b5e0,(%esp)
+801003c5:	e8 29 4c 00 00       	call   80104ff3 <acquire>
+
+  if (fmt == 0)
+801003ca:	8b 45 08             	mov    0x8(%ebp),%eax
+801003cd:	85 c0                	test   %eax,%eax
+801003cf:	75 0c                	jne    801003dd <cprintf+0x33>
+    panic("null fmt");
+801003d1:	c7 04 24 62 87 10 80 	movl   $0x80108762,(%esp)
+801003d8:	e8 69 01 00 00       	call   80100546 <panic>
+
+  argp = (uint*)(void*)(&fmt + 1);
+801003dd:	8d 45 0c             	lea    0xc(%ebp),%eax
+801003e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801003e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801003ea:	e9 20 01 00 00       	jmp    8010050f <cprintf+0x165>
+    if(c != '%'){
+801003ef:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+801003f3:	74 10                	je     80100405 <cprintf+0x5b>
+      consputc(c);
+801003f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801003f8:	89 04 24             	mov    %eax,(%esp)
+801003fb:	e8 59 03 00 00       	call   80100759 <consputc>
+      continue;
+80100400:	e9 06 01 00 00       	jmp    8010050b <cprintf+0x161>
+    }
+    c = fmt[++i] & 0xff;
+80100405:	8b 55 08             	mov    0x8(%ebp),%edx
+80100408:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+8010040c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010040f:	01 d0                	add    %edx,%eax
+80100411:	0f b6 00             	movzbl (%eax),%eax
+80100414:	0f be c0             	movsbl %al,%eax
+80100417:	25 ff 00 00 00       	and    $0xff,%eax
+8010041c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(c == 0)
+8010041f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+80100423:	0f 84 08 01 00 00    	je     80100531 <cprintf+0x187>
+      break;
+    switch(c){
+80100429:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+8010042c:	83 f8 70             	cmp    $0x70,%eax
+8010042f:	74 4d                	je     8010047e <cprintf+0xd4>
+80100431:	83 f8 70             	cmp    $0x70,%eax
+80100434:	7f 13                	jg     80100449 <cprintf+0x9f>
+80100436:	83 f8 25             	cmp    $0x25,%eax
+80100439:	0f 84 a6 00 00 00    	je     801004e5 <cprintf+0x13b>
+8010043f:	83 f8 64             	cmp    $0x64,%eax
+80100442:	74 14                	je     80100458 <cprintf+0xae>
+80100444:	e9 aa 00 00 00       	jmp    801004f3 <cprintf+0x149>
+80100449:	83 f8 73             	cmp    $0x73,%eax
+8010044c:	74 53                	je     801004a1 <cprintf+0xf7>
+8010044e:	83 f8 78             	cmp    $0x78,%eax
+80100451:	74 2b                	je     8010047e <cprintf+0xd4>
+80100453:	e9 9b 00 00 00       	jmp    801004f3 <cprintf+0x149>
+    case 'd':
+      printint(*argp++, 10, 1);
+80100458:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010045b:	8b 00                	mov    (%eax),%eax
+8010045d:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
+80100461:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+80100468:	00 
+80100469:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+80100470:	00 
+80100471:	89 04 24             	mov    %eax,(%esp)
+80100474:	e8 85 fe ff ff       	call   801002fe <printint>
+      break;
+80100479:	e9 8d 00 00 00       	jmp    8010050b <cprintf+0x161>
+    case 'x':
+    case 'p':
+      printint(*argp++, 16, 0);
+8010047e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80100481:	8b 00                	mov    (%eax),%eax
+80100483:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
+80100487:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+8010048e:	00 
+8010048f:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+80100496:	00 
+80100497:	89 04 24             	mov    %eax,(%esp)
+8010049a:	e8 5f fe ff ff       	call   801002fe <printint>
+      break;
+8010049f:	eb 6a                	jmp    8010050b <cprintf+0x161>
+    case 's':
+      if((s = (char*)*argp++) == 0)
+801004a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801004a4:	8b 00                	mov    (%eax),%eax
+801004a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+801004a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+801004ad:	0f 94 c0             	sete   %al
+801004b0:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
+801004b4:	84 c0                	test   %al,%al
+801004b6:	74 20                	je     801004d8 <cprintf+0x12e>
+        s = "(null)";
+801004b8:	c7 45 ec 6b 87 10 80 	movl   $0x8010876b,-0x14(%ebp)
+      for(; *s; s++)
+801004bf:	eb 17                	jmp    801004d8 <cprintf+0x12e>
+        consputc(*s);
+801004c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801004c4:	0f b6 00             	movzbl (%eax),%eax
+801004c7:	0f be c0             	movsbl %al,%eax
+801004ca:	89 04 24             	mov    %eax,(%esp)
+801004cd:	e8 87 02 00 00       	call   80100759 <consputc>
+      printint(*argp++, 16, 0);
+      break;
+    case 's':
+      if((s = (char*)*argp++) == 0)
+        s = "(null)";
+      for(; *s; s++)
+801004d2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+801004d6:	eb 01                	jmp    801004d9 <cprintf+0x12f>
+801004d8:	90                   	nop
+801004d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801004dc:	0f b6 00             	movzbl (%eax),%eax
+801004df:	84 c0                	test   %al,%al
+801004e1:	75 de                	jne    801004c1 <cprintf+0x117>
+        consputc(*s);
+      break;
+801004e3:	eb 26                	jmp    8010050b <cprintf+0x161>
+    case '%':
+      consputc('%');
+801004e5:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+801004ec:	e8 68 02 00 00       	call   80100759 <consputc>
+      break;
+801004f1:	eb 18                	jmp    8010050b <cprintf+0x161>
+    default:
+      // Print unknown % sequence to draw attention.
+      consputc('%');
+801004f3:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+801004fa:	e8 5a 02 00 00       	call   80100759 <consputc>
+      consputc(c);
+801004ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100502:	89 04 24             	mov    %eax,(%esp)
+80100505:	e8 4f 02 00 00       	call   80100759 <consputc>
+      break;
+8010050a:	90                   	nop
+
+  if (fmt == 0)
+    panic("null fmt");
+
+  argp = (uint*)(void*)(&fmt + 1);
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+8010050b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+8010050f:	8b 55 08             	mov    0x8(%ebp),%edx
+80100512:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100515:	01 d0                	add    %edx,%eax
+80100517:	0f b6 00             	movzbl (%eax),%eax
+8010051a:	0f be c0             	movsbl %al,%eax
+8010051d:	25 ff 00 00 00       	and    $0xff,%eax
+80100522:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80100525:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+80100529:	0f 85 c0 fe ff ff    	jne    801003ef <cprintf+0x45>
+8010052f:	eb 01                	jmp    80100532 <cprintf+0x188>
+      consputc(c);
+      continue;
+    }
+    c = fmt[++i] & 0xff;
+    if(c == 0)
+      break;
+80100531:	90                   	nop
+      consputc(c);
+      break;
+    }
+  }
+
+  if(locking)
+80100532:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+80100536:	74 0c                	je     80100544 <cprintf+0x19a>
+    release(&cons.lock);
+80100538:	c7 04 24 e0 b5 10 80 	movl   $0x8010b5e0,(%esp)
+8010053f:	e8 11 4b 00 00       	call   80105055 <release>
+}
+80100544:	c9                   	leave  
+80100545:	c3                   	ret    
+
+80100546 <panic>:
+
+void
+panic(char *s)
+{
+80100546:	55                   	push   %ebp
+80100547:	89 e5                	mov    %esp,%ebp
+80100549:	83 ec 48             	sub    $0x48,%esp
+  int i;
+  uint pcs[10];
+  
+  cli();
+8010054c:	e8 a7 fd ff ff       	call   801002f8 <cli>
+  cons.locking = 0;
+80100551:	c7 05 14 b6 10 80 00 	movl   $0x0,0x8010b614
+80100558:	00 00 00 
+  cprintf("cpu%d: panic: ", cpu->id);
+8010055b:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80100561:	0f b6 00             	movzbl (%eax),%eax
+80100564:	0f b6 c0             	movzbl %al,%eax
+80100567:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010056b:	c7 04 24 72 87 10 80 	movl   $0x80108772,(%esp)
+80100572:	e8 33 fe ff ff       	call   801003aa <cprintf>
+  cprintf(s);
+80100577:	8b 45 08             	mov    0x8(%ebp),%eax
+8010057a:	89 04 24             	mov    %eax,(%esp)
+8010057d:	e8 28 fe ff ff       	call   801003aa <cprintf>
+  cprintf("\n");
+80100582:	c7 04 24 81 87 10 80 	movl   $0x80108781,(%esp)
+80100589:	e8 1c fe ff ff       	call   801003aa <cprintf>
+  getcallerpcs(&s, pcs);
+8010058e:	8d 45 cc             	lea    -0x34(%ebp),%eax
+80100591:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100595:	8d 45 08             	lea    0x8(%ebp),%eax
+80100598:	89 04 24             	mov    %eax,(%esp)
+8010059b:	e8 04 4b 00 00       	call   801050a4 <getcallerpcs>
+  for(i=0; i<10; i++)
+801005a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801005a7:	eb 1b                	jmp    801005c4 <panic+0x7e>
+    cprintf(" %p", pcs[i]);
+801005a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801005ac:	8b 44 85 cc          	mov    -0x34(%ebp,%eax,4),%eax
+801005b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+801005b4:	c7 04 24 83 87 10 80 	movl   $0x80108783,(%esp)
+801005bb:	e8 ea fd ff ff       	call   801003aa <cprintf>
+  cons.locking = 0;
+  cprintf("cpu%d: panic: ", cpu->id);
+  cprintf(s);
+  cprintf("\n");
+  getcallerpcs(&s, pcs);
+  for(i=0; i<10; i++)
+801005c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801005c4:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+801005c8:	7e df                	jle    801005a9 <panic+0x63>
+    cprintf(" %p", pcs[i]);
+  panicked = 1; // freeze other CPU
+801005ca:	c7 05 c0 b5 10 80 01 	movl   $0x1,0x8010b5c0
+801005d1:	00 00 00 
+  for(;;)
+    ;
+801005d4:	eb fe                	jmp    801005d4 <panic+0x8e>
+
+801005d6 <cgaputc>:
+#define CRTPORT 0x3d4
+static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+
+static void
+cgaputc(int c)
+{
+801005d6:	55                   	push   %ebp
+801005d7:	89 e5                	mov    %esp,%ebp
+801005d9:	83 ec 28             	sub    $0x28,%esp
+  int pos;
+  
+  // Cursor position: col + 80*row.
+  outb(CRTPORT, 14);
+801005dc:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
+801005e3:	00 
+801005e4:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
+801005eb:	e8 ea fc ff ff       	call   801002da <outb>
+  pos = inb(CRTPORT+1) << 8;
+801005f0:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
+801005f7:	e8 b4 fc ff ff       	call   801002b0 <inb>
+801005fc:	0f b6 c0             	movzbl %al,%eax
+801005ff:	c1 e0 08             	shl    $0x8,%eax
+80100602:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  outb(CRTPORT, 15);
+80100605:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
+8010060c:	00 
+8010060d:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
+80100614:	e8 c1 fc ff ff       	call   801002da <outb>
+  pos |= inb(CRTPORT+1);
+80100619:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
+80100620:	e8 8b fc ff ff       	call   801002b0 <inb>
+80100625:	0f b6 c0             	movzbl %al,%eax
+80100628:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+  if(c == '\n')
+8010062b:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
+8010062f:	75 30                	jne    80100661 <cgaputc+0x8b>
+    pos += 80 - pos%80;
+80100631:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+80100634:	ba 67 66 66 66       	mov    $0x66666667,%edx
+80100639:	89 c8                	mov    %ecx,%eax
+8010063b:	f7 ea                	imul   %edx
+8010063d:	c1 fa 05             	sar    $0x5,%edx
+80100640:	89 c8                	mov    %ecx,%eax
+80100642:	c1 f8 1f             	sar    $0x1f,%eax
+80100645:	29 c2                	sub    %eax,%edx
+80100647:	89 d0                	mov    %edx,%eax
+80100649:	c1 e0 02             	shl    $0x2,%eax
+8010064c:	01 d0                	add    %edx,%eax
+8010064e:	c1 e0 04             	shl    $0x4,%eax
+80100651:	89 ca                	mov    %ecx,%edx
+80100653:	29 c2                	sub    %eax,%edx
+80100655:	b8 50 00 00 00       	mov    $0x50,%eax
+8010065a:	29 d0                	sub    %edx,%eax
+8010065c:	01 45 f4             	add    %eax,-0xc(%ebp)
+8010065f:	eb 32                	jmp    80100693 <cgaputc+0xbd>
+  else if(c == BACKSPACE){
+80100661:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
+80100668:	75 0c                	jne    80100676 <cgaputc+0xa0>
+    if(pos > 0) --pos;
+8010066a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010066e:	7e 23                	jle    80100693 <cgaputc+0xbd>
+80100670:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+80100674:	eb 1d                	jmp    80100693 <cgaputc+0xbd>
+  } else
+    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+80100676:	a1 00 90 10 80       	mov    0x80109000,%eax
+8010067b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010067e:	01 d2                	add    %edx,%edx
+80100680:	01 c2                	add    %eax,%edx
+80100682:	8b 45 08             	mov    0x8(%ebp),%eax
+80100685:	66 25 ff 00          	and    $0xff,%ax
+80100689:	80 cc 07             	or     $0x7,%ah
+8010068c:	66 89 02             	mov    %ax,(%edx)
+8010068f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  
+  if((pos/80) >= 24){  // Scroll up.
+80100693:	81 7d f4 7f 07 00 00 	cmpl   $0x77f,-0xc(%ebp)
+8010069a:	7e 53                	jle    801006ef <cgaputc+0x119>
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+8010069c:	a1 00 90 10 80       	mov    0x80109000,%eax
+801006a1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+801006a7:	a1 00 90 10 80       	mov    0x80109000,%eax
+801006ac:	c7 44 24 08 60 0e 00 	movl   $0xe60,0x8(%esp)
+801006b3:	00 
+801006b4:	89 54 24 04          	mov    %edx,0x4(%esp)
+801006b8:	89 04 24             	mov    %eax,(%esp)
+801006bb:	e8 61 4c 00 00       	call   80105321 <memmove>
+    pos -= 80;
+801006c0:	83 6d f4 50          	subl   $0x50,-0xc(%ebp)
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+801006c4:	b8 80 07 00 00       	mov    $0x780,%eax
+801006c9:	2b 45 f4             	sub    -0xc(%ebp),%eax
+801006cc:	01 c0                	add    %eax,%eax
+801006ce:	8b 15 00 90 10 80    	mov    0x80109000,%edx
+801006d4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+801006d7:	01 c9                	add    %ecx,%ecx
+801006d9:	01 ca                	add    %ecx,%edx
+801006db:	89 44 24 08          	mov    %eax,0x8(%esp)
+801006df:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801006e6:	00 
+801006e7:	89 14 24             	mov    %edx,(%esp)
+801006ea:	e8 5f 4b 00 00       	call   8010524e <memset>
+  }
+  
+  outb(CRTPORT, 14);
+801006ef:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
+801006f6:	00 
+801006f7:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
+801006fe:	e8 d7 fb ff ff       	call   801002da <outb>
+  outb(CRTPORT+1, pos>>8);
+80100703:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100706:	c1 f8 08             	sar    $0x8,%eax
+80100709:	0f b6 c0             	movzbl %al,%eax
+8010070c:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100710:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
+80100717:	e8 be fb ff ff       	call   801002da <outb>
+  outb(CRTPORT, 15);
+8010071c:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
+80100723:	00 
+80100724:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
+8010072b:	e8 aa fb ff ff       	call   801002da <outb>
+  outb(CRTPORT+1, pos);
+80100730:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100733:	0f b6 c0             	movzbl %al,%eax
+80100736:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010073a:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
+80100741:	e8 94 fb ff ff       	call   801002da <outb>
+  crt[pos] = ' ' | 0x0700;
+80100746:	a1 00 90 10 80       	mov    0x80109000,%eax
+8010074b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010074e:	01 d2                	add    %edx,%edx
+80100750:	01 d0                	add    %edx,%eax
+80100752:	66 c7 00 20 07       	movw   $0x720,(%eax)
+}
+80100757:	c9                   	leave  
+80100758:	c3                   	ret    
+
+80100759 <consputc>:
+
+void
+consputc(int c)
+{
+80100759:	55                   	push   %ebp
+8010075a:	89 e5                	mov    %esp,%ebp
+8010075c:	83 ec 18             	sub    $0x18,%esp
+  if(panicked){
+8010075f:	a1 c0 b5 10 80       	mov    0x8010b5c0,%eax
+80100764:	85 c0                	test   %eax,%eax
+80100766:	74 07                	je     8010076f <consputc+0x16>
+    cli();
+80100768:	e8 8b fb ff ff       	call   801002f8 <cli>
+    for(;;)
+      ;
+8010076d:	eb fe                	jmp    8010076d <consputc+0x14>
+  }
+
+  if(c == BACKSPACE){
+8010076f:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
+80100776:	75 26                	jne    8010079e <consputc+0x45>
+    uartputc('\b'); uartputc(' '); uartputc('\b');
+80100778:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+8010077f:	e8 f1 65 00 00       	call   80106d75 <uartputc>
+80100784:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+8010078b:	e8 e5 65 00 00       	call   80106d75 <uartputc>
+80100790:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+80100797:	e8 d9 65 00 00       	call   80106d75 <uartputc>
+8010079c:	eb 0b                	jmp    801007a9 <consputc+0x50>
+  } else
+    uartputc(c);
+8010079e:	8b 45 08             	mov    0x8(%ebp),%eax
+801007a1:	89 04 24             	mov    %eax,(%esp)
+801007a4:	e8 cc 65 00 00       	call   80106d75 <uartputc>
+  cgaputc(c);
+801007a9:	8b 45 08             	mov    0x8(%ebp),%eax
+801007ac:	89 04 24             	mov    %eax,(%esp)
+801007af:	e8 22 fe ff ff       	call   801005d6 <cgaputc>
+}
+801007b4:	c9                   	leave  
+801007b5:	c3                   	ret    
+
+801007b6 <consoleintr>:
+
+#define C(x)  ((x)-'@')  // Control-x
+
+void
+consoleintr(int (*getc)(void))
+{
+801007b6:	55                   	push   %ebp
+801007b7:	89 e5                	mov    %esp,%ebp
+801007b9:	83 ec 28             	sub    $0x28,%esp
+  int c;
+
+  acquire(&input.lock);
+801007bc:	c7 04 24 a0 07 11 80 	movl   $0x801107a0,(%esp)
+801007c3:	e8 2b 48 00 00       	call   80104ff3 <acquire>
+  while((c = getc()) >= 0){
+801007c8:	e9 41 01 00 00       	jmp    8010090e <consoleintr+0x158>
+    switch(c){
+801007cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801007d0:	83 f8 10             	cmp    $0x10,%eax
+801007d3:	74 1e                	je     801007f3 <consoleintr+0x3d>
+801007d5:	83 f8 10             	cmp    $0x10,%eax
+801007d8:	7f 0a                	jg     801007e4 <consoleintr+0x2e>
+801007da:	83 f8 08             	cmp    $0x8,%eax
+801007dd:	74 68                	je     80100847 <consoleintr+0x91>
+801007df:	e9 94 00 00 00       	jmp    80100878 <consoleintr+0xc2>
+801007e4:	83 f8 15             	cmp    $0x15,%eax
+801007e7:	74 2f                	je     80100818 <consoleintr+0x62>
+801007e9:	83 f8 7f             	cmp    $0x7f,%eax
+801007ec:	74 59                	je     80100847 <consoleintr+0x91>
+801007ee:	e9 85 00 00 00       	jmp    80100878 <consoleintr+0xc2>
+    case C('P'):  // Process listing.
+      procdump();
+801007f3:	e8 99 46 00 00       	call   80104e91 <procdump>
+      break;
+801007f8:	e9 11 01 00 00       	jmp    8010090e <consoleintr+0x158>
+    case C('U'):  // Kill line.
+      while(input.e != input.w &&
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+        input.e--;
+801007fd:	a1 5c 08 11 80       	mov    0x8011085c,%eax
+80100802:	83 e8 01             	sub    $0x1,%eax
+80100805:	a3 5c 08 11 80       	mov    %eax,0x8011085c
+        consputc(BACKSPACE);
+8010080a:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+80100811:	e8 43 ff ff ff       	call   80100759 <consputc>
+80100816:	eb 01                	jmp    80100819 <consoleintr+0x63>
+    switch(c){
+    case C('P'):  // Process listing.
+      procdump();
+      break;
+    case C('U'):  // Kill line.
+      while(input.e != input.w &&
+80100818:	90                   	nop
+80100819:	8b 15 5c 08 11 80    	mov    0x8011085c,%edx
+8010081f:	a1 58 08 11 80       	mov    0x80110858,%eax
+80100824:	39 c2                	cmp    %eax,%edx
+80100826:	0f 84 db 00 00 00    	je     80100907 <consoleintr+0x151>
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+8010082c:	a1 5c 08 11 80       	mov    0x8011085c,%eax
+80100831:	83 e8 01             	sub    $0x1,%eax
+80100834:	83 e0 7f             	and    $0x7f,%eax
+80100837:	0f b6 80 d4 07 11 80 	movzbl -0x7feef82c(%eax),%eax
+    switch(c){
+    case C('P'):  // Process listing.
+      procdump();
+      break;
+    case C('U'):  // Kill line.
+      while(input.e != input.w &&
+8010083e:	3c 0a                	cmp    $0xa,%al
+80100840:	75 bb                	jne    801007fd <consoleintr+0x47>
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+        input.e--;
+        consputc(BACKSPACE);
+      }
+      break;
+80100842:	e9 c0 00 00 00       	jmp    80100907 <consoleintr+0x151>
+    case C('H'): case '\x7f':  // Backspace
+      if(input.e != input.w){
+80100847:	8b 15 5c 08 11 80    	mov    0x8011085c,%edx
+8010084d:	a1 58 08 11 80       	mov    0x80110858,%eax
+80100852:	39 c2                	cmp    %eax,%edx
+80100854:	0f 84 b0 00 00 00    	je     8010090a <consoleintr+0x154>
+        input.e--;
+8010085a:	a1 5c 08 11 80       	mov    0x8011085c,%eax
+8010085f:	83 e8 01             	sub    $0x1,%eax
+80100862:	a3 5c 08 11 80       	mov    %eax,0x8011085c
+        consputc(BACKSPACE);
+80100867:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+8010086e:	e8 e6 fe ff ff       	call   80100759 <consputc>
+      }
+      break;
+80100873:	e9 92 00 00 00       	jmp    8010090a <consoleintr+0x154>
+    default:
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+80100878:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010087c:	0f 84 8b 00 00 00    	je     8010090d <consoleintr+0x157>
+80100882:	8b 15 5c 08 11 80    	mov    0x8011085c,%edx
+80100888:	a1 54 08 11 80       	mov    0x80110854,%eax
+8010088d:	89 d1                	mov    %edx,%ecx
+8010088f:	29 c1                	sub    %eax,%ecx
+80100891:	89 c8                	mov    %ecx,%eax
+80100893:	83 f8 7f             	cmp    $0x7f,%eax
+80100896:	77 75                	ja     8010090d <consoleintr+0x157>
+        c = (c == '\r') ? '\n' : c;
+80100898:	83 7d f4 0d          	cmpl   $0xd,-0xc(%ebp)
+8010089c:	74 05                	je     801008a3 <consoleintr+0xed>
+8010089e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801008a1:	eb 05                	jmp    801008a8 <consoleintr+0xf2>
+801008a3:	b8 0a 00 00 00       	mov    $0xa,%eax
+801008a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        input.buf[input.e++ % INPUT_BUF] = c;
+801008ab:	a1 5c 08 11 80       	mov    0x8011085c,%eax
+801008b0:	89 c1                	mov    %eax,%ecx
+801008b2:	83 e1 7f             	and    $0x7f,%ecx
+801008b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801008b8:	88 91 d4 07 11 80    	mov    %dl,-0x7feef82c(%ecx)
+801008be:	83 c0 01             	add    $0x1,%eax
+801008c1:	a3 5c 08 11 80       	mov    %eax,0x8011085c
+        consputc(c);
+801008c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801008c9:	89 04 24             	mov    %eax,(%esp)
+801008cc:	e8 88 fe ff ff       	call   80100759 <consputc>
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+801008d1:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
+801008d5:	74 18                	je     801008ef <consoleintr+0x139>
+801008d7:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
+801008db:	74 12                	je     801008ef <consoleintr+0x139>
+801008dd:	a1 5c 08 11 80       	mov    0x8011085c,%eax
+801008e2:	8b 15 54 08 11 80    	mov    0x80110854,%edx
+801008e8:	83 ea 80             	sub    $0xffffff80,%edx
+801008eb:	39 d0                	cmp    %edx,%eax
+801008ed:	75 1e                	jne    8010090d <consoleintr+0x157>
+          input.w = input.e;
+801008ef:	a1 5c 08 11 80       	mov    0x8011085c,%eax
+801008f4:	a3 58 08 11 80       	mov    %eax,0x80110858
+          wakeup(&input.r);
+801008f9:	c7 04 24 54 08 11 80 	movl   $0x80110854,(%esp)
+80100900:	e8 e9 44 00 00       	call   80104dee <wakeup>
+        }
+      }
+      break;
+80100905:	eb 06                	jmp    8010090d <consoleintr+0x157>
+      while(input.e != input.w &&
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+        input.e--;
+        consputc(BACKSPACE);
+      }
+      break;
+80100907:	90                   	nop
+80100908:	eb 04                	jmp    8010090e <consoleintr+0x158>
+    case C('H'): case '\x7f':  // Backspace
+      if(input.e != input.w){
+        input.e--;
+        consputc(BACKSPACE);
+      }
+      break;
+8010090a:	90                   	nop
+8010090b:	eb 01                	jmp    8010090e <consoleintr+0x158>
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+          input.w = input.e;
+          wakeup(&input.r);
+        }
+      }
+      break;
+8010090d:	90                   	nop
+consoleintr(int (*getc)(void))
+{
+  int c;
+
+  acquire(&input.lock);
+  while((c = getc()) >= 0){
+8010090e:	8b 45 08             	mov    0x8(%ebp),%eax
+80100911:	ff d0                	call   *%eax
+80100913:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80100916:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010091a:	0f 89 ad fe ff ff    	jns    801007cd <consoleintr+0x17>
+        }
+      }
+      break;
+    }
+  }
+  release(&input.lock);
+80100920:	c7 04 24 a0 07 11 80 	movl   $0x801107a0,(%esp)
+80100927:	e8 29 47 00 00       	call   80105055 <release>
+}
+8010092c:	c9                   	leave  
+8010092d:	c3                   	ret    
+
+8010092e <consoleread>:
+
+int
+consoleread(struct inode *ip, char *dst, int n)
+{
+8010092e:	55                   	push   %ebp
+8010092f:	89 e5                	mov    %esp,%ebp
+80100931:	83 ec 28             	sub    $0x28,%esp
+  uint target;
+  int c;
+
+  iunlock(ip);
+80100934:	8b 45 08             	mov    0x8(%ebp),%eax
+80100937:	89 04 24             	mov    %eax,(%esp)
+8010093a:	e8 b6 10 00 00       	call   801019f5 <iunlock>
+  target = n;
+8010093f:	8b 45 10             	mov    0x10(%ebp),%eax
+80100942:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  acquire(&input.lock);
+80100945:	c7 04 24 a0 07 11 80 	movl   $0x801107a0,(%esp)
+8010094c:	e8 a2 46 00 00       	call   80104ff3 <acquire>
+  while(n > 0){
+80100951:	e9 a8 00 00 00       	jmp    801009fe <consoleread+0xd0>
+    while(input.r == input.w){
+      if(proc->killed){
+80100956:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010095c:	8b 40 24             	mov    0x24(%eax),%eax
+8010095f:	85 c0                	test   %eax,%eax
+80100961:	74 21                	je     80100984 <consoleread+0x56>
+        release(&input.lock);
+80100963:	c7 04 24 a0 07 11 80 	movl   $0x801107a0,(%esp)
+8010096a:	e8 e6 46 00 00       	call   80105055 <release>
+        ilock(ip);
+8010096f:	8b 45 08             	mov    0x8(%ebp),%eax
+80100972:	89 04 24             	mov    %eax,(%esp)
+80100975:	e8 2d 0f 00 00       	call   801018a7 <ilock>
+        return -1;
+8010097a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010097f:	e9 a9 00 00 00       	jmp    80100a2d <consoleread+0xff>
+      }
+      sleep(&input.r, &input.lock);
+80100984:	c7 44 24 04 a0 07 11 	movl   $0x801107a0,0x4(%esp)
+8010098b:	80 
+8010098c:	c7 04 24 54 08 11 80 	movl   $0x80110854,(%esp)
+80100993:	e8 7d 43 00 00       	call   80104d15 <sleep>
+80100998:	eb 01                	jmp    8010099b <consoleread+0x6d>
+
+  iunlock(ip);
+  target = n;
+  acquire(&input.lock);
+  while(n > 0){
+    while(input.r == input.w){
+8010099a:	90                   	nop
+8010099b:	8b 15 54 08 11 80    	mov    0x80110854,%edx
+801009a1:	a1 58 08 11 80       	mov    0x80110858,%eax
+801009a6:	39 c2                	cmp    %eax,%edx
+801009a8:	74 ac                	je     80100956 <consoleread+0x28>
+        ilock(ip);
+        return -1;
+      }
+      sleep(&input.r, &input.lock);
+    }
+    c = input.buf[input.r++ % INPUT_BUF];
+801009aa:	a1 54 08 11 80       	mov    0x80110854,%eax
+801009af:	89 c2                	mov    %eax,%edx
+801009b1:	83 e2 7f             	and    $0x7f,%edx
+801009b4:	0f b6 92 d4 07 11 80 	movzbl -0x7feef82c(%edx),%edx
+801009bb:	0f be d2             	movsbl %dl,%edx
+801009be:	89 55 f0             	mov    %edx,-0x10(%ebp)
+801009c1:	83 c0 01             	add    $0x1,%eax
+801009c4:	a3 54 08 11 80       	mov    %eax,0x80110854
+    if(c == C('D')){  // EOF
+801009c9:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+801009cd:	75 17                	jne    801009e6 <consoleread+0xb8>
+      if(n < target){
+801009cf:	8b 45 10             	mov    0x10(%ebp),%eax
+801009d2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+801009d5:	73 2f                	jae    80100a06 <consoleread+0xd8>
+        // Save ^D for next time, to make sure
+        // caller gets a 0-byte result.
+        input.r--;
+801009d7:	a1 54 08 11 80       	mov    0x80110854,%eax
+801009dc:	83 e8 01             	sub    $0x1,%eax
+801009df:	a3 54 08 11 80       	mov    %eax,0x80110854
+      }
+      break;
+801009e4:	eb 20                	jmp    80100a06 <consoleread+0xd8>
+    }
+    *dst++ = c;
+801009e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801009e9:	89 c2                	mov    %eax,%edx
+801009eb:	8b 45 0c             	mov    0xc(%ebp),%eax
+801009ee:	88 10                	mov    %dl,(%eax)
+801009f0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+    --n;
+801009f4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+    if(c == '\n')
+801009f8:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+801009fc:	74 0b                	je     80100a09 <consoleread+0xdb>
+  int c;
+
+  iunlock(ip);
+  target = n;
+  acquire(&input.lock);
+  while(n > 0){
+801009fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80100a02:	7f 96                	jg     8010099a <consoleread+0x6c>
+80100a04:	eb 04                	jmp    80100a0a <consoleread+0xdc>
+      if(n < target){
+        // Save ^D for next time, to make sure
+        // caller gets a 0-byte result.
+        input.r--;
+      }
+      break;
+80100a06:	90                   	nop
+80100a07:	eb 01                	jmp    80100a0a <consoleread+0xdc>
+    }
+    *dst++ = c;
+    --n;
+    if(c == '\n')
+      break;
+80100a09:	90                   	nop
+  }
+  release(&input.lock);
+80100a0a:	c7 04 24 a0 07 11 80 	movl   $0x801107a0,(%esp)
+80100a11:	e8 3f 46 00 00       	call   80105055 <release>
+  ilock(ip);
+80100a16:	8b 45 08             	mov    0x8(%ebp),%eax
+80100a19:	89 04 24             	mov    %eax,(%esp)
+80100a1c:	e8 86 0e 00 00       	call   801018a7 <ilock>
+
+  return target - n;
+80100a21:	8b 45 10             	mov    0x10(%ebp),%eax
+80100a24:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80100a27:	89 d1                	mov    %edx,%ecx
+80100a29:	29 c1                	sub    %eax,%ecx
+80100a2b:	89 c8                	mov    %ecx,%eax
+}
+80100a2d:	c9                   	leave  
+80100a2e:	c3                   	ret    
+
+80100a2f <consolewrite>:
+
+int
+consolewrite(struct inode *ip, char *buf, int n)
+{
+80100a2f:	55                   	push   %ebp
+80100a30:	89 e5                	mov    %esp,%ebp
+80100a32:	83 ec 28             	sub    $0x28,%esp
+  int i;
+
+  iunlock(ip);
+80100a35:	8b 45 08             	mov    0x8(%ebp),%eax
+80100a38:	89 04 24             	mov    %eax,(%esp)
+80100a3b:	e8 b5 0f 00 00       	call   801019f5 <iunlock>
+  acquire(&cons.lock);
+80100a40:	c7 04 24 e0 b5 10 80 	movl   $0x8010b5e0,(%esp)
+80100a47:	e8 a7 45 00 00       	call   80104ff3 <acquire>
+  for(i = 0; i < n; i++)
+80100a4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80100a53:	eb 1f                	jmp    80100a74 <consolewrite+0x45>
+    consputc(buf[i] & 0xff);
+80100a55:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80100a58:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100a5b:	01 d0                	add    %edx,%eax
+80100a5d:	0f b6 00             	movzbl (%eax),%eax
+80100a60:	0f be c0             	movsbl %al,%eax
+80100a63:	25 ff 00 00 00       	and    $0xff,%eax
+80100a68:	89 04 24             	mov    %eax,(%esp)
+80100a6b:	e8 e9 fc ff ff       	call   80100759 <consputc>
+{
+  int i;
+
+  iunlock(ip);
+  acquire(&cons.lock);
+  for(i = 0; i < n; i++)
+80100a70:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100a74:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100a77:	3b 45 10             	cmp    0x10(%ebp),%eax
+80100a7a:	7c d9                	jl     80100a55 <consolewrite+0x26>
+    consputc(buf[i] & 0xff);
+  release(&cons.lock);
+80100a7c:	c7 04 24 e0 b5 10 80 	movl   $0x8010b5e0,(%esp)
+80100a83:	e8 cd 45 00 00       	call   80105055 <release>
+  ilock(ip);
+80100a88:	8b 45 08             	mov    0x8(%ebp),%eax
+80100a8b:	89 04 24             	mov    %eax,(%esp)
+80100a8e:	e8 14 0e 00 00       	call   801018a7 <ilock>
+
+  return n;
+80100a93:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+80100a96:	c9                   	leave  
+80100a97:	c3                   	ret    
+
+80100a98 <consoleinit>:
+
+void
+consoleinit(void)
+{
+80100a98:	55                   	push   %ebp
+80100a99:	89 e5                	mov    %esp,%ebp
+80100a9b:	83 ec 18             	sub    $0x18,%esp
+  initlock(&cons.lock, "console");
+80100a9e:	c7 44 24 04 87 87 10 	movl   $0x80108787,0x4(%esp)
+80100aa5:	80 
+80100aa6:	c7 04 24 e0 b5 10 80 	movl   $0x8010b5e0,(%esp)
+80100aad:	e8 20 45 00 00       	call   80104fd2 <initlock>
+  initlock(&input.lock, "input");
+80100ab2:	c7 44 24 04 8f 87 10 	movl   $0x8010878f,0x4(%esp)
+80100ab9:	80 
+80100aba:	c7 04 24 a0 07 11 80 	movl   $0x801107a0,(%esp)
+80100ac1:	e8 0c 45 00 00       	call   80104fd2 <initlock>
+
+  devsw[CONSOLE].write = consolewrite;
+80100ac6:	c7 05 0c 12 11 80 2f 	movl   $0x80100a2f,0x8011120c
+80100acd:	0a 10 80 
+  devsw[CONSOLE].read = consoleread;
+80100ad0:	c7 05 08 12 11 80 2e 	movl   $0x8010092e,0x80111208
+80100ad7:	09 10 80 
+  cons.locking = 1;
+80100ada:	c7 05 14 b6 10 80 01 	movl   $0x1,0x8010b614
+80100ae1:	00 00 00 
+
+  picenable(IRQ_KBD);
+80100ae4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80100aeb:	e8 61 33 00 00       	call   80103e51 <picenable>
+  ioapicenable(IRQ_KBD, 0);
+80100af0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80100af7:	00 
+80100af8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80100aff:	e8 be 1e 00 00       	call   801029c2 <ioapicenable>
+}
+80100b04:	c9                   	leave  
+80100b05:	c3                   	ret    
+	...
+
+80100b08 <exec>:
+#include "x86.h"
+#include "elf.h"
+
+int
+exec(char *path, char **argv)
+{
+80100b08:	55                   	push   %ebp
+80100b09:	89 e5                	mov    %esp,%ebp
+80100b0b:	81 ec 38 01 00 00    	sub    $0x138,%esp
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pde_t *pgdir, *oldpgdir;
+
+  begin_op();
+80100b11:	e8 92 29 00 00       	call   801034a8 <begin_op>
+  if((ip = namei(path)) == 0){
+80100b16:	8b 45 08             	mov    0x8(%ebp),%eax
+80100b19:	89 04 24             	mov    %eax,(%esp)
+80100b1c:	e8 37 19 00 00       	call   80102458 <namei>
+80100b21:	89 45 d8             	mov    %eax,-0x28(%ebp)
+80100b24:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+80100b28:	75 0f                	jne    80100b39 <exec+0x31>
+    end_op();
+80100b2a:	e8 fa 29 00 00       	call   80103529 <end_op>
+    return -1;
+80100b2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100b34:	e9 f9 03 00 00       	jmp    80100f32 <exec+0x42a>
+  }
+  ilock(ip);
+80100b39:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80100b3c:	89 04 24             	mov    %eax,(%esp)
+80100b3f:	e8 63 0d 00 00       	call   801018a7 <ilock>
+  pgdir = 0;
+80100b44:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
+80100b4b:	c7 44 24 0c 34 00 00 	movl   $0x34,0xc(%esp)
+80100b52:	00 
+80100b53:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+80100b5a:	00 
+80100b5b:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
+80100b61:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100b65:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80100b68:	89 04 24             	mov    %eax,(%esp)
+80100b6b:	e8 44 12 00 00       	call   80101db4 <readi>
+80100b70:	83 f8 33             	cmp    $0x33,%eax
+80100b73:	0f 86 6e 03 00 00    	jbe    80100ee7 <exec+0x3df>
+    goto bad;
+  if(elf.magic != ELF_MAGIC)
+80100b79:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
+80100b7f:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
+80100b84:	0f 85 60 03 00 00    	jne    80100eea <exec+0x3e2>
+    goto bad;
+
+  if((pgdir = setupkvm()) == 0)
+80100b8a:	e8 38 73 00 00       	call   80107ec7 <setupkvm>
+80100b8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+80100b92:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
+80100b96:	0f 84 51 03 00 00    	je     80100eed <exec+0x3e5>
+    goto bad;
+
+  // Load program into memory.
+  sz = 0;
+80100b9c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100ba3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+80100baa:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
+80100bb0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+80100bb3:	e9 c5 00 00 00       	jmp    80100c7d <exec+0x175>
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+80100bb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80100bbb:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
+80100bc2:	00 
+80100bc3:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100bc7:	8d 85 ec fe ff ff    	lea    -0x114(%ebp),%eax
+80100bcd:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100bd1:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80100bd4:	89 04 24             	mov    %eax,(%esp)
+80100bd7:	e8 d8 11 00 00       	call   80101db4 <readi>
+80100bdc:	83 f8 20             	cmp    $0x20,%eax
+80100bdf:	0f 85 0b 03 00 00    	jne    80100ef0 <exec+0x3e8>
+      goto bad;
+    if(ph.type != ELF_PROG_LOAD)
+80100be5:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
+80100beb:	83 f8 01             	cmp    $0x1,%eax
+80100bee:	75 7f                	jne    80100c6f <exec+0x167>
+      continue;
+    if(ph.memsz < ph.filesz)
+80100bf0:	8b 95 00 ff ff ff    	mov    -0x100(%ebp),%edx
+80100bf6:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
+80100bfc:	39 c2                	cmp    %eax,%edx
+80100bfe:	0f 82 ef 02 00 00    	jb     80100ef3 <exec+0x3eb>
+      goto bad;
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+80100c04:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
+80100c0a:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
+80100c10:	01 d0                	add    %edx,%eax
+80100c12:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100c16:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100c19:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100c1d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100c20:	89 04 24             	mov    %eax,(%esp)
+80100c23:	e8 71 76 00 00       	call   80108299 <allocuvm>
+80100c28:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80100c2b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+80100c2f:	0f 84 c1 02 00 00    	je     80100ef6 <exec+0x3ee>
+      goto bad;
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+80100c35:	8b 8d fc fe ff ff    	mov    -0x104(%ebp),%ecx
+80100c3b:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
+80100c41:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+80100c47:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+80100c4b:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80100c4f:	8b 55 d8             	mov    -0x28(%ebp),%edx
+80100c52:	89 54 24 08          	mov    %edx,0x8(%esp)
+80100c56:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100c5a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100c5d:	89 04 24             	mov    %eax,(%esp)
+80100c60:	e8 45 75 00 00       	call   801081aa <loaduvm>
+80100c65:	85 c0                	test   %eax,%eax
+80100c67:	0f 88 8c 02 00 00    	js     80100ef9 <exec+0x3f1>
+80100c6d:	eb 01                	jmp    80100c70 <exec+0x168>
+  sz = 0;
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+      goto bad;
+    if(ph.type != ELF_PROG_LOAD)
+      continue;
+80100c6f:	90                   	nop
+  if((pgdir = setupkvm()) == 0)
+    goto bad;
+
+  // Load program into memory.
+  sz = 0;
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100c70:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+80100c74:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80100c77:	83 c0 20             	add    $0x20,%eax
+80100c7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+80100c7d:	0f b7 85 38 ff ff ff 	movzwl -0xc8(%ebp),%eax
+80100c84:	0f b7 c0             	movzwl %ax,%eax
+80100c87:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80100c8a:	0f 8f 28 ff ff ff    	jg     80100bb8 <exec+0xb0>
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+      goto bad;
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+      goto bad;
+  }
+  iunlockput(ip);
+80100c90:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80100c93:	89 04 24             	mov    %eax,(%esp)
+80100c96:	e8 90 0e 00 00       	call   80101b2b <iunlockput>
+  end_op();
+80100c9b:	e8 89 28 00 00       	call   80103529 <end_op>
+  ip = 0;
+80100ca0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
+
+  // Allocate two pages at the next page boundary.
+  // Make the first inaccessible.  Use the second as the user stack.
+  sz = PGROUNDUP(sz);
+80100ca7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100caa:	05 ff 0f 00 00       	add    $0xfff,%eax
+80100caf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80100cb4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+80100cb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100cba:	05 00 20 00 00       	add    $0x2000,%eax
+80100cbf:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100cc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100cc6:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100cca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100ccd:	89 04 24             	mov    %eax,(%esp)
+80100cd0:	e8 c4 75 00 00       	call   80108299 <allocuvm>
+80100cd5:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80100cd8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+80100cdc:	0f 84 1a 02 00 00    	je     80100efc <exec+0x3f4>
+    goto bad;
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100ce2:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100ce5:	2d 00 20 00 00       	sub    $0x2000,%eax
+80100cea:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100cee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100cf1:	89 04 24             	mov    %eax,(%esp)
+80100cf4:	e8 d0 77 00 00       	call   801084c9 <clearpteu>
+  sp = sz;
+80100cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100cfc:	89 45 dc             	mov    %eax,-0x24(%ebp)
+
+  // Push argument strings, prepare rest of stack in ustack.
+  for(argc = 0; argv[argc]; argc++) {
+80100cff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+80100d06:	e9 97 00 00 00       	jmp    80100da2 <exec+0x29a>
+    if(argc >= MAXARG)
+80100d0b:	83 7d e4 1f          	cmpl   $0x1f,-0x1c(%ebp)
+80100d0f:	0f 87 ea 01 00 00    	ja     80100eff <exec+0x3f7>
+      goto bad;
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100d15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100d18:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100d1f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100d22:	01 d0                	add    %edx,%eax
+80100d24:	8b 00                	mov    (%eax),%eax
+80100d26:	89 04 24             	mov    %eax,(%esp)
+80100d29:	e8 9e 47 00 00       	call   801054cc <strlen>
+80100d2e:	f7 d0                	not    %eax
+80100d30:	89 c2                	mov    %eax,%edx
+80100d32:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100d35:	01 d0                	add    %edx,%eax
+80100d37:	83 e0 fc             	and    $0xfffffffc,%eax
+80100d3a:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100d3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100d40:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100d47:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100d4a:	01 d0                	add    %edx,%eax
+80100d4c:	8b 00                	mov    (%eax),%eax
+80100d4e:	89 04 24             	mov    %eax,(%esp)
+80100d51:	e8 76 47 00 00       	call   801054cc <strlen>
+80100d56:	83 c0 01             	add    $0x1,%eax
+80100d59:	89 c2                	mov    %eax,%edx
+80100d5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100d5e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
+80100d65:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100d68:	01 c8                	add    %ecx,%eax
+80100d6a:	8b 00                	mov    (%eax),%eax
+80100d6c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80100d70:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100d74:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100d77:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100d7b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100d7e:	89 04 24             	mov    %eax,(%esp)
+80100d81:	e8 08 79 00 00       	call   8010868e <copyout>
+80100d86:	85 c0                	test   %eax,%eax
+80100d88:	0f 88 74 01 00 00    	js     80100f02 <exec+0x3fa>
+      goto bad;
+    ustack[3+argc] = sp;
+80100d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100d91:	8d 50 03             	lea    0x3(%eax),%edx
+80100d94:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100d97:	89 84 95 40 ff ff ff 	mov    %eax,-0xc0(%ebp,%edx,4)
+    goto bad;
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+  sp = sz;
+
+  // Push argument strings, prepare rest of stack in ustack.
+  for(argc = 0; argv[argc]; argc++) {
+80100d9e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+80100da2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100da5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100dac:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100daf:	01 d0                	add    %edx,%eax
+80100db1:	8b 00                	mov    (%eax),%eax
+80100db3:	85 c0                	test   %eax,%eax
+80100db5:	0f 85 50 ff ff ff    	jne    80100d0b <exec+0x203>
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+      goto bad;
+    ustack[3+argc] = sp;
+  }
+  ustack[3+argc] = 0;
+80100dbb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100dbe:	83 c0 03             	add    $0x3,%eax
+80100dc1:	c7 84 85 40 ff ff ff 	movl   $0x0,-0xc0(%ebp,%eax,4)
+80100dc8:	00 00 00 00 
+
+  ustack[0] = 0xffffffff;  // fake return PC
+80100dcc:	c7 85 40 ff ff ff ff 	movl   $0xffffffff,-0xc0(%ebp)
+80100dd3:	ff ff ff 
+  ustack[1] = argc;
+80100dd6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100dd9:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100ddf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100de2:	83 c0 01             	add    $0x1,%eax
+80100de5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100dec:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100def:	29 d0                	sub    %edx,%eax
+80100df1:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
+
+  sp -= (3+argc+1) * 4;
+80100df7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100dfa:	83 c0 04             	add    $0x4,%eax
+80100dfd:	c1 e0 02             	shl    $0x2,%eax
+80100e00:	29 45 dc             	sub    %eax,-0x24(%ebp)
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100e03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100e06:	83 c0 04             	add    $0x4,%eax
+80100e09:	c1 e0 02             	shl    $0x2,%eax
+80100e0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80100e10:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
+80100e16:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100e1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100e1d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100e21:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100e24:	89 04 24             	mov    %eax,(%esp)
+80100e27:	e8 62 78 00 00       	call   8010868e <copyout>
+80100e2c:	85 c0                	test   %eax,%eax
+80100e2e:	0f 88 d1 00 00 00    	js     80100f05 <exec+0x3fd>
+    goto bad;
+
+  // Save program name for debugging.
+  for(last=s=path; *s; s++)
+80100e34:	8b 45 08             	mov    0x8(%ebp),%eax
+80100e37:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80100e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100e3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80100e40:	eb 17                	jmp    80100e59 <exec+0x351>
+    if(*s == '/')
+80100e42:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100e45:	0f b6 00             	movzbl (%eax),%eax
+80100e48:	3c 2f                	cmp    $0x2f,%al
+80100e4a:	75 09                	jne    80100e55 <exec+0x34d>
+      last = s+1;
+80100e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100e4f:	83 c0 01             	add    $0x1,%eax
+80100e52:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  sp -= (3+argc+1) * 4;
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+    goto bad;
+
+  // Save program name for debugging.
+  for(last=s=path; *s; s++)
+80100e55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100e59:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100e5c:	0f b6 00             	movzbl (%eax),%eax
+80100e5f:	84 c0                	test   %al,%al
+80100e61:	75 df                	jne    80100e42 <exec+0x33a>
+    if(*s == '/')
+      last = s+1;
+  safestrcpy(proc->name, last, sizeof(proc->name));
+80100e63:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100e69:	8d 50 6c             	lea    0x6c(%eax),%edx
+80100e6c:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80100e73:	00 
+80100e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80100e77:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100e7b:	89 14 24             	mov    %edx,(%esp)
+80100e7e:	e8 fb 45 00 00       	call   8010547e <safestrcpy>
+
+  // Commit to the user image.
+  oldpgdir = proc->pgdir;
+80100e83:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100e89:	8b 40 04             	mov    0x4(%eax),%eax
+80100e8c:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  proc->pgdir = pgdir;
+80100e8f:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100e95:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+80100e98:	89 50 04             	mov    %edx,0x4(%eax)
+  proc->sz = sz;
+80100e9b:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100ea1:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80100ea4:	89 10                	mov    %edx,(%eax)
+  proc->tf->eip = elf.entry;  // main
+80100ea6:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100eac:	8b 40 18             	mov    0x18(%eax),%eax
+80100eaf:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
+80100eb5:	89 50 38             	mov    %edx,0x38(%eax)
+  proc->tf->esp = sp;
+80100eb8:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100ebe:	8b 40 18             	mov    0x18(%eax),%eax
+80100ec1:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80100ec4:	89 50 44             	mov    %edx,0x44(%eax)
+  switchuvm(proc);
+80100ec7:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80100ecd:	89 04 24             	mov    %eax,(%esp)
+80100ed0:	e8 e3 70 00 00       	call   80107fb8 <switchuvm>
+  freevm(oldpgdir);
+80100ed5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100ed8:	89 04 24             	mov    %eax,(%esp)
+80100edb:	e8 4f 75 00 00       	call   8010842f <freevm>
+  return 0;
+80100ee0:	b8 00 00 00 00       	mov    $0x0,%eax
+80100ee5:	eb 4b                	jmp    80100f32 <exec+0x42a>
+  ilock(ip);
+  pgdir = 0;
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
+    goto bad;
+80100ee7:	90                   	nop
+80100ee8:	eb 1c                	jmp    80100f06 <exec+0x3fe>
+  if(elf.magic != ELF_MAGIC)
+    goto bad;
+80100eea:	90                   	nop
+80100eeb:	eb 19                	jmp    80100f06 <exec+0x3fe>
+
+  if((pgdir = setupkvm()) == 0)
+    goto bad;
+80100eed:	90                   	nop
+80100eee:	eb 16                	jmp    80100f06 <exec+0x3fe>
+
+  // Load program into memory.
+  sz = 0;
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+      goto bad;
+80100ef0:	90                   	nop
+80100ef1:	eb 13                	jmp    80100f06 <exec+0x3fe>
+    if(ph.type != ELF_PROG_LOAD)
+      continue;
+    if(ph.memsz < ph.filesz)
+      goto bad;
+80100ef3:	90                   	nop
+80100ef4:	eb 10                	jmp    80100f06 <exec+0x3fe>
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+      goto bad;
+80100ef6:	90                   	nop
+80100ef7:	eb 0d                	jmp    80100f06 <exec+0x3fe>
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+      goto bad;
+80100ef9:	90                   	nop
+80100efa:	eb 0a                	jmp    80100f06 <exec+0x3fe>
+
+  // Allocate two pages at the next page boundary.
+  // Make the first inaccessible.  Use the second as the user stack.
+  sz = PGROUNDUP(sz);
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+    goto bad;
+80100efc:	90                   	nop
+80100efd:	eb 07                	jmp    80100f06 <exec+0x3fe>
+  sp = sz;
+
+  // Push argument strings, prepare rest of stack in ustack.
+  for(argc = 0; argv[argc]; argc++) {
+    if(argc >= MAXARG)
+      goto bad;
+80100eff:	90                   	nop
+80100f00:	eb 04                	jmp    80100f06 <exec+0x3fe>
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+      goto bad;
+80100f02:	90                   	nop
+80100f03:	eb 01                	jmp    80100f06 <exec+0x3fe>
+  ustack[1] = argc;
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+
+  sp -= (3+argc+1) * 4;
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+    goto bad;
+80100f05:	90                   	nop
+  switchuvm(proc);
+  freevm(oldpgdir);
+  return 0;
+
+ bad:
+  if(pgdir)
+80100f06:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
+80100f0a:	74 0b                	je     80100f17 <exec+0x40f>
+    freevm(pgdir);
+80100f0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80100f0f:	89 04 24             	mov    %eax,(%esp)
+80100f12:	e8 18 75 00 00       	call   8010842f <freevm>
+  if(ip){
+80100f17:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+80100f1b:	74 10                	je     80100f2d <exec+0x425>
+    iunlockput(ip);
+80100f1d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80100f20:	89 04 24             	mov    %eax,(%esp)
+80100f23:	e8 03 0c 00 00       	call   80101b2b <iunlockput>
+    end_op();
+80100f28:	e8 fc 25 00 00       	call   80103529 <end_op>
+  }
+  return -1;
+80100f2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100f32:	c9                   	leave  
+80100f33:	c3                   	ret    
+
+80100f34 <fileinit>:
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+80100f34:	55                   	push   %ebp
+80100f35:	89 e5                	mov    %esp,%ebp
+80100f37:	83 ec 18             	sub    $0x18,%esp
+  initlock(&ftable.lock, "ftable");
+80100f3a:	c7 44 24 04 95 87 10 	movl   $0x80108795,0x4(%esp)
+80100f41:	80 
+80100f42:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80100f49:	e8 84 40 00 00       	call   80104fd2 <initlock>
+}
+80100f4e:	c9                   	leave  
+80100f4f:	c3                   	ret    
+
+80100f50 <filealloc>:
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+80100f50:	55                   	push   %ebp
+80100f51:	89 e5                	mov    %esp,%ebp
+80100f53:	83 ec 28             	sub    $0x28,%esp
+  struct file *f;
+
+  acquire(&ftable.lock);
+80100f56:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80100f5d:	e8 91 40 00 00       	call   80104ff3 <acquire>
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100f62:	c7 45 f4 94 08 11 80 	movl   $0x80110894,-0xc(%ebp)
+80100f69:	eb 29                	jmp    80100f94 <filealloc+0x44>
+    if(f->ref == 0){
+80100f6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f6e:	8b 40 04             	mov    0x4(%eax),%eax
+80100f71:	85 c0                	test   %eax,%eax
+80100f73:	75 1b                	jne    80100f90 <filealloc+0x40>
+      f->ref = 1;
+80100f75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f78:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
+      release(&ftable.lock);
+80100f7f:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80100f86:	e8 ca 40 00 00       	call   80105055 <release>
+      return f;
+80100f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f8e:	eb 1e                	jmp    80100fae <filealloc+0x5e>
+filealloc(void)
+{
+  struct file *f;
+
+  acquire(&ftable.lock);
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100f90:	83 45 f4 18          	addl   $0x18,-0xc(%ebp)
+80100f94:	81 7d f4 f4 11 11 80 	cmpl   $0x801111f4,-0xc(%ebp)
+80100f9b:	72 ce                	jb     80100f6b <filealloc+0x1b>
+      f->ref = 1;
+      release(&ftable.lock);
+      return f;
+    }
+  }
+  release(&ftable.lock);
+80100f9d:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80100fa4:	e8 ac 40 00 00       	call   80105055 <release>
+  return 0;
+80100fa9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80100fae:	c9                   	leave  
+80100faf:	c3                   	ret    
+
+80100fb0 <filedup>:
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+80100fb0:	55                   	push   %ebp
+80100fb1:	89 e5                	mov    %esp,%ebp
+80100fb3:	83 ec 18             	sub    $0x18,%esp
+  acquire(&ftable.lock);
+80100fb6:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80100fbd:	e8 31 40 00 00       	call   80104ff3 <acquire>
+  if(f->ref < 1)
+80100fc2:	8b 45 08             	mov    0x8(%ebp),%eax
+80100fc5:	8b 40 04             	mov    0x4(%eax),%eax
+80100fc8:	85 c0                	test   %eax,%eax
+80100fca:	7f 0c                	jg     80100fd8 <filedup+0x28>
+    panic("filedup");
+80100fcc:	c7 04 24 9c 87 10 80 	movl   $0x8010879c,(%esp)
+80100fd3:	e8 6e f5 ff ff       	call   80100546 <panic>
+  f->ref++;
+80100fd8:	8b 45 08             	mov    0x8(%ebp),%eax
+80100fdb:	8b 40 04             	mov    0x4(%eax),%eax
+80100fde:	8d 50 01             	lea    0x1(%eax),%edx
+80100fe1:	8b 45 08             	mov    0x8(%ebp),%eax
+80100fe4:	89 50 04             	mov    %edx,0x4(%eax)
+  release(&ftable.lock);
+80100fe7:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80100fee:	e8 62 40 00 00       	call   80105055 <release>
+  return f;
+80100ff3:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80100ff6:	c9                   	leave  
+80100ff7:	c3                   	ret    
+
+80100ff8 <fileclose>:
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+80100ff8:	55                   	push   %ebp
+80100ff9:	89 e5                	mov    %esp,%ebp
+80100ffb:	83 ec 38             	sub    $0x38,%esp
+  struct file ff;
+
+  acquire(&ftable.lock);
+80100ffe:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80101005:	e8 e9 3f 00 00       	call   80104ff3 <acquire>
+  if(f->ref < 1)
+8010100a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010100d:	8b 40 04             	mov    0x4(%eax),%eax
+80101010:	85 c0                	test   %eax,%eax
+80101012:	7f 0c                	jg     80101020 <fileclose+0x28>
+    panic("fileclose");
+80101014:	c7 04 24 a4 87 10 80 	movl   $0x801087a4,(%esp)
+8010101b:	e8 26 f5 ff ff       	call   80100546 <panic>
+  if(--f->ref > 0){
+80101020:	8b 45 08             	mov    0x8(%ebp),%eax
+80101023:	8b 40 04             	mov    0x4(%eax),%eax
+80101026:	8d 50 ff             	lea    -0x1(%eax),%edx
+80101029:	8b 45 08             	mov    0x8(%ebp),%eax
+8010102c:	89 50 04             	mov    %edx,0x4(%eax)
+8010102f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101032:	8b 40 04             	mov    0x4(%eax),%eax
+80101035:	85 c0                	test   %eax,%eax
+80101037:	7e 11                	jle    8010104a <fileclose+0x52>
+    release(&ftable.lock);
+80101039:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+80101040:	e8 10 40 00 00       	call   80105055 <release>
+80101045:	e9 82 00 00 00       	jmp    801010cc <fileclose+0xd4>
+    return;
+  }
+  ff = *f;
+8010104a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010104d:	8b 10                	mov    (%eax),%edx
+8010104f:	89 55 e0             	mov    %edx,-0x20(%ebp)
+80101052:	8b 50 04             	mov    0x4(%eax),%edx
+80101055:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80101058:	8b 50 08             	mov    0x8(%eax),%edx
+8010105b:	89 55 e8             	mov    %edx,-0x18(%ebp)
+8010105e:	8b 50 0c             	mov    0xc(%eax),%edx
+80101061:	89 55 ec             	mov    %edx,-0x14(%ebp)
+80101064:	8b 50 10             	mov    0x10(%eax),%edx
+80101067:	89 55 f0             	mov    %edx,-0x10(%ebp)
+8010106a:	8b 40 14             	mov    0x14(%eax),%eax
+8010106d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  f->ref = 0;
+80101070:	8b 45 08             	mov    0x8(%ebp),%eax
+80101073:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+  f->type = FD_NONE;
+8010107a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010107d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  release(&ftable.lock);
+80101083:	c7 04 24 60 08 11 80 	movl   $0x80110860,(%esp)
+8010108a:	e8 c6 3f 00 00       	call   80105055 <release>
+  
+  if(ff.type == FD_PIPE)
+8010108f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80101092:	83 f8 01             	cmp    $0x1,%eax
+80101095:	75 18                	jne    801010af <fileclose+0xb7>
+    pipeclose(ff.pipe, ff.writable);
+80101097:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+8010109b:	0f be d0             	movsbl %al,%edx
+8010109e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801010a1:	89 54 24 04          	mov    %edx,0x4(%esp)
+801010a5:	89 04 24             	mov    %eax,(%esp)
+801010a8:	e8 5e 30 00 00       	call   8010410b <pipeclose>
+801010ad:	eb 1d                	jmp    801010cc <fileclose+0xd4>
+  else if(ff.type == FD_INODE){
+801010af:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801010b2:	83 f8 02             	cmp    $0x2,%eax
+801010b5:	75 15                	jne    801010cc <fileclose+0xd4>
+    begin_op();
+801010b7:	e8 ec 23 00 00       	call   801034a8 <begin_op>
+    iput(ff.ip);
+801010bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801010bf:	89 04 24             	mov    %eax,(%esp)
+801010c2:	e8 93 09 00 00       	call   80101a5a <iput>
+    end_op();
+801010c7:	e8 5d 24 00 00       	call   80103529 <end_op>
+  }
+}
+801010cc:	c9                   	leave  
+801010cd:	c3                   	ret    
+
+801010ce <filestat>:
+
+// Get metadata about file f.
+int
+filestat(struct file *f, struct stat *st)
+{
+801010ce:	55                   	push   %ebp
+801010cf:	89 e5                	mov    %esp,%ebp
+801010d1:	83 ec 18             	sub    $0x18,%esp
+  if(f->type == FD_INODE){
+801010d4:	8b 45 08             	mov    0x8(%ebp),%eax
+801010d7:	8b 00                	mov    (%eax),%eax
+801010d9:	83 f8 02             	cmp    $0x2,%eax
+801010dc:	75 38                	jne    80101116 <filestat+0x48>
+    ilock(f->ip);
+801010de:	8b 45 08             	mov    0x8(%ebp),%eax
+801010e1:	8b 40 10             	mov    0x10(%eax),%eax
+801010e4:	89 04 24             	mov    %eax,(%esp)
+801010e7:	e8 bb 07 00 00       	call   801018a7 <ilock>
+    stati(f->ip, st);
+801010ec:	8b 45 08             	mov    0x8(%ebp),%eax
+801010ef:	8b 40 10             	mov    0x10(%eax),%eax
+801010f2:	8b 55 0c             	mov    0xc(%ebp),%edx
+801010f5:	89 54 24 04          	mov    %edx,0x4(%esp)
+801010f9:	89 04 24             	mov    %eax,(%esp)
+801010fc:	e8 6e 0c 00 00       	call   80101d6f <stati>
+    iunlock(f->ip);
+80101101:	8b 45 08             	mov    0x8(%ebp),%eax
+80101104:	8b 40 10             	mov    0x10(%eax),%eax
+80101107:	89 04 24             	mov    %eax,(%esp)
+8010110a:	e8 e6 08 00 00       	call   801019f5 <iunlock>
+    return 0;
+8010110f:	b8 00 00 00 00       	mov    $0x0,%eax
+80101114:	eb 05                	jmp    8010111b <filestat+0x4d>
+  }
+  return -1;
+80101116:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+8010111b:	c9                   	leave  
+8010111c:	c3                   	ret    
+
+8010111d <fileread>:
+
+// Read from file f.
+int
+fileread(struct file *f, char *addr, int n)
+{
+8010111d:	55                   	push   %ebp
+8010111e:	89 e5                	mov    %esp,%ebp
+80101120:	83 ec 28             	sub    $0x28,%esp
+  int r;
+
+  if(f->readable == 0)
+80101123:	8b 45 08             	mov    0x8(%ebp),%eax
+80101126:	0f b6 40 08          	movzbl 0x8(%eax),%eax
+8010112a:	84 c0                	test   %al,%al
+8010112c:	75 0a                	jne    80101138 <fileread+0x1b>
+    return -1;
+8010112e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101133:	e9 9f 00 00 00       	jmp    801011d7 <fileread+0xba>
+  if(f->type == FD_PIPE)
+80101138:	8b 45 08             	mov    0x8(%ebp),%eax
+8010113b:	8b 00                	mov    (%eax),%eax
+8010113d:	83 f8 01             	cmp    $0x1,%eax
+80101140:	75 1e                	jne    80101160 <fileread+0x43>
+    return piperead(f->pipe, addr, n);
+80101142:	8b 45 08             	mov    0x8(%ebp),%eax
+80101145:	8b 40 0c             	mov    0xc(%eax),%eax
+80101148:	8b 55 10             	mov    0x10(%ebp),%edx
+8010114b:	89 54 24 08          	mov    %edx,0x8(%esp)
+8010114f:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101152:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101156:	89 04 24             	mov    %eax,(%esp)
+80101159:	e8 31 31 00 00       	call   8010428f <piperead>
+8010115e:	eb 77                	jmp    801011d7 <fileread+0xba>
+  if(f->type == FD_INODE){
+80101160:	8b 45 08             	mov    0x8(%ebp),%eax
+80101163:	8b 00                	mov    (%eax),%eax
+80101165:	83 f8 02             	cmp    $0x2,%eax
+80101168:	75 61                	jne    801011cb <fileread+0xae>
+    ilock(f->ip);
+8010116a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010116d:	8b 40 10             	mov    0x10(%eax),%eax
+80101170:	89 04 24             	mov    %eax,(%esp)
+80101173:	e8 2f 07 00 00       	call   801018a7 <ilock>
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+80101178:	8b 4d 10             	mov    0x10(%ebp),%ecx
+8010117b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010117e:	8b 50 14             	mov    0x14(%eax),%edx
+80101181:	8b 45 08             	mov    0x8(%ebp),%eax
+80101184:	8b 40 10             	mov    0x10(%eax),%eax
+80101187:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+8010118b:	89 54 24 08          	mov    %edx,0x8(%esp)
+8010118f:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101192:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101196:	89 04 24             	mov    %eax,(%esp)
+80101199:	e8 16 0c 00 00       	call   80101db4 <readi>
+8010119e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801011a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801011a5:	7e 11                	jle    801011b8 <fileread+0x9b>
+      f->off += r;
+801011a7:	8b 45 08             	mov    0x8(%ebp),%eax
+801011aa:	8b 50 14             	mov    0x14(%eax),%edx
+801011ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801011b0:	01 c2                	add    %eax,%edx
+801011b2:	8b 45 08             	mov    0x8(%ebp),%eax
+801011b5:	89 50 14             	mov    %edx,0x14(%eax)
+    iunlock(f->ip);
+801011b8:	8b 45 08             	mov    0x8(%ebp),%eax
+801011bb:	8b 40 10             	mov    0x10(%eax),%eax
+801011be:	89 04 24             	mov    %eax,(%esp)
+801011c1:	e8 2f 08 00 00       	call   801019f5 <iunlock>
+    return r;
+801011c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801011c9:	eb 0c                	jmp    801011d7 <fileread+0xba>
+  }
+  panic("fileread");
+801011cb:	c7 04 24 ae 87 10 80 	movl   $0x801087ae,(%esp)
+801011d2:	e8 6f f3 ff ff       	call   80100546 <panic>
+}
+801011d7:	c9                   	leave  
+801011d8:	c3                   	ret    
+
+801011d9 <filewrite>:
+
+//PAGEBREAK!
+// Write to file f.
+int
+filewrite(struct file *f, char *addr, int n)
+{
+801011d9:	55                   	push   %ebp
+801011da:	89 e5                	mov    %esp,%ebp
+801011dc:	53                   	push   %ebx
+801011dd:	83 ec 24             	sub    $0x24,%esp
+  int r;
+
+  if(f->writable == 0)
+801011e0:	8b 45 08             	mov    0x8(%ebp),%eax
+801011e3:	0f b6 40 09          	movzbl 0x9(%eax),%eax
+801011e7:	84 c0                	test   %al,%al
+801011e9:	75 0a                	jne    801011f5 <filewrite+0x1c>
+    return -1;
+801011eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801011f0:	e9 23 01 00 00       	jmp    80101318 <filewrite+0x13f>
+  if(f->type == FD_PIPE)
+801011f5:	8b 45 08             	mov    0x8(%ebp),%eax
+801011f8:	8b 00                	mov    (%eax),%eax
+801011fa:	83 f8 01             	cmp    $0x1,%eax
+801011fd:	75 21                	jne    80101220 <filewrite+0x47>
+    return pipewrite(f->pipe, addr, n);
+801011ff:	8b 45 08             	mov    0x8(%ebp),%eax
+80101202:	8b 40 0c             	mov    0xc(%eax),%eax
+80101205:	8b 55 10             	mov    0x10(%ebp),%edx
+80101208:	89 54 24 08          	mov    %edx,0x8(%esp)
+8010120c:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010120f:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101213:	89 04 24             	mov    %eax,(%esp)
+80101216:	e8 82 2f 00 00       	call   8010419d <pipewrite>
+8010121b:	e9 f8 00 00 00       	jmp    80101318 <filewrite+0x13f>
+  if(f->type == FD_INODE){
+80101220:	8b 45 08             	mov    0x8(%ebp),%eax
+80101223:	8b 00                	mov    (%eax),%eax
+80101225:	83 f8 02             	cmp    $0x2,%eax
+80101228:	0f 85 de 00 00 00    	jne    8010130c <filewrite+0x133>
+    // the maximum log transaction size, including
+    // i-node, indirect block, allocation blocks,
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+8010122e:	c7 45 ec 00 1a 00 00 	movl   $0x1a00,-0x14(%ebp)
+    int i = 0;
+80101235:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while(i < n){
+8010123c:	e9 a8 00 00 00       	jmp    801012e9 <filewrite+0x110>
+      int n1 = n - i;
+80101241:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101244:	8b 55 10             	mov    0x10(%ebp),%edx
+80101247:	89 d1                	mov    %edx,%ecx
+80101249:	29 c1                	sub    %eax,%ecx
+8010124b:	89 c8                	mov    %ecx,%eax
+8010124d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      if(n1 > max)
+80101250:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101253:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80101256:	7e 06                	jle    8010125e <filewrite+0x85>
+        n1 = max;
+80101258:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010125b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+      begin_op();
+8010125e:	e8 45 22 00 00       	call   801034a8 <begin_op>
+      ilock(f->ip);
+80101263:	8b 45 08             	mov    0x8(%ebp),%eax
+80101266:	8b 40 10             	mov    0x10(%eax),%eax
+80101269:	89 04 24             	mov    %eax,(%esp)
+8010126c:	e8 36 06 00 00       	call   801018a7 <ilock>
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+80101271:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+80101274:	8b 45 08             	mov    0x8(%ebp),%eax
+80101277:	8b 50 14             	mov    0x14(%eax),%edx
+8010127a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+8010127d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101280:	01 c3                	add    %eax,%ebx
+80101282:	8b 45 08             	mov    0x8(%ebp),%eax
+80101285:	8b 40 10             	mov    0x10(%eax),%eax
+80101288:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+8010128c:	89 54 24 08          	mov    %edx,0x8(%esp)
+80101290:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80101294:	89 04 24             	mov    %eax,(%esp)
+80101297:	e8 7e 0c 00 00       	call   80101f1a <writei>
+8010129c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+8010129f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+801012a3:	7e 11                	jle    801012b6 <filewrite+0xdd>
+        f->off += r;
+801012a5:	8b 45 08             	mov    0x8(%ebp),%eax
+801012a8:	8b 50 14             	mov    0x14(%eax),%edx
+801012ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801012ae:	01 c2                	add    %eax,%edx
+801012b0:	8b 45 08             	mov    0x8(%ebp),%eax
+801012b3:	89 50 14             	mov    %edx,0x14(%eax)
+      iunlock(f->ip);
+801012b6:	8b 45 08             	mov    0x8(%ebp),%eax
+801012b9:	8b 40 10             	mov    0x10(%eax),%eax
+801012bc:	89 04 24             	mov    %eax,(%esp)
+801012bf:	e8 31 07 00 00       	call   801019f5 <iunlock>
+      end_op();
+801012c4:	e8 60 22 00 00       	call   80103529 <end_op>
+
+      if(r < 0)
+801012c9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+801012cd:	78 28                	js     801012f7 <filewrite+0x11e>
+        break;
+      if(r != n1)
+801012cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801012d2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+801012d5:	74 0c                	je     801012e3 <filewrite+0x10a>
+        panic("short filewrite");
+801012d7:	c7 04 24 b7 87 10 80 	movl   $0x801087b7,(%esp)
+801012de:	e8 63 f2 ff ff       	call   80100546 <panic>
+      i += r;
+801012e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801012e6:	01 45 f4             	add    %eax,-0xc(%ebp)
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+    int i = 0;
+    while(i < n){
+801012e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801012ec:	3b 45 10             	cmp    0x10(%ebp),%eax
+801012ef:	0f 8c 4c ff ff ff    	jl     80101241 <filewrite+0x68>
+801012f5:	eb 01                	jmp    801012f8 <filewrite+0x11f>
+        f->off += r;
+      iunlock(f->ip);
+      end_op();
+
+      if(r < 0)
+        break;
+801012f7:	90                   	nop
+      if(r != n1)
+        panic("short filewrite");
+      i += r;
+    }
+    return i == n ? n : -1;
+801012f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801012fb:	3b 45 10             	cmp    0x10(%ebp),%eax
+801012fe:	75 05                	jne    80101305 <filewrite+0x12c>
+80101300:	8b 45 10             	mov    0x10(%ebp),%eax
+80101303:	eb 05                	jmp    8010130a <filewrite+0x131>
+80101305:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010130a:	eb 0c                	jmp    80101318 <filewrite+0x13f>
+  }
+  panic("filewrite");
+8010130c:	c7 04 24 c7 87 10 80 	movl   $0x801087c7,(%esp)
+80101313:	e8 2e f2 ff ff       	call   80100546 <panic>
+}
+80101318:	83 c4 24             	add    $0x24,%esp
+8010131b:	5b                   	pop    %ebx
+8010131c:	5d                   	pop    %ebp
+8010131d:	c3                   	ret    
+	...
+
+80101320 <readsb>:
+static void itrunc(struct inode*);
+
+// Read the super block.
+void
+readsb(int dev, struct superblock *sb)
+{
+80101320:	55                   	push   %ebp
+80101321:	89 e5                	mov    %esp,%ebp
+80101323:	83 ec 28             	sub    $0x28,%esp
+  struct buf *bp;
+  
+  bp = bread(dev, 1);
+80101326:	8b 45 08             	mov    0x8(%ebp),%eax
+80101329:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80101330:	00 
+80101331:	89 04 24             	mov    %eax,(%esp)
+80101334:	e8 6d ee ff ff       	call   801001a6 <bread>
+80101339:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memmove(sb, bp->data, sizeof(*sb));
+8010133c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010133f:	83 c0 18             	add    $0x18,%eax
+80101342:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80101349:	00 
+8010134a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010134e:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101351:	89 04 24             	mov    %eax,(%esp)
+80101354:	e8 c8 3f 00 00       	call   80105321 <memmove>
+  brelse(bp);
+80101359:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010135c:	89 04 24             	mov    %eax,(%esp)
+8010135f:	e8 b3 ee ff ff       	call   80100217 <brelse>
+}
+80101364:	c9                   	leave  
+80101365:	c3                   	ret    
+
+80101366 <bzero>:
+
+// Zero a block.
+static void
+bzero(int dev, int bno)
+{
+80101366:	55                   	push   %ebp
+80101367:	89 e5                	mov    %esp,%ebp
+80101369:	83 ec 28             	sub    $0x28,%esp
+  struct buf *bp;
+  
+  bp = bread(dev, bno);
+8010136c:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010136f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101372:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101376:	89 04 24             	mov    %eax,(%esp)
+80101379:	e8 28 ee ff ff       	call   801001a6 <bread>
+8010137e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(bp->data, 0, BSIZE);
+80101381:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101384:	83 c0 18             	add    $0x18,%eax
+80101387:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+8010138e:	00 
+8010138f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80101396:	00 
+80101397:	89 04 24             	mov    %eax,(%esp)
+8010139a:	e8 af 3e 00 00       	call   8010524e <memset>
+  log_write(bp);
+8010139f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801013a2:	89 04 24             	mov    %eax,(%esp)
+801013a5:	e8 06 23 00 00       	call   801036b0 <log_write>
+  brelse(bp);
+801013aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801013ad:	89 04 24             	mov    %eax,(%esp)
+801013b0:	e8 62 ee ff ff       	call   80100217 <brelse>
+}
+801013b5:	c9                   	leave  
+801013b6:	c3                   	ret    
+
+801013b7 <balloc>:
+// Blocks. 
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+801013b7:	55                   	push   %ebp
+801013b8:	89 e5                	mov    %esp,%ebp
+801013ba:	53                   	push   %ebx
+801013bb:	83 ec 34             	sub    $0x34,%esp
+  int b, bi, m;
+  struct buf *bp;
+  struct superblock sb;
+
+  bp = 0;
+801013be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  readsb(dev, &sb);
+801013c5:	8b 45 08             	mov    0x8(%ebp),%eax
+801013c8:	8d 55 d8             	lea    -0x28(%ebp),%edx
+801013cb:	89 54 24 04          	mov    %edx,0x4(%esp)
+801013cf:	89 04 24             	mov    %eax,(%esp)
+801013d2:	e8 49 ff ff ff       	call   80101320 <readsb>
+  for(b = 0; b < sb.size; b += BPB){
+801013d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801013de:	e9 10 01 00 00       	jmp    801014f3 <balloc+0x13c>
+    bp = bread(dev, BBLOCK(b, sb.ninodes));
+801013e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801013e6:	89 c2                	mov    %eax,%edx
+801013e8:	c1 fa 1f             	sar    $0x1f,%edx
+801013eb:	c1 ea 14             	shr    $0x14,%edx
+801013ee:	01 d0                	add    %edx,%eax
+801013f0:	c1 f8 0c             	sar    $0xc,%eax
+801013f3:	8b 55 e0             	mov    -0x20(%ebp),%edx
+801013f6:	c1 ea 03             	shr    $0x3,%edx
+801013f9:	01 d0                	add    %edx,%eax
+801013fb:	83 c0 03             	add    $0x3,%eax
+801013fe:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101402:	8b 45 08             	mov    0x8(%ebp),%eax
+80101405:	89 04 24             	mov    %eax,(%esp)
+80101408:	e8 99 ed ff ff       	call   801001a6 <bread>
+8010140d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+80101410:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80101417:	e9 a7 00 00 00       	jmp    801014c3 <balloc+0x10c>
+      m = 1 << (bi % 8);
+8010141c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010141f:	89 c2                	mov    %eax,%edx
+80101421:	c1 fa 1f             	sar    $0x1f,%edx
+80101424:	c1 ea 1d             	shr    $0x1d,%edx
+80101427:	01 d0                	add    %edx,%eax
+80101429:	83 e0 07             	and    $0x7,%eax
+8010142c:	29 d0                	sub    %edx,%eax
+8010142e:	ba 01 00 00 00       	mov    $0x1,%edx
+80101433:	89 d3                	mov    %edx,%ebx
+80101435:	89 c1                	mov    %eax,%ecx
+80101437:	d3 e3                	shl    %cl,%ebx
+80101439:	89 d8                	mov    %ebx,%eax
+8010143b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+8010143e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101441:	89 c2                	mov    %eax,%edx
+80101443:	c1 fa 1f             	sar    $0x1f,%edx
+80101446:	c1 ea 1d             	shr    $0x1d,%edx
+80101449:	01 d0                	add    %edx,%eax
+8010144b:	c1 f8 03             	sar    $0x3,%eax
+8010144e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80101451:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
+80101456:	0f b6 c0             	movzbl %al,%eax
+80101459:	23 45 e8             	and    -0x18(%ebp),%eax
+8010145c:	85 c0                	test   %eax,%eax
+8010145e:	75 5f                	jne    801014bf <balloc+0x108>
+        bp->data[bi/8] |= m;  // Mark block in use.
+80101460:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101463:	89 c2                	mov    %eax,%edx
+80101465:	c1 fa 1f             	sar    $0x1f,%edx
+80101468:	c1 ea 1d             	shr    $0x1d,%edx
+8010146b:	01 d0                	add    %edx,%eax
+8010146d:	c1 f8 03             	sar    $0x3,%eax
+80101470:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80101473:	0f b6 54 02 18       	movzbl 0x18(%edx,%eax,1),%edx
+80101478:	89 d1                	mov    %edx,%ecx
+8010147a:	8b 55 e8             	mov    -0x18(%ebp),%edx
+8010147d:	09 ca                	or     %ecx,%edx
+8010147f:	89 d1                	mov    %edx,%ecx
+80101481:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80101484:	88 4c 02 18          	mov    %cl,0x18(%edx,%eax,1)
+        log_write(bp);
+80101488:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010148b:	89 04 24             	mov    %eax,(%esp)
+8010148e:	e8 1d 22 00 00       	call   801036b0 <log_write>
+        brelse(bp);
+80101493:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101496:	89 04 24             	mov    %eax,(%esp)
+80101499:	e8 79 ed ff ff       	call   80100217 <brelse>
+        bzero(dev, b + bi);
+8010149e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801014a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801014a4:	01 c2                	add    %eax,%edx
+801014a6:	8b 45 08             	mov    0x8(%ebp),%eax
+801014a9:	89 54 24 04          	mov    %edx,0x4(%esp)
+801014ad:	89 04 24             	mov    %eax,(%esp)
+801014b0:	e8 b1 fe ff ff       	call   80101366 <bzero>
+        return b + bi;
+801014b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801014b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801014bb:	01 d0                	add    %edx,%eax
+801014bd:	eb 4e                	jmp    8010150d <balloc+0x156>
+
+  bp = 0;
+  readsb(dev, &sb);
+  for(b = 0; b < sb.size; b += BPB){
+    bp = bread(dev, BBLOCK(b, sb.ninodes));
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+801014bf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+801014c3:	81 7d f0 ff 0f 00 00 	cmpl   $0xfff,-0x10(%ebp)
+801014ca:	7f 15                	jg     801014e1 <balloc+0x12a>
+801014cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801014cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801014d2:	01 d0                	add    %edx,%eax
+801014d4:	89 c2                	mov    %eax,%edx
+801014d6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+801014d9:	39 c2                	cmp    %eax,%edx
+801014db:	0f 82 3b ff ff ff    	jb     8010141c <balloc+0x65>
+        brelse(bp);
+        bzero(dev, b + bi);
+        return b + bi;
+      }
+    }
+    brelse(bp);
+801014e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801014e4:	89 04 24             	mov    %eax,(%esp)
+801014e7:	e8 2b ed ff ff       	call   80100217 <brelse>
+  struct buf *bp;
+  struct superblock sb;
+
+  bp = 0;
+  readsb(dev, &sb);
+  for(b = 0; b < sb.size; b += BPB){
+801014ec:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+801014f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801014f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+801014f9:	39 c2                	cmp    %eax,%edx
+801014fb:	0f 82 e2 fe ff ff    	jb     801013e3 <balloc+0x2c>
+        return b + bi;
+      }
+    }
+    brelse(bp);
+  }
+  panic("balloc: out of blocks");
+80101501:	c7 04 24 d1 87 10 80 	movl   $0x801087d1,(%esp)
+80101508:	e8 39 f0 ff ff       	call   80100546 <panic>
+}
+8010150d:	83 c4 34             	add    $0x34,%esp
+80101510:	5b                   	pop    %ebx
+80101511:	5d                   	pop    %ebp
+80101512:	c3                   	ret    
+
+80101513 <bfree>:
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+80101513:	55                   	push   %ebp
+80101514:	89 e5                	mov    %esp,%ebp
+80101516:	53                   	push   %ebx
+80101517:	83 ec 34             	sub    $0x34,%esp
+  struct buf *bp;
+  struct superblock sb;
+  int bi, m;
+
+  readsb(dev, &sb);
+8010151a:	8d 45 dc             	lea    -0x24(%ebp),%eax
+8010151d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101521:	8b 45 08             	mov    0x8(%ebp),%eax
+80101524:	89 04 24             	mov    %eax,(%esp)
+80101527:	e8 f4 fd ff ff       	call   80101320 <readsb>
+  bp = bread(dev, BBLOCK(b, sb.ninodes));
+8010152c:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010152f:	89 c2                	mov    %eax,%edx
+80101531:	c1 ea 0c             	shr    $0xc,%edx
+80101534:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101537:	c1 e8 03             	shr    $0x3,%eax
+8010153a:	01 d0                	add    %edx,%eax
+8010153c:	8d 50 03             	lea    0x3(%eax),%edx
+8010153f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101542:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101546:	89 04 24             	mov    %eax,(%esp)
+80101549:	e8 58 ec ff ff       	call   801001a6 <bread>
+8010154e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  bi = b % BPB;
+80101551:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101554:	25 ff 0f 00 00       	and    $0xfff,%eax
+80101559:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  m = 1 << (bi % 8);
+8010155c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010155f:	89 c2                	mov    %eax,%edx
+80101561:	c1 fa 1f             	sar    $0x1f,%edx
+80101564:	c1 ea 1d             	shr    $0x1d,%edx
+80101567:	01 d0                	add    %edx,%eax
+80101569:	83 e0 07             	and    $0x7,%eax
+8010156c:	29 d0                	sub    %edx,%eax
+8010156e:	ba 01 00 00 00       	mov    $0x1,%edx
+80101573:	89 d3                	mov    %edx,%ebx
+80101575:	89 c1                	mov    %eax,%ecx
+80101577:	d3 e3                	shl    %cl,%ebx
+80101579:	89 d8                	mov    %ebx,%eax
+8010157b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((bp->data[bi/8] & m) == 0)
+8010157e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101581:	89 c2                	mov    %eax,%edx
+80101583:	c1 fa 1f             	sar    $0x1f,%edx
+80101586:	c1 ea 1d             	shr    $0x1d,%edx
+80101589:	01 d0                	add    %edx,%eax
+8010158b:	c1 f8 03             	sar    $0x3,%eax
+8010158e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101591:	0f b6 44 02 18       	movzbl 0x18(%edx,%eax,1),%eax
+80101596:	0f b6 c0             	movzbl %al,%eax
+80101599:	23 45 ec             	and    -0x14(%ebp),%eax
+8010159c:	85 c0                	test   %eax,%eax
+8010159e:	75 0c                	jne    801015ac <bfree+0x99>
+    panic("freeing free block");
+801015a0:	c7 04 24 e7 87 10 80 	movl   $0x801087e7,(%esp)
+801015a7:	e8 9a ef ff ff       	call   80100546 <panic>
+  bp->data[bi/8] &= ~m;
+801015ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801015af:	89 c2                	mov    %eax,%edx
+801015b1:	c1 fa 1f             	sar    $0x1f,%edx
+801015b4:	c1 ea 1d             	shr    $0x1d,%edx
+801015b7:	01 d0                	add    %edx,%eax
+801015b9:	c1 f8 03             	sar    $0x3,%eax
+801015bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801015bf:	0f b6 54 02 18       	movzbl 0x18(%edx,%eax,1),%edx
+801015c4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+801015c7:	f7 d1                	not    %ecx
+801015c9:	21 ca                	and    %ecx,%edx
+801015cb:	89 d1                	mov    %edx,%ecx
+801015cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801015d0:	88 4c 02 18          	mov    %cl,0x18(%edx,%eax,1)
+  log_write(bp);
+801015d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801015d7:	89 04 24             	mov    %eax,(%esp)
+801015da:	e8 d1 20 00 00       	call   801036b0 <log_write>
+  brelse(bp);
+801015df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801015e2:	89 04 24             	mov    %eax,(%esp)
+801015e5:	e8 2d ec ff ff       	call   80100217 <brelse>
+}
+801015ea:	83 c4 34             	add    $0x34,%esp
+801015ed:	5b                   	pop    %ebx
+801015ee:	5d                   	pop    %ebp
+801015ef:	c3                   	ret    
+
+801015f0 <iinit>:
+  struct inode inode[NINODE];
+} icache;
+
+void
+iinit(void)
+{
+801015f0:	55                   	push   %ebp
+801015f1:	89 e5                	mov    %esp,%ebp
+801015f3:	83 ec 18             	sub    $0x18,%esp
+  initlock(&icache.lock, "icache");
+801015f6:	c7 44 24 04 fa 87 10 	movl   $0x801087fa,0x4(%esp)
+801015fd:	80 
+801015fe:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101605:	e8 c8 39 00 00       	call   80104fd2 <initlock>
+}
+8010160a:	c9                   	leave  
+8010160b:	c3                   	ret    
+
+8010160c <ialloc>:
+//PAGEBREAK!
+// Allocate a new inode with the given type on device dev.
+// A free inode has a type of zero.
+struct inode*
+ialloc(uint dev, short type)
+{
+8010160c:	55                   	push   %ebp
+8010160d:	89 e5                	mov    %esp,%ebp
+8010160f:	83 ec 48             	sub    $0x48,%esp
+80101612:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101615:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
+  int inum;
+  struct buf *bp;
+  struct dinode *dip;
+  struct superblock sb;
+
+  readsb(dev, &sb);
+80101619:	8b 45 08             	mov    0x8(%ebp),%eax
+8010161c:	8d 55 dc             	lea    -0x24(%ebp),%edx
+8010161f:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101623:	89 04 24             	mov    %eax,(%esp)
+80101626:	e8 f5 fc ff ff       	call   80101320 <readsb>
+
+  for(inum = 1; inum < sb.ninodes; inum++){
+8010162b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+80101632:	e9 98 00 00 00       	jmp    801016cf <ialloc+0xc3>
+    bp = bread(dev, IBLOCK(inum));
+80101637:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010163a:	c1 e8 03             	shr    $0x3,%eax
+8010163d:	83 c0 02             	add    $0x2,%eax
+80101640:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101644:	8b 45 08             	mov    0x8(%ebp),%eax
+80101647:	89 04 24             	mov    %eax,(%esp)
+8010164a:	e8 57 eb ff ff       	call   801001a6 <bread>
+8010164f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    dip = (struct dinode*)bp->data + inum%IPB;
+80101652:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101655:	8d 50 18             	lea    0x18(%eax),%edx
+80101658:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010165b:	83 e0 07             	and    $0x7,%eax
+8010165e:	c1 e0 06             	shl    $0x6,%eax
+80101661:	01 d0                	add    %edx,%eax
+80101663:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(dip->type == 0){  // a free inode
+80101666:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101669:	0f b7 00             	movzwl (%eax),%eax
+8010166c:	66 85 c0             	test   %ax,%ax
+8010166f:	75 4f                	jne    801016c0 <ialloc+0xb4>
+      memset(dip, 0, sizeof(*dip));
+80101671:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
+80101678:	00 
+80101679:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80101680:	00 
+80101681:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101684:	89 04 24             	mov    %eax,(%esp)
+80101687:	e8 c2 3b 00 00       	call   8010524e <memset>
+      dip->type = type;
+8010168c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010168f:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
+80101693:	66 89 10             	mov    %dx,(%eax)
+      log_write(bp);   // mark it allocated on the disk
+80101696:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101699:	89 04 24             	mov    %eax,(%esp)
+8010169c:	e8 0f 20 00 00       	call   801036b0 <log_write>
+      brelse(bp);
+801016a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801016a4:	89 04 24             	mov    %eax,(%esp)
+801016a7:	e8 6b eb ff ff       	call   80100217 <brelse>
+      return iget(dev, inum);
+801016ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801016af:	89 44 24 04          	mov    %eax,0x4(%esp)
+801016b3:	8b 45 08             	mov    0x8(%ebp),%eax
+801016b6:	89 04 24             	mov    %eax,(%esp)
+801016b9:	e8 e5 00 00 00       	call   801017a3 <iget>
+801016be:	eb 29                	jmp    801016e9 <ialloc+0xdd>
+    }
+    brelse(bp);
+801016c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801016c3:	89 04 24             	mov    %eax,(%esp)
+801016c6:	e8 4c eb ff ff       	call   80100217 <brelse>
+  struct dinode *dip;
+  struct superblock sb;
+
+  readsb(dev, &sb);
+
+  for(inum = 1; inum < sb.ninodes; inum++){
+801016cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801016cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801016d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801016d5:	39 c2                	cmp    %eax,%edx
+801016d7:	0f 82 5a ff ff ff    	jb     80101637 <ialloc+0x2b>
+      brelse(bp);
+      return iget(dev, inum);
+    }
+    brelse(bp);
+  }
+  panic("ialloc: no inodes");
+801016dd:	c7 04 24 01 88 10 80 	movl   $0x80108801,(%esp)
+801016e4:	e8 5d ee ff ff       	call   80100546 <panic>
+}
+801016e9:	c9                   	leave  
+801016ea:	c3                   	ret    
+
+801016eb <iupdate>:
+
+// Copy a modified in-memory inode to disk.
+void
+iupdate(struct inode *ip)
+{
+801016eb:	55                   	push   %ebp
+801016ec:	89 e5                	mov    %esp,%ebp
+801016ee:	83 ec 28             	sub    $0x28,%esp
+  struct buf *bp;
+  struct dinode *dip;
+
+  bp = bread(ip->dev, IBLOCK(ip->inum));
+801016f1:	8b 45 08             	mov    0x8(%ebp),%eax
+801016f4:	8b 40 04             	mov    0x4(%eax),%eax
+801016f7:	c1 e8 03             	shr    $0x3,%eax
+801016fa:	8d 50 02             	lea    0x2(%eax),%edx
+801016fd:	8b 45 08             	mov    0x8(%ebp),%eax
+80101700:	8b 00                	mov    (%eax),%eax
+80101702:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101706:	89 04 24             	mov    %eax,(%esp)
+80101709:	e8 98 ea ff ff       	call   801001a6 <bread>
+8010170e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101711:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101714:	8d 50 18             	lea    0x18(%eax),%edx
+80101717:	8b 45 08             	mov    0x8(%ebp),%eax
+8010171a:	8b 40 04             	mov    0x4(%eax),%eax
+8010171d:	83 e0 07             	and    $0x7,%eax
+80101720:	c1 e0 06             	shl    $0x6,%eax
+80101723:	01 d0                	add    %edx,%eax
+80101725:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  dip->type = ip->type;
+80101728:	8b 45 08             	mov    0x8(%ebp),%eax
+8010172b:	0f b7 50 10          	movzwl 0x10(%eax),%edx
+8010172f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101732:	66 89 10             	mov    %dx,(%eax)
+  dip->major = ip->major;
+80101735:	8b 45 08             	mov    0x8(%ebp),%eax
+80101738:	0f b7 50 12          	movzwl 0x12(%eax),%edx
+8010173c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010173f:	66 89 50 02          	mov    %dx,0x2(%eax)
+  dip->minor = ip->minor;
+80101743:	8b 45 08             	mov    0x8(%ebp),%eax
+80101746:	0f b7 50 14          	movzwl 0x14(%eax),%edx
+8010174a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010174d:	66 89 50 04          	mov    %dx,0x4(%eax)
+  dip->nlink = ip->nlink;
+80101751:	8b 45 08             	mov    0x8(%ebp),%eax
+80101754:	0f b7 50 16          	movzwl 0x16(%eax),%edx
+80101758:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010175b:	66 89 50 06          	mov    %dx,0x6(%eax)
+  dip->size = ip->size;
+8010175f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101762:	8b 50 18             	mov    0x18(%eax),%edx
+80101765:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101768:	89 50 08             	mov    %edx,0x8(%eax)
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+8010176b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010176e:	8d 50 1c             	lea    0x1c(%eax),%edx
+80101771:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101774:	83 c0 0c             	add    $0xc,%eax
+80101777:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
+8010177e:	00 
+8010177f:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101783:	89 04 24             	mov    %eax,(%esp)
+80101786:	e8 96 3b 00 00       	call   80105321 <memmove>
+  log_write(bp);
+8010178b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010178e:	89 04 24             	mov    %eax,(%esp)
+80101791:	e8 1a 1f 00 00       	call   801036b0 <log_write>
+  brelse(bp);
+80101796:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101799:	89 04 24             	mov    %eax,(%esp)
+8010179c:	e8 76 ea ff ff       	call   80100217 <brelse>
+}
+801017a1:	c9                   	leave  
+801017a2:	c3                   	ret    
+
+801017a3 <iget>:
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+801017a3:	55                   	push   %ebp
+801017a4:	89 e5                	mov    %esp,%ebp
+801017a6:	83 ec 28             	sub    $0x28,%esp
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+801017a9:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+801017b0:	e8 3e 38 00 00       	call   80104ff3 <acquire>
+
+  // Is the inode already cached?
+  empty = 0;
+801017b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+801017bc:	c7 45 f4 94 12 11 80 	movl   $0x80111294,-0xc(%ebp)
+801017c3:	eb 59                	jmp    8010181e <iget+0x7b>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+801017c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801017c8:	8b 40 08             	mov    0x8(%eax),%eax
+801017cb:	85 c0                	test   %eax,%eax
+801017cd:	7e 35                	jle    80101804 <iget+0x61>
+801017cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801017d2:	8b 00                	mov    (%eax),%eax
+801017d4:	3b 45 08             	cmp    0x8(%ebp),%eax
+801017d7:	75 2b                	jne    80101804 <iget+0x61>
+801017d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801017dc:	8b 40 04             	mov    0x4(%eax),%eax
+801017df:	3b 45 0c             	cmp    0xc(%ebp),%eax
+801017e2:	75 20                	jne    80101804 <iget+0x61>
+      ip->ref++;
+801017e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801017e7:	8b 40 08             	mov    0x8(%eax),%eax
+801017ea:	8d 50 01             	lea    0x1(%eax),%edx
+801017ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801017f0:	89 50 08             	mov    %edx,0x8(%eax)
+      release(&icache.lock);
+801017f3:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+801017fa:	e8 56 38 00 00       	call   80105055 <release>
+      return ip;
+801017ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101802:	eb 6f                	jmp    80101873 <iget+0xd0>
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+80101804:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80101808:	75 10                	jne    8010181a <iget+0x77>
+8010180a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010180d:	8b 40 08             	mov    0x8(%eax),%eax
+80101810:	85 c0                	test   %eax,%eax
+80101812:	75 06                	jne    8010181a <iget+0x77>
+      empty = ip;
+80101814:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101817:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010181a:	83 45 f4 50          	addl   $0x50,-0xc(%ebp)
+8010181e:	81 7d f4 34 22 11 80 	cmpl   $0x80112234,-0xc(%ebp)
+80101825:	72 9e                	jb     801017c5 <iget+0x22>
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+      empty = ip;
+  }
+
+  // Recycle an inode cache entry.
+  if(empty == 0)
+80101827:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010182b:	75 0c                	jne    80101839 <iget+0x96>
+    panic("iget: no inodes");
+8010182d:	c7 04 24 13 88 10 80 	movl   $0x80108813,(%esp)
+80101834:	e8 0d ed ff ff       	call   80100546 <panic>
+
+  ip = empty;
+80101839:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010183c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  ip->dev = dev;
+8010183f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101842:	8b 55 08             	mov    0x8(%ebp),%edx
+80101845:	89 10                	mov    %edx,(%eax)
+  ip->inum = inum;
+80101847:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010184a:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010184d:	89 50 04             	mov    %edx,0x4(%eax)
+  ip->ref = 1;
+80101850:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101853:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
+  ip->flags = 0;
+8010185a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010185d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+  release(&icache.lock);
+80101864:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+8010186b:	e8 e5 37 00 00       	call   80105055 <release>
+
+  return ip;
+80101870:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80101873:	c9                   	leave  
+80101874:	c3                   	ret    
+
+80101875 <idup>:
+
+// Increment reference count for ip.
+// Returns ip to enable ip = idup(ip1) idiom.
+struct inode*
+idup(struct inode *ip)
+{
+80101875:	55                   	push   %ebp
+80101876:	89 e5                	mov    %esp,%ebp
+80101878:	83 ec 18             	sub    $0x18,%esp
+  acquire(&icache.lock);
+8010187b:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101882:	e8 6c 37 00 00       	call   80104ff3 <acquire>
+  ip->ref++;
+80101887:	8b 45 08             	mov    0x8(%ebp),%eax
+8010188a:	8b 40 08             	mov    0x8(%eax),%eax
+8010188d:	8d 50 01             	lea    0x1(%eax),%edx
+80101890:	8b 45 08             	mov    0x8(%ebp),%eax
+80101893:	89 50 08             	mov    %edx,0x8(%eax)
+  release(&icache.lock);
+80101896:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+8010189d:	e8 b3 37 00 00       	call   80105055 <release>
+  return ip;
+801018a2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+801018a5:	c9                   	leave  
+801018a6:	c3                   	ret    
+
+801018a7 <ilock>:
+
+// Lock the given inode.
+// Reads the inode from disk if necessary.
+void
+ilock(struct inode *ip)
+{
+801018a7:	55                   	push   %ebp
+801018a8:	89 e5                	mov    %esp,%ebp
+801018aa:	83 ec 28             	sub    $0x28,%esp
+  struct buf *bp;
+  struct dinode *dip;
+
+  if(ip == 0 || ip->ref < 1)
+801018ad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+801018b1:	74 0a                	je     801018bd <ilock+0x16>
+801018b3:	8b 45 08             	mov    0x8(%ebp),%eax
+801018b6:	8b 40 08             	mov    0x8(%eax),%eax
+801018b9:	85 c0                	test   %eax,%eax
+801018bb:	7f 0c                	jg     801018c9 <ilock+0x22>
+    panic("ilock");
+801018bd:	c7 04 24 23 88 10 80 	movl   $0x80108823,(%esp)
+801018c4:	e8 7d ec ff ff       	call   80100546 <panic>
+
+  acquire(&icache.lock);
+801018c9:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+801018d0:	e8 1e 37 00 00       	call   80104ff3 <acquire>
+  while(ip->flags & I_BUSY)
+801018d5:	eb 13                	jmp    801018ea <ilock+0x43>
+    sleep(ip, &icache.lock);
+801018d7:	c7 44 24 04 60 12 11 	movl   $0x80111260,0x4(%esp)
+801018de:	80 
+801018df:	8b 45 08             	mov    0x8(%ebp),%eax
+801018e2:	89 04 24             	mov    %eax,(%esp)
+801018e5:	e8 2b 34 00 00       	call   80104d15 <sleep>
+
+  if(ip == 0 || ip->ref < 1)
+    panic("ilock");
+
+  acquire(&icache.lock);
+  while(ip->flags & I_BUSY)
+801018ea:	8b 45 08             	mov    0x8(%ebp),%eax
+801018ed:	8b 40 0c             	mov    0xc(%eax),%eax
+801018f0:	83 e0 01             	and    $0x1,%eax
+801018f3:	85 c0                	test   %eax,%eax
+801018f5:	75 e0                	jne    801018d7 <ilock+0x30>
+    sleep(ip, &icache.lock);
+  ip->flags |= I_BUSY;
+801018f7:	8b 45 08             	mov    0x8(%ebp),%eax
+801018fa:	8b 40 0c             	mov    0xc(%eax),%eax
+801018fd:	89 c2                	mov    %eax,%edx
+801018ff:	83 ca 01             	or     $0x1,%edx
+80101902:	8b 45 08             	mov    0x8(%ebp),%eax
+80101905:	89 50 0c             	mov    %edx,0xc(%eax)
+  release(&icache.lock);
+80101908:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+8010190f:	e8 41 37 00 00       	call   80105055 <release>
+
+  if(!(ip->flags & I_VALID)){
+80101914:	8b 45 08             	mov    0x8(%ebp),%eax
+80101917:	8b 40 0c             	mov    0xc(%eax),%eax
+8010191a:	83 e0 02             	and    $0x2,%eax
+8010191d:	85 c0                	test   %eax,%eax
+8010191f:	0f 85 ce 00 00 00    	jne    801019f3 <ilock+0x14c>
+    bp = bread(ip->dev, IBLOCK(ip->inum));
+80101925:	8b 45 08             	mov    0x8(%ebp),%eax
+80101928:	8b 40 04             	mov    0x4(%eax),%eax
+8010192b:	c1 e8 03             	shr    $0x3,%eax
+8010192e:	8d 50 02             	lea    0x2(%eax),%edx
+80101931:	8b 45 08             	mov    0x8(%ebp),%eax
+80101934:	8b 00                	mov    (%eax),%eax
+80101936:	89 54 24 04          	mov    %edx,0x4(%esp)
+8010193a:	89 04 24             	mov    %eax,(%esp)
+8010193d:	e8 64 e8 ff ff       	call   801001a6 <bread>
+80101942:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101945:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101948:	8d 50 18             	lea    0x18(%eax),%edx
+8010194b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010194e:	8b 40 04             	mov    0x4(%eax),%eax
+80101951:	83 e0 07             	and    $0x7,%eax
+80101954:	c1 e0 06             	shl    $0x6,%eax
+80101957:	01 d0                	add    %edx,%eax
+80101959:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    ip->type = dip->type;
+8010195c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010195f:	0f b7 10             	movzwl (%eax),%edx
+80101962:	8b 45 08             	mov    0x8(%ebp),%eax
+80101965:	66 89 50 10          	mov    %dx,0x10(%eax)
+    ip->major = dip->major;
+80101969:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010196c:	0f b7 50 02          	movzwl 0x2(%eax),%edx
+80101970:	8b 45 08             	mov    0x8(%ebp),%eax
+80101973:	66 89 50 12          	mov    %dx,0x12(%eax)
+    ip->minor = dip->minor;
+80101977:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010197a:	0f b7 50 04          	movzwl 0x4(%eax),%edx
+8010197e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101981:	66 89 50 14          	mov    %dx,0x14(%eax)
+    ip->nlink = dip->nlink;
+80101985:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101988:	0f b7 50 06          	movzwl 0x6(%eax),%edx
+8010198c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010198f:	66 89 50 16          	mov    %dx,0x16(%eax)
+    ip->size = dip->size;
+80101993:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101996:	8b 50 08             	mov    0x8(%eax),%edx
+80101999:	8b 45 08             	mov    0x8(%ebp),%eax
+8010199c:	89 50 18             	mov    %edx,0x18(%eax)
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+8010199f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801019a2:	8d 50 0c             	lea    0xc(%eax),%edx
+801019a5:	8b 45 08             	mov    0x8(%ebp),%eax
+801019a8:	83 c0 1c             	add    $0x1c,%eax
+801019ab:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
+801019b2:	00 
+801019b3:	89 54 24 04          	mov    %edx,0x4(%esp)
+801019b7:	89 04 24             	mov    %eax,(%esp)
+801019ba:	e8 62 39 00 00       	call   80105321 <memmove>
+    brelse(bp);
+801019bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019c2:	89 04 24             	mov    %eax,(%esp)
+801019c5:	e8 4d e8 ff ff       	call   80100217 <brelse>
+    ip->flags |= I_VALID;
+801019ca:	8b 45 08             	mov    0x8(%ebp),%eax
+801019cd:	8b 40 0c             	mov    0xc(%eax),%eax
+801019d0:	89 c2                	mov    %eax,%edx
+801019d2:	83 ca 02             	or     $0x2,%edx
+801019d5:	8b 45 08             	mov    0x8(%ebp),%eax
+801019d8:	89 50 0c             	mov    %edx,0xc(%eax)
+    if(ip->type == 0)
+801019db:	8b 45 08             	mov    0x8(%ebp),%eax
+801019de:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+801019e2:	66 85 c0             	test   %ax,%ax
+801019e5:	75 0c                	jne    801019f3 <ilock+0x14c>
+      panic("ilock: no type");
+801019e7:	c7 04 24 29 88 10 80 	movl   $0x80108829,(%esp)
+801019ee:	e8 53 eb ff ff       	call   80100546 <panic>
+  }
+}
+801019f3:	c9                   	leave  
+801019f4:	c3                   	ret    
+
+801019f5 <iunlock>:
+
+// Unlock the given inode.
+void
+iunlock(struct inode *ip)
+{
+801019f5:	55                   	push   %ebp
+801019f6:	89 e5                	mov    %esp,%ebp
+801019f8:	83 ec 18             	sub    $0x18,%esp
+  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
+801019fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+801019ff:	74 17                	je     80101a18 <iunlock+0x23>
+80101a01:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a04:	8b 40 0c             	mov    0xc(%eax),%eax
+80101a07:	83 e0 01             	and    $0x1,%eax
+80101a0a:	85 c0                	test   %eax,%eax
+80101a0c:	74 0a                	je     80101a18 <iunlock+0x23>
+80101a0e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a11:	8b 40 08             	mov    0x8(%eax),%eax
+80101a14:	85 c0                	test   %eax,%eax
+80101a16:	7f 0c                	jg     80101a24 <iunlock+0x2f>
+    panic("iunlock");
+80101a18:	c7 04 24 38 88 10 80 	movl   $0x80108838,(%esp)
+80101a1f:	e8 22 eb ff ff       	call   80100546 <panic>
+
+  acquire(&icache.lock);
+80101a24:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101a2b:	e8 c3 35 00 00       	call   80104ff3 <acquire>
+  ip->flags &= ~I_BUSY;
+80101a30:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a33:	8b 40 0c             	mov    0xc(%eax),%eax
+80101a36:	89 c2                	mov    %eax,%edx
+80101a38:	83 e2 fe             	and    $0xfffffffe,%edx
+80101a3b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a3e:	89 50 0c             	mov    %edx,0xc(%eax)
+  wakeup(ip);
+80101a41:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a44:	89 04 24             	mov    %eax,(%esp)
+80101a47:	e8 a2 33 00 00       	call   80104dee <wakeup>
+  release(&icache.lock);
+80101a4c:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101a53:	e8 fd 35 00 00       	call   80105055 <release>
+}
+80101a58:	c9                   	leave  
+80101a59:	c3                   	ret    
+
+80101a5a <iput>:
+// to it, free the inode (and its content) on disk.
+// All calls to iput() must be inside a transaction in
+// case it has to free the inode.
+void
+iput(struct inode *ip)
+{
+80101a5a:	55                   	push   %ebp
+80101a5b:	89 e5                	mov    %esp,%ebp
+80101a5d:	83 ec 18             	sub    $0x18,%esp
+  acquire(&icache.lock);
+80101a60:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101a67:	e8 87 35 00 00       	call   80104ff3 <acquire>
+  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+80101a6c:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a6f:	8b 40 08             	mov    0x8(%eax),%eax
+80101a72:	83 f8 01             	cmp    $0x1,%eax
+80101a75:	0f 85 93 00 00 00    	jne    80101b0e <iput+0xb4>
+80101a7b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a7e:	8b 40 0c             	mov    0xc(%eax),%eax
+80101a81:	83 e0 02             	and    $0x2,%eax
+80101a84:	85 c0                	test   %eax,%eax
+80101a86:	0f 84 82 00 00 00    	je     80101b0e <iput+0xb4>
+80101a8c:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a8f:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80101a93:	66 85 c0             	test   %ax,%ax
+80101a96:	75 76                	jne    80101b0e <iput+0xb4>
+    // inode has no links and no other references: truncate and free.
+    if(ip->flags & I_BUSY)
+80101a98:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a9b:	8b 40 0c             	mov    0xc(%eax),%eax
+80101a9e:	83 e0 01             	and    $0x1,%eax
+80101aa1:	85 c0                	test   %eax,%eax
+80101aa3:	74 0c                	je     80101ab1 <iput+0x57>
+      panic("iput busy");
+80101aa5:	c7 04 24 40 88 10 80 	movl   $0x80108840,(%esp)
+80101aac:	e8 95 ea ff ff       	call   80100546 <panic>
+    ip->flags |= I_BUSY;
+80101ab1:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ab4:	8b 40 0c             	mov    0xc(%eax),%eax
+80101ab7:	89 c2                	mov    %eax,%edx
+80101ab9:	83 ca 01             	or     $0x1,%edx
+80101abc:	8b 45 08             	mov    0x8(%ebp),%eax
+80101abf:	89 50 0c             	mov    %edx,0xc(%eax)
+    release(&icache.lock);
+80101ac2:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101ac9:	e8 87 35 00 00       	call   80105055 <release>
+    itrunc(ip);
+80101ace:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ad1:	89 04 24             	mov    %eax,(%esp)
+80101ad4:	e8 7d 01 00 00       	call   80101c56 <itrunc>
+    ip->type = 0;
+80101ad9:	8b 45 08             	mov    0x8(%ebp),%eax
+80101adc:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
+    iupdate(ip);
+80101ae2:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ae5:	89 04 24             	mov    %eax,(%esp)
+80101ae8:	e8 fe fb ff ff       	call   801016eb <iupdate>
+    acquire(&icache.lock);
+80101aed:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101af4:	e8 fa 34 00 00       	call   80104ff3 <acquire>
+    ip->flags = 0;
+80101af9:	8b 45 08             	mov    0x8(%ebp),%eax
+80101afc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+    wakeup(ip);
+80101b03:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b06:	89 04 24             	mov    %eax,(%esp)
+80101b09:	e8 e0 32 00 00       	call   80104dee <wakeup>
+  }
+  ip->ref--;
+80101b0e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b11:	8b 40 08             	mov    0x8(%eax),%eax
+80101b14:	8d 50 ff             	lea    -0x1(%eax),%edx
+80101b17:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b1a:	89 50 08             	mov    %edx,0x8(%eax)
+  release(&icache.lock);
+80101b1d:	c7 04 24 60 12 11 80 	movl   $0x80111260,(%esp)
+80101b24:	e8 2c 35 00 00       	call   80105055 <release>
+}
+80101b29:	c9                   	leave  
+80101b2a:	c3                   	ret    
+
+80101b2b <iunlockput>:
+
+// Common idiom: unlock, then put.
+void
+iunlockput(struct inode *ip)
+{
+80101b2b:	55                   	push   %ebp
+80101b2c:	89 e5                	mov    %esp,%ebp
+80101b2e:	83 ec 18             	sub    $0x18,%esp
+  iunlock(ip);
+80101b31:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b34:	89 04 24             	mov    %eax,(%esp)
+80101b37:	e8 b9 fe ff ff       	call   801019f5 <iunlock>
+  iput(ip);
+80101b3c:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b3f:	89 04 24             	mov    %eax,(%esp)
+80101b42:	e8 13 ff ff ff       	call   80101a5a <iput>
+}
+80101b47:	c9                   	leave  
+80101b48:	c3                   	ret    
+
+80101b49 <bmap>:
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+80101b49:	55                   	push   %ebp
+80101b4a:	89 e5                	mov    %esp,%ebp
+80101b4c:	53                   	push   %ebx
+80101b4d:	83 ec 24             	sub    $0x24,%esp
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+80101b50:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
+80101b54:	77 3e                	ja     80101b94 <bmap+0x4b>
+    if((addr = ip->addrs[bn]) == 0)
+80101b56:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b59:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101b5c:	83 c2 04             	add    $0x4,%edx
+80101b5f:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+80101b63:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101b66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80101b6a:	75 20                	jne    80101b8c <bmap+0x43>
+      ip->addrs[bn] = addr = balloc(ip->dev);
+80101b6c:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b6f:	8b 00                	mov    (%eax),%eax
+80101b71:	89 04 24             	mov    %eax,(%esp)
+80101b74:	e8 3e f8 ff ff       	call   801013b7 <balloc>
+80101b79:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101b7c:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b7f:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101b82:	8d 4a 04             	lea    0x4(%edx),%ecx
+80101b85:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101b88:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)
+    return addr;
+80101b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101b8f:	e9 bc 00 00 00       	jmp    80101c50 <bmap+0x107>
+  }
+  bn -= NDIRECT;
+80101b94:	83 6d 0c 0c          	subl   $0xc,0xc(%ebp)
+
+  if(bn < NINDIRECT){
+80101b98:	83 7d 0c 7f          	cmpl   $0x7f,0xc(%ebp)
+80101b9c:	0f 87 a2 00 00 00    	ja     80101c44 <bmap+0xfb>
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0)
+80101ba2:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ba5:	8b 40 4c             	mov    0x4c(%eax),%eax
+80101ba8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101bab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80101baf:	75 19                	jne    80101bca <bmap+0x81>
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+80101bb1:	8b 45 08             	mov    0x8(%ebp),%eax
+80101bb4:	8b 00                	mov    (%eax),%eax
+80101bb6:	89 04 24             	mov    %eax,(%esp)
+80101bb9:	e8 f9 f7 ff ff       	call   801013b7 <balloc>
+80101bbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101bc1:	8b 45 08             	mov    0x8(%ebp),%eax
+80101bc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101bc7:	89 50 4c             	mov    %edx,0x4c(%eax)
+    bp = bread(ip->dev, addr);
+80101bca:	8b 45 08             	mov    0x8(%ebp),%eax
+80101bcd:	8b 00                	mov    (%eax),%eax
+80101bcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101bd2:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101bd6:	89 04 24             	mov    %eax,(%esp)
+80101bd9:	e8 c8 e5 ff ff       	call   801001a6 <bread>
+80101bde:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    a = (uint*)bp->data;
+80101be1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101be4:	83 c0 18             	add    $0x18,%eax
+80101be7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if((addr = a[bn]) == 0){
+80101bea:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101bed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101bf4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101bf7:	01 d0                	add    %edx,%eax
+80101bf9:	8b 00                	mov    (%eax),%eax
+80101bfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101bfe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80101c02:	75 30                	jne    80101c34 <bmap+0xeb>
+      a[bn] = addr = balloc(ip->dev);
+80101c04:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101c07:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101c0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101c11:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+80101c14:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c17:	8b 00                	mov    (%eax),%eax
+80101c19:	89 04 24             	mov    %eax,(%esp)
+80101c1c:	e8 96 f7 ff ff       	call   801013b7 <balloc>
+80101c21:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101c24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101c27:	89 03                	mov    %eax,(%ebx)
+      log_write(bp);
+80101c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101c2c:	89 04 24             	mov    %eax,(%esp)
+80101c2f:	e8 7c 1a 00 00       	call   801036b0 <log_write>
+    }
+    brelse(bp);
+80101c34:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101c37:	89 04 24             	mov    %eax,(%esp)
+80101c3a:	e8 d8 e5 ff ff       	call   80100217 <brelse>
+    return addr;
+80101c3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101c42:	eb 0c                	jmp    80101c50 <bmap+0x107>
+  }
+
+  panic("bmap: out of range");
+80101c44:	c7 04 24 4a 88 10 80 	movl   $0x8010884a,(%esp)
+80101c4b:	e8 f6 e8 ff ff       	call   80100546 <panic>
+}
+80101c50:	83 c4 24             	add    $0x24,%esp
+80101c53:	5b                   	pop    %ebx
+80101c54:	5d                   	pop    %ebp
+80101c55:	c3                   	ret    
+
+80101c56 <itrunc>:
+// to it (no directory entries referring to it)
+// and has no in-memory reference to it (is
+// not an open file or current directory).
+static void
+itrunc(struct inode *ip)
+{
+80101c56:	55                   	push   %ebp
+80101c57:	89 e5                	mov    %esp,%ebp
+80101c59:	83 ec 28             	sub    $0x28,%esp
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+80101c5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80101c63:	eb 44                	jmp    80101ca9 <itrunc+0x53>
+    if(ip->addrs[i]){
+80101c65:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c68:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101c6b:	83 c2 04             	add    $0x4,%edx
+80101c6e:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+80101c72:	85 c0                	test   %eax,%eax
+80101c74:	74 2f                	je     80101ca5 <itrunc+0x4f>
+      bfree(ip->dev, ip->addrs[i]);
+80101c76:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c79:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101c7c:	83 c2 04             	add    $0x4,%edx
+80101c7f:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
+80101c83:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c86:	8b 00                	mov    (%eax),%eax
+80101c88:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101c8c:	89 04 24             	mov    %eax,(%esp)
+80101c8f:	e8 7f f8 ff ff       	call   80101513 <bfree>
+      ip->addrs[i] = 0;
+80101c94:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c97:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101c9a:	83 c2 04             	add    $0x4,%edx
+80101c9d:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
+80101ca4:	00 
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+80101ca5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80101ca9:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
+80101cad:	7e b6                	jle    80101c65 <itrunc+0xf>
+      bfree(ip->dev, ip->addrs[i]);
+      ip->addrs[i] = 0;
+    }
+  }
+  
+  if(ip->addrs[NDIRECT]){
+80101caf:	8b 45 08             	mov    0x8(%ebp),%eax
+80101cb2:	8b 40 4c             	mov    0x4c(%eax),%eax
+80101cb5:	85 c0                	test   %eax,%eax
+80101cb7:	0f 84 9b 00 00 00    	je     80101d58 <itrunc+0x102>
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+80101cbd:	8b 45 08             	mov    0x8(%ebp),%eax
+80101cc0:	8b 50 4c             	mov    0x4c(%eax),%edx
+80101cc3:	8b 45 08             	mov    0x8(%ebp),%eax
+80101cc6:	8b 00                	mov    (%eax),%eax
+80101cc8:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101ccc:	89 04 24             	mov    %eax,(%esp)
+80101ccf:	e8 d2 e4 ff ff       	call   801001a6 <bread>
+80101cd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    a = (uint*)bp->data;
+80101cd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101cda:	83 c0 18             	add    $0x18,%eax
+80101cdd:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    for(j = 0; j < NINDIRECT; j++){
+80101ce0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80101ce7:	eb 3b                	jmp    80101d24 <itrunc+0xce>
+      if(a[j])
+80101ce9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101cec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101cf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80101cf6:	01 d0                	add    %edx,%eax
+80101cf8:	8b 00                	mov    (%eax),%eax
+80101cfa:	85 c0                	test   %eax,%eax
+80101cfc:	74 22                	je     80101d20 <itrunc+0xca>
+        bfree(ip->dev, a[j]);
+80101cfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101d01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101d08:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80101d0b:	01 d0                	add    %edx,%eax
+80101d0d:	8b 10                	mov    (%eax),%edx
+80101d0f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d12:	8b 00                	mov    (%eax),%eax
+80101d14:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101d18:	89 04 24             	mov    %eax,(%esp)
+80101d1b:	e8 f3 f7 ff ff       	call   80101513 <bfree>
+  }
+  
+  if(ip->addrs[NDIRECT]){
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+    a = (uint*)bp->data;
+    for(j = 0; j < NINDIRECT; j++){
+80101d20:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+80101d24:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101d27:	83 f8 7f             	cmp    $0x7f,%eax
+80101d2a:	76 bd                	jbe    80101ce9 <itrunc+0x93>
+      if(a[j])
+        bfree(ip->dev, a[j]);
+    }
+    brelse(bp);
+80101d2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101d2f:	89 04 24             	mov    %eax,(%esp)
+80101d32:	e8 e0 e4 ff ff       	call   80100217 <brelse>
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+80101d37:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d3a:	8b 50 4c             	mov    0x4c(%eax),%edx
+80101d3d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d40:	8b 00                	mov    (%eax),%eax
+80101d42:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101d46:	89 04 24             	mov    %eax,(%esp)
+80101d49:	e8 c5 f7 ff ff       	call   80101513 <bfree>
+    ip->addrs[NDIRECT] = 0;
+80101d4e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d51:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
+  }
+
+  ip->size = 0;
+80101d58:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d5b:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
+  iupdate(ip);
+80101d62:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d65:	89 04 24             	mov    %eax,(%esp)
+80101d68:	e8 7e f9 ff ff       	call   801016eb <iupdate>
+}
+80101d6d:	c9                   	leave  
+80101d6e:	c3                   	ret    
+
+80101d6f <stati>:
+
+// Copy stat information from inode.
+void
+stati(struct inode *ip, struct stat *st)
+{
+80101d6f:	55                   	push   %ebp
+80101d70:	89 e5                	mov    %esp,%ebp
+  st->dev = ip->dev;
+80101d72:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d75:	8b 00                	mov    (%eax),%eax
+80101d77:	89 c2                	mov    %eax,%edx
+80101d79:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101d7c:	89 50 04             	mov    %edx,0x4(%eax)
+  st->ino = ip->inum;
+80101d7f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d82:	8b 50 04             	mov    0x4(%eax),%edx
+80101d85:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101d88:	89 50 08             	mov    %edx,0x8(%eax)
+  st->type = ip->type;
+80101d8b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d8e:	0f b7 50 10          	movzwl 0x10(%eax),%edx
+80101d92:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101d95:	66 89 10             	mov    %dx,(%eax)
+  st->nlink = ip->nlink;
+80101d98:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d9b:	0f b7 50 16          	movzwl 0x16(%eax),%edx
+80101d9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101da2:	66 89 50 0c          	mov    %dx,0xc(%eax)
+  st->size = ip->size;
+80101da6:	8b 45 08             	mov    0x8(%ebp),%eax
+80101da9:	8b 50 18             	mov    0x18(%eax),%edx
+80101dac:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101daf:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80101db2:	5d                   	pop    %ebp
+80101db3:	c3                   	ret    
+
+80101db4 <readi>:
+
+//PAGEBREAK!
+// Read data from inode.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+80101db4:	55                   	push   %ebp
+80101db5:	89 e5                	mov    %esp,%ebp
+80101db7:	83 ec 28             	sub    $0x28,%esp
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101dba:	8b 45 08             	mov    0x8(%ebp),%eax
+80101dbd:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80101dc1:	66 83 f8 03          	cmp    $0x3,%ax
+80101dc5:	75 60                	jne    80101e27 <readi+0x73>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+80101dc7:	8b 45 08             	mov    0x8(%ebp),%eax
+80101dca:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101dce:	66 85 c0             	test   %ax,%ax
+80101dd1:	78 20                	js     80101df3 <readi+0x3f>
+80101dd3:	8b 45 08             	mov    0x8(%ebp),%eax
+80101dd6:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101dda:	66 83 f8 09          	cmp    $0x9,%ax
+80101dde:	7f 13                	jg     80101df3 <readi+0x3f>
+80101de0:	8b 45 08             	mov    0x8(%ebp),%eax
+80101de3:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101de7:	98                   	cwtl   
+80101de8:	8b 04 c5 00 12 11 80 	mov    -0x7feeee00(,%eax,8),%eax
+80101def:	85 c0                	test   %eax,%eax
+80101df1:	75 0a                	jne    80101dfd <readi+0x49>
+      return -1;
+80101df3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101df8:	e9 1b 01 00 00       	jmp    80101f18 <readi+0x164>
+    return devsw[ip->major].read(ip, dst, n);
+80101dfd:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e00:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101e04:	98                   	cwtl   
+80101e05:	8b 04 c5 00 12 11 80 	mov    -0x7feeee00(,%eax,8),%eax
+80101e0c:	8b 55 14             	mov    0x14(%ebp),%edx
+80101e0f:	89 54 24 08          	mov    %edx,0x8(%esp)
+80101e13:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101e16:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101e1a:	8b 55 08             	mov    0x8(%ebp),%edx
+80101e1d:	89 14 24             	mov    %edx,(%esp)
+80101e20:	ff d0                	call   *%eax
+80101e22:	e9 f1 00 00 00       	jmp    80101f18 <readi+0x164>
+  }
+
+  if(off > ip->size || off + n < off)
+80101e27:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e2a:	8b 40 18             	mov    0x18(%eax),%eax
+80101e2d:	3b 45 10             	cmp    0x10(%ebp),%eax
+80101e30:	72 0d                	jb     80101e3f <readi+0x8b>
+80101e32:	8b 45 14             	mov    0x14(%ebp),%eax
+80101e35:	8b 55 10             	mov    0x10(%ebp),%edx
+80101e38:	01 d0                	add    %edx,%eax
+80101e3a:	3b 45 10             	cmp    0x10(%ebp),%eax
+80101e3d:	73 0a                	jae    80101e49 <readi+0x95>
+    return -1;
+80101e3f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101e44:	e9 cf 00 00 00       	jmp    80101f18 <readi+0x164>
+  if(off + n > ip->size)
+80101e49:	8b 45 14             	mov    0x14(%ebp),%eax
+80101e4c:	8b 55 10             	mov    0x10(%ebp),%edx
+80101e4f:	01 c2                	add    %eax,%edx
+80101e51:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e54:	8b 40 18             	mov    0x18(%eax),%eax
+80101e57:	39 c2                	cmp    %eax,%edx
+80101e59:	76 0c                	jbe    80101e67 <readi+0xb3>
+    n = ip->size - off;
+80101e5b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e5e:	8b 40 18             	mov    0x18(%eax),%eax
+80101e61:	2b 45 10             	sub    0x10(%ebp),%eax
+80101e64:	89 45 14             	mov    %eax,0x14(%ebp)
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101e67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80101e6e:	e9 96 00 00 00       	jmp    80101f09 <readi+0x155>
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101e73:	8b 45 10             	mov    0x10(%ebp),%eax
+80101e76:	c1 e8 09             	shr    $0x9,%eax
+80101e79:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101e7d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e80:	89 04 24             	mov    %eax,(%esp)
+80101e83:	e8 c1 fc ff ff       	call   80101b49 <bmap>
+80101e88:	8b 55 08             	mov    0x8(%ebp),%edx
+80101e8b:	8b 12                	mov    (%edx),%edx
+80101e8d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101e91:	89 14 24             	mov    %edx,(%esp)
+80101e94:	e8 0d e3 ff ff       	call   801001a6 <bread>
+80101e99:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101e9c:	8b 45 10             	mov    0x10(%ebp),%eax
+80101e9f:	89 c2                	mov    %eax,%edx
+80101ea1:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+80101ea7:	b8 00 02 00 00       	mov    $0x200,%eax
+80101eac:	89 c1                	mov    %eax,%ecx
+80101eae:	29 d1                	sub    %edx,%ecx
+80101eb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101eb3:	8b 55 14             	mov    0x14(%ebp),%edx
+80101eb6:	29 c2                	sub    %eax,%edx
+80101eb8:	89 c8                	mov    %ecx,%eax
+80101eba:	39 d0                	cmp    %edx,%eax
+80101ebc:	76 02                	jbe    80101ec0 <readi+0x10c>
+80101ebe:	89 d0                	mov    %edx,%eax
+80101ec0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(dst, bp->data + off%BSIZE, m);
+80101ec3:	8b 45 10             	mov    0x10(%ebp),%eax
+80101ec6:	25 ff 01 00 00       	and    $0x1ff,%eax
+80101ecb:	8d 50 10             	lea    0x10(%eax),%edx
+80101ece:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101ed1:	01 d0                	add    %edx,%eax
+80101ed3:	8d 50 08             	lea    0x8(%eax),%edx
+80101ed6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101ed9:	89 44 24 08          	mov    %eax,0x8(%esp)
+80101edd:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101ee1:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101ee4:	89 04 24             	mov    %eax,(%esp)
+80101ee7:	e8 35 34 00 00       	call   80105321 <memmove>
+    brelse(bp);
+80101eec:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101eef:	89 04 24             	mov    %eax,(%esp)
+80101ef2:	e8 20 e3 ff ff       	call   80100217 <brelse>
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101ef7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101efa:	01 45 f4             	add    %eax,-0xc(%ebp)
+80101efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101f00:	01 45 10             	add    %eax,0x10(%ebp)
+80101f03:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101f06:	01 45 0c             	add    %eax,0xc(%ebp)
+80101f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101f0c:	3b 45 14             	cmp    0x14(%ebp),%eax
+80101f0f:	0f 82 5e ff ff ff    	jb     80101e73 <readi+0xbf>
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(dst, bp->data + off%BSIZE, m);
+    brelse(bp);
+  }
+  return n;
+80101f15:	8b 45 14             	mov    0x14(%ebp),%eax
+}
+80101f18:	c9                   	leave  
+80101f19:	c3                   	ret    
+
+80101f1a <writei>:
+
+// PAGEBREAK!
+// Write data to inode.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+80101f1a:	55                   	push   %ebp
+80101f1b:	89 e5                	mov    %esp,%ebp
+80101f1d:	83 ec 28             	sub    $0x28,%esp
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101f20:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f23:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80101f27:	66 83 f8 03          	cmp    $0x3,%ax
+80101f2b:	75 60                	jne    80101f8d <writei+0x73>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+80101f2d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f30:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101f34:	66 85 c0             	test   %ax,%ax
+80101f37:	78 20                	js     80101f59 <writei+0x3f>
+80101f39:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f3c:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101f40:	66 83 f8 09          	cmp    $0x9,%ax
+80101f44:	7f 13                	jg     80101f59 <writei+0x3f>
+80101f46:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f49:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101f4d:	98                   	cwtl   
+80101f4e:	8b 04 c5 04 12 11 80 	mov    -0x7feeedfc(,%eax,8),%eax
+80101f55:	85 c0                	test   %eax,%eax
+80101f57:	75 0a                	jne    80101f63 <writei+0x49>
+      return -1;
+80101f59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101f5e:	e9 46 01 00 00       	jmp    801020a9 <writei+0x18f>
+    return devsw[ip->major].write(ip, src, n);
+80101f63:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f66:	0f b7 40 12          	movzwl 0x12(%eax),%eax
+80101f6a:	98                   	cwtl   
+80101f6b:	8b 04 c5 04 12 11 80 	mov    -0x7feeedfc(,%eax,8),%eax
+80101f72:	8b 55 14             	mov    0x14(%ebp),%edx
+80101f75:	89 54 24 08          	mov    %edx,0x8(%esp)
+80101f79:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101f7c:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101f80:	8b 55 08             	mov    0x8(%ebp),%edx
+80101f83:	89 14 24             	mov    %edx,(%esp)
+80101f86:	ff d0                	call   *%eax
+80101f88:	e9 1c 01 00 00       	jmp    801020a9 <writei+0x18f>
+  }
+
+  if(off > ip->size || off + n < off)
+80101f8d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f90:	8b 40 18             	mov    0x18(%eax),%eax
+80101f93:	3b 45 10             	cmp    0x10(%ebp),%eax
+80101f96:	72 0d                	jb     80101fa5 <writei+0x8b>
+80101f98:	8b 45 14             	mov    0x14(%ebp),%eax
+80101f9b:	8b 55 10             	mov    0x10(%ebp),%edx
+80101f9e:	01 d0                	add    %edx,%eax
+80101fa0:	3b 45 10             	cmp    0x10(%ebp),%eax
+80101fa3:	73 0a                	jae    80101faf <writei+0x95>
+    return -1;
+80101fa5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101faa:	e9 fa 00 00 00       	jmp    801020a9 <writei+0x18f>
+  if(off + n > MAXFILE*BSIZE)
+80101faf:	8b 45 14             	mov    0x14(%ebp),%eax
+80101fb2:	8b 55 10             	mov    0x10(%ebp),%edx
+80101fb5:	01 d0                	add    %edx,%eax
+80101fb7:	3d 00 18 01 00       	cmp    $0x11800,%eax
+80101fbc:	76 0a                	jbe    80101fc8 <writei+0xae>
+    return -1;
+80101fbe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101fc3:	e9 e1 00 00 00       	jmp    801020a9 <writei+0x18f>
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101fc8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80101fcf:	e9 a1 00 00 00       	jmp    80102075 <writei+0x15b>
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101fd4:	8b 45 10             	mov    0x10(%ebp),%eax
+80101fd7:	c1 e8 09             	shr    $0x9,%eax
+80101fda:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101fde:	8b 45 08             	mov    0x8(%ebp),%eax
+80101fe1:	89 04 24             	mov    %eax,(%esp)
+80101fe4:	e8 60 fb ff ff       	call   80101b49 <bmap>
+80101fe9:	8b 55 08             	mov    0x8(%ebp),%edx
+80101fec:	8b 12                	mov    (%edx),%edx
+80101fee:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101ff2:	89 14 24             	mov    %edx,(%esp)
+80101ff5:	e8 ac e1 ff ff       	call   801001a6 <bread>
+80101ffa:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101ffd:	8b 45 10             	mov    0x10(%ebp),%eax
+80102000:	89 c2                	mov    %eax,%edx
+80102002:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+80102008:	b8 00 02 00 00       	mov    $0x200,%eax
+8010200d:	89 c1                	mov    %eax,%ecx
+8010200f:	29 d1                	sub    %edx,%ecx
+80102011:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102014:	8b 55 14             	mov    0x14(%ebp),%edx
+80102017:	29 c2                	sub    %eax,%edx
+80102019:	89 c8                	mov    %ecx,%eax
+8010201b:	39 d0                	cmp    %edx,%eax
+8010201d:	76 02                	jbe    80102021 <writei+0x107>
+8010201f:	89 d0                	mov    %edx,%eax
+80102021:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(bp->data + off%BSIZE, src, m);
+80102024:	8b 45 10             	mov    0x10(%ebp),%eax
+80102027:	25 ff 01 00 00       	and    $0x1ff,%eax
+8010202c:	8d 50 10             	lea    0x10(%eax),%edx
+8010202f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80102032:	01 d0                	add    %edx,%eax
+80102034:	8d 50 08             	lea    0x8(%eax),%edx
+80102037:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010203a:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010203e:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102041:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102045:	89 14 24             	mov    %edx,(%esp)
+80102048:	e8 d4 32 00 00       	call   80105321 <memmove>
+    log_write(bp);
+8010204d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80102050:	89 04 24             	mov    %eax,(%esp)
+80102053:	e8 58 16 00 00       	call   801036b0 <log_write>
+    brelse(bp);
+80102058:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010205b:	89 04 24             	mov    %eax,(%esp)
+8010205e:	e8 b4 e1 ff ff       	call   80100217 <brelse>
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80102063:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80102066:	01 45 f4             	add    %eax,-0xc(%ebp)
+80102069:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010206c:	01 45 10             	add    %eax,0x10(%ebp)
+8010206f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80102072:	01 45 0c             	add    %eax,0xc(%ebp)
+80102075:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102078:	3b 45 14             	cmp    0x14(%ebp),%eax
+8010207b:	0f 82 53 ff ff ff    	jb     80101fd4 <writei+0xba>
+    memmove(bp->data + off%BSIZE, src, m);
+    log_write(bp);
+    brelse(bp);
+  }
+
+  if(n > 0 && off > ip->size){
+80102081:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+80102085:	74 1f                	je     801020a6 <writei+0x18c>
+80102087:	8b 45 08             	mov    0x8(%ebp),%eax
+8010208a:	8b 40 18             	mov    0x18(%eax),%eax
+8010208d:	3b 45 10             	cmp    0x10(%ebp),%eax
+80102090:	73 14                	jae    801020a6 <writei+0x18c>
+    ip->size = off;
+80102092:	8b 45 08             	mov    0x8(%ebp),%eax
+80102095:	8b 55 10             	mov    0x10(%ebp),%edx
+80102098:	89 50 18             	mov    %edx,0x18(%eax)
+    iupdate(ip);
+8010209b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010209e:	89 04 24             	mov    %eax,(%esp)
+801020a1:	e8 45 f6 ff ff       	call   801016eb <iupdate>
+  }
+  return n;
+801020a6:	8b 45 14             	mov    0x14(%ebp),%eax
+}
+801020a9:	c9                   	leave  
+801020aa:	c3                   	ret    
+
+801020ab <namecmp>:
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+801020ab:	55                   	push   %ebp
+801020ac:	89 e5                	mov    %esp,%ebp
+801020ae:	83 ec 18             	sub    $0x18,%esp
+  return strncmp(s, t, DIRSIZ);
+801020b1:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+801020b8:	00 
+801020b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+801020bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+801020c0:	8b 45 08             	mov    0x8(%ebp),%eax
+801020c3:	89 04 24             	mov    %eax,(%esp)
+801020c6:	e8 fa 32 00 00       	call   801053c5 <strncmp>
+}
+801020cb:	c9                   	leave  
+801020cc:	c3                   	ret    
+
+801020cd <dirlookup>:
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+801020cd:	55                   	push   %ebp
+801020ce:	89 e5                	mov    %esp,%ebp
+801020d0:	83 ec 38             	sub    $0x38,%esp
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+801020d3:	8b 45 08             	mov    0x8(%ebp),%eax
+801020d6:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+801020da:	66 83 f8 01          	cmp    $0x1,%ax
+801020de:	74 0c                	je     801020ec <dirlookup+0x1f>
+    panic("dirlookup not DIR");
+801020e0:	c7 04 24 5d 88 10 80 	movl   $0x8010885d,(%esp)
+801020e7:	e8 5a e4 ff ff       	call   80100546 <panic>
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+801020ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801020f3:	e9 87 00 00 00       	jmp    8010217f <dirlookup+0xb2>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+801020f8:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+801020ff:	00 
+80102100:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102103:	89 44 24 08          	mov    %eax,0x8(%esp)
+80102107:	8d 45 e0             	lea    -0x20(%ebp),%eax
+8010210a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010210e:	8b 45 08             	mov    0x8(%ebp),%eax
+80102111:	89 04 24             	mov    %eax,(%esp)
+80102114:	e8 9b fc ff ff       	call   80101db4 <readi>
+80102119:	83 f8 10             	cmp    $0x10,%eax
+8010211c:	74 0c                	je     8010212a <dirlookup+0x5d>
+      panic("dirlink read");
+8010211e:	c7 04 24 6f 88 10 80 	movl   $0x8010886f,(%esp)
+80102125:	e8 1c e4 ff ff       	call   80100546 <panic>
+    if(de.inum == 0)
+8010212a:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
+8010212e:	66 85 c0             	test   %ax,%ax
+80102131:	74 47                	je     8010217a <dirlookup+0xad>
+      continue;
+    if(namecmp(name, de.name) == 0){
+80102133:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80102136:	83 c0 02             	add    $0x2,%eax
+80102139:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010213d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102140:	89 04 24             	mov    %eax,(%esp)
+80102143:	e8 63 ff ff ff       	call   801020ab <namecmp>
+80102148:	85 c0                	test   %eax,%eax
+8010214a:	75 2f                	jne    8010217b <dirlookup+0xae>
+      // entry matches path element
+      if(poff)
+8010214c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80102150:	74 08                	je     8010215a <dirlookup+0x8d>
+        *poff = off;
+80102152:	8b 45 10             	mov    0x10(%ebp),%eax
+80102155:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80102158:	89 10                	mov    %edx,(%eax)
+      inum = de.inum;
+8010215a:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
+8010215e:	0f b7 c0             	movzwl %ax,%eax
+80102161:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      return iget(dp->dev, inum);
+80102164:	8b 45 08             	mov    0x8(%ebp),%eax
+80102167:	8b 00                	mov    (%eax),%eax
+80102169:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010216c:	89 54 24 04          	mov    %edx,0x4(%esp)
+80102170:	89 04 24             	mov    %eax,(%esp)
+80102173:	e8 2b f6 ff ff       	call   801017a3 <iget>
+80102178:	eb 19                	jmp    80102193 <dirlookup+0xc6>
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink read");
+    if(de.inum == 0)
+      continue;
+8010217a:	90                   	nop
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+8010217b:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
+8010217f:	8b 45 08             	mov    0x8(%ebp),%eax
+80102182:	8b 40 18             	mov    0x18(%eax),%eax
+80102185:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80102188:	0f 87 6a ff ff ff    	ja     801020f8 <dirlookup+0x2b>
+      inum = de.inum;
+      return iget(dp->dev, inum);
+    }
+  }
+
+  return 0;
+8010218e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80102193:	c9                   	leave  
+80102194:	c3                   	ret    
+
+80102195 <dirlink>:
+
+// Write a new directory entry (name, inum) into the directory dp.
+int
+dirlink(struct inode *dp, char *name, uint inum)
+{
+80102195:	55                   	push   %ebp
+80102196:	89 e5                	mov    %esp,%ebp
+80102198:	83 ec 38             	sub    $0x38,%esp
+  int off;
+  struct dirent de;
+  struct inode *ip;
+
+  // Check that name is not present.
+  if((ip = dirlookup(dp, name, 0)) != 0){
+8010219b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801021a2:	00 
+801021a3:	8b 45 0c             	mov    0xc(%ebp),%eax
+801021a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+801021aa:	8b 45 08             	mov    0x8(%ebp),%eax
+801021ad:	89 04 24             	mov    %eax,(%esp)
+801021b0:	e8 18 ff ff ff       	call   801020cd <dirlookup>
+801021b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801021b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801021bc:	74 15                	je     801021d3 <dirlink+0x3e>
+    iput(ip);
+801021be:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801021c1:	89 04 24             	mov    %eax,(%esp)
+801021c4:	e8 91 f8 ff ff       	call   80101a5a <iput>
+    return -1;
+801021c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801021ce:	e9 b8 00 00 00       	jmp    8010228b <dirlink+0xf6>
+  }
+
+  // Look for an empty dirent.
+  for(off = 0; off < dp->size; off += sizeof(de)){
+801021d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801021da:	eb 44                	jmp    80102220 <dirlink+0x8b>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+801021dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801021df:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+801021e6:	00 
+801021e7:	89 44 24 08          	mov    %eax,0x8(%esp)
+801021eb:	8d 45 e0             	lea    -0x20(%ebp),%eax
+801021ee:	89 44 24 04          	mov    %eax,0x4(%esp)
+801021f2:	8b 45 08             	mov    0x8(%ebp),%eax
+801021f5:	89 04 24             	mov    %eax,(%esp)
+801021f8:	e8 b7 fb ff ff       	call   80101db4 <readi>
+801021fd:	83 f8 10             	cmp    $0x10,%eax
+80102200:	74 0c                	je     8010220e <dirlink+0x79>
+      panic("dirlink read");
+80102202:	c7 04 24 6f 88 10 80 	movl   $0x8010886f,(%esp)
+80102209:	e8 38 e3 ff ff       	call   80100546 <panic>
+    if(de.inum == 0)
+8010220e:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
+80102212:	66 85 c0             	test   %ax,%ax
+80102215:	74 18                	je     8010222f <dirlink+0x9a>
+    iput(ip);
+    return -1;
+  }
+
+  // Look for an empty dirent.
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80102217:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010221a:	83 c0 10             	add    $0x10,%eax
+8010221d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80102220:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80102223:	8b 45 08             	mov    0x8(%ebp),%eax
+80102226:	8b 40 18             	mov    0x18(%eax),%eax
+80102229:	39 c2                	cmp    %eax,%edx
+8010222b:	72 af                	jb     801021dc <dirlink+0x47>
+8010222d:	eb 01                	jmp    80102230 <dirlink+0x9b>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink read");
+    if(de.inum == 0)
+      break;
+8010222f:	90                   	nop
+  }
+
+  strncpy(de.name, name, DIRSIZ);
+80102230:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+80102237:	00 
+80102238:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010223b:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010223f:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80102242:	83 c0 02             	add    $0x2,%eax
+80102245:	89 04 24             	mov    %eax,(%esp)
+80102248:	e8 d0 31 00 00       	call   8010541d <strncpy>
+  de.inum = inum;
+8010224d:	8b 45 10             	mov    0x10(%ebp),%eax
+80102250:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80102254:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102257:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+8010225e:	00 
+8010225f:	89 44 24 08          	mov    %eax,0x8(%esp)
+80102263:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80102266:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010226a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010226d:	89 04 24             	mov    %eax,(%esp)
+80102270:	e8 a5 fc ff ff       	call   80101f1a <writei>
+80102275:	83 f8 10             	cmp    $0x10,%eax
+80102278:	74 0c                	je     80102286 <dirlink+0xf1>
+    panic("dirlink");
+8010227a:	c7 04 24 7c 88 10 80 	movl   $0x8010887c,(%esp)
+80102281:	e8 c0 e2 ff ff       	call   80100546 <panic>
+  
+  return 0;
+80102286:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010228b:	c9                   	leave  
+8010228c:	c3                   	ret    
+
+8010228d <skipelem>:
+//   skipelem("a", name) = "", setting name = "a"
+//   skipelem("", name) = skipelem("////", name) = 0
+//
+static char*
+skipelem(char *path, char *name)
+{
+8010228d:	55                   	push   %ebp
+8010228e:	89 e5                	mov    %esp,%ebp
+80102290:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int len;
+
+  while(*path == '/')
+80102293:	eb 04                	jmp    80102299 <skipelem+0xc>
+    path++;
+80102295:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+skipelem(char *path, char *name)
+{
+  char *s;
+  int len;
+
+  while(*path == '/')
+80102299:	8b 45 08             	mov    0x8(%ebp),%eax
+8010229c:	0f b6 00             	movzbl (%eax),%eax
+8010229f:	3c 2f                	cmp    $0x2f,%al
+801022a1:	74 f2                	je     80102295 <skipelem+0x8>
+    path++;
+  if(*path == 0)
+801022a3:	8b 45 08             	mov    0x8(%ebp),%eax
+801022a6:	0f b6 00             	movzbl (%eax),%eax
+801022a9:	84 c0                	test   %al,%al
+801022ab:	75 0a                	jne    801022b7 <skipelem+0x2a>
+    return 0;
+801022ad:	b8 00 00 00 00       	mov    $0x0,%eax
+801022b2:	e9 88 00 00 00       	jmp    8010233f <skipelem+0xb2>
+  s = path;
+801022b7:	8b 45 08             	mov    0x8(%ebp),%eax
+801022ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(*path != '/' && *path != 0)
+801022bd:	eb 04                	jmp    801022c3 <skipelem+0x36>
+    path++;
+801022bf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  while(*path == '/')
+    path++;
+  if(*path == 0)
+    return 0;
+  s = path;
+  while(*path != '/' && *path != 0)
+801022c3:	8b 45 08             	mov    0x8(%ebp),%eax
+801022c6:	0f b6 00             	movzbl (%eax),%eax
+801022c9:	3c 2f                	cmp    $0x2f,%al
+801022cb:	74 0a                	je     801022d7 <skipelem+0x4a>
+801022cd:	8b 45 08             	mov    0x8(%ebp),%eax
+801022d0:	0f b6 00             	movzbl (%eax),%eax
+801022d3:	84 c0                	test   %al,%al
+801022d5:	75 e8                	jne    801022bf <skipelem+0x32>
+    path++;
+  len = path - s;
+801022d7:	8b 55 08             	mov    0x8(%ebp),%edx
+801022da:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801022dd:	89 d1                	mov    %edx,%ecx
+801022df:	29 c1                	sub    %eax,%ecx
+801022e1:	89 c8                	mov    %ecx,%eax
+801022e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(len >= DIRSIZ)
+801022e6:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+801022ea:	7e 1c                	jle    80102308 <skipelem+0x7b>
+    memmove(name, s, DIRSIZ);
+801022ec:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+801022f3:	00 
+801022f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801022f7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801022fb:	8b 45 0c             	mov    0xc(%ebp),%eax
+801022fe:	89 04 24             	mov    %eax,(%esp)
+80102301:	e8 1b 30 00 00       	call   80105321 <memmove>
+  else {
+    memmove(name, s, len);
+    name[len] = 0;
+  }
+  while(*path == '/')
+80102306:	eb 2a                	jmp    80102332 <skipelem+0xa5>
+    path++;
+  len = path - s;
+  if(len >= DIRSIZ)
+    memmove(name, s, DIRSIZ);
+  else {
+    memmove(name, s, len);
+80102308:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010230b:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010230f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102312:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102316:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102319:	89 04 24             	mov    %eax,(%esp)
+8010231c:	e8 00 30 00 00       	call   80105321 <memmove>
+    name[len] = 0;
+80102321:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80102324:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102327:	01 d0                	add    %edx,%eax
+80102329:	c6 00 00             	movb   $0x0,(%eax)
+  }
+  while(*path == '/')
+8010232c:	eb 04                	jmp    80102332 <skipelem+0xa5>
+    path++;
+8010232e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    memmove(name, s, DIRSIZ);
+  else {
+    memmove(name, s, len);
+    name[len] = 0;
+  }
+  while(*path == '/')
+80102332:	8b 45 08             	mov    0x8(%ebp),%eax
+80102335:	0f b6 00             	movzbl (%eax),%eax
+80102338:	3c 2f                	cmp    $0x2f,%al
+8010233a:	74 f2                	je     8010232e <skipelem+0xa1>
+    path++;
+  return path;
+8010233c:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+8010233f:	c9                   	leave  
+80102340:	c3                   	ret    
+
+80102341 <namex>:
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+80102341:	55                   	push   %ebp
+80102342:	89 e5                	mov    %esp,%ebp
+80102344:	83 ec 28             	sub    $0x28,%esp
+  struct inode *ip, *next;
+
+  if(*path == '/')
+80102347:	8b 45 08             	mov    0x8(%ebp),%eax
+8010234a:	0f b6 00             	movzbl (%eax),%eax
+8010234d:	3c 2f                	cmp    $0x2f,%al
+8010234f:	75 1c                	jne    8010236d <namex+0x2c>
+    ip = iget(ROOTDEV, ROOTINO);
+80102351:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80102358:	00 
+80102359:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80102360:	e8 3e f4 ff ff       	call   801017a3 <iget>
+80102365:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  else
+    ip = idup(proc->cwd);
+
+  while((path = skipelem(path, name)) != 0){
+80102368:	e9 af 00 00 00       	jmp    8010241c <namex+0xdb>
+  struct inode *ip, *next;
+
+  if(*path == '/')
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(proc->cwd);
+8010236d:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80102373:	8b 40 68             	mov    0x68(%eax),%eax
+80102376:	89 04 24             	mov    %eax,(%esp)
+80102379:	e8 f7 f4 ff ff       	call   80101875 <idup>
+8010237e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  while((path = skipelem(path, name)) != 0){
+80102381:	e9 96 00 00 00       	jmp    8010241c <namex+0xdb>
+    ilock(ip);
+80102386:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102389:	89 04 24             	mov    %eax,(%esp)
+8010238c:	e8 16 f5 ff ff       	call   801018a7 <ilock>
+    if(ip->type != T_DIR){
+80102391:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102394:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80102398:	66 83 f8 01          	cmp    $0x1,%ax
+8010239c:	74 15                	je     801023b3 <namex+0x72>
+      iunlockput(ip);
+8010239e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023a1:	89 04 24             	mov    %eax,(%esp)
+801023a4:	e8 82 f7 ff ff       	call   80101b2b <iunlockput>
+      return 0;
+801023a9:	b8 00 00 00 00       	mov    $0x0,%eax
+801023ae:	e9 a3 00 00 00       	jmp    80102456 <namex+0x115>
+    }
+    if(nameiparent && *path == '\0'){
+801023b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+801023b7:	74 1d                	je     801023d6 <namex+0x95>
+801023b9:	8b 45 08             	mov    0x8(%ebp),%eax
+801023bc:	0f b6 00             	movzbl (%eax),%eax
+801023bf:	84 c0                	test   %al,%al
+801023c1:	75 13                	jne    801023d6 <namex+0x95>
+      // Stop one level early.
+      iunlock(ip);
+801023c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023c6:	89 04 24             	mov    %eax,(%esp)
+801023c9:	e8 27 f6 ff ff       	call   801019f5 <iunlock>
+      return ip;
+801023ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023d1:	e9 80 00 00 00       	jmp    80102456 <namex+0x115>
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+801023d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801023dd:	00 
+801023de:	8b 45 10             	mov    0x10(%ebp),%eax
+801023e1:	89 44 24 04          	mov    %eax,0x4(%esp)
+801023e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023e8:	89 04 24             	mov    %eax,(%esp)
+801023eb:	e8 dd fc ff ff       	call   801020cd <dirlookup>
+801023f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801023f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801023f7:	75 12                	jne    8010240b <namex+0xca>
+      iunlockput(ip);
+801023f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023fc:	89 04 24             	mov    %eax,(%esp)
+801023ff:	e8 27 f7 ff ff       	call   80101b2b <iunlockput>
+      return 0;
+80102404:	b8 00 00 00 00       	mov    $0x0,%eax
+80102409:	eb 4b                	jmp    80102456 <namex+0x115>
+    }
+    iunlockput(ip);
+8010240b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010240e:	89 04 24             	mov    %eax,(%esp)
+80102411:	e8 15 f7 ff ff       	call   80101b2b <iunlockput>
+    ip = next;
+80102416:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80102419:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(*path == '/')
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(proc->cwd);
+
+  while((path = skipelem(path, name)) != 0){
+8010241c:	8b 45 10             	mov    0x10(%ebp),%eax
+8010241f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102423:	8b 45 08             	mov    0x8(%ebp),%eax
+80102426:	89 04 24             	mov    %eax,(%esp)
+80102429:	e8 5f fe ff ff       	call   8010228d <skipelem>
+8010242e:	89 45 08             	mov    %eax,0x8(%ebp)
+80102431:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80102435:	0f 85 4b ff ff ff    	jne    80102386 <namex+0x45>
+      return 0;
+    }
+    iunlockput(ip);
+    ip = next;
+  }
+  if(nameiparent){
+8010243b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+8010243f:	74 12                	je     80102453 <namex+0x112>
+    iput(ip);
+80102441:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102444:	89 04 24             	mov    %eax,(%esp)
+80102447:	e8 0e f6 ff ff       	call   80101a5a <iput>
+    return 0;
+8010244c:	b8 00 00 00 00       	mov    $0x0,%eax
+80102451:	eb 03                	jmp    80102456 <namex+0x115>
+  }
+  return ip;
+80102453:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80102456:	c9                   	leave  
+80102457:	c3                   	ret    
+
+80102458 <namei>:
+
+struct inode*
+namei(char *path)
+{
+80102458:	55                   	push   %ebp
+80102459:	89 e5                	mov    %esp,%ebp
+8010245b:	83 ec 28             	sub    $0x28,%esp
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+8010245e:	8d 45 ea             	lea    -0x16(%ebp),%eax
+80102461:	89 44 24 08          	mov    %eax,0x8(%esp)
+80102465:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+8010246c:	00 
+8010246d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102470:	89 04 24             	mov    %eax,(%esp)
+80102473:	e8 c9 fe ff ff       	call   80102341 <namex>
+}
+80102478:	c9                   	leave  
+80102479:	c3                   	ret    
+
+8010247a <nameiparent>:
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+8010247a:	55                   	push   %ebp
+8010247b:	89 e5                	mov    %esp,%ebp
+8010247d:	83 ec 18             	sub    $0x18,%esp
+  return namex(path, 1, name);
+80102480:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102483:	89 44 24 08          	mov    %eax,0x8(%esp)
+80102487:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+8010248e:	00 
+8010248f:	8b 45 08             	mov    0x8(%ebp),%eax
+80102492:	89 04 24             	mov    %eax,(%esp)
+80102495:	e8 a7 fe ff ff       	call   80102341 <namex>
+}
+8010249a:	c9                   	leave  
+8010249b:	c3                   	ret    
+
+8010249c <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+8010249c:	55                   	push   %ebp
+8010249d:	89 e5                	mov    %esp,%ebp
+8010249f:	53                   	push   %ebx
+801024a0:	83 ec 14             	sub    $0x14,%esp
+801024a3:	8b 45 08             	mov    0x8(%ebp),%eax
+801024a6:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801024aa:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+801024ae:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+801024b2:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+801024b6:	ec                   	in     (%dx),%al
+801024b7:	89 c3                	mov    %eax,%ebx
+801024b9:	88 5d fb             	mov    %bl,-0x5(%ebp)
+  return data;
+801024bc:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+}
+801024c0:	83 c4 14             	add    $0x14,%esp
+801024c3:	5b                   	pop    %ebx
+801024c4:	5d                   	pop    %ebp
+801024c5:	c3                   	ret    
+
+801024c6 <insl>:
+
+static inline void
+insl(int port, void *addr, int cnt)
+{
+801024c6:	55                   	push   %ebp
+801024c7:	89 e5                	mov    %esp,%ebp
+801024c9:	57                   	push   %edi
+801024ca:	53                   	push   %ebx
+  asm volatile("cld; rep insl" :
+801024cb:	8b 55 08             	mov    0x8(%ebp),%edx
+801024ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+801024d1:	8b 45 10             	mov    0x10(%ebp),%eax
+801024d4:	89 cb                	mov    %ecx,%ebx
+801024d6:	89 df                	mov    %ebx,%edi
+801024d8:	89 c1                	mov    %eax,%ecx
+801024da:	fc                   	cld    
+801024db:	f3 6d                	rep insl (%dx),%es:(%edi)
+801024dd:	89 c8                	mov    %ecx,%eax
+801024df:	89 fb                	mov    %edi,%ebx
+801024e1:	89 5d 0c             	mov    %ebx,0xc(%ebp)
+801024e4:	89 45 10             	mov    %eax,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "d" (port), "0" (addr), "1" (cnt) :
+               "memory", "cc");
+}
+801024e7:	5b                   	pop    %ebx
+801024e8:	5f                   	pop    %edi
+801024e9:	5d                   	pop    %ebp
+801024ea:	c3                   	ret    
+
+801024eb <outb>:
+
+static inline void
+outb(ushort port, uchar data)
+{
+801024eb:	55                   	push   %ebp
+801024ec:	89 e5                	mov    %esp,%ebp
+801024ee:	83 ec 08             	sub    $0x8,%esp
+801024f1:	8b 55 08             	mov    0x8(%ebp),%edx
+801024f4:	8b 45 0c             	mov    0xc(%ebp),%eax
+801024f7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+801024fb:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801024fe:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80102502:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80102506:	ee                   	out    %al,(%dx)
+}
+80102507:	c9                   	leave  
+80102508:	c3                   	ret    
+
+80102509 <outsl>:
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+}
+
+static inline void
+outsl(int port, const void *addr, int cnt)
+{
+80102509:	55                   	push   %ebp
+8010250a:	89 e5                	mov    %esp,%ebp
+8010250c:	56                   	push   %esi
+8010250d:	53                   	push   %ebx
+  asm volatile("cld; rep outsl" :
+8010250e:	8b 55 08             	mov    0x8(%ebp),%edx
+80102511:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80102514:	8b 45 10             	mov    0x10(%ebp),%eax
+80102517:	89 cb                	mov    %ecx,%ebx
+80102519:	89 de                	mov    %ebx,%esi
+8010251b:	89 c1                	mov    %eax,%ecx
+8010251d:	fc                   	cld    
+8010251e:	f3 6f                	rep outsl %ds:(%esi),(%dx)
+80102520:	89 c8                	mov    %ecx,%eax
+80102522:	89 f3                	mov    %esi,%ebx
+80102524:	89 5d 0c             	mov    %ebx,0xc(%ebp)
+80102527:	89 45 10             	mov    %eax,0x10(%ebp)
+               "=S" (addr), "=c" (cnt) :
+               "d" (port), "0" (addr), "1" (cnt) :
+               "cc");
+}
+8010252a:	5b                   	pop    %ebx
+8010252b:	5e                   	pop    %esi
+8010252c:	5d                   	pop    %ebp
+8010252d:	c3                   	ret    
+
+8010252e <idewait>:
+static void idestart(struct buf*);
+
+// Wait for IDE disk to become ready.
+static int
+idewait(int checkerr)
+{
+8010252e:	55                   	push   %ebp
+8010252f:	89 e5                	mov    %esp,%ebp
+80102531:	83 ec 14             	sub    $0x14,%esp
+  int r;
+
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY) 
+80102534:	90                   	nop
+80102535:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
+8010253c:	e8 5b ff ff ff       	call   8010249c <inb>
+80102541:	0f b6 c0             	movzbl %al,%eax
+80102544:	89 45 fc             	mov    %eax,-0x4(%ebp)
+80102547:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010254a:	25 c0 00 00 00       	and    $0xc0,%eax
+8010254f:	83 f8 40             	cmp    $0x40,%eax
+80102552:	75 e1                	jne    80102535 <idewait+0x7>
+    ;
+  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+80102554:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80102558:	74 11                	je     8010256b <idewait+0x3d>
+8010255a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010255d:	83 e0 21             	and    $0x21,%eax
+80102560:	85 c0                	test   %eax,%eax
+80102562:	74 07                	je     8010256b <idewait+0x3d>
+    return -1;
+80102564:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80102569:	eb 05                	jmp    80102570 <idewait+0x42>
+  return 0;
+8010256b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80102570:	c9                   	leave  
+80102571:	c3                   	ret    
+
+80102572 <ideinit>:
+
+void
+ideinit(void)
+{
+80102572:	55                   	push   %ebp
+80102573:	89 e5                	mov    %esp,%ebp
+80102575:	83 ec 28             	sub    $0x28,%esp
+  int i;
+
+  initlock(&idelock, "ide");
+80102578:	c7 44 24 04 84 88 10 	movl   $0x80108884,0x4(%esp)
+8010257f:	80 
+80102580:	c7 04 24 20 b6 10 80 	movl   $0x8010b620,(%esp)
+80102587:	e8 46 2a 00 00       	call   80104fd2 <initlock>
+  picenable(IRQ_IDE);
+8010258c:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
+80102593:	e8 b9 18 00 00       	call   80103e51 <picenable>
+  ioapicenable(IRQ_IDE, ncpu - 1);
+80102598:	a1 60 29 11 80       	mov    0x80112960,%eax
+8010259d:	83 e8 01             	sub    $0x1,%eax
+801025a0:	89 44 24 04          	mov    %eax,0x4(%esp)
+801025a4:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
+801025ab:	e8 12 04 00 00       	call   801029c2 <ioapicenable>
+  idewait(0);
+801025b0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801025b7:	e8 72 ff ff ff       	call   8010252e <idewait>
+  
+  // Check if disk 1 is present
+  outb(0x1f6, 0xe0 | (1<<4));
+801025bc:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
+801025c3:	00 
+801025c4:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
+801025cb:	e8 1b ff ff ff       	call   801024eb <outb>
+  for(i=0; i<1000; i++){
+801025d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801025d7:	eb 20                	jmp    801025f9 <ideinit+0x87>
+    if(inb(0x1f7) != 0){
+801025d9:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
+801025e0:	e8 b7 fe ff ff       	call   8010249c <inb>
+801025e5:	84 c0                	test   %al,%al
+801025e7:	74 0c                	je     801025f5 <ideinit+0x83>
+      havedisk1 = 1;
+801025e9:	c7 05 58 b6 10 80 01 	movl   $0x1,0x8010b658
+801025f0:	00 00 00 
+      break;
+801025f3:	eb 0d                	jmp    80102602 <ideinit+0x90>
+  ioapicenable(IRQ_IDE, ncpu - 1);
+  idewait(0);
+  
+  // Check if disk 1 is present
+  outb(0x1f6, 0xe0 | (1<<4));
+  for(i=0; i<1000; i++){
+801025f5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801025f9:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+80102600:	7e d7                	jle    801025d9 <ideinit+0x67>
+      break;
+    }
+  }
+  
+  // Switch back to disk 0.
+  outb(0x1f6, 0xe0 | (0<<4));
+80102602:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
+80102609:	00 
+8010260a:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
+80102611:	e8 d5 fe ff ff       	call   801024eb <outb>
+}
+80102616:	c9                   	leave  
+80102617:	c3                   	ret    
+
+80102618 <idestart>:
+
+// Start the request for b.  Caller must hold idelock.
+static void
+idestart(struct buf *b)
+{
+80102618:	55                   	push   %ebp
+80102619:	89 e5                	mov    %esp,%ebp
+8010261b:	83 ec 18             	sub    $0x18,%esp
+  if(b == 0)
+8010261e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80102622:	75 0c                	jne    80102630 <idestart+0x18>
+    panic("idestart");
+80102624:	c7 04 24 88 88 10 80 	movl   $0x80108888,(%esp)
+8010262b:	e8 16 df ff ff       	call   80100546 <panic>
+
+  idewait(0);
+80102630:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80102637:	e8 f2 fe ff ff       	call   8010252e <idewait>
+  outb(0x3f6, 0);  // generate interrupt
+8010263c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102643:	00 
+80102644:	c7 04 24 f6 03 00 00 	movl   $0x3f6,(%esp)
+8010264b:	e8 9b fe ff ff       	call   801024eb <outb>
+  outb(0x1f2, 1);  // number of sectors
+80102650:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80102657:	00 
+80102658:	c7 04 24 f2 01 00 00 	movl   $0x1f2,(%esp)
+8010265f:	e8 87 fe ff ff       	call   801024eb <outb>
+  outb(0x1f3, b->sector & 0xff);
+80102664:	8b 45 08             	mov    0x8(%ebp),%eax
+80102667:	8b 40 08             	mov    0x8(%eax),%eax
+8010266a:	0f b6 c0             	movzbl %al,%eax
+8010266d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102671:	c7 04 24 f3 01 00 00 	movl   $0x1f3,(%esp)
+80102678:	e8 6e fe ff ff       	call   801024eb <outb>
+  outb(0x1f4, (b->sector >> 8) & 0xff);
+8010267d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102680:	8b 40 08             	mov    0x8(%eax),%eax
+80102683:	c1 e8 08             	shr    $0x8,%eax
+80102686:	0f b6 c0             	movzbl %al,%eax
+80102689:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010268d:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
+80102694:	e8 52 fe ff ff       	call   801024eb <outb>
+  outb(0x1f5, (b->sector >> 16) & 0xff);
+80102699:	8b 45 08             	mov    0x8(%ebp),%eax
+8010269c:	8b 40 08             	mov    0x8(%eax),%eax
+8010269f:	c1 e8 10             	shr    $0x10,%eax
+801026a2:	0f b6 c0             	movzbl %al,%eax
+801026a5:	89 44 24 04          	mov    %eax,0x4(%esp)
+801026a9:	c7 04 24 f5 01 00 00 	movl   $0x1f5,(%esp)
+801026b0:	e8 36 fe ff ff       	call   801024eb <outb>
+  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
+801026b5:	8b 45 08             	mov    0x8(%ebp),%eax
+801026b8:	8b 40 04             	mov    0x4(%eax),%eax
+801026bb:	83 e0 01             	and    $0x1,%eax
+801026be:	89 c2                	mov    %eax,%edx
+801026c0:	c1 e2 04             	shl    $0x4,%edx
+801026c3:	8b 45 08             	mov    0x8(%ebp),%eax
+801026c6:	8b 40 08             	mov    0x8(%eax),%eax
+801026c9:	c1 e8 18             	shr    $0x18,%eax
+801026cc:	83 e0 0f             	and    $0xf,%eax
+801026cf:	09 d0                	or     %edx,%eax
+801026d1:	83 c8 e0             	or     $0xffffffe0,%eax
+801026d4:	0f b6 c0             	movzbl %al,%eax
+801026d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801026db:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
+801026e2:	e8 04 fe ff ff       	call   801024eb <outb>
+  if(b->flags & B_DIRTY){
+801026e7:	8b 45 08             	mov    0x8(%ebp),%eax
+801026ea:	8b 00                	mov    (%eax),%eax
+801026ec:	83 e0 04             	and    $0x4,%eax
+801026ef:	85 c0                	test   %eax,%eax
+801026f1:	74 34                	je     80102727 <idestart+0x10f>
+    outb(0x1f7, IDE_CMD_WRITE);
+801026f3:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
+801026fa:	00 
+801026fb:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
+80102702:	e8 e4 fd ff ff       	call   801024eb <outb>
+    outsl(0x1f0, b->data, 512/4);
+80102707:	8b 45 08             	mov    0x8(%ebp),%eax
+8010270a:	83 c0 18             	add    $0x18,%eax
+8010270d:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
+80102714:	00 
+80102715:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102719:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
+80102720:	e8 e4 fd ff ff       	call   80102509 <outsl>
+80102725:	eb 14                	jmp    8010273b <idestart+0x123>
+  } else {
+    outb(0x1f7, IDE_CMD_READ);
+80102727:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
+8010272e:	00 
+8010272f:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
+80102736:	e8 b0 fd ff ff       	call   801024eb <outb>
+  }
+}
+8010273b:	c9                   	leave  
+8010273c:	c3                   	ret    
+
+8010273d <ideintr>:
+
+// Interrupt handler.
+void
+ideintr(void)
+{
+8010273d:	55                   	push   %ebp
+8010273e:	89 e5                	mov    %esp,%ebp
+80102740:	83 ec 28             	sub    $0x28,%esp
+  struct buf *b;
+
+  // First queued buffer is the active request.
+  acquire(&idelock);
+80102743:	c7 04 24 20 b6 10 80 	movl   $0x8010b620,(%esp)
+8010274a:	e8 a4 28 00 00       	call   80104ff3 <acquire>
+  if((b = idequeue) == 0){
+8010274f:	a1 54 b6 10 80       	mov    0x8010b654,%eax
+80102754:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80102757:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010275b:	75 11                	jne    8010276e <ideintr+0x31>
+    release(&idelock);
+8010275d:	c7 04 24 20 b6 10 80 	movl   $0x8010b620,(%esp)
+80102764:	e8 ec 28 00 00       	call   80105055 <release>
+    // cprintf("spurious IDE interrupt\n");
+    return;
+80102769:	e9 90 00 00 00       	jmp    801027fe <ideintr+0xc1>
+  }
+  idequeue = b->qnext;
+8010276e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102771:	8b 40 14             	mov    0x14(%eax),%eax
+80102774:	a3 54 b6 10 80       	mov    %eax,0x8010b654
+
+  // Read data if needed.
+  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+80102779:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010277c:	8b 00                	mov    (%eax),%eax
+8010277e:	83 e0 04             	and    $0x4,%eax
+80102781:	85 c0                	test   %eax,%eax
+80102783:	75 2e                	jne    801027b3 <ideintr+0x76>
+80102785:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+8010278c:	e8 9d fd ff ff       	call   8010252e <idewait>
+80102791:	85 c0                	test   %eax,%eax
+80102793:	78 1e                	js     801027b3 <ideintr+0x76>
+    insl(0x1f0, b->data, 512/4);
+80102795:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102798:	83 c0 18             	add    $0x18,%eax
+8010279b:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
+801027a2:	00 
+801027a3:	89 44 24 04          	mov    %eax,0x4(%esp)
+801027a7:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
+801027ae:	e8 13 fd ff ff       	call   801024c6 <insl>
+  
+  // Wake process waiting for this buf.
+  b->flags |= B_VALID;
+801027b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801027b6:	8b 00                	mov    (%eax),%eax
+801027b8:	89 c2                	mov    %eax,%edx
+801027ba:	83 ca 02             	or     $0x2,%edx
+801027bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801027c0:	89 10                	mov    %edx,(%eax)
+  b->flags &= ~B_DIRTY;
+801027c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801027c5:	8b 00                	mov    (%eax),%eax
+801027c7:	89 c2                	mov    %eax,%edx
+801027c9:	83 e2 fb             	and    $0xfffffffb,%edx
+801027cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801027cf:	89 10                	mov    %edx,(%eax)
+  wakeup(b);
+801027d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801027d4:	89 04 24             	mov    %eax,(%esp)
+801027d7:	e8 12 26 00 00       	call   80104dee <wakeup>
+  
+  // Start disk on next buf in queue.
+  if(idequeue != 0)
+801027dc:	a1 54 b6 10 80       	mov    0x8010b654,%eax
+801027e1:	85 c0                	test   %eax,%eax
+801027e3:	74 0d                	je     801027f2 <ideintr+0xb5>
+    idestart(idequeue);
+801027e5:	a1 54 b6 10 80       	mov    0x8010b654,%eax
+801027ea:	89 04 24             	mov    %eax,(%esp)
+801027ed:	e8 26 fe ff ff       	call   80102618 <idestart>
+
+  release(&idelock);
+801027f2:	c7 04 24 20 b6 10 80 	movl   $0x8010b620,(%esp)
+801027f9:	e8 57 28 00 00       	call   80105055 <release>
+}
+801027fe:	c9                   	leave  
+801027ff:	c3                   	ret    
+
+80102800 <iderw>:
+// Sync buf with disk. 
+// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+// Else if B_VALID is not set, read buf from disk, set B_VALID.
+void
+iderw(struct buf *b)
+{
+80102800:	55                   	push   %ebp
+80102801:	89 e5                	mov    %esp,%ebp
+80102803:	83 ec 28             	sub    $0x28,%esp
+  struct buf **pp;
+
+  if(!(b->flags & B_BUSY))
+80102806:	8b 45 08             	mov    0x8(%ebp),%eax
+80102809:	8b 00                	mov    (%eax),%eax
+8010280b:	83 e0 01             	and    $0x1,%eax
+8010280e:	85 c0                	test   %eax,%eax
+80102810:	75 0c                	jne    8010281e <iderw+0x1e>
+    panic("iderw: buf not busy");
+80102812:	c7 04 24 91 88 10 80 	movl   $0x80108891,(%esp)
+80102819:	e8 28 dd ff ff       	call   80100546 <panic>
+  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+8010281e:	8b 45 08             	mov    0x8(%ebp),%eax
+80102821:	8b 00                	mov    (%eax),%eax
+80102823:	83 e0 06             	and    $0x6,%eax
+80102826:	83 f8 02             	cmp    $0x2,%eax
+80102829:	75 0c                	jne    80102837 <iderw+0x37>
+    panic("iderw: nothing to do");
+8010282b:	c7 04 24 a5 88 10 80 	movl   $0x801088a5,(%esp)
+80102832:	e8 0f dd ff ff       	call   80100546 <panic>
+  if(b->dev != 0 && !havedisk1)
+80102837:	8b 45 08             	mov    0x8(%ebp),%eax
+8010283a:	8b 40 04             	mov    0x4(%eax),%eax
+8010283d:	85 c0                	test   %eax,%eax
+8010283f:	74 15                	je     80102856 <iderw+0x56>
+80102841:	a1 58 b6 10 80       	mov    0x8010b658,%eax
+80102846:	85 c0                	test   %eax,%eax
+80102848:	75 0c                	jne    80102856 <iderw+0x56>
+    panic("iderw: ide disk 1 not present");
+8010284a:	c7 04 24 ba 88 10 80 	movl   $0x801088ba,(%esp)
+80102851:	e8 f0 dc ff ff       	call   80100546 <panic>
+
+  acquire(&idelock);  //DOC:acquire-lock
+80102856:	c7 04 24 20 b6 10 80 	movl   $0x8010b620,(%esp)
+8010285d:	e8 91 27 00 00       	call   80104ff3 <acquire>
+
+  // Append b to idequeue.
+  b->qnext = 0;
+80102862:	8b 45 08             	mov    0x8(%ebp),%eax
+80102865:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+8010286c:	c7 45 f4 54 b6 10 80 	movl   $0x8010b654,-0xc(%ebp)
+80102873:	eb 0b                	jmp    80102880 <iderw+0x80>
+80102875:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102878:	8b 00                	mov    (%eax),%eax
+8010287a:	83 c0 14             	add    $0x14,%eax
+8010287d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80102880:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102883:	8b 00                	mov    (%eax),%eax
+80102885:	85 c0                	test   %eax,%eax
+80102887:	75 ec                	jne    80102875 <iderw+0x75>
+    ;
+  *pp = b;
+80102889:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010288c:	8b 55 08             	mov    0x8(%ebp),%edx
+8010288f:	89 10                	mov    %edx,(%eax)
+  
+  // Start disk if necessary.
+  if(idequeue == b)
+80102891:	a1 54 b6 10 80       	mov    0x8010b654,%eax
+80102896:	3b 45 08             	cmp    0x8(%ebp),%eax
+80102899:	75 22                	jne    801028bd <iderw+0xbd>
+    idestart(b);
+8010289b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010289e:	89 04 24             	mov    %eax,(%esp)
+801028a1:	e8 72 fd ff ff       	call   80102618 <idestart>
+  
+  // Wait for request to finish.
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+801028a6:	eb 15                	jmp    801028bd <iderw+0xbd>
+    sleep(b, &idelock);
+801028a8:	c7 44 24 04 20 b6 10 	movl   $0x8010b620,0x4(%esp)
+801028af:	80 
+801028b0:	8b 45 08             	mov    0x8(%ebp),%eax
+801028b3:	89 04 24             	mov    %eax,(%esp)
+801028b6:	e8 5a 24 00 00       	call   80104d15 <sleep>
+801028bb:	eb 01                	jmp    801028be <iderw+0xbe>
+  // Start disk if necessary.
+  if(idequeue == b)
+    idestart(b);
+  
+  // Wait for request to finish.
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+801028bd:	90                   	nop
+801028be:	8b 45 08             	mov    0x8(%ebp),%eax
+801028c1:	8b 00                	mov    (%eax),%eax
+801028c3:	83 e0 06             	and    $0x6,%eax
+801028c6:	83 f8 02             	cmp    $0x2,%eax
+801028c9:	75 dd                	jne    801028a8 <iderw+0xa8>
+    sleep(b, &idelock);
+  }
+
+  release(&idelock);
+801028cb:	c7 04 24 20 b6 10 80 	movl   $0x8010b620,(%esp)
+801028d2:	e8 7e 27 00 00       	call   80105055 <release>
+}
+801028d7:	c9                   	leave  
+801028d8:	c3                   	ret    
+801028d9:	00 00                	add    %al,(%eax)
+	...
+
+801028dc <ioapicread>:
+  uint data;
+};
+
+static uint
+ioapicread(int reg)
+{
+801028dc:	55                   	push   %ebp
+801028dd:	89 e5                	mov    %esp,%ebp
+  ioapic->reg = reg;
+801028df:	a1 34 22 11 80       	mov    0x80112234,%eax
+801028e4:	8b 55 08             	mov    0x8(%ebp),%edx
+801028e7:	89 10                	mov    %edx,(%eax)
+  return ioapic->data;
+801028e9:	a1 34 22 11 80       	mov    0x80112234,%eax
+801028ee:	8b 40 10             	mov    0x10(%eax),%eax
+}
+801028f1:	5d                   	pop    %ebp
+801028f2:	c3                   	ret    
+
+801028f3 <ioapicwrite>:
+
+static void
+ioapicwrite(int reg, uint data)
+{
+801028f3:	55                   	push   %ebp
+801028f4:	89 e5                	mov    %esp,%ebp
+  ioapic->reg = reg;
+801028f6:	a1 34 22 11 80       	mov    0x80112234,%eax
+801028fb:	8b 55 08             	mov    0x8(%ebp),%edx
+801028fe:	89 10                	mov    %edx,(%eax)
+  ioapic->data = data;
+80102900:	a1 34 22 11 80       	mov    0x80112234,%eax
+80102905:	8b 55 0c             	mov    0xc(%ebp),%edx
+80102908:	89 50 10             	mov    %edx,0x10(%eax)
+}
+8010290b:	5d                   	pop    %ebp
+8010290c:	c3                   	ret    
+
+8010290d <ioapicinit>:
+
+void
+ioapicinit(void)
+{
+8010290d:	55                   	push   %ebp
+8010290e:	89 e5                	mov    %esp,%ebp
+80102910:	83 ec 28             	sub    $0x28,%esp
+  int i, id, maxintr;
+
+  if(!ismp)
+80102913:	a1 64 23 11 80       	mov    0x80112364,%eax
+80102918:	85 c0                	test   %eax,%eax
+8010291a:	0f 84 9f 00 00 00    	je     801029bf <ioapicinit+0xb2>
+    return;
+
+  ioapic = (volatile struct ioapic*)IOAPIC;
+80102920:	c7 05 34 22 11 80 00 	movl   $0xfec00000,0x80112234
+80102927:	00 c0 fe 
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+8010292a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80102931:	e8 a6 ff ff ff       	call   801028dc <ioapicread>
+80102936:	c1 e8 10             	shr    $0x10,%eax
+80102939:	25 ff 00 00 00       	and    $0xff,%eax
+8010293e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  id = ioapicread(REG_ID) >> 24;
+80102941:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80102948:	e8 8f ff ff ff       	call   801028dc <ioapicread>
+8010294d:	c1 e8 18             	shr    $0x18,%eax
+80102950:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(id != ioapicid)
+80102953:	0f b6 05 60 23 11 80 	movzbl 0x80112360,%eax
+8010295a:	0f b6 c0             	movzbl %al,%eax
+8010295d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80102960:	74 0c                	je     8010296e <ioapicinit+0x61>
+    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+80102962:	c7 04 24 d8 88 10 80 	movl   $0x801088d8,(%esp)
+80102969:	e8 3c da ff ff       	call   801003aa <cprintf>
+
+  // Mark all interrupts edge-triggered, active high, disabled,
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+8010296e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80102975:	eb 3e                	jmp    801029b5 <ioapicinit+0xa8>
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+80102977:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010297a:	83 c0 20             	add    $0x20,%eax
+8010297d:	0d 00 00 01 00       	or     $0x10000,%eax
+80102982:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80102985:	83 c2 08             	add    $0x8,%edx
+80102988:	01 d2                	add    %edx,%edx
+8010298a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010298e:	89 14 24             	mov    %edx,(%esp)
+80102991:	e8 5d ff ff ff       	call   801028f3 <ioapicwrite>
+    ioapicwrite(REG_TABLE+2*i+1, 0);
+80102996:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102999:	83 c0 08             	add    $0x8,%eax
+8010299c:	01 c0                	add    %eax,%eax
+8010299e:	83 c0 01             	add    $0x1,%eax
+801029a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801029a8:	00 
+801029a9:	89 04 24             	mov    %eax,(%esp)
+801029ac:	e8 42 ff ff ff       	call   801028f3 <ioapicwrite>
+  if(id != ioapicid)
+    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+
+  // Mark all interrupts edge-triggered, active high, disabled,
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+801029b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801029b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029b8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+801029bb:	7e ba                	jle    80102977 <ioapicinit+0x6a>
+801029bd:	eb 01                	jmp    801029c0 <ioapicinit+0xb3>
+ioapicinit(void)
+{
+  int i, id, maxintr;
+
+  if(!ismp)
+    return;
+801029bf:	90                   	nop
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+    ioapicwrite(REG_TABLE+2*i+1, 0);
+  }
+}
+801029c0:	c9                   	leave  
+801029c1:	c3                   	ret    
+
+801029c2 <ioapicenable>:
+
+void
+ioapicenable(int irq, int cpunum)
+{
+801029c2:	55                   	push   %ebp
+801029c3:	89 e5                	mov    %esp,%ebp
+801029c5:	83 ec 08             	sub    $0x8,%esp
+  if(!ismp)
+801029c8:	a1 64 23 11 80       	mov    0x80112364,%eax
+801029cd:	85 c0                	test   %eax,%eax
+801029cf:	74 39                	je     80102a0a <ioapicenable+0x48>
+    return;
+
+  // Mark interrupt edge-triggered, active high,
+  // enabled, and routed to the given cpunum,
+  // which happens to be that cpu's APIC ID.
+  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+801029d1:	8b 45 08             	mov    0x8(%ebp),%eax
+801029d4:	83 c0 20             	add    $0x20,%eax
+801029d7:	8b 55 08             	mov    0x8(%ebp),%edx
+801029da:	83 c2 08             	add    $0x8,%edx
+801029dd:	01 d2                	add    %edx,%edx
+801029df:	89 44 24 04          	mov    %eax,0x4(%esp)
+801029e3:	89 14 24             	mov    %edx,(%esp)
+801029e6:	e8 08 ff ff ff       	call   801028f3 <ioapicwrite>
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+801029eb:	8b 45 0c             	mov    0xc(%ebp),%eax
+801029ee:	c1 e0 18             	shl    $0x18,%eax
+801029f1:	8b 55 08             	mov    0x8(%ebp),%edx
+801029f4:	83 c2 08             	add    $0x8,%edx
+801029f7:	01 d2                	add    %edx,%edx
+801029f9:	83 c2 01             	add    $0x1,%edx
+801029fc:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102a00:	89 14 24             	mov    %edx,(%esp)
+80102a03:	e8 eb fe ff ff       	call   801028f3 <ioapicwrite>
+80102a08:	eb 01                	jmp    80102a0b <ioapicenable+0x49>
+
+void
+ioapicenable(int irq, int cpunum)
+{
+  if(!ismp)
+    return;
+80102a0a:	90                   	nop
+  // Mark interrupt edge-triggered, active high,
+  // enabled, and routed to the given cpunum,
+  // which happens to be that cpu's APIC ID.
+  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+}
+80102a0b:	c9                   	leave  
+80102a0c:	c3                   	ret    
+80102a0d:	00 00                	add    %al,(%eax)
+	...
+
+80102a10 <v2p>:
+#define KERNBASE 0x80000000         // First kernel virtual address
+#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+
+#ifndef __ASSEMBLER__
+
+static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
+80102a10:	55                   	push   %ebp
+80102a11:	89 e5                	mov    %esp,%ebp
+80102a13:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a16:	05 00 00 00 80       	add    $0x80000000,%eax
+80102a1b:	5d                   	pop    %ebp
+80102a1c:	c3                   	ret    
+
+80102a1d <kinit1>:
+// the pages mapped by entrypgdir on free list.
+// 2. main() calls kinit2() with the rest of the physical pages
+// after installing a full page table that maps them on all cores.
+void
+kinit1(void *vstart, void *vend)
+{
+80102a1d:	55                   	push   %ebp
+80102a1e:	89 e5                	mov    %esp,%ebp
+80102a20:	83 ec 18             	sub    $0x18,%esp
+  initlock(&kmem.lock, "kmem");
+80102a23:	c7 44 24 04 0a 89 10 	movl   $0x8010890a,0x4(%esp)
+80102a2a:	80 
+80102a2b:	c7 04 24 40 22 11 80 	movl   $0x80112240,(%esp)
+80102a32:	e8 9b 25 00 00       	call   80104fd2 <initlock>
+  kmem.use_lock = 0;
+80102a37:	c7 05 74 22 11 80 00 	movl   $0x0,0x80112274
+80102a3e:	00 00 00 
+  freerange(vstart, vend);
+80102a41:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102a44:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102a48:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a4b:	89 04 24             	mov    %eax,(%esp)
+80102a4e:	e8 26 00 00 00       	call   80102a79 <freerange>
+}
+80102a53:	c9                   	leave  
+80102a54:	c3                   	ret    
+
+80102a55 <kinit2>:
+
+void
+kinit2(void *vstart, void *vend)
+{
+80102a55:	55                   	push   %ebp
+80102a56:	89 e5                	mov    %esp,%ebp
+80102a58:	83 ec 18             	sub    $0x18,%esp
+  freerange(vstart, vend);
+80102a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102a5e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102a62:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a65:	89 04 24             	mov    %eax,(%esp)
+80102a68:	e8 0c 00 00 00       	call   80102a79 <freerange>
+  kmem.use_lock = 1;
+80102a6d:	c7 05 74 22 11 80 01 	movl   $0x1,0x80112274
+80102a74:	00 00 00 
+}
+80102a77:	c9                   	leave  
+80102a78:	c3                   	ret    
+
+80102a79 <freerange>:
+
+void
+freerange(void *vstart, void *vend)
+{
+80102a79:	55                   	push   %ebp
+80102a7a:	89 e5                	mov    %esp,%ebp
+80102a7c:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  p = (char*)PGROUNDUP((uint)vstart);
+80102a7f:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a82:	05 ff 0f 00 00       	add    $0xfff,%eax
+80102a87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80102a8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102a8f:	eb 12                	jmp    80102aa3 <freerange+0x2a>
+    kfree(p);
+80102a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102a94:	89 04 24             	mov    %eax,(%esp)
+80102a97:	e8 16 00 00 00       	call   80102ab2 <kfree>
+void
+freerange(void *vstart, void *vend)
+{
+  char *p;
+  p = (char*)PGROUNDUP((uint)vstart);
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102a9c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80102aa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102aa6:	05 00 10 00 00       	add    $0x1000,%eax
+80102aab:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80102aae:	76 e1                	jbe    80102a91 <freerange+0x18>
+    kfree(p);
+}
+80102ab0:	c9                   	leave  
+80102ab1:	c3                   	ret    
+
+80102ab2 <kfree>:
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(char *v)
+{
+80102ab2:	55                   	push   %ebp
+80102ab3:	89 e5                	mov    %esp,%ebp
+80102ab5:	83 ec 28             	sub    $0x28,%esp
+  struct run *r;
+
+  if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
+80102ab8:	8b 45 08             	mov    0x8(%ebp),%eax
+80102abb:	25 ff 0f 00 00       	and    $0xfff,%eax
+80102ac0:	85 c0                	test   %eax,%eax
+80102ac2:	75 1b                	jne    80102adf <kfree+0x2d>
+80102ac4:	81 7d 08 7c 52 11 80 	cmpl   $0x8011527c,0x8(%ebp)
+80102acb:	72 12                	jb     80102adf <kfree+0x2d>
+80102acd:	8b 45 08             	mov    0x8(%ebp),%eax
+80102ad0:	89 04 24             	mov    %eax,(%esp)
+80102ad3:	e8 38 ff ff ff       	call   80102a10 <v2p>
+80102ad8:	3d ff ff ff 0d       	cmp    $0xdffffff,%eax
+80102add:	76 0c                	jbe    80102aeb <kfree+0x39>
+    panic("kfree");
+80102adf:	c7 04 24 0f 89 10 80 	movl   $0x8010890f,(%esp)
+80102ae6:	e8 5b da ff ff       	call   80100546 <panic>
+
+  // Fill with junk to catch dangling refs.
+  memset(v, 1, PGSIZE);
+80102aeb:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80102af2:	00 
+80102af3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80102afa:	00 
+80102afb:	8b 45 08             	mov    0x8(%ebp),%eax
+80102afe:	89 04 24             	mov    %eax,(%esp)
+80102b01:	e8 48 27 00 00       	call   8010524e <memset>
+
+  if(kmem.use_lock)
+80102b06:	a1 74 22 11 80       	mov    0x80112274,%eax
+80102b0b:	85 c0                	test   %eax,%eax
+80102b0d:	74 0c                	je     80102b1b <kfree+0x69>
+    acquire(&kmem.lock);
+80102b0f:	c7 04 24 40 22 11 80 	movl   $0x80112240,(%esp)
+80102b16:	e8 d8 24 00 00       	call   80104ff3 <acquire>
+  r = (struct run*)v;
+80102b1b:	8b 45 08             	mov    0x8(%ebp),%eax
+80102b1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  r->next = kmem.freelist;
+80102b21:	8b 15 78 22 11 80    	mov    0x80112278,%edx
+80102b27:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102b2a:	89 10                	mov    %edx,(%eax)
+  kmem.freelist = r;
+80102b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102b2f:	a3 78 22 11 80       	mov    %eax,0x80112278
+  if(kmem.use_lock)
+80102b34:	a1 74 22 11 80       	mov    0x80112274,%eax
+80102b39:	85 c0                	test   %eax,%eax
+80102b3b:	74 0c                	je     80102b49 <kfree+0x97>
+    release(&kmem.lock);
+80102b3d:	c7 04 24 40 22 11 80 	movl   $0x80112240,(%esp)
+80102b44:	e8 0c 25 00 00       	call   80105055 <release>
+}
+80102b49:	c9                   	leave  
+80102b4a:	c3                   	ret    
+
+80102b4b <kalloc>:
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+char*
+kalloc(void)
+{
+80102b4b:	55                   	push   %ebp
+80102b4c:	89 e5                	mov    %esp,%ebp
+80102b4e:	83 ec 28             	sub    $0x28,%esp
+  struct run *r;
+
+  if(kmem.use_lock)
+80102b51:	a1 74 22 11 80       	mov    0x80112274,%eax
+80102b56:	85 c0                	test   %eax,%eax
+80102b58:	74 0c                	je     80102b66 <kalloc+0x1b>
+    acquire(&kmem.lock);
+80102b5a:	c7 04 24 40 22 11 80 	movl   $0x80112240,(%esp)
+80102b61:	e8 8d 24 00 00       	call   80104ff3 <acquire>
+  r = kmem.freelist;
+80102b66:	a1 78 22 11 80       	mov    0x80112278,%eax
+80102b6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(r)
+80102b6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80102b72:	74 0a                	je     80102b7e <kalloc+0x33>
+    kmem.freelist = r->next;
+80102b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102b77:	8b 00                	mov    (%eax),%eax
+80102b79:	a3 78 22 11 80       	mov    %eax,0x80112278
+  if(kmem.use_lock)
+80102b7e:	a1 74 22 11 80       	mov    0x80112274,%eax
+80102b83:	85 c0                	test   %eax,%eax
+80102b85:	74 0c                	je     80102b93 <kalloc+0x48>
+    release(&kmem.lock);
+80102b87:	c7 04 24 40 22 11 80 	movl   $0x80112240,(%esp)
+80102b8e:	e8 c2 24 00 00       	call   80105055 <release>
+  return (char*)r;
+80102b93:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80102b96:	c9                   	leave  
+80102b97:	c3                   	ret    
+
+80102b98 <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+80102b98:	55                   	push   %ebp
+80102b99:	89 e5                	mov    %esp,%ebp
+80102b9b:	53                   	push   %ebx
+80102b9c:	83 ec 14             	sub    $0x14,%esp
+80102b9f:	8b 45 08             	mov    0x8(%ebp),%eax
+80102ba2:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102ba6:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+80102baa:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+80102bae:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+80102bb2:	ec                   	in     (%dx),%al
+80102bb3:	89 c3                	mov    %eax,%ebx
+80102bb5:	88 5d fb             	mov    %bl,-0x5(%ebp)
+  return data;
+80102bb8:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+}
+80102bbc:	83 c4 14             	add    $0x14,%esp
+80102bbf:	5b                   	pop    %ebx
+80102bc0:	5d                   	pop    %ebp
+80102bc1:	c3                   	ret    
+
+80102bc2 <kbdgetc>:
+#include "defs.h"
+#include "kbd.h"
+
+int
+kbdgetc(void)
+{
+80102bc2:	55                   	push   %ebp
+80102bc3:	89 e5                	mov    %esp,%ebp
+80102bc5:	83 ec 14             	sub    $0x14,%esp
+  static uchar *charcode[4] = {
+    normalmap, shiftmap, ctlmap, ctlmap
+  };
+  uint st, data, c;
+
+  st = inb(KBSTATP);
+80102bc8:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
+80102bcf:	e8 c4 ff ff ff       	call   80102b98 <inb>
+80102bd4:	0f b6 c0             	movzbl %al,%eax
+80102bd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if((st & KBS_DIB) == 0)
+80102bda:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102bdd:	83 e0 01             	and    $0x1,%eax
+80102be0:	85 c0                	test   %eax,%eax
+80102be2:	75 0a                	jne    80102bee <kbdgetc+0x2c>
+    return -1;
+80102be4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80102be9:	e9 25 01 00 00       	jmp    80102d13 <kbdgetc+0x151>
+  data = inb(KBDATAP);
+80102bee:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
+80102bf5:	e8 9e ff ff ff       	call   80102b98 <inb>
+80102bfa:	0f b6 c0             	movzbl %al,%eax
+80102bfd:	89 45 fc             	mov    %eax,-0x4(%ebp)
+
+  if(data == 0xE0){
+80102c00:	81 7d fc e0 00 00 00 	cmpl   $0xe0,-0x4(%ebp)
+80102c07:	75 17                	jne    80102c20 <kbdgetc+0x5e>
+    shift |= E0ESC;
+80102c09:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102c0e:	83 c8 40             	or     $0x40,%eax
+80102c11:	a3 5c b6 10 80       	mov    %eax,0x8010b65c
+    return 0;
+80102c16:	b8 00 00 00 00       	mov    $0x0,%eax
+80102c1b:	e9 f3 00 00 00       	jmp    80102d13 <kbdgetc+0x151>
+  } else if(data & 0x80){
+80102c20:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102c23:	25 80 00 00 00       	and    $0x80,%eax
+80102c28:	85 c0                	test   %eax,%eax
+80102c2a:	74 45                	je     80102c71 <kbdgetc+0xaf>
+    // Key released
+    data = (shift & E0ESC ? data : data & 0x7F);
+80102c2c:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102c31:	83 e0 40             	and    $0x40,%eax
+80102c34:	85 c0                	test   %eax,%eax
+80102c36:	75 08                	jne    80102c40 <kbdgetc+0x7e>
+80102c38:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102c3b:	83 e0 7f             	and    $0x7f,%eax
+80102c3e:	eb 03                	jmp    80102c43 <kbdgetc+0x81>
+80102c40:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102c43:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    shift &= ~(shiftcode[data] | E0ESC);
+80102c46:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102c49:	05 20 90 10 80       	add    $0x80109020,%eax
+80102c4e:	0f b6 00             	movzbl (%eax),%eax
+80102c51:	83 c8 40             	or     $0x40,%eax
+80102c54:	0f b6 c0             	movzbl %al,%eax
+80102c57:	f7 d0                	not    %eax
+80102c59:	89 c2                	mov    %eax,%edx
+80102c5b:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102c60:	21 d0                	and    %edx,%eax
+80102c62:	a3 5c b6 10 80       	mov    %eax,0x8010b65c
+    return 0;
+80102c67:	b8 00 00 00 00       	mov    $0x0,%eax
+80102c6c:	e9 a2 00 00 00       	jmp    80102d13 <kbdgetc+0x151>
+  } else if(shift & E0ESC){
+80102c71:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102c76:	83 e0 40             	and    $0x40,%eax
+80102c79:	85 c0                	test   %eax,%eax
+80102c7b:	74 14                	je     80102c91 <kbdgetc+0xcf>
+    // Last character was an E0 escape; or with 0x80
+    data |= 0x80;
+80102c7d:	81 4d fc 80 00 00 00 	orl    $0x80,-0x4(%ebp)
+    shift &= ~E0ESC;
+80102c84:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102c89:	83 e0 bf             	and    $0xffffffbf,%eax
+80102c8c:	a3 5c b6 10 80       	mov    %eax,0x8010b65c
+  }
+
+  shift |= shiftcode[data];
+80102c91:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102c94:	05 20 90 10 80       	add    $0x80109020,%eax
+80102c99:	0f b6 00             	movzbl (%eax),%eax
+80102c9c:	0f b6 d0             	movzbl %al,%edx
+80102c9f:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102ca4:	09 d0                	or     %edx,%eax
+80102ca6:	a3 5c b6 10 80       	mov    %eax,0x8010b65c
+  shift ^= togglecode[data];
+80102cab:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102cae:	05 20 91 10 80       	add    $0x80109120,%eax
+80102cb3:	0f b6 00             	movzbl (%eax),%eax
+80102cb6:	0f b6 d0             	movzbl %al,%edx
+80102cb9:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102cbe:	31 d0                	xor    %edx,%eax
+80102cc0:	a3 5c b6 10 80       	mov    %eax,0x8010b65c
+  c = charcode[shift & (CTL | SHIFT)][data];
+80102cc5:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102cca:	83 e0 03             	and    $0x3,%eax
+80102ccd:	8b 14 85 20 95 10 80 	mov    -0x7fef6ae0(,%eax,4),%edx
+80102cd4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102cd7:	01 d0                	add    %edx,%eax
+80102cd9:	0f b6 00             	movzbl (%eax),%eax
+80102cdc:	0f b6 c0             	movzbl %al,%eax
+80102cdf:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  if(shift & CAPSLOCK){
+80102ce2:	a1 5c b6 10 80       	mov    0x8010b65c,%eax
+80102ce7:	83 e0 08             	and    $0x8,%eax
+80102cea:	85 c0                	test   %eax,%eax
+80102cec:	74 22                	je     80102d10 <kbdgetc+0x14e>
+    if('a' <= c && c <= 'z')
+80102cee:	83 7d f8 60          	cmpl   $0x60,-0x8(%ebp)
+80102cf2:	76 0c                	jbe    80102d00 <kbdgetc+0x13e>
+80102cf4:	83 7d f8 7a          	cmpl   $0x7a,-0x8(%ebp)
+80102cf8:	77 06                	ja     80102d00 <kbdgetc+0x13e>
+      c += 'A' - 'a';
+80102cfa:	83 6d f8 20          	subl   $0x20,-0x8(%ebp)
+80102cfe:	eb 10                	jmp    80102d10 <kbdgetc+0x14e>
+    else if('A' <= c && c <= 'Z')
+80102d00:	83 7d f8 40          	cmpl   $0x40,-0x8(%ebp)
+80102d04:	76 0a                	jbe    80102d10 <kbdgetc+0x14e>
+80102d06:	83 7d f8 5a          	cmpl   $0x5a,-0x8(%ebp)
+80102d0a:	77 04                	ja     80102d10 <kbdgetc+0x14e>
+      c += 'a' - 'A';
+80102d0c:	83 45 f8 20          	addl   $0x20,-0x8(%ebp)
+  }
+  return c;
+80102d10:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80102d13:	c9                   	leave  
+80102d14:	c3                   	ret    
+
+80102d15 <kbdintr>:
+
+void
+kbdintr(void)
+{
+80102d15:	55                   	push   %ebp
+80102d16:	89 e5                	mov    %esp,%ebp
+80102d18:	83 ec 18             	sub    $0x18,%esp
+  consoleintr(kbdgetc);
+80102d1b:	c7 04 24 c2 2b 10 80 	movl   $0x80102bc2,(%esp)
+80102d22:	e8 8f da ff ff       	call   801007b6 <consoleintr>
+}
+80102d27:	c9                   	leave  
+80102d28:	c3                   	ret    
+80102d29:	00 00                	add    %al,(%eax)
+	...
+
+80102d2c <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+80102d2c:	55                   	push   %ebp
+80102d2d:	89 e5                	mov    %esp,%ebp
+80102d2f:	53                   	push   %ebx
+80102d30:	83 ec 14             	sub    $0x14,%esp
+80102d33:	8b 45 08             	mov    0x8(%ebp),%eax
+80102d36:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102d3a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+80102d3e:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+80102d42:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+80102d46:	ec                   	in     (%dx),%al
+80102d47:	89 c3                	mov    %eax,%ebx
+80102d49:	88 5d fb             	mov    %bl,-0x5(%ebp)
+  return data;
+80102d4c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+}
+80102d50:	83 c4 14             	add    $0x14,%esp
+80102d53:	5b                   	pop    %ebx
+80102d54:	5d                   	pop    %ebp
+80102d55:	c3                   	ret    
+
+80102d56 <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+80102d56:	55                   	push   %ebp
+80102d57:	89 e5                	mov    %esp,%ebp
+80102d59:	83 ec 08             	sub    $0x8,%esp
+80102d5c:	8b 55 08             	mov    0x8(%ebp),%edx
+80102d5f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102d62:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+80102d66:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102d69:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80102d6d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80102d71:	ee                   	out    %al,(%dx)
+}
+80102d72:	c9                   	leave  
+80102d73:	c3                   	ret    
+
+80102d74 <readeflags>:
+  asm volatile("ltr %0" : : "r" (sel));
+}
+
+static inline uint
+readeflags(void)
+{
+80102d74:	55                   	push   %ebp
+80102d75:	89 e5                	mov    %esp,%ebp
+80102d77:	53                   	push   %ebx
+80102d78:	83 ec 10             	sub    $0x10,%esp
+  uint eflags;
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80102d7b:	9c                   	pushf  
+80102d7c:	5b                   	pop    %ebx
+80102d7d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+  return eflags;
+80102d80:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80102d83:	83 c4 10             	add    $0x10,%esp
+80102d86:	5b                   	pop    %ebx
+80102d87:	5d                   	pop    %ebp
+80102d88:	c3                   	ret    
+
+80102d89 <lapicw>:
+
+volatile uint *lapic;  // Initialized in mp.c
+
+static void
+lapicw(int index, int value)
+{
+80102d89:	55                   	push   %ebp
+80102d8a:	89 e5                	mov    %esp,%ebp
+  lapic[index] = value;
+80102d8c:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102d91:	8b 55 08             	mov    0x8(%ebp),%edx
+80102d94:	c1 e2 02             	shl    $0x2,%edx
+80102d97:	01 c2                	add    %eax,%edx
+80102d99:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102d9c:	89 02                	mov    %eax,(%edx)
+  lapic[ID];  // wait for write to finish, by reading
+80102d9e:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102da3:	83 c0 20             	add    $0x20,%eax
+80102da6:	8b 00                	mov    (%eax),%eax
+}
+80102da8:	5d                   	pop    %ebp
+80102da9:	c3                   	ret    
+
+80102daa <lapicinit>:
+//PAGEBREAK!
+
+void
+lapicinit(void)
+{
+80102daa:	55                   	push   %ebp
+80102dab:	89 e5                	mov    %esp,%ebp
+80102dad:	83 ec 08             	sub    $0x8,%esp
+  if(!lapic) 
+80102db0:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102db5:	85 c0                	test   %eax,%eax
+80102db7:	0f 84 47 01 00 00    	je     80102f04 <lapicinit+0x15a>
+    return;
+
+  // Enable local APIC; set spurious interrupt vector.
+  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+80102dbd:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
+80102dc4:	00 
+80102dc5:	c7 04 24 3c 00 00 00 	movl   $0x3c,(%esp)
+80102dcc:	e8 b8 ff ff ff       	call   80102d89 <lapicw>
+
+  // The timer repeatedly counts down at bus frequency
+  // from lapic[TICR] and then issues an interrupt.  
+  // If xv6 cared more about precise timekeeping,
+  // TICR would be calibrated using an external time source.
+  lapicw(TDCR, X1);
+80102dd1:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
+80102dd8:	00 
+80102dd9:	c7 04 24 f8 00 00 00 	movl   $0xf8,(%esp)
+80102de0:	e8 a4 ff ff ff       	call   80102d89 <lapicw>
+  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+80102de5:	c7 44 24 04 20 00 02 	movl   $0x20020,0x4(%esp)
+80102dec:	00 
+80102ded:	c7 04 24 c8 00 00 00 	movl   $0xc8,(%esp)
+80102df4:	e8 90 ff ff ff       	call   80102d89 <lapicw>
+  lapicw(TICR, 10000000); 
+80102df9:	c7 44 24 04 80 96 98 	movl   $0x989680,0x4(%esp)
+80102e00:	00 
+80102e01:	c7 04 24 e0 00 00 00 	movl   $0xe0,(%esp)
+80102e08:	e8 7c ff ff ff       	call   80102d89 <lapicw>
+
+  // Disable logical interrupt lines.
+  lapicw(LINT0, MASKED);
+80102e0d:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
+80102e14:	00 
+80102e15:	c7 04 24 d4 00 00 00 	movl   $0xd4,(%esp)
+80102e1c:	e8 68 ff ff ff       	call   80102d89 <lapicw>
+  lapicw(LINT1, MASKED);
+80102e21:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
+80102e28:	00 
+80102e29:	c7 04 24 d8 00 00 00 	movl   $0xd8,(%esp)
+80102e30:	e8 54 ff ff ff       	call   80102d89 <lapicw>
+
+  // Disable performance counter overflow interrupts
+  // on machines that provide that interrupt entry.
+  if(((lapic[VER]>>16) & 0xFF) >= 4)
+80102e35:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102e3a:	83 c0 30             	add    $0x30,%eax
+80102e3d:	8b 00                	mov    (%eax),%eax
+80102e3f:	c1 e8 10             	shr    $0x10,%eax
+80102e42:	25 ff 00 00 00       	and    $0xff,%eax
+80102e47:	83 f8 03             	cmp    $0x3,%eax
+80102e4a:	76 14                	jbe    80102e60 <lapicinit+0xb6>
+    lapicw(PCINT, MASKED);
+80102e4c:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
+80102e53:	00 
+80102e54:	c7 04 24 d0 00 00 00 	movl   $0xd0,(%esp)
+80102e5b:	e8 29 ff ff ff       	call   80102d89 <lapicw>
+
+  // Map error interrupt to IRQ_ERROR.
+  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
+80102e60:	c7 44 24 04 33 00 00 	movl   $0x33,0x4(%esp)
+80102e67:	00 
+80102e68:	c7 04 24 dc 00 00 00 	movl   $0xdc,(%esp)
+80102e6f:	e8 15 ff ff ff       	call   80102d89 <lapicw>
+
+  // Clear error status register (requires back-to-back writes).
+  lapicw(ESR, 0);
+80102e74:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102e7b:	00 
+80102e7c:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
+80102e83:	e8 01 ff ff ff       	call   80102d89 <lapicw>
+  lapicw(ESR, 0);
+80102e88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102e8f:	00 
+80102e90:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
+80102e97:	e8 ed fe ff ff       	call   80102d89 <lapicw>
+
+  // Ack any outstanding interrupts.
+  lapicw(EOI, 0);
+80102e9c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102ea3:	00 
+80102ea4:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
+80102eab:	e8 d9 fe ff ff       	call   80102d89 <lapicw>
+
+  // Send an Init Level De-Assert to synchronise arbitration ID's.
+  lapicw(ICRHI, 0);
+80102eb0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102eb7:	00 
+80102eb8:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
+80102ebf:	e8 c5 fe ff ff       	call   80102d89 <lapicw>
+  lapicw(ICRLO, BCAST | INIT | LEVEL);
+80102ec4:	c7 44 24 04 00 85 08 	movl   $0x88500,0x4(%esp)
+80102ecb:	00 
+80102ecc:	c7 04 24 c0 00 00 00 	movl   $0xc0,(%esp)
+80102ed3:	e8 b1 fe ff ff       	call   80102d89 <lapicw>
+  while(lapic[ICRLO] & DELIVS)
+80102ed8:	90                   	nop
+80102ed9:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102ede:	05 00 03 00 00       	add    $0x300,%eax
+80102ee3:	8b 00                	mov    (%eax),%eax
+80102ee5:	25 00 10 00 00       	and    $0x1000,%eax
+80102eea:	85 c0                	test   %eax,%eax
+80102eec:	75 eb                	jne    80102ed9 <lapicinit+0x12f>
+    ;
+
+  // Enable interrupts on the APIC (but not on the processor).
+  lapicw(TPR, 0);
+80102eee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102ef5:	00 
+80102ef6:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+80102efd:	e8 87 fe ff ff       	call   80102d89 <lapicw>
+80102f02:	eb 01                	jmp    80102f05 <lapicinit+0x15b>
+
+void
+lapicinit(void)
+{
+  if(!lapic) 
+    return;
+80102f04:	90                   	nop
+  while(lapic[ICRLO] & DELIVS)
+    ;
+
+  // Enable interrupts on the APIC (but not on the processor).
+  lapicw(TPR, 0);
+}
+80102f05:	c9                   	leave  
+80102f06:	c3                   	ret    
+
+80102f07 <cpunum>:
+
+int
+cpunum(void)
+{
+80102f07:	55                   	push   %ebp
+80102f08:	89 e5                	mov    %esp,%ebp
+80102f0a:	83 ec 18             	sub    $0x18,%esp
+  // Cannot call cpu when interrupts are enabled:
+  // result not guaranteed to last long enough to be used!
+  // Would prefer to panic but even printing is chancy here:
+  // almost everything, including cprintf and panic, calls cpu,
+  // often indirectly through acquire and release.
+  if(readeflags()&FL_IF){
+80102f0d:	e8 62 fe ff ff       	call   80102d74 <readeflags>
+80102f12:	25 00 02 00 00       	and    $0x200,%eax
+80102f17:	85 c0                	test   %eax,%eax
+80102f19:	74 29                	je     80102f44 <cpunum+0x3d>
+    static int n;
+    if(n++ == 0)
+80102f1b:	a1 60 b6 10 80       	mov    0x8010b660,%eax
+80102f20:	85 c0                	test   %eax,%eax
+80102f22:	0f 94 c2             	sete   %dl
+80102f25:	83 c0 01             	add    $0x1,%eax
+80102f28:	a3 60 b6 10 80       	mov    %eax,0x8010b660
+80102f2d:	84 d2                	test   %dl,%dl
+80102f2f:	74 13                	je     80102f44 <cpunum+0x3d>
+      cprintf("cpu called from %x with interrupts enabled\n",
+80102f31:	8b 45 04             	mov    0x4(%ebp),%eax
+80102f34:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102f38:	c7 04 24 18 89 10 80 	movl   $0x80108918,(%esp)
+80102f3f:	e8 66 d4 ff ff       	call   801003aa <cprintf>
+        __builtin_return_address(0));
+  }
+
+  if(lapic)
+80102f44:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102f49:	85 c0                	test   %eax,%eax
+80102f4b:	74 0f                	je     80102f5c <cpunum+0x55>
+    return lapic[ID]>>24;
+80102f4d:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102f52:	83 c0 20             	add    $0x20,%eax
+80102f55:	8b 00                	mov    (%eax),%eax
+80102f57:	c1 e8 18             	shr    $0x18,%eax
+80102f5a:	eb 05                	jmp    80102f61 <cpunum+0x5a>
+  return 0;
+80102f5c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80102f61:	c9                   	leave  
+80102f62:	c3                   	ret    
+
+80102f63 <lapiceoi>:
+
+// Acknowledge interrupt.
+void
+lapiceoi(void)
+{
+80102f63:	55                   	push   %ebp
+80102f64:	89 e5                	mov    %esp,%ebp
+80102f66:	83 ec 08             	sub    $0x8,%esp
+  if(lapic)
+80102f69:	a1 7c 22 11 80       	mov    0x8011227c,%eax
+80102f6e:	85 c0                	test   %eax,%eax
+80102f70:	74 14                	je     80102f86 <lapiceoi+0x23>
+    lapicw(EOI, 0);
+80102f72:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80102f79:	00 
+80102f7a:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
+80102f81:	e8 03 fe ff ff       	call   80102d89 <lapicw>
+}
+80102f86:	c9                   	leave  
+80102f87:	c3                   	ret    
+
+80102f88 <microdelay>:
+
+// Spin for a given number of microseconds.
+// On real hardware would want to tune this dynamically.
+void
+microdelay(int us)
+{
+80102f88:	55                   	push   %ebp
+80102f89:	89 e5                	mov    %esp,%ebp
+}
+80102f8b:	5d                   	pop    %ebp
+80102f8c:	c3                   	ret    
+
+80102f8d <lapicstartap>:
+
+// Start additional processor running entry code at addr.
+// See Appendix B of MultiProcessor Specification.
+void
+lapicstartap(uchar apicid, uint addr)
+{
+80102f8d:	55                   	push   %ebp
+80102f8e:	89 e5                	mov    %esp,%ebp
+80102f90:	83 ec 1c             	sub    $0x1c,%esp
+80102f93:	8b 45 08             	mov    0x8(%ebp),%eax
+80102f96:	88 45 ec             	mov    %al,-0x14(%ebp)
+  ushort *wrv;
+  
+  // "The BSP must initialize CMOS shutdown code to 0AH
+  // and the warm reset vector (DWORD based at 40:67) to point at
+  // the AP startup code prior to the [universal startup algorithm]."
+  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+80102f99:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
+80102fa0:	00 
+80102fa1:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
+80102fa8:	e8 a9 fd ff ff       	call   80102d56 <outb>
+  outb(CMOS_PORT+1, 0x0A);
+80102fad:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+80102fb4:	00 
+80102fb5:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
+80102fbc:	e8 95 fd ff ff       	call   80102d56 <outb>
+  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+80102fc1:	c7 45 f8 67 04 00 80 	movl   $0x80000467,-0x8(%ebp)
+  wrv[0] = 0;
+80102fc8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80102fcb:	66 c7 00 00 00       	movw   $0x0,(%eax)
+  wrv[1] = addr >> 4;
+80102fd0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80102fd3:	8d 50 02             	lea    0x2(%eax),%edx
+80102fd6:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102fd9:	c1 e8 04             	shr    $0x4,%eax
+80102fdc:	66 89 02             	mov    %ax,(%edx)
+
+  // "Universal startup algorithm."
+  // Send INIT (level-triggered) interrupt to reset other CPU.
+  lapicw(ICRHI, apicid<<24);
+80102fdf:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
+80102fe3:	c1 e0 18             	shl    $0x18,%eax
+80102fe6:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102fea:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
+80102ff1:	e8 93 fd ff ff       	call   80102d89 <lapicw>
+  lapicw(ICRLO, INIT | LEVEL | ASSERT);
+80102ff6:	c7 44 24 04 00 c5 00 	movl   $0xc500,0x4(%esp)
+80102ffd:	00 
+80102ffe:	c7 04 24 c0 00 00 00 	movl   $0xc0,(%esp)
+80103005:	e8 7f fd ff ff       	call   80102d89 <lapicw>
+  microdelay(200);
+8010300a:	c7 04 24 c8 00 00 00 	movl   $0xc8,(%esp)
+80103011:	e8 72 ff ff ff       	call   80102f88 <microdelay>
+  lapicw(ICRLO, INIT | LEVEL);
+80103016:	c7 44 24 04 00 85 00 	movl   $0x8500,0x4(%esp)
+8010301d:	00 
+8010301e:	c7 04 24 c0 00 00 00 	movl   $0xc0,(%esp)
+80103025:	e8 5f fd ff ff       	call   80102d89 <lapicw>
+  microdelay(100);    // should be 10ms, but too slow in Bochs!
+8010302a:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
+80103031:	e8 52 ff ff ff       	call   80102f88 <microdelay>
+  // Send startup IPI (twice!) to enter code.
+  // Regular hardware is supposed to only accept a STARTUP
+  // when it is in the halted state due to an INIT.  So the second
+  // should be ignored, but it is part of the official Intel algorithm.
+  // Bochs complains about the second one.  Too bad for Bochs.
+  for(i = 0; i < 2; i++){
+80103036:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+8010303d:	eb 40                	jmp    8010307f <lapicstartap+0xf2>
+    lapicw(ICRHI, apicid<<24);
+8010303f:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
+80103043:	c1 e0 18             	shl    $0x18,%eax
+80103046:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010304a:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
+80103051:	e8 33 fd ff ff       	call   80102d89 <lapicw>
+    lapicw(ICRLO, STARTUP | (addr>>12));
+80103056:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103059:	c1 e8 0c             	shr    $0xc,%eax
+8010305c:	80 cc 06             	or     $0x6,%ah
+8010305f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103063:	c7 04 24 c0 00 00 00 	movl   $0xc0,(%esp)
+8010306a:	e8 1a fd ff ff       	call   80102d89 <lapicw>
+    microdelay(200);
+8010306f:	c7 04 24 c8 00 00 00 	movl   $0xc8,(%esp)
+80103076:	e8 0d ff ff ff       	call   80102f88 <microdelay>
+  // Send startup IPI (twice!) to enter code.
+  // Regular hardware is supposed to only accept a STARTUP
+  // when it is in the halted state due to an INIT.  So the second
+  // should be ignored, but it is part of the official Intel algorithm.
+  // Bochs complains about the second one.  Too bad for Bochs.
+  for(i = 0; i < 2; i++){
+8010307b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+8010307f:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)
+80103083:	7e ba                	jle    8010303f <lapicstartap+0xb2>
+    lapicw(ICRHI, apicid<<24);
+    lapicw(ICRLO, STARTUP | (addr>>12));
+    microdelay(200);
+  }
+}
+80103085:	c9                   	leave  
+80103086:	c3                   	ret    
+
+80103087 <cmos_read>:
+#define DAY     0x07
+#define MONTH   0x08
+#define YEAR    0x09
+
+static uint cmos_read(uint reg)
+{
+80103087:	55                   	push   %ebp
+80103088:	89 e5                	mov    %esp,%ebp
+8010308a:	83 ec 08             	sub    $0x8,%esp
+  outb(CMOS_PORT,  reg);
+8010308d:	8b 45 08             	mov    0x8(%ebp),%eax
+80103090:	0f b6 c0             	movzbl %al,%eax
+80103093:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103097:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
+8010309e:	e8 b3 fc ff ff       	call   80102d56 <outb>
+  microdelay(200);
+801030a3:	c7 04 24 c8 00 00 00 	movl   $0xc8,(%esp)
+801030aa:	e8 d9 fe ff ff       	call   80102f88 <microdelay>
+
+  return inb(CMOS_RETURN);
+801030af:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
+801030b6:	e8 71 fc ff ff       	call   80102d2c <inb>
+801030bb:	0f b6 c0             	movzbl %al,%eax
+}
+801030be:	c9                   	leave  
+801030bf:	c3                   	ret    
+
+801030c0 <fill_rtcdate>:
+
+static void fill_rtcdate(struct rtcdate *r)
+{
+801030c0:	55                   	push   %ebp
+801030c1:	89 e5                	mov    %esp,%ebp
+801030c3:	83 ec 04             	sub    $0x4,%esp
+  r->second = cmos_read(SECS);
+801030c6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801030cd:	e8 b5 ff ff ff       	call   80103087 <cmos_read>
+801030d2:	8b 55 08             	mov    0x8(%ebp),%edx
+801030d5:	89 02                	mov    %eax,(%edx)
+  r->minute = cmos_read(MINS);
+801030d7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+801030de:	e8 a4 ff ff ff       	call   80103087 <cmos_read>
+801030e3:	8b 55 08             	mov    0x8(%ebp),%edx
+801030e6:	89 42 04             	mov    %eax,0x4(%edx)
+  r->hour   = cmos_read(HOURS);
+801030e9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+801030f0:	e8 92 ff ff ff       	call   80103087 <cmos_read>
+801030f5:	8b 55 08             	mov    0x8(%ebp),%edx
+801030f8:	89 42 08             	mov    %eax,0x8(%edx)
+  r->day    = cmos_read(DAY);
+801030fb:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
+80103102:	e8 80 ff ff ff       	call   80103087 <cmos_read>
+80103107:	8b 55 08             	mov    0x8(%ebp),%edx
+8010310a:	89 42 0c             	mov    %eax,0xc(%edx)
+  r->month  = cmos_read(MONTH);
+8010310d:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+80103114:	e8 6e ff ff ff       	call   80103087 <cmos_read>
+80103119:	8b 55 08             	mov    0x8(%ebp),%edx
+8010311c:	89 42 10             	mov    %eax,0x10(%edx)
+  r->year   = cmos_read(YEAR);
+8010311f:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
+80103126:	e8 5c ff ff ff       	call   80103087 <cmos_read>
+8010312b:	8b 55 08             	mov    0x8(%ebp),%edx
+8010312e:	89 42 14             	mov    %eax,0x14(%edx)
+}
+80103131:	c9                   	leave  
+80103132:	c3                   	ret    
+
+80103133 <cmostime>:
+
+// qemu seems to use 24-hour GWT and the values are BCD encoded
+void cmostime(struct rtcdate *r)
+{
+80103133:	55                   	push   %ebp
+80103134:	89 e5                	mov    %esp,%ebp
+80103136:	83 ec 58             	sub    $0x58,%esp
+  struct rtcdate t1, t2;
+  int sb, bcd;
+
+  sb = cmos_read(CMOS_STATB);
+80103139:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
+80103140:	e8 42 ff ff ff       	call   80103087 <cmos_read>
+80103145:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  bcd = (sb & (1 << 2)) == 0;
+80103148:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010314b:	83 e0 04             	and    $0x4,%eax
+8010314e:	85 c0                	test   %eax,%eax
+80103150:	0f 94 c0             	sete   %al
+80103153:	0f b6 c0             	movzbl %al,%eax
+80103156:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80103159:	eb 01                	jmp    8010315c <cmostime+0x29>
+    if (cmos_read(CMOS_STATA) & CMOS_UIP)
+        continue;
+    fill_rtcdate(&t2);
+    if (memcmp(&t1, &t2, sizeof(t1)) == 0)
+      break;
+  }
+8010315b:	90                   	nop
+
+  bcd = (sb & (1 << 2)) == 0;
+
+  // make sure CMOS doesn't modify time while we read it
+  for (;;) {
+    fill_rtcdate(&t1);
+8010315c:	8d 45 d8             	lea    -0x28(%ebp),%eax
+8010315f:	89 04 24             	mov    %eax,(%esp)
+80103162:	e8 59 ff ff ff       	call   801030c0 <fill_rtcdate>
+    if (cmos_read(CMOS_STATA) & CMOS_UIP)
+80103167:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+8010316e:	e8 14 ff ff ff       	call   80103087 <cmos_read>
+80103173:	25 80 00 00 00       	and    $0x80,%eax
+80103178:	85 c0                	test   %eax,%eax
+8010317a:	75 2b                	jne    801031a7 <cmostime+0x74>
+        continue;
+    fill_rtcdate(&t2);
+8010317c:	8d 45 c0             	lea    -0x40(%ebp),%eax
+8010317f:	89 04 24             	mov    %eax,(%esp)
+80103182:	e8 39 ff ff ff       	call   801030c0 <fill_rtcdate>
+    if (memcmp(&t1, &t2, sizeof(t1)) == 0)
+80103187:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
+8010318e:	00 
+8010318f:	8d 45 c0             	lea    -0x40(%ebp),%eax
+80103192:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103196:	8d 45 d8             	lea    -0x28(%ebp),%eax
+80103199:	89 04 24             	mov    %eax,(%esp)
+8010319c:	e8 24 21 00 00       	call   801052c5 <memcmp>
+801031a1:	85 c0                	test   %eax,%eax
+801031a3:	75 b6                	jne    8010315b <cmostime+0x28>
+      break;
+801031a5:	eb 03                	jmp    801031aa <cmostime+0x77>
+
+  // make sure CMOS doesn't modify time while we read it
+  for (;;) {
+    fill_rtcdate(&t1);
+    if (cmos_read(CMOS_STATA) & CMOS_UIP)
+        continue;
+801031a7:	90                   	nop
+    fill_rtcdate(&t2);
+    if (memcmp(&t1, &t2, sizeof(t1)) == 0)
+      break;
+  }
+801031a8:	eb b1                	jmp    8010315b <cmostime+0x28>
+
+  // convert
+  if (bcd) {
+801031aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801031ae:	0f 84 a8 00 00 00    	je     8010325c <cmostime+0x129>
+#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+    CONV(second);
+801031b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
+801031b7:	89 c2                	mov    %eax,%edx
+801031b9:	c1 ea 04             	shr    $0x4,%edx
+801031bc:	89 d0                	mov    %edx,%eax
+801031be:	c1 e0 02             	shl    $0x2,%eax
+801031c1:	01 d0                	add    %edx,%eax
+801031c3:	01 c0                	add    %eax,%eax
+801031c5:	8b 55 d8             	mov    -0x28(%ebp),%edx
+801031c8:	83 e2 0f             	and    $0xf,%edx
+801031cb:	01 d0                	add    %edx,%eax
+801031cd:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    CONV(minute);
+801031d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801031d3:	89 c2                	mov    %eax,%edx
+801031d5:	c1 ea 04             	shr    $0x4,%edx
+801031d8:	89 d0                	mov    %edx,%eax
+801031da:	c1 e0 02             	shl    $0x2,%eax
+801031dd:	01 d0                	add    %edx,%eax
+801031df:	01 c0                	add    %eax,%eax
+801031e1:	8b 55 dc             	mov    -0x24(%ebp),%edx
+801031e4:	83 e2 0f             	and    $0xf,%edx
+801031e7:	01 d0                	add    %edx,%eax
+801031e9:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    CONV(hour  );
+801031ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801031ef:	89 c2                	mov    %eax,%edx
+801031f1:	c1 ea 04             	shr    $0x4,%edx
+801031f4:	89 d0                	mov    %edx,%eax
+801031f6:	c1 e0 02             	shl    $0x2,%eax
+801031f9:	01 d0                	add    %edx,%eax
+801031fb:	01 c0                	add    %eax,%eax
+801031fd:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80103200:	83 e2 0f             	and    $0xf,%edx
+80103203:	01 d0                	add    %edx,%eax
+80103205:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    CONV(day   );
+80103208:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+8010320b:	89 c2                	mov    %eax,%edx
+8010320d:	c1 ea 04             	shr    $0x4,%edx
+80103210:	89 d0                	mov    %edx,%eax
+80103212:	c1 e0 02             	shl    $0x2,%eax
+80103215:	01 d0                	add    %edx,%eax
+80103217:	01 c0                	add    %eax,%eax
+80103219:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+8010321c:	83 e2 0f             	and    $0xf,%edx
+8010321f:	01 d0                	add    %edx,%eax
+80103221:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    CONV(month );
+80103224:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80103227:	89 c2                	mov    %eax,%edx
+80103229:	c1 ea 04             	shr    $0x4,%edx
+8010322c:	89 d0                	mov    %edx,%eax
+8010322e:	c1 e0 02             	shl    $0x2,%eax
+80103231:	01 d0                	add    %edx,%eax
+80103233:	01 c0                	add    %eax,%eax
+80103235:	8b 55 e8             	mov    -0x18(%ebp),%edx
+80103238:	83 e2 0f             	and    $0xf,%edx
+8010323b:	01 d0                	add    %edx,%eax
+8010323d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    CONV(year  );
+80103240:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103243:	89 c2                	mov    %eax,%edx
+80103245:	c1 ea 04             	shr    $0x4,%edx
+80103248:	89 d0                	mov    %edx,%eax
+8010324a:	c1 e0 02             	shl    $0x2,%eax
+8010324d:	01 d0                	add    %edx,%eax
+8010324f:	01 c0                	add    %eax,%eax
+80103251:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80103254:	83 e2 0f             	and    $0xf,%edx
+80103257:	01 d0                	add    %edx,%eax
+80103259:	89 45 ec             	mov    %eax,-0x14(%ebp)
+#undef     CONV
+  }
+
+  *r = t1;
+8010325c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010325f:	8b 55 d8             	mov    -0x28(%ebp),%edx
+80103262:	89 10                	mov    %edx,(%eax)
+80103264:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80103267:	89 50 04             	mov    %edx,0x4(%eax)
+8010326a:	8b 55 e0             	mov    -0x20(%ebp),%edx
+8010326d:	89 50 08             	mov    %edx,0x8(%eax)
+80103270:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80103273:	89 50 0c             	mov    %edx,0xc(%eax)
+80103276:	8b 55 e8             	mov    -0x18(%ebp),%edx
+80103279:	89 50 10             	mov    %edx,0x10(%eax)
+8010327c:	8b 55 ec             	mov    -0x14(%ebp),%edx
+8010327f:	89 50 14             	mov    %edx,0x14(%eax)
+  r->year += 2000;
+80103282:	8b 45 08             	mov    0x8(%ebp),%eax
+80103285:	8b 40 14             	mov    0x14(%eax),%eax
+80103288:	8d 90 d0 07 00 00    	lea    0x7d0(%eax),%edx
+8010328e:	8b 45 08             	mov    0x8(%ebp),%eax
+80103291:	89 50 14             	mov    %edx,0x14(%eax)
+}
+80103294:	c9                   	leave  
+80103295:	c3                   	ret    
+	...
+
+80103298 <initlog>:
+static void recover_from_log(void);
+static void commit();
+
+void
+initlog(void)
+{
+80103298:	55                   	push   %ebp
+80103299:	89 e5                	mov    %esp,%ebp
+8010329b:	83 ec 28             	sub    $0x28,%esp
+  if (sizeof(struct logheader) >= BSIZE)
+    panic("initlog: too big logheader");
+
+  struct superblock sb;
+  initlock(&log.lock, "log");
+8010329e:	c7 44 24 04 44 89 10 	movl   $0x80108944,0x4(%esp)
+801032a5:	80 
+801032a6:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+801032ad:	e8 20 1d 00 00       	call   80104fd2 <initlock>
+  readsb(ROOTDEV, &sb);
+801032b2:	8d 45 e8             	lea    -0x18(%ebp),%eax
+801032b5:	89 44 24 04          	mov    %eax,0x4(%esp)
+801032b9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801032c0:	e8 5b e0 ff ff       	call   80101320 <readsb>
+  log.start = sb.size - sb.nlog;
+801032c5:	8b 55 e8             	mov    -0x18(%ebp),%edx
+801032c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801032cb:	89 d1                	mov    %edx,%ecx
+801032cd:	29 c1                	sub    %eax,%ecx
+801032cf:	89 c8                	mov    %ecx,%eax
+801032d1:	a3 b4 22 11 80       	mov    %eax,0x801122b4
+  log.size = sb.nlog;
+801032d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801032d9:	a3 b8 22 11 80       	mov    %eax,0x801122b8
+  log.dev = ROOTDEV;
+801032de:	c7 05 c4 22 11 80 01 	movl   $0x1,0x801122c4
+801032e5:	00 00 00 
+  recover_from_log();
+801032e8:	e8 9a 01 00 00       	call   80103487 <recover_from_log>
+}
+801032ed:	c9                   	leave  
+801032ee:	c3                   	ret    
+
+801032ef <install_trans>:
+
+// Copy committed blocks from log to their home location
+static void 
+install_trans(void)
+{
+801032ef:	55                   	push   %ebp
+801032f0:	89 e5                	mov    %esp,%ebp
+801032f2:	83 ec 28             	sub    $0x28,%esp
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+801032f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801032fc:	e9 8c 00 00 00       	jmp    8010338d <install_trans+0x9e>
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+80103301:	8b 15 b4 22 11 80    	mov    0x801122b4,%edx
+80103307:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010330a:	01 d0                	add    %edx,%eax
+8010330c:	83 c0 01             	add    $0x1,%eax
+8010330f:	89 c2                	mov    %eax,%edx
+80103311:	a1 c4 22 11 80       	mov    0x801122c4,%eax
+80103316:	89 54 24 04          	mov    %edx,0x4(%esp)
+8010331a:	89 04 24             	mov    %eax,(%esp)
+8010331d:	e8 84 ce ff ff       	call   801001a6 <bread>
+80103322:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); // read dst
+80103325:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103328:	83 c0 10             	add    $0x10,%eax
+8010332b:	8b 04 85 8c 22 11 80 	mov    -0x7feedd74(,%eax,4),%eax
+80103332:	89 c2                	mov    %eax,%edx
+80103334:	a1 c4 22 11 80       	mov    0x801122c4,%eax
+80103339:	89 54 24 04          	mov    %edx,0x4(%esp)
+8010333d:	89 04 24             	mov    %eax,(%esp)
+80103340:	e8 61 ce ff ff       	call   801001a6 <bread>
+80103345:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+80103348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010334b:	8d 50 18             	lea    0x18(%eax),%edx
+8010334e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103351:	83 c0 18             	add    $0x18,%eax
+80103354:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+8010335b:	00 
+8010335c:	89 54 24 04          	mov    %edx,0x4(%esp)
+80103360:	89 04 24             	mov    %eax,(%esp)
+80103363:	e8 b9 1f 00 00       	call   80105321 <memmove>
+    bwrite(dbuf);  // write dst to disk
+80103368:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010336b:	89 04 24             	mov    %eax,(%esp)
+8010336e:	e8 6a ce ff ff       	call   801001dd <bwrite>
+    brelse(lbuf); 
+80103373:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103376:	89 04 24             	mov    %eax,(%esp)
+80103379:	e8 99 ce ff ff       	call   80100217 <brelse>
+    brelse(dbuf);
+8010337e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103381:	89 04 24             	mov    %eax,(%esp)
+80103384:	e8 8e ce ff ff       	call   80100217 <brelse>
+static void 
+install_trans(void)
+{
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+80103389:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+8010338d:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+80103392:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80103395:	0f 8f 66 ff ff ff    	jg     80103301 <install_trans+0x12>
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+    bwrite(dbuf);  // write dst to disk
+    brelse(lbuf); 
+    brelse(dbuf);
+  }
+}
+8010339b:	c9                   	leave  
+8010339c:	c3                   	ret    
+
+8010339d <read_head>:
+
+// Read the log header from disk into the in-memory log header
+static void
+read_head(void)
+{
+8010339d:	55                   	push   %ebp
+8010339e:	89 e5                	mov    %esp,%ebp
+801033a0:	83 ec 28             	sub    $0x28,%esp
+  struct buf *buf = bread(log.dev, log.start);
+801033a3:	a1 b4 22 11 80       	mov    0x801122b4,%eax
+801033a8:	89 c2                	mov    %eax,%edx
+801033aa:	a1 c4 22 11 80       	mov    0x801122c4,%eax
+801033af:	89 54 24 04          	mov    %edx,0x4(%esp)
+801033b3:	89 04 24             	mov    %eax,(%esp)
+801033b6:	e8 eb cd ff ff       	call   801001a6 <bread>
+801033bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  struct logheader *lh = (struct logheader *) (buf->data);
+801033be:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801033c1:	83 c0 18             	add    $0x18,%eax
+801033c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  int i;
+  log.lh.n = lh->n;
+801033c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801033ca:	8b 00                	mov    (%eax),%eax
+801033cc:	a3 c8 22 11 80       	mov    %eax,0x801122c8
+  for (i = 0; i < log.lh.n; i++) {
+801033d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801033d8:	eb 1b                	jmp    801033f5 <read_head+0x58>
+    log.lh.sector[i] = lh->sector[i];
+801033da:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801033dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801033e0:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
+801033e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801033e7:	83 c2 10             	add    $0x10,%edx
+801033ea:	89 04 95 8c 22 11 80 	mov    %eax,-0x7feedd74(,%edx,4)
+{
+  struct buf *buf = bread(log.dev, log.start);
+  struct logheader *lh = (struct logheader *) (buf->data);
+  int i;
+  log.lh.n = lh->n;
+  for (i = 0; i < log.lh.n; i++) {
+801033f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801033f5:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+801033fa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+801033fd:	7f db                	jg     801033da <read_head+0x3d>
+    log.lh.sector[i] = lh->sector[i];
+  }
+  brelse(buf);
+801033ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103402:	89 04 24             	mov    %eax,(%esp)
+80103405:	e8 0d ce ff ff       	call   80100217 <brelse>
+}
+8010340a:	c9                   	leave  
+8010340b:	c3                   	ret    
+
+8010340c <write_head>:
+// Write in-memory log header to disk.
+// This is the true point at which the
+// current transaction commits.
+static void
+write_head(void)
+{
+8010340c:	55                   	push   %ebp
+8010340d:	89 e5                	mov    %esp,%ebp
+8010340f:	83 ec 28             	sub    $0x28,%esp
+  struct buf *buf = bread(log.dev, log.start);
+80103412:	a1 b4 22 11 80       	mov    0x801122b4,%eax
+80103417:	89 c2                	mov    %eax,%edx
+80103419:	a1 c4 22 11 80       	mov    0x801122c4,%eax
+8010341e:	89 54 24 04          	mov    %edx,0x4(%esp)
+80103422:	89 04 24             	mov    %eax,(%esp)
+80103425:	e8 7c cd ff ff       	call   801001a6 <bread>
+8010342a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  struct logheader *hb = (struct logheader *) (buf->data);
+8010342d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103430:	83 c0 18             	add    $0x18,%eax
+80103433:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  int i;
+  hb->n = log.lh.n;
+80103436:	8b 15 c8 22 11 80    	mov    0x801122c8,%edx
+8010343c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010343f:	89 10                	mov    %edx,(%eax)
+  for (i = 0; i < log.lh.n; i++) {
+80103441:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80103448:	eb 1b                	jmp    80103465 <write_head+0x59>
+    hb->sector[i] = log.lh.sector[i];
+8010344a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010344d:	83 c0 10             	add    $0x10,%eax
+80103450:	8b 0c 85 8c 22 11 80 	mov    -0x7feedd74(,%eax,4),%ecx
+80103457:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010345a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010345d:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
+{
+  struct buf *buf = bread(log.dev, log.start);
+  struct logheader *hb = (struct logheader *) (buf->data);
+  int i;
+  hb->n = log.lh.n;
+  for (i = 0; i < log.lh.n; i++) {
+80103461:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80103465:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+8010346a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+8010346d:	7f db                	jg     8010344a <write_head+0x3e>
+    hb->sector[i] = log.lh.sector[i];
+  }
+  bwrite(buf);
+8010346f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103472:	89 04 24             	mov    %eax,(%esp)
+80103475:	e8 63 cd ff ff       	call   801001dd <bwrite>
+  brelse(buf);
+8010347a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010347d:	89 04 24             	mov    %eax,(%esp)
+80103480:	e8 92 cd ff ff       	call   80100217 <brelse>
+}
+80103485:	c9                   	leave  
+80103486:	c3                   	ret    
+
+80103487 <recover_from_log>:
+
+static void
+recover_from_log(void)
+{
+80103487:	55                   	push   %ebp
+80103488:	89 e5                	mov    %esp,%ebp
+8010348a:	83 ec 08             	sub    $0x8,%esp
+  read_head();      
+8010348d:	e8 0b ff ff ff       	call   8010339d <read_head>
+  install_trans(); // if committed, copy from log to disk
+80103492:	e8 58 fe ff ff       	call   801032ef <install_trans>
+  log.lh.n = 0;
+80103497:	c7 05 c8 22 11 80 00 	movl   $0x0,0x801122c8
+8010349e:	00 00 00 
+  write_head(); // clear the log
+801034a1:	e8 66 ff ff ff       	call   8010340c <write_head>
+}
+801034a6:	c9                   	leave  
+801034a7:	c3                   	ret    
+
+801034a8 <begin_op>:
+
+// called at the start of each FS system call.
+void
+begin_op(void)
+{
+801034a8:	55                   	push   %ebp
+801034a9:	89 e5                	mov    %esp,%ebp
+801034ab:	83 ec 18             	sub    $0x18,%esp
+  acquire(&log.lock);
+801034ae:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+801034b5:	e8 39 1b 00 00       	call   80104ff3 <acquire>
+  while(1){
+    if(log.committing){
+801034ba:	a1 c0 22 11 80       	mov    0x801122c0,%eax
+801034bf:	85 c0                	test   %eax,%eax
+801034c1:	74 16                	je     801034d9 <begin_op+0x31>
+      sleep(&log, &log.lock);
+801034c3:	c7 44 24 04 80 22 11 	movl   $0x80112280,0x4(%esp)
+801034ca:	80 
+801034cb:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+801034d2:	e8 3e 18 00 00       	call   80104d15 <sleep>
+    } else {
+      log.outstanding += 1;
+      release(&log.lock);
+      break;
+    }
+  }
+801034d7:	eb e1                	jmp    801034ba <begin_op+0x12>
+{
+  acquire(&log.lock);
+  while(1){
+    if(log.committing){
+      sleep(&log, &log.lock);
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+801034d9:	8b 0d c8 22 11 80    	mov    0x801122c8,%ecx
+801034df:	a1 bc 22 11 80       	mov    0x801122bc,%eax
+801034e4:	8d 50 01             	lea    0x1(%eax),%edx
+801034e7:	89 d0                	mov    %edx,%eax
+801034e9:	c1 e0 02             	shl    $0x2,%eax
+801034ec:	01 d0                	add    %edx,%eax
+801034ee:	01 c0                	add    %eax,%eax
+801034f0:	01 c8                	add    %ecx,%eax
+801034f2:	83 f8 1e             	cmp    $0x1e,%eax
+801034f5:	7e 16                	jle    8010350d <begin_op+0x65>
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+801034f7:	c7 44 24 04 80 22 11 	movl   $0x80112280,0x4(%esp)
+801034fe:	80 
+801034ff:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+80103506:	e8 0a 18 00 00       	call   80104d15 <sleep>
+    } else {
+      log.outstanding += 1;
+      release(&log.lock);
+      break;
+    }
+  }
+8010350b:	eb ad                	jmp    801034ba <begin_op+0x12>
+      sleep(&log, &log.lock);
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+    } else {
+      log.outstanding += 1;
+8010350d:	a1 bc 22 11 80       	mov    0x801122bc,%eax
+80103512:	83 c0 01             	add    $0x1,%eax
+80103515:	a3 bc 22 11 80       	mov    %eax,0x801122bc
+      release(&log.lock);
+8010351a:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+80103521:	e8 2f 1b 00 00       	call   80105055 <release>
+      break;
+80103526:	90                   	nop
+    }
+  }
+}
+80103527:	c9                   	leave  
+80103528:	c3                   	ret    
+
+80103529 <end_op>:
+
+// called at the end of each FS system call.
+// commits if this was the last outstanding operation.
+void
+end_op(void)
+{
+80103529:	55                   	push   %ebp
+8010352a:	89 e5                	mov    %esp,%ebp
+8010352c:	83 ec 28             	sub    $0x28,%esp
+  int do_commit = 0;
+8010352f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+  acquire(&log.lock);
+80103536:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+8010353d:	e8 b1 1a 00 00       	call   80104ff3 <acquire>
+  log.outstanding -= 1;
+80103542:	a1 bc 22 11 80       	mov    0x801122bc,%eax
+80103547:	83 e8 01             	sub    $0x1,%eax
+8010354a:	a3 bc 22 11 80       	mov    %eax,0x801122bc
+  if(log.committing)
+8010354f:	a1 c0 22 11 80       	mov    0x801122c0,%eax
+80103554:	85 c0                	test   %eax,%eax
+80103556:	74 0c                	je     80103564 <end_op+0x3b>
+    panic("log.committing");
+80103558:	c7 04 24 48 89 10 80 	movl   $0x80108948,(%esp)
+8010355f:	e8 e2 cf ff ff       	call   80100546 <panic>
+  if(log.outstanding == 0){
+80103564:	a1 bc 22 11 80       	mov    0x801122bc,%eax
+80103569:	85 c0                	test   %eax,%eax
+8010356b:	75 13                	jne    80103580 <end_op+0x57>
+    do_commit = 1;
+8010356d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+    log.committing = 1;
+80103574:	c7 05 c0 22 11 80 01 	movl   $0x1,0x801122c0
+8010357b:	00 00 00 
+8010357e:	eb 0c                	jmp    8010358c <end_op+0x63>
+  } else {
+    // begin_op() may be waiting for log space.
+    wakeup(&log);
+80103580:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+80103587:	e8 62 18 00 00       	call   80104dee <wakeup>
+  }
+  release(&log.lock);
+8010358c:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+80103593:	e8 bd 1a 00 00       	call   80105055 <release>
+
+  if(do_commit){
+80103598:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010359c:	74 33                	je     801035d1 <end_op+0xa8>
+    // call commit w/o holding locks, since not allowed
+    // to sleep with locks.
+    commit();
+8010359e:	e8 de 00 00 00       	call   80103681 <commit>
+    acquire(&log.lock);
+801035a3:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+801035aa:	e8 44 1a 00 00       	call   80104ff3 <acquire>
+    log.committing = 0;
+801035af:	c7 05 c0 22 11 80 00 	movl   $0x0,0x801122c0
+801035b6:	00 00 00 
+    wakeup(&log);
+801035b9:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+801035c0:	e8 29 18 00 00       	call   80104dee <wakeup>
+    release(&log.lock);
+801035c5:	c7 04 24 80 22 11 80 	movl   $0x80112280,(%esp)
+801035cc:	e8 84 1a 00 00       	call   80105055 <release>
+  }
+}
+801035d1:	c9                   	leave  
+801035d2:	c3                   	ret    
+
+801035d3 <write_log>:
+
+// Copy modified blocks from cache to log.
+static void 
+write_log(void)
+{
+801035d3:	55                   	push   %ebp
+801035d4:	89 e5                	mov    %esp,%ebp
+801035d6:	83 ec 28             	sub    $0x28,%esp
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+801035d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801035e0:	e9 8c 00 00 00       	jmp    80103671 <write_log+0x9e>
+    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+801035e5:	8b 15 b4 22 11 80    	mov    0x801122b4,%edx
+801035eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801035ee:	01 d0                	add    %edx,%eax
+801035f0:	83 c0 01             	add    $0x1,%eax
+801035f3:	89 c2                	mov    %eax,%edx
+801035f5:	a1 c4 22 11 80       	mov    0x801122c4,%eax
+801035fa:	89 54 24 04          	mov    %edx,0x4(%esp)
+801035fe:	89 04 24             	mov    %eax,(%esp)
+80103601:	e8 a0 cb ff ff       	call   801001a6 <bread>
+80103606:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    struct buf *from = bread(log.dev, log.lh.sector[tail]); // cache block
+80103609:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010360c:	83 c0 10             	add    $0x10,%eax
+8010360f:	8b 04 85 8c 22 11 80 	mov    -0x7feedd74(,%eax,4),%eax
+80103616:	89 c2                	mov    %eax,%edx
+80103618:	a1 c4 22 11 80       	mov    0x801122c4,%eax
+8010361d:	89 54 24 04          	mov    %edx,0x4(%esp)
+80103621:	89 04 24             	mov    %eax,(%esp)
+80103624:	e8 7d cb ff ff       	call   801001a6 <bread>
+80103629:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(to->data, from->data, BSIZE);
+8010362c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010362f:	8d 50 18             	lea    0x18(%eax),%edx
+80103632:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103635:	83 c0 18             	add    $0x18,%eax
+80103638:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+8010363f:	00 
+80103640:	89 54 24 04          	mov    %edx,0x4(%esp)
+80103644:	89 04 24             	mov    %eax,(%esp)
+80103647:	e8 d5 1c 00 00       	call   80105321 <memmove>
+    bwrite(to);  // write the log
+8010364c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010364f:	89 04 24             	mov    %eax,(%esp)
+80103652:	e8 86 cb ff ff       	call   801001dd <bwrite>
+    brelse(from); 
+80103657:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010365a:	89 04 24             	mov    %eax,(%esp)
+8010365d:	e8 b5 cb ff ff       	call   80100217 <brelse>
+    brelse(to);
+80103662:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103665:	89 04 24             	mov    %eax,(%esp)
+80103668:	e8 aa cb ff ff       	call   80100217 <brelse>
+static void 
+write_log(void)
+{
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+8010366d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80103671:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+80103676:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80103679:	0f 8f 66 ff ff ff    	jg     801035e5 <write_log+0x12>
+    memmove(to->data, from->data, BSIZE);
+    bwrite(to);  // write the log
+    brelse(from); 
+    brelse(to);
+  }
+}
+8010367f:	c9                   	leave  
+80103680:	c3                   	ret    
+
+80103681 <commit>:
+
+static void
+commit()
+{
+80103681:	55                   	push   %ebp
+80103682:	89 e5                	mov    %esp,%ebp
+80103684:	83 ec 08             	sub    $0x8,%esp
+  if (log.lh.n > 0) {
+80103687:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+8010368c:	85 c0                	test   %eax,%eax
+8010368e:	7e 1e                	jle    801036ae <commit+0x2d>
+    write_log();     // Write modified blocks from cache to log
+80103690:	e8 3e ff ff ff       	call   801035d3 <write_log>
+    write_head();    // Write header to disk -- the real commit
+80103695:	e8 72 fd ff ff       	call   8010340c <write_head>
+    install_trans(); // Now install writes to home locations
+8010369a:	e8 50 fc ff ff       	call   801032ef <install_trans>
+    log.lh.n = 0; 
+8010369f:	c7 05 c8 22 11 80 00 	movl   $0x0,0x801122c8
+801036a6:	00 00 00 
+    write_head();    // Erase the transaction from the log
+801036a9:	e8 5e fd ff ff       	call   8010340c <write_head>
+  }
+}
+801036ae:	c9                   	leave  
+801036af:	c3                   	ret    
+
+801036b0 <log_write>:
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+801036b0:	55                   	push   %ebp
+801036b1:	89 e5                	mov    %esp,%ebp
+801036b3:	83 ec 28             	sub    $0x28,%esp
+  int i;
+
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+801036b6:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+801036bb:	83 f8 1d             	cmp    $0x1d,%eax
+801036be:	7f 12                	jg     801036d2 <log_write+0x22>
+801036c0:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+801036c5:	8b 15 b8 22 11 80    	mov    0x801122b8,%edx
+801036cb:	83 ea 01             	sub    $0x1,%edx
+801036ce:	39 d0                	cmp    %edx,%eax
+801036d0:	7c 0c                	jl     801036de <log_write+0x2e>
+    panic("too big a transaction");
+801036d2:	c7 04 24 57 89 10 80 	movl   $0x80108957,(%esp)
+801036d9:	e8 68 ce ff ff       	call   80100546 <panic>
+  if (log.outstanding < 1)
+801036de:	a1 bc 22 11 80       	mov    0x801122bc,%eax
+801036e3:	85 c0                	test   %eax,%eax
+801036e5:	7f 0c                	jg     801036f3 <log_write+0x43>
+    panic("log_write outside of trans");
+801036e7:	c7 04 24 6d 89 10 80 	movl   $0x8010896d,(%esp)
+801036ee:	e8 53 ce ff ff       	call   80100546 <panic>
+
+  for (i = 0; i < log.lh.n; i++) {
+801036f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801036fa:	eb 1d                	jmp    80103719 <log_write+0x69>
+    if (log.lh.sector[i] == b->sector)   // log absorbtion
+801036fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801036ff:	83 c0 10             	add    $0x10,%eax
+80103702:	8b 04 85 8c 22 11 80 	mov    -0x7feedd74(,%eax,4),%eax
+80103709:	89 c2                	mov    %eax,%edx
+8010370b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010370e:	8b 40 08             	mov    0x8(%eax),%eax
+80103711:	39 c2                	cmp    %eax,%edx
+80103713:	74 10                	je     80103725 <log_write+0x75>
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+    panic("too big a transaction");
+  if (log.outstanding < 1)
+    panic("log_write outside of trans");
+
+  for (i = 0; i < log.lh.n; i++) {
+80103715:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80103719:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+8010371e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80103721:	7f d9                	jg     801036fc <log_write+0x4c>
+80103723:	eb 01                	jmp    80103726 <log_write+0x76>
+    if (log.lh.sector[i] == b->sector)   // log absorbtion
+      break;
+80103725:	90                   	nop
+  }
+  log.lh.sector[i] = b->sector;
+80103726:	8b 45 08             	mov    0x8(%ebp),%eax
+80103729:	8b 40 08             	mov    0x8(%eax),%eax
+8010372c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010372f:	83 c2 10             	add    $0x10,%edx
+80103732:	89 04 95 8c 22 11 80 	mov    %eax,-0x7feedd74(,%edx,4)
+  if (i == log.lh.n)
+80103739:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+8010373e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80103741:	75 0d                	jne    80103750 <log_write+0xa0>
+    log.lh.n++;
+80103743:	a1 c8 22 11 80       	mov    0x801122c8,%eax
+80103748:	83 c0 01             	add    $0x1,%eax
+8010374b:	a3 c8 22 11 80       	mov    %eax,0x801122c8
+  b->flags |= B_DIRTY; // prevent eviction
+80103750:	8b 45 08             	mov    0x8(%ebp),%eax
+80103753:	8b 00                	mov    (%eax),%eax
+80103755:	89 c2                	mov    %eax,%edx
+80103757:	83 ca 04             	or     $0x4,%edx
+8010375a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010375d:	89 10                	mov    %edx,(%eax)
+}
+8010375f:	c9                   	leave  
+80103760:	c3                   	ret    
+80103761:	00 00                	add    %al,(%eax)
+	...
+
+80103764 <v2p>:
+80103764:	55                   	push   %ebp
+80103765:	89 e5                	mov    %esp,%ebp
+80103767:	8b 45 08             	mov    0x8(%ebp),%eax
+8010376a:	05 00 00 00 80       	add    $0x80000000,%eax
+8010376f:	5d                   	pop    %ebp
+80103770:	c3                   	ret    
+
+80103771 <p2v>:
+static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
+80103771:	55                   	push   %ebp
+80103772:	89 e5                	mov    %esp,%ebp
+80103774:	8b 45 08             	mov    0x8(%ebp),%eax
+80103777:	05 00 00 00 80       	add    $0x80000000,%eax
+8010377c:	5d                   	pop    %ebp
+8010377d:	c3                   	ret    
+
+8010377e <xchg>:
+  asm volatile("sti");
+}
+
+static inline uint
+xchg(volatile uint *addr, uint newval)
+{
+8010377e:	55                   	push   %ebp
+8010377f:	89 e5                	mov    %esp,%ebp
+80103781:	53                   	push   %ebx
+80103782:	83 ec 10             	sub    $0x10,%esp
+  uint result;
+  
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+               "+m" (*addr), "=a" (result) :
+80103785:	8b 55 08             	mov    0x8(%ebp),%edx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+  
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+80103788:	8b 45 0c             	mov    0xc(%ebp),%eax
+               "+m" (*addr), "=a" (result) :
+8010378b:	8b 4d 08             	mov    0x8(%ebp),%ecx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+  
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+8010378e:	89 c3                	mov    %eax,%ebx
+80103790:	89 d8                	mov    %ebx,%eax
+80103792:	f0 87 02             	lock xchg %eax,(%edx)
+80103795:	89 c3                	mov    %eax,%ebx
+80103797:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+               "+m" (*addr), "=a" (result) :
+               "1" (newval) :
+               "cc");
+  return result;
+8010379a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+8010379d:	83 c4 10             	add    $0x10,%esp
+801037a0:	5b                   	pop    %ebx
+801037a1:	5d                   	pop    %ebp
+801037a2:	c3                   	ret    
+
+801037a3 <main>:
+// Bootstrap processor starts running C code here.
+// Allocate a real stack and switch to it, first
+// doing some setup required for memory allocator to work.
+int
+main(void)
+{
+801037a3:	55                   	push   %ebp
+801037a4:	89 e5                	mov    %esp,%ebp
+801037a6:	83 e4 f0             	and    $0xfffffff0,%esp
+801037a9:	83 ec 10             	sub    $0x10,%esp
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+801037ac:	c7 44 24 04 00 00 40 	movl   $0x80400000,0x4(%esp)
+801037b3:	80 
+801037b4:	c7 04 24 7c 52 11 80 	movl   $0x8011527c,(%esp)
+801037bb:	e8 5d f2 ff ff       	call   80102a1d <kinit1>
+  kvmalloc();      // kernel page table
+801037c0:	e8 bf 47 00 00       	call   80107f84 <kvmalloc>
+  mpinit();        // collect info about this machine
+801037c5:	e8 57 04 00 00       	call   80103c21 <mpinit>
+  lapicinit();
+801037ca:	e8 db f5 ff ff       	call   80102daa <lapicinit>
+  seginit();       // set up segments
+801037cf:	e8 45 41 00 00       	call   80107919 <seginit>
+  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
+801037d4:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801037da:	0f b6 00             	movzbl (%eax),%eax
+801037dd:	0f b6 c0             	movzbl %al,%eax
+801037e0:	89 44 24 04          	mov    %eax,0x4(%esp)
+801037e4:	c7 04 24 88 89 10 80 	movl   $0x80108988,(%esp)
+801037eb:	e8 ba cb ff ff       	call   801003aa <cprintf>
+  picinit();       // interrupt controller
+801037f0:	e8 91 06 00 00       	call   80103e86 <picinit>
+  ioapicinit();    // another interrupt controller
+801037f5:	e8 13 f1 ff ff       	call   8010290d <ioapicinit>
+  consoleinit();   // I/O devices & their interrupts
+801037fa:	e8 99 d2 ff ff       	call   80100a98 <consoleinit>
+  uartinit();      // serial port
+801037ff:	e8 60 34 00 00       	call   80106c64 <uartinit>
+  pinit();         // process table
+80103804:	e8 c8 0b 00 00       	call   801043d1 <pinit>
+  tvinit();        // trap vectors
+80103809:	e8 f9 2f 00 00       	call   80106807 <tvinit>
+  binit();         // buffer cache
+8010380e:	e8 21 c8 ff ff       	call   80100034 <binit>
+  fileinit();      // file table
+80103813:	e8 1c d7 ff ff       	call   80100f34 <fileinit>
+  iinit();         // inode cache
+80103818:	e8 d3 dd ff ff       	call   801015f0 <iinit>
+  ideinit();       // disk
+8010381d:	e8 50 ed ff ff       	call   80102572 <ideinit>
+  if(!ismp)
+80103822:	a1 64 23 11 80       	mov    0x80112364,%eax
+80103827:	85 c0                	test   %eax,%eax
+80103829:	75 05                	jne    80103830 <main+0x8d>
+    timerinit();   // uniprocessor timer
+8010382b:	e8 1a 2f 00 00       	call   8010674a <timerinit>
+  startothers();   // start other processors
+80103830:	e8 7f 00 00 00       	call   801038b4 <startothers>
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+80103835:	c7 44 24 04 00 00 00 	movl   $0x8e000000,0x4(%esp)
+8010383c:	8e 
+8010383d:	c7 04 24 00 00 40 80 	movl   $0x80400000,(%esp)
+80103844:	e8 0c f2 ff ff       	call   80102a55 <kinit2>
+  userinit();      // first user process
+80103849:	e8 9e 0c 00 00       	call   801044ec <userinit>
+  // Finish setting up this processor in mpmain.
+  mpmain();
+8010384e:	e8 1a 00 00 00       	call   8010386d <mpmain>
+
+80103853 <mpenter>:
+}
+
+// Other CPUs jump here from entryother.S.
+static void
+mpenter(void)
+{
+80103853:	55                   	push   %ebp
+80103854:	89 e5                	mov    %esp,%ebp
+80103856:	83 ec 08             	sub    $0x8,%esp
+  switchkvm(); 
+80103859:	e8 3d 47 00 00       	call   80107f9b <switchkvm>
+  seginit();
+8010385e:	e8 b6 40 00 00       	call   80107919 <seginit>
+  lapicinit();
+80103863:	e8 42 f5 ff ff       	call   80102daa <lapicinit>
+  mpmain();
+80103868:	e8 00 00 00 00       	call   8010386d <mpmain>
+
+8010386d <mpmain>:
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+8010386d:	55                   	push   %ebp
+8010386e:	89 e5                	mov    %esp,%ebp
+80103870:	83 ec 18             	sub    $0x18,%esp
+  cprintf("cpu%d: starting\n", cpu->id);
+80103873:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80103879:	0f b6 00             	movzbl (%eax),%eax
+8010387c:	0f b6 c0             	movzbl %al,%eax
+8010387f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103883:	c7 04 24 9f 89 10 80 	movl   $0x8010899f,(%esp)
+8010388a:	e8 1b cb ff ff       	call   801003aa <cprintf>
+  idtinit();       // load idt register
+8010388f:	e8 e7 30 00 00       	call   8010697b <idtinit>
+  xchg(&cpu->started, 1); // tell startothers() we're up
+80103894:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+8010389a:	05 a8 00 00 00       	add    $0xa8,%eax
+8010389f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+801038a6:	00 
+801038a7:	89 04 24             	mov    %eax,(%esp)
+801038aa:	e8 cf fe ff ff       	call   8010377e <xchg>
+  scheduler();     // start running processes
+801038af:	e8 aa 11 00 00       	call   80104a5e <scheduler>
+
+801038b4 <startothers>:
+pde_t entrypgdir[];  // For entry.S
+
+// Start the non-boot (AP) processors.
+static void
+startothers(void)
+{
+801038b4:	55                   	push   %ebp
+801038b5:	89 e5                	mov    %esp,%ebp
+801038b7:	53                   	push   %ebx
+801038b8:	83 ec 24             	sub    $0x24,%esp
+  char *stack;
+
+  // Write entry code to unused memory at 0x7000.
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = p2v(0x7000);
+801038bb:	c7 04 24 00 70 00 00 	movl   $0x7000,(%esp)
+801038c2:	e8 aa fe ff ff       	call   80103771 <p2v>
+801038c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+801038ca:	b8 8a 00 00 00       	mov    $0x8a,%eax
+801038cf:	89 44 24 08          	mov    %eax,0x8(%esp)
+801038d3:	c7 44 24 04 2c b5 10 	movl   $0x8010b52c,0x4(%esp)
+801038da:	80 
+801038db:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801038de:	89 04 24             	mov    %eax,(%esp)
+801038e1:	e8 3b 1a 00 00       	call   80105321 <memmove>
+
+  for(c = cpus; c < cpus+ncpu; c++){
+801038e6:	c7 45 f4 80 23 11 80 	movl   $0x80112380,-0xc(%ebp)
+801038ed:	e9 86 00 00 00       	jmp    80103978 <startothers+0xc4>
+    if(c == cpus+cpunum())  // We've started already.
+801038f2:	e8 10 f6 ff ff       	call   80102f07 <cpunum>
+801038f7:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
+801038fd:	05 80 23 11 80       	add    $0x80112380,%eax
+80103902:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80103905:	74 69                	je     80103970 <startothers+0xbc>
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what 
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+80103907:	e8 3f f2 ff ff       	call   80102b4b <kalloc>
+8010390c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    *(void**)(code-4) = stack + KSTACKSIZE;
+8010390f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103912:	83 e8 04             	sub    $0x4,%eax
+80103915:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80103918:	81 c2 00 10 00 00    	add    $0x1000,%edx
+8010391e:	89 10                	mov    %edx,(%eax)
+    *(void**)(code-8) = mpenter;
+80103920:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103923:	83 e8 08             	sub    $0x8,%eax
+80103926:	c7 00 53 38 10 80    	movl   $0x80103853,(%eax)
+    *(int**)(code-12) = (void *) v2p(entrypgdir);
+8010392c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010392f:	8d 58 f4             	lea    -0xc(%eax),%ebx
+80103932:	c7 04 24 00 a0 10 80 	movl   $0x8010a000,(%esp)
+80103939:	e8 26 fe ff ff       	call   80103764 <v2p>
+8010393e:	89 03                	mov    %eax,(%ebx)
+
+    lapicstartap(c->id, v2p(code));
+80103940:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103943:	89 04 24             	mov    %eax,(%esp)
+80103946:	e8 19 fe ff ff       	call   80103764 <v2p>
+8010394b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010394e:	0f b6 12             	movzbl (%edx),%edx
+80103951:	0f b6 d2             	movzbl %dl,%edx
+80103954:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103958:	89 14 24             	mov    %edx,(%esp)
+8010395b:	e8 2d f6 ff ff       	call   80102f8d <lapicstartap>
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+80103960:	90                   	nop
+80103961:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103964:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
+8010396a:	85 c0                	test   %eax,%eax
+8010396c:	74 f3                	je     80103961 <startothers+0xad>
+8010396e:	eb 01                	jmp    80103971 <startothers+0xbd>
+  code = p2v(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+
+  for(c = cpus; c < cpus+ncpu; c++){
+    if(c == cpus+cpunum())  // We've started already.
+      continue;
+80103970:	90                   	nop
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = p2v(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+
+  for(c = cpus; c < cpus+ncpu; c++){
+80103971:	81 45 f4 bc 00 00 00 	addl   $0xbc,-0xc(%ebp)
+80103978:	a1 60 29 11 80       	mov    0x80112960,%eax
+8010397d:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
+80103983:	05 80 23 11 80       	add    $0x80112380,%eax
+80103988:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+8010398b:	0f 87 61 ff ff ff    	ja     801038f2 <startothers+0x3e>
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+      ;
+  }
+}
+80103991:	83 c4 24             	add    $0x24,%esp
+80103994:	5b                   	pop    %ebx
+80103995:	5d                   	pop    %ebp
+80103996:	c3                   	ret    
+	...
+
+80103998 <p2v>:
+80103998:	55                   	push   %ebp
+80103999:	89 e5                	mov    %esp,%ebp
+8010399b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010399e:	05 00 00 00 80       	add    $0x80000000,%eax
+801039a3:	5d                   	pop    %ebp
+801039a4:	c3                   	ret    
+
+801039a5 <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+801039a5:	55                   	push   %ebp
+801039a6:	89 e5                	mov    %esp,%ebp
+801039a8:	53                   	push   %ebx
+801039a9:	83 ec 14             	sub    $0x14,%esp
+801039ac:	8b 45 08             	mov    0x8(%ebp),%eax
+801039af:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801039b3:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+801039b7:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+801039bb:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+801039bf:	ec                   	in     (%dx),%al
+801039c0:	89 c3                	mov    %eax,%ebx
+801039c2:	88 5d fb             	mov    %bl,-0x5(%ebp)
+  return data;
+801039c5:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+}
+801039c9:	83 c4 14             	add    $0x14,%esp
+801039cc:	5b                   	pop    %ebx
+801039cd:	5d                   	pop    %ebp
+801039ce:	c3                   	ret    
+
+801039cf <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+801039cf:	55                   	push   %ebp
+801039d0:	89 e5                	mov    %esp,%ebp
+801039d2:	83 ec 08             	sub    $0x8,%esp
+801039d5:	8b 55 08             	mov    0x8(%ebp),%edx
+801039d8:	8b 45 0c             	mov    0xc(%ebp),%eax
+801039db:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+801039df:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801039e2:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+801039e6:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+801039ea:	ee                   	out    %al,(%dx)
+}
+801039eb:	c9                   	leave  
+801039ec:	c3                   	ret    
+
+801039ed <mpbcpu>:
+int ncpu;
+uchar ioapicid;
+
+int
+mpbcpu(void)
+{
+801039ed:	55                   	push   %ebp
+801039ee:	89 e5                	mov    %esp,%ebp
+  return bcpu-cpus;
+801039f0:	a1 64 b6 10 80       	mov    0x8010b664,%eax
+801039f5:	89 c2                	mov    %eax,%edx
+801039f7:	b8 80 23 11 80       	mov    $0x80112380,%eax
+801039fc:	89 d1                	mov    %edx,%ecx
+801039fe:	29 c1                	sub    %eax,%ecx
+80103a00:	89 c8                	mov    %ecx,%eax
+80103a02:	c1 f8 02             	sar    $0x2,%eax
+80103a05:	69 c0 cf 46 7d 67    	imul   $0x677d46cf,%eax,%eax
+}
+80103a0b:	5d                   	pop    %ebp
+80103a0c:	c3                   	ret    
+
+80103a0d <sum>:
+
+static uchar
+sum(uchar *addr, int len)
+{
+80103a0d:	55                   	push   %ebp
+80103a0e:	89 e5                	mov    %esp,%ebp
+80103a10:	83 ec 10             	sub    $0x10,%esp
+  int i, sum;
+  
+  sum = 0;
+80103a13:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+  for(i=0; i<len; i++)
+80103a1a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+80103a21:	eb 15                	jmp    80103a38 <sum+0x2b>
+    sum += addr[i];
+80103a23:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80103a26:	8b 45 08             	mov    0x8(%ebp),%eax
+80103a29:	01 d0                	add    %edx,%eax
+80103a2b:	0f b6 00             	movzbl (%eax),%eax
+80103a2e:	0f b6 c0             	movzbl %al,%eax
+80103a31:	01 45 f8             	add    %eax,-0x8(%ebp)
+sum(uchar *addr, int len)
+{
+  int i, sum;
+  
+  sum = 0;
+  for(i=0; i<len; i++)
+80103a34:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+80103a38:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80103a3b:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80103a3e:	7c e3                	jl     80103a23 <sum+0x16>
+    sum += addr[i];
+  return sum;
+80103a40:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80103a43:	c9                   	leave  
+80103a44:	c3                   	ret    
+
+80103a45 <mpsearch1>:
+
+// Look for an MP structure in the len bytes at addr.
+static struct mp*
+mpsearch1(uint a, int len)
+{
+80103a45:	55                   	push   %ebp
+80103a46:	89 e5                	mov    %esp,%ebp
+80103a48:	83 ec 28             	sub    $0x28,%esp
+  uchar *e, *p, *addr;
+
+  addr = p2v(a);
+80103a4b:	8b 45 08             	mov    0x8(%ebp),%eax
+80103a4e:	89 04 24             	mov    %eax,(%esp)
+80103a51:	e8 42 ff ff ff       	call   80103998 <p2v>
+80103a56:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  e = addr+len;
+80103a59:	8b 55 0c             	mov    0xc(%ebp),%edx
+80103a5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103a5f:	01 d0                	add    %edx,%eax
+80103a61:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  for(p = addr; p < e; p += sizeof(struct mp))
+80103a64:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103a67:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103a6a:	eb 3f                	jmp    80103aab <mpsearch1+0x66>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80103a6c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+80103a73:	00 
+80103a74:	c7 44 24 04 b0 89 10 	movl   $0x801089b0,0x4(%esp)
+80103a7b:	80 
+80103a7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103a7f:	89 04 24             	mov    %eax,(%esp)
+80103a82:	e8 3e 18 00 00       	call   801052c5 <memcmp>
+80103a87:	85 c0                	test   %eax,%eax
+80103a89:	75 1c                	jne    80103aa7 <mpsearch1+0x62>
+80103a8b:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+80103a92:	00 
+80103a93:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103a96:	89 04 24             	mov    %eax,(%esp)
+80103a99:	e8 6f ff ff ff       	call   80103a0d <sum>
+80103a9e:	84 c0                	test   %al,%al
+80103aa0:	75 05                	jne    80103aa7 <mpsearch1+0x62>
+      return (struct mp*)p;
+80103aa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103aa5:	eb 11                	jmp    80103ab8 <mpsearch1+0x73>
+{
+  uchar *e, *p, *addr;
+
+  addr = p2v(a);
+  e = addr+len;
+  for(p = addr; p < e; p += sizeof(struct mp))
+80103aa7:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
+80103aab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103aae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80103ab1:	72 b9                	jb     80103a6c <mpsearch1+0x27>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+      return (struct mp*)p;
+  return 0;
+80103ab3:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80103ab8:	c9                   	leave  
+80103ab9:	c3                   	ret    
+
+80103aba <mpsearch>:
+// 1) in the first KB of the EBDA;
+// 2) in the last KB of system base memory;
+// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
+static struct mp*
+mpsearch(void)
+{
+80103aba:	55                   	push   %ebp
+80103abb:	89 e5                	mov    %esp,%ebp
+80103abd:	83 ec 28             	sub    $0x28,%esp
+  uchar *bda;
+  uint p;
+  struct mp *mp;
+
+  bda = (uchar *) P2V(0x400);
+80103ac0:	c7 45 f4 00 04 00 80 	movl   $0x80000400,-0xc(%ebp)
+  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+80103ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103aca:	83 c0 0f             	add    $0xf,%eax
+80103acd:	0f b6 00             	movzbl (%eax),%eax
+80103ad0:	0f b6 c0             	movzbl %al,%eax
+80103ad3:	89 c2                	mov    %eax,%edx
+80103ad5:	c1 e2 08             	shl    $0x8,%edx
+80103ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103adb:	83 c0 0e             	add    $0xe,%eax
+80103ade:	0f b6 00             	movzbl (%eax),%eax
+80103ae1:	0f b6 c0             	movzbl %al,%eax
+80103ae4:	09 d0                	or     %edx,%eax
+80103ae6:	c1 e0 04             	shl    $0x4,%eax
+80103ae9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80103aec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80103af0:	74 21                	je     80103b13 <mpsearch+0x59>
+    if((mp = mpsearch1(p, 1024)))
+80103af2:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
+80103af9:	00 
+80103afa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103afd:	89 04 24             	mov    %eax,(%esp)
+80103b00:	e8 40 ff ff ff       	call   80103a45 <mpsearch1>
+80103b05:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80103b08:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80103b0c:	74 50                	je     80103b5e <mpsearch+0xa4>
+      return mp;
+80103b0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103b11:	eb 5f                	jmp    80103b72 <mpsearch+0xb8>
+  } else {
+    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+80103b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103b16:	83 c0 14             	add    $0x14,%eax
+80103b19:	0f b6 00             	movzbl (%eax),%eax
+80103b1c:	0f b6 c0             	movzbl %al,%eax
+80103b1f:	89 c2                	mov    %eax,%edx
+80103b21:	c1 e2 08             	shl    $0x8,%edx
+80103b24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103b27:	83 c0 13             	add    $0x13,%eax
+80103b2a:	0f b6 00             	movzbl (%eax),%eax
+80103b2d:	0f b6 c0             	movzbl %al,%eax
+80103b30:	09 d0                	or     %edx,%eax
+80103b32:	c1 e0 0a             	shl    $0xa,%eax
+80103b35:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if((mp = mpsearch1(p-1024, 1024)))
+80103b38:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103b3b:	2d 00 04 00 00       	sub    $0x400,%eax
+80103b40:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
+80103b47:	00 
+80103b48:	89 04 24             	mov    %eax,(%esp)
+80103b4b:	e8 f5 fe ff ff       	call   80103a45 <mpsearch1>
+80103b50:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80103b53:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80103b57:	74 05                	je     80103b5e <mpsearch+0xa4>
+      return mp;
+80103b59:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103b5c:	eb 14                	jmp    80103b72 <mpsearch+0xb8>
+  }
+  return mpsearch1(0xF0000, 0x10000);
+80103b5e:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
+80103b65:	00 
+80103b66:	c7 04 24 00 00 0f 00 	movl   $0xf0000,(%esp)
+80103b6d:	e8 d3 fe ff ff       	call   80103a45 <mpsearch1>
+}
+80103b72:	c9                   	leave  
+80103b73:	c3                   	ret    
+
+80103b74 <mpconfig>:
+// Check for correct signature, calculate the checksum and,
+// if correct, check the version.
+// To do: check extended table checksum.
+static struct mpconf*
+mpconfig(struct mp **pmp)
+{
+80103b74:	55                   	push   %ebp
+80103b75:	89 e5                	mov    %esp,%ebp
+80103b77:	83 ec 28             	sub    $0x28,%esp
+  struct mpconf *conf;
+  struct mp *mp;
+
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103b7a:	e8 3b ff ff ff       	call   80103aba <mpsearch>
+80103b7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103b82:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80103b86:	74 0a                	je     80103b92 <mpconfig+0x1e>
+80103b88:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103b8b:	8b 40 04             	mov    0x4(%eax),%eax
+80103b8e:	85 c0                	test   %eax,%eax
+80103b90:	75 0a                	jne    80103b9c <mpconfig+0x28>
+    return 0;
+80103b92:	b8 00 00 00 00       	mov    $0x0,%eax
+80103b97:	e9 83 00 00 00       	jmp    80103c1f <mpconfig+0xab>
+  conf = (struct mpconf*) p2v((uint) mp->physaddr);
+80103b9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103b9f:	8b 40 04             	mov    0x4(%eax),%eax
+80103ba2:	89 04 24             	mov    %eax,(%esp)
+80103ba5:	e8 ee fd ff ff       	call   80103998 <p2v>
+80103baa:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103bad:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+80103bb4:	00 
+80103bb5:	c7 44 24 04 b5 89 10 	movl   $0x801089b5,0x4(%esp)
+80103bbc:	80 
+80103bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103bc0:	89 04 24             	mov    %eax,(%esp)
+80103bc3:	e8 fd 16 00 00       	call   801052c5 <memcmp>
+80103bc8:	85 c0                	test   %eax,%eax
+80103bca:	74 07                	je     80103bd3 <mpconfig+0x5f>
+    return 0;
+80103bcc:	b8 00 00 00 00       	mov    $0x0,%eax
+80103bd1:	eb 4c                	jmp    80103c1f <mpconfig+0xab>
+  if(conf->version != 1 && conf->version != 4)
+80103bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103bd6:	0f b6 40 06          	movzbl 0x6(%eax),%eax
+80103bda:	3c 01                	cmp    $0x1,%al
+80103bdc:	74 12                	je     80103bf0 <mpconfig+0x7c>
+80103bde:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103be1:	0f b6 40 06          	movzbl 0x6(%eax),%eax
+80103be5:	3c 04                	cmp    $0x4,%al
+80103be7:	74 07                	je     80103bf0 <mpconfig+0x7c>
+    return 0;
+80103be9:	b8 00 00 00 00       	mov    $0x0,%eax
+80103bee:	eb 2f                	jmp    80103c1f <mpconfig+0xab>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103bf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103bf3:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+80103bf7:	0f b7 c0             	movzwl %ax,%eax
+80103bfa:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103bfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c01:	89 04 24             	mov    %eax,(%esp)
+80103c04:	e8 04 fe ff ff       	call   80103a0d <sum>
+80103c09:	84 c0                	test   %al,%al
+80103c0b:	74 07                	je     80103c14 <mpconfig+0xa0>
+    return 0;
+80103c0d:	b8 00 00 00 00       	mov    $0x0,%eax
+80103c12:	eb 0b                	jmp    80103c1f <mpconfig+0xab>
+  *pmp = mp;
+80103c14:	8b 45 08             	mov    0x8(%ebp),%eax
+80103c17:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80103c1a:	89 10                	mov    %edx,(%eax)
+  return conf;
+80103c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+80103c1f:	c9                   	leave  
+80103c20:	c3                   	ret    
+
+80103c21 <mpinit>:
+
+void
+mpinit(void)
+{
+80103c21:	55                   	push   %ebp
+80103c22:	89 e5                	mov    %esp,%ebp
+80103c24:	83 ec 38             	sub    $0x38,%esp
+  struct mp *mp;
+  struct mpconf *conf;
+  struct mpproc *proc;
+  struct mpioapic *ioapic;
+
+  bcpu = &cpus[0];
+80103c27:	c7 05 64 b6 10 80 80 	movl   $0x80112380,0x8010b664
+80103c2e:	23 11 80 
+  if((conf = mpconfig(&mp)) == 0)
+80103c31:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80103c34:	89 04 24             	mov    %eax,(%esp)
+80103c37:	e8 38 ff ff ff       	call   80103b74 <mpconfig>
+80103c3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80103c3f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80103c43:	0f 84 9c 01 00 00    	je     80103de5 <mpinit+0x1c4>
+    return;
+  ismp = 1;
+80103c49:	c7 05 64 23 11 80 01 	movl   $0x1,0x80112364
+80103c50:	00 00 00 
+  lapic = (uint*)conf->lapicaddr;
+80103c53:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c56:	8b 40 24             	mov    0x24(%eax),%eax
+80103c59:	a3 7c 22 11 80       	mov    %eax,0x8011227c
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+80103c5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c61:	83 c0 2c             	add    $0x2c,%eax
+80103c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103c67:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c6a:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+80103c6e:	0f b7 d0             	movzwl %ax,%edx
+80103c71:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c74:	01 d0                	add    %edx,%eax
+80103c76:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80103c79:	e9 f4 00 00 00       	jmp    80103d72 <mpinit+0x151>
+    switch(*p){
+80103c7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103c81:	0f b6 00             	movzbl (%eax),%eax
+80103c84:	0f b6 c0             	movzbl %al,%eax
+80103c87:	83 f8 04             	cmp    $0x4,%eax
+80103c8a:	0f 87 bf 00 00 00    	ja     80103d4f <mpinit+0x12e>
+80103c90:	8b 04 85 f8 89 10 80 	mov    -0x7fef7608(,%eax,4),%eax
+80103c97:	ff e0                	jmp    *%eax
+    case MPPROC:
+      proc = (struct mpproc*)p;
+80103c99:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103c9c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if(ncpu != proc->apicid){
+80103c9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80103ca2:	0f b6 40 01          	movzbl 0x1(%eax),%eax
+80103ca6:	0f b6 d0             	movzbl %al,%edx
+80103ca9:	a1 60 29 11 80       	mov    0x80112960,%eax
+80103cae:	39 c2                	cmp    %eax,%edx
+80103cb0:	74 2d                	je     80103cdf <mpinit+0xbe>
+        cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
+80103cb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80103cb5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
+80103cb9:	0f b6 d0             	movzbl %al,%edx
+80103cbc:	a1 60 29 11 80       	mov    0x80112960,%eax
+80103cc1:	89 54 24 08          	mov    %edx,0x8(%esp)
+80103cc5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103cc9:	c7 04 24 ba 89 10 80 	movl   $0x801089ba,(%esp)
+80103cd0:	e8 d5 c6 ff ff       	call   801003aa <cprintf>
+        ismp = 0;
+80103cd5:	c7 05 64 23 11 80 00 	movl   $0x0,0x80112364
+80103cdc:	00 00 00 
+      }
+      if(proc->flags & MPBOOT)
+80103cdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80103ce2:	0f b6 40 03          	movzbl 0x3(%eax),%eax
+80103ce6:	0f b6 c0             	movzbl %al,%eax
+80103ce9:	83 e0 02             	and    $0x2,%eax
+80103cec:	85 c0                	test   %eax,%eax
+80103cee:	74 15                	je     80103d05 <mpinit+0xe4>
+        bcpu = &cpus[ncpu];
+80103cf0:	a1 60 29 11 80       	mov    0x80112960,%eax
+80103cf5:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
+80103cfb:	05 80 23 11 80       	add    $0x80112380,%eax
+80103d00:	a3 64 b6 10 80       	mov    %eax,0x8010b664
+      cpus[ncpu].id = ncpu;
+80103d05:	8b 15 60 29 11 80    	mov    0x80112960,%edx
+80103d0b:	a1 60 29 11 80       	mov    0x80112960,%eax
+80103d10:	69 d2 bc 00 00 00    	imul   $0xbc,%edx,%edx
+80103d16:	81 c2 80 23 11 80    	add    $0x80112380,%edx
+80103d1c:	88 02                	mov    %al,(%edx)
+      ncpu++;
+80103d1e:	a1 60 29 11 80       	mov    0x80112960,%eax
+80103d23:	83 c0 01             	add    $0x1,%eax
+80103d26:	a3 60 29 11 80       	mov    %eax,0x80112960
+      p += sizeof(struct mpproc);
+80103d2b:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
+      continue;
+80103d2f:	eb 41                	jmp    80103d72 <mpinit+0x151>
+    case MPIOAPIC:
+      ioapic = (struct mpioapic*)p;
+80103d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103d34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+      ioapicid = ioapic->apicno;
+80103d37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80103d3a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
+80103d3e:	a2 60 23 11 80       	mov    %al,0x80112360
+      p += sizeof(struct mpioapic);
+80103d43:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
+      continue;
+80103d47:	eb 29                	jmp    80103d72 <mpinit+0x151>
+    case MPBUS:
+    case MPIOINTR:
+    case MPLINTR:
+      p += 8;
+80103d49:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
+      continue;
+80103d4d:	eb 23                	jmp    80103d72 <mpinit+0x151>
+    default:
+      cprintf("mpinit: unknown config type %x\n", *p);
+80103d4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103d52:	0f b6 00             	movzbl (%eax),%eax
+80103d55:	0f b6 c0             	movzbl %al,%eax
+80103d58:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103d5c:	c7 04 24 d8 89 10 80 	movl   $0x801089d8,(%esp)
+80103d63:	e8 42 c6 ff ff       	call   801003aa <cprintf>
+      ismp = 0;
+80103d68:	c7 05 64 23 11 80 00 	movl   $0x0,0x80112364
+80103d6f:	00 00 00 
+  bcpu = &cpus[0];
+  if((conf = mpconfig(&mp)) == 0)
+    return;
+  ismp = 1;
+  lapic = (uint*)conf->lapicaddr;
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+80103d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103d75:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80103d78:	0f 82 00 ff ff ff    	jb     80103c7e <mpinit+0x5d>
+    default:
+      cprintf("mpinit: unknown config type %x\n", *p);
+      ismp = 0;
+    }
+  }
+  if(!ismp){
+80103d7e:	a1 64 23 11 80       	mov    0x80112364,%eax
+80103d83:	85 c0                	test   %eax,%eax
+80103d85:	75 1d                	jne    80103da4 <mpinit+0x183>
+    // Didn't like what we found; fall back to no MP.
+    ncpu = 1;
+80103d87:	c7 05 60 29 11 80 01 	movl   $0x1,0x80112960
+80103d8e:	00 00 00 
+    lapic = 0;
+80103d91:	c7 05 7c 22 11 80 00 	movl   $0x0,0x8011227c
+80103d98:	00 00 00 
+    ioapicid = 0;
+80103d9b:	c6 05 60 23 11 80 00 	movb   $0x0,0x80112360
+80103da2:	eb 41                	jmp    80103de5 <mpinit+0x1c4>
+    return;
+  }
+
+  if(mp->imcrp){
+80103da4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80103da7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
+80103dab:	84 c0                	test   %al,%al
+80103dad:	74 36                	je     80103de5 <mpinit+0x1c4>
+    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    // But it would on real hardware.
+    outb(0x22, 0x70);   // Select IMCR
+80103daf:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
+80103db6:	00 
+80103db7:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
+80103dbe:	e8 0c fc ff ff       	call   801039cf <outb>
+    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+80103dc3:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
+80103dca:	e8 d6 fb ff ff       	call   801039a5 <inb>
+80103dcf:	83 c8 01             	or     $0x1,%eax
+80103dd2:	0f b6 c0             	movzbl %al,%eax
+80103dd5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103dd9:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
+80103de0:	e8 ea fb ff ff       	call   801039cf <outb>
+  }
+}
+80103de5:	c9                   	leave  
+80103de6:	c3                   	ret    
+	...
+
+80103de8 <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+80103de8:	55                   	push   %ebp
+80103de9:	89 e5                	mov    %esp,%ebp
+80103deb:	83 ec 08             	sub    $0x8,%esp
+80103dee:	8b 55 08             	mov    0x8(%ebp),%edx
+80103df1:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103df4:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+80103df8:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80103dfb:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80103dff:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80103e03:	ee                   	out    %al,(%dx)
+}
+80103e04:	c9                   	leave  
+80103e05:	c3                   	ret    
+
+80103e06 <picsetmask>:
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
+
+static void
+picsetmask(ushort mask)
+{
+80103e06:	55                   	push   %ebp
+80103e07:	89 e5                	mov    %esp,%ebp
+80103e09:	83 ec 0c             	sub    $0xc,%esp
+80103e0c:	8b 45 08             	mov    0x8(%ebp),%eax
+80103e0f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  irqmask = mask;
+80103e13:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+80103e17:	66 a3 00 b0 10 80    	mov    %ax,0x8010b000
+  outb(IO_PIC1+1, mask);
+80103e1d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+80103e21:	0f b6 c0             	movzbl %al,%eax
+80103e24:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103e28:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
+80103e2f:	e8 b4 ff ff ff       	call   80103de8 <outb>
+  outb(IO_PIC2+1, mask >> 8);
+80103e34:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+80103e38:	66 c1 e8 08          	shr    $0x8,%ax
+80103e3c:	0f b6 c0             	movzbl %al,%eax
+80103e3f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103e43:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
+80103e4a:	e8 99 ff ff ff       	call   80103de8 <outb>
+}
+80103e4f:	c9                   	leave  
+80103e50:	c3                   	ret    
+
+80103e51 <picenable>:
+
+void
+picenable(int irq)
+{
+80103e51:	55                   	push   %ebp
+80103e52:	89 e5                	mov    %esp,%ebp
+80103e54:	53                   	push   %ebx
+80103e55:	83 ec 04             	sub    $0x4,%esp
+  picsetmask(irqmask & ~(1<<irq));
+80103e58:	8b 45 08             	mov    0x8(%ebp),%eax
+80103e5b:	ba 01 00 00 00       	mov    $0x1,%edx
+80103e60:	89 d3                	mov    %edx,%ebx
+80103e62:	89 c1                	mov    %eax,%ecx
+80103e64:	d3 e3                	shl    %cl,%ebx
+80103e66:	89 d8                	mov    %ebx,%eax
+80103e68:	89 c2                	mov    %eax,%edx
+80103e6a:	f7 d2                	not    %edx
+80103e6c:	0f b7 05 00 b0 10 80 	movzwl 0x8010b000,%eax
+80103e73:	21 d0                	and    %edx,%eax
+80103e75:	0f b7 c0             	movzwl %ax,%eax
+80103e78:	89 04 24             	mov    %eax,(%esp)
+80103e7b:	e8 86 ff ff ff       	call   80103e06 <picsetmask>
+}
+80103e80:	83 c4 04             	add    $0x4,%esp
+80103e83:	5b                   	pop    %ebx
+80103e84:	5d                   	pop    %ebp
+80103e85:	c3                   	ret    
+
+80103e86 <picinit>:
+
+// Initialize the 8259A interrupt controllers.
+void
+picinit(void)
+{
+80103e86:	55                   	push   %ebp
+80103e87:	89 e5                	mov    %esp,%ebp
+80103e89:	83 ec 08             	sub    $0x8,%esp
+  // mask all interrupts
+  outb(IO_PIC1+1, 0xFF);
+80103e8c:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
+80103e93:	00 
+80103e94:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
+80103e9b:	e8 48 ff ff ff       	call   80103de8 <outb>
+  outb(IO_PIC2+1, 0xFF);
+80103ea0:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
+80103ea7:	00 
+80103ea8:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
+80103eaf:	e8 34 ff ff ff       	call   80103de8 <outb>
+
+  // ICW1:  0001g0hi
+  //    g:  0 = edge triggering, 1 = level triggering
+  //    h:  0 = cascaded PICs, 1 = master only
+  //    i:  0 = no ICW4, 1 = ICW4 required
+  outb(IO_PIC1, 0x11);
+80103eb4:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
+80103ebb:	00 
+80103ebc:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+80103ec3:	e8 20 ff ff ff       	call   80103de8 <outb>
+
+  // ICW2:  Vector offset
+  outb(IO_PIC1+1, T_IRQ0);
+80103ec8:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
+80103ecf:	00 
+80103ed0:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
+80103ed7:	e8 0c ff ff ff       	call   80103de8 <outb>
+
+  // ICW3:  (master PIC) bit mask of IR lines connected to slaves
+  //        (slave PIC) 3-bit # of slave's connection to master
+  outb(IO_PIC1+1, 1<<IRQ_SLAVE);
+80103edc:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
+80103ee3:	00 
+80103ee4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
+80103eeb:	e8 f8 fe ff ff       	call   80103de8 <outb>
+  //    m:  0 = slave PIC, 1 = master PIC
+  //      (ignored when b is 0, as the master/slave role
+  //      can be hardwired).
+  //    a:  1 = Automatic EOI mode
+  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
+  outb(IO_PIC1+1, 0x3);
+80103ef0:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+80103ef7:	00 
+80103ef8:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
+80103eff:	e8 e4 fe ff ff       	call   80103de8 <outb>
+
+  // Set up slave (8259A-2)
+  outb(IO_PIC2, 0x11);                  // ICW1
+80103f04:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
+80103f0b:	00 
+80103f0c:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
+80103f13:	e8 d0 fe ff ff       	call   80103de8 <outb>
+  outb(IO_PIC2+1, T_IRQ0 + 8);      // ICW2
+80103f18:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
+80103f1f:	00 
+80103f20:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
+80103f27:	e8 bc fe ff ff       	call   80103de8 <outb>
+  outb(IO_PIC2+1, IRQ_SLAVE);           // ICW3
+80103f2c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+80103f33:	00 
+80103f34:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
+80103f3b:	e8 a8 fe ff ff       	call   80103de8 <outb>
+  // NB Automatic EOI mode doesn't tend to work on the slave.
+  // Linux source code says it's "to be investigated".
+  outb(IO_PIC2+1, 0x3);                 // ICW4
+80103f40:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+80103f47:	00 
+80103f48:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
+80103f4f:	e8 94 fe ff ff       	call   80103de8 <outb>
+
+  // OCW3:  0ef01prs
+  //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
+  //    p:  0 = no polling, 1 = polling mode
+  //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
+  outb(IO_PIC1, 0x68);             // clear specific mask
+80103f54:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
+80103f5b:	00 
+80103f5c:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+80103f63:	e8 80 fe ff ff       	call   80103de8 <outb>
+  outb(IO_PIC1, 0x0a);             // read IRR by default
+80103f68:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+80103f6f:	00 
+80103f70:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+80103f77:	e8 6c fe ff ff       	call   80103de8 <outb>
+
+  outb(IO_PIC2, 0x68);             // OCW3
+80103f7c:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
+80103f83:	00 
+80103f84:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
+80103f8b:	e8 58 fe ff ff       	call   80103de8 <outb>
+  outb(IO_PIC2, 0x0a);             // OCW3
+80103f90:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+80103f97:	00 
+80103f98:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
+80103f9f:	e8 44 fe ff ff       	call   80103de8 <outb>
+
+  if(irqmask != 0xFFFF)
+80103fa4:	0f b7 05 00 b0 10 80 	movzwl 0x8010b000,%eax
+80103fab:	66 83 f8 ff          	cmp    $0xffff,%ax
+80103faf:	74 12                	je     80103fc3 <picinit+0x13d>
+    picsetmask(irqmask);
+80103fb1:	0f b7 05 00 b0 10 80 	movzwl 0x8010b000,%eax
+80103fb8:	0f b7 c0             	movzwl %ax,%eax
+80103fbb:	89 04 24             	mov    %eax,(%esp)
+80103fbe:	e8 43 fe ff ff       	call   80103e06 <picsetmask>
+}
+80103fc3:	c9                   	leave  
+80103fc4:	c3                   	ret    
+80103fc5:	00 00                	add    %al,(%eax)
+	...
+
+80103fc8 <pipealloc>:
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+80103fc8:	55                   	push   %ebp
+80103fc9:	89 e5                	mov    %esp,%ebp
+80103fcb:	83 ec 28             	sub    $0x28,%esp
+  struct pipe *p;
+
+  p = 0;
+80103fce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  *f0 = *f1 = 0;
+80103fd5:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103fd8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+80103fde:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103fe1:	8b 10                	mov    (%eax),%edx
+80103fe3:	8b 45 08             	mov    0x8(%ebp),%eax
+80103fe6:	89 10                	mov    %edx,(%eax)
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+80103fe8:	e8 63 cf ff ff       	call   80100f50 <filealloc>
+80103fed:	8b 55 08             	mov    0x8(%ebp),%edx
+80103ff0:	89 02                	mov    %eax,(%edx)
+80103ff2:	8b 45 08             	mov    0x8(%ebp),%eax
+80103ff5:	8b 00                	mov    (%eax),%eax
+80103ff7:	85 c0                	test   %eax,%eax
+80103ff9:	0f 84 c8 00 00 00    	je     801040c7 <pipealloc+0xff>
+80103fff:	e8 4c cf ff ff       	call   80100f50 <filealloc>
+80104004:	8b 55 0c             	mov    0xc(%ebp),%edx
+80104007:	89 02                	mov    %eax,(%edx)
+80104009:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010400c:	8b 00                	mov    (%eax),%eax
+8010400e:	85 c0                	test   %eax,%eax
+80104010:	0f 84 b1 00 00 00    	je     801040c7 <pipealloc+0xff>
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+80104016:	e8 30 eb ff ff       	call   80102b4b <kalloc>
+8010401b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010401e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80104022:	0f 84 9e 00 00 00    	je     801040c6 <pipealloc+0xfe>
+    goto bad;
+  p->readopen = 1;
+80104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010402b:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
+80104032:	00 00 00 
+  p->writeopen = 1;
+80104035:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104038:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
+8010403f:	00 00 00 
+  p->nwrite = 0;
+80104042:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104045:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
+8010404c:	00 00 00 
+  p->nread = 0;
+8010404f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104052:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
+80104059:	00 00 00 
+  initlock(&p->lock, "pipe");
+8010405c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010405f:	c7 44 24 04 0c 8a 10 	movl   $0x80108a0c,0x4(%esp)
+80104066:	80 
+80104067:	89 04 24             	mov    %eax,(%esp)
+8010406a:	e8 63 0f 00 00       	call   80104fd2 <initlock>
+  (*f0)->type = FD_PIPE;
+8010406f:	8b 45 08             	mov    0x8(%ebp),%eax
+80104072:	8b 00                	mov    (%eax),%eax
+80104074:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f0)->readable = 1;
+8010407a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010407d:	8b 00                	mov    (%eax),%eax
+8010407f:	c6 40 08 01          	movb   $0x1,0x8(%eax)
+  (*f0)->writable = 0;
+80104083:	8b 45 08             	mov    0x8(%ebp),%eax
+80104086:	8b 00                	mov    (%eax),%eax
+80104088:	c6 40 09 00          	movb   $0x0,0x9(%eax)
+  (*f0)->pipe = p;
+8010408c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010408f:	8b 00                	mov    (%eax),%eax
+80104091:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104094:	89 50 0c             	mov    %edx,0xc(%eax)
+  (*f1)->type = FD_PIPE;
+80104097:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010409a:	8b 00                	mov    (%eax),%eax
+8010409c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f1)->readable = 0;
+801040a2:	8b 45 0c             	mov    0xc(%ebp),%eax
+801040a5:	8b 00                	mov    (%eax),%eax
+801040a7:	c6 40 08 00          	movb   $0x0,0x8(%eax)
+  (*f1)->writable = 1;
+801040ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+801040ae:	8b 00                	mov    (%eax),%eax
+801040b0:	c6 40 09 01          	movb   $0x1,0x9(%eax)
+  (*f1)->pipe = p;
+801040b4:	8b 45 0c             	mov    0xc(%ebp),%eax
+801040b7:	8b 00                	mov    (%eax),%eax
+801040b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801040bc:	89 50 0c             	mov    %edx,0xc(%eax)
+  return 0;
+801040bf:	b8 00 00 00 00       	mov    $0x0,%eax
+801040c4:	eb 43                	jmp    80104109 <pipealloc+0x141>
+  p = 0;
+  *f0 = *f1 = 0;
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+    goto bad;
+801040c6:	90                   	nop
+  (*f1)->pipe = p;
+  return 0;
+
+//PAGEBREAK: 20
+ bad:
+  if(p)
+801040c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801040cb:	74 0b                	je     801040d8 <pipealloc+0x110>
+    kfree((char*)p);
+801040cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801040d0:	89 04 24             	mov    %eax,(%esp)
+801040d3:	e8 da e9 ff ff       	call   80102ab2 <kfree>
+  if(*f0)
+801040d8:	8b 45 08             	mov    0x8(%ebp),%eax
+801040db:	8b 00                	mov    (%eax),%eax
+801040dd:	85 c0                	test   %eax,%eax
+801040df:	74 0d                	je     801040ee <pipealloc+0x126>
+    fileclose(*f0);
+801040e1:	8b 45 08             	mov    0x8(%ebp),%eax
+801040e4:	8b 00                	mov    (%eax),%eax
+801040e6:	89 04 24             	mov    %eax,(%esp)
+801040e9:	e8 0a cf ff ff       	call   80100ff8 <fileclose>
+  if(*f1)
+801040ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+801040f1:	8b 00                	mov    (%eax),%eax
+801040f3:	85 c0                	test   %eax,%eax
+801040f5:	74 0d                	je     80104104 <pipealloc+0x13c>
+    fileclose(*f1);
+801040f7:	8b 45 0c             	mov    0xc(%ebp),%eax
+801040fa:	8b 00                	mov    (%eax),%eax
+801040fc:	89 04 24             	mov    %eax,(%esp)
+801040ff:	e8 f4 ce ff ff       	call   80100ff8 <fileclose>
+  return -1;
+80104104:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104109:	c9                   	leave  
+8010410a:	c3                   	ret    
+
+8010410b <pipeclose>:
+
+void
+pipeclose(struct pipe *p, int writable)
+{
+8010410b:	55                   	push   %ebp
+8010410c:	89 e5                	mov    %esp,%ebp
+8010410e:	83 ec 18             	sub    $0x18,%esp
+  acquire(&p->lock);
+80104111:	8b 45 08             	mov    0x8(%ebp),%eax
+80104114:	89 04 24             	mov    %eax,(%esp)
+80104117:	e8 d7 0e 00 00       	call   80104ff3 <acquire>
+  if(writable){
+8010411c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+80104120:	74 1f                	je     80104141 <pipeclose+0x36>
+    p->writeopen = 0;
+80104122:	8b 45 08             	mov    0x8(%ebp),%eax
+80104125:	c7 80 40 02 00 00 00 	movl   $0x0,0x240(%eax)
+8010412c:	00 00 00 
+    wakeup(&p->nread);
+8010412f:	8b 45 08             	mov    0x8(%ebp),%eax
+80104132:	05 34 02 00 00       	add    $0x234,%eax
+80104137:	89 04 24             	mov    %eax,(%esp)
+8010413a:	e8 af 0c 00 00       	call   80104dee <wakeup>
+8010413f:	eb 1d                	jmp    8010415e <pipeclose+0x53>
+  } else {
+    p->readopen = 0;
+80104141:	8b 45 08             	mov    0x8(%ebp),%eax
+80104144:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%eax)
+8010414b:	00 00 00 
+    wakeup(&p->nwrite);
+8010414e:	8b 45 08             	mov    0x8(%ebp),%eax
+80104151:	05 38 02 00 00       	add    $0x238,%eax
+80104156:	89 04 24             	mov    %eax,(%esp)
+80104159:	e8 90 0c 00 00       	call   80104dee <wakeup>
+  }
+  if(p->readopen == 0 && p->writeopen == 0){
+8010415e:	8b 45 08             	mov    0x8(%ebp),%eax
+80104161:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
+80104167:	85 c0                	test   %eax,%eax
+80104169:	75 25                	jne    80104190 <pipeclose+0x85>
+8010416b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010416e:	8b 80 40 02 00 00    	mov    0x240(%eax),%eax
+80104174:	85 c0                	test   %eax,%eax
+80104176:	75 18                	jne    80104190 <pipeclose+0x85>
+    release(&p->lock);
+80104178:	8b 45 08             	mov    0x8(%ebp),%eax
+8010417b:	89 04 24             	mov    %eax,(%esp)
+8010417e:	e8 d2 0e 00 00       	call   80105055 <release>
+    kfree((char*)p);
+80104183:	8b 45 08             	mov    0x8(%ebp),%eax
+80104186:	89 04 24             	mov    %eax,(%esp)
+80104189:	e8 24 e9 ff ff       	call   80102ab2 <kfree>
+8010418e:	eb 0b                	jmp    8010419b <pipeclose+0x90>
+  } else
+    release(&p->lock);
+80104190:	8b 45 08             	mov    0x8(%ebp),%eax
+80104193:	89 04 24             	mov    %eax,(%esp)
+80104196:	e8 ba 0e 00 00       	call   80105055 <release>
+}
+8010419b:	c9                   	leave  
+8010419c:	c3                   	ret    
+
+8010419d <pipewrite>:
+
+//PAGEBREAK: 40
+int
+pipewrite(struct pipe *p, char *addr, int n)
+{
+8010419d:	55                   	push   %ebp
+8010419e:	89 e5                	mov    %esp,%ebp
+801041a0:	53                   	push   %ebx
+801041a1:	83 ec 24             	sub    $0x24,%esp
+  int i;
+
+  acquire(&p->lock);
+801041a4:	8b 45 08             	mov    0x8(%ebp),%eax
+801041a7:	89 04 24             	mov    %eax,(%esp)
+801041aa:	e8 44 0e 00 00       	call   80104ff3 <acquire>
+  for(i = 0; i < n; i++){
+801041af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801041b6:	e9 a8 00 00 00       	jmp    80104263 <pipewrite+0xc6>
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+      if(p->readopen == 0 || proc->killed){
+801041bb:	8b 45 08             	mov    0x8(%ebp),%eax
+801041be:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
+801041c4:	85 c0                	test   %eax,%eax
+801041c6:	74 0d                	je     801041d5 <pipewrite+0x38>
+801041c8:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801041ce:	8b 40 24             	mov    0x24(%eax),%eax
+801041d1:	85 c0                	test   %eax,%eax
+801041d3:	74 15                	je     801041ea <pipewrite+0x4d>
+        release(&p->lock);
+801041d5:	8b 45 08             	mov    0x8(%ebp),%eax
+801041d8:	89 04 24             	mov    %eax,(%esp)
+801041db:	e8 75 0e 00 00       	call   80105055 <release>
+        return -1;
+801041e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801041e5:	e9 9f 00 00 00       	jmp    80104289 <pipewrite+0xec>
+      }
+      wakeup(&p->nread);
+801041ea:	8b 45 08             	mov    0x8(%ebp),%eax
+801041ed:	05 34 02 00 00       	add    $0x234,%eax
+801041f2:	89 04 24             	mov    %eax,(%esp)
+801041f5:	e8 f4 0b 00 00       	call   80104dee <wakeup>
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+801041fa:	8b 45 08             	mov    0x8(%ebp),%eax
+801041fd:	8b 55 08             	mov    0x8(%ebp),%edx
+80104200:	81 c2 38 02 00 00    	add    $0x238,%edx
+80104206:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010420a:	89 14 24             	mov    %edx,(%esp)
+8010420d:	e8 03 0b 00 00       	call   80104d15 <sleep>
+80104212:	eb 01                	jmp    80104215 <pipewrite+0x78>
+{
+  int i;
+
+  acquire(&p->lock);
+  for(i = 0; i < n; i++){
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+80104214:	90                   	nop
+80104215:	8b 45 08             	mov    0x8(%ebp),%eax
+80104218:	8b 90 38 02 00 00    	mov    0x238(%eax),%edx
+8010421e:	8b 45 08             	mov    0x8(%ebp),%eax
+80104221:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
+80104227:	05 00 02 00 00       	add    $0x200,%eax
+8010422c:	39 c2                	cmp    %eax,%edx
+8010422e:	74 8b                	je     801041bb <pipewrite+0x1e>
+        return -1;
+      }
+      wakeup(&p->nread);
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+    }
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+80104230:	8b 45 08             	mov    0x8(%ebp),%eax
+80104233:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
+80104239:	89 c3                	mov    %eax,%ebx
+8010423b:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
+80104241:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+80104244:	8b 55 0c             	mov    0xc(%ebp),%edx
+80104247:	01 ca                	add    %ecx,%edx
+80104249:	0f b6 0a             	movzbl (%edx),%ecx
+8010424c:	8b 55 08             	mov    0x8(%ebp),%edx
+8010424f:	88 4c 1a 34          	mov    %cl,0x34(%edx,%ebx,1)
+80104253:	8d 50 01             	lea    0x1(%eax),%edx
+80104256:	8b 45 08             	mov    0x8(%ebp),%eax
+80104259:	89 90 38 02 00 00    	mov    %edx,0x238(%eax)
+pipewrite(struct pipe *p, char *addr, int n)
+{
+  int i;
+
+  acquire(&p->lock);
+  for(i = 0; i < n; i++){
+8010425f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80104263:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104266:	3b 45 10             	cmp    0x10(%ebp),%eax
+80104269:	7c a9                	jl     80104214 <pipewrite+0x77>
+      wakeup(&p->nread);
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+    }
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+  }
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+8010426b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010426e:	05 34 02 00 00       	add    $0x234,%eax
+80104273:	89 04 24             	mov    %eax,(%esp)
+80104276:	e8 73 0b 00 00       	call   80104dee <wakeup>
+  release(&p->lock);
+8010427b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010427e:	89 04 24             	mov    %eax,(%esp)
+80104281:	e8 cf 0d 00 00       	call   80105055 <release>
+  return n;
+80104286:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+80104289:	83 c4 24             	add    $0x24,%esp
+8010428c:	5b                   	pop    %ebx
+8010428d:	5d                   	pop    %ebp
+8010428e:	c3                   	ret    
+
+8010428f <piperead>:
+
+int
+piperead(struct pipe *p, char *addr, int n)
+{
+8010428f:	55                   	push   %ebp
+80104290:	89 e5                	mov    %esp,%ebp
+80104292:	53                   	push   %ebx
+80104293:	83 ec 24             	sub    $0x24,%esp
+  int i;
+
+  acquire(&p->lock);
+80104296:	8b 45 08             	mov    0x8(%ebp),%eax
+80104299:	89 04 24             	mov    %eax,(%esp)
+8010429c:	e8 52 0d 00 00       	call   80104ff3 <acquire>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+801042a1:	eb 3a                	jmp    801042dd <piperead+0x4e>
+    if(proc->killed){
+801042a3:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801042a9:	8b 40 24             	mov    0x24(%eax),%eax
+801042ac:	85 c0                	test   %eax,%eax
+801042ae:	74 15                	je     801042c5 <piperead+0x36>
+      release(&p->lock);
+801042b0:	8b 45 08             	mov    0x8(%ebp),%eax
+801042b3:	89 04 24             	mov    %eax,(%esp)
+801042b6:	e8 9a 0d 00 00       	call   80105055 <release>
+      return -1;
+801042bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801042c0:	e9 b7 00 00 00       	jmp    8010437c <piperead+0xed>
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+801042c5:	8b 45 08             	mov    0x8(%ebp),%eax
+801042c8:	8b 55 08             	mov    0x8(%ebp),%edx
+801042cb:	81 c2 34 02 00 00    	add    $0x234,%edx
+801042d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+801042d5:	89 14 24             	mov    %edx,(%esp)
+801042d8:	e8 38 0a 00 00       	call   80104d15 <sleep>
+piperead(struct pipe *p, char *addr, int n)
+{
+  int i;
+
+  acquire(&p->lock);
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+801042dd:	8b 45 08             	mov    0x8(%ebp),%eax
+801042e0:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
+801042e6:	8b 45 08             	mov    0x8(%ebp),%eax
+801042e9:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
+801042ef:	39 c2                	cmp    %eax,%edx
+801042f1:	75 0d                	jne    80104300 <piperead+0x71>
+801042f3:	8b 45 08             	mov    0x8(%ebp),%eax
+801042f6:	8b 80 40 02 00 00    	mov    0x240(%eax),%eax
+801042fc:	85 c0                	test   %eax,%eax
+801042fe:	75 a3                	jne    801042a3 <piperead+0x14>
+      release(&p->lock);
+      return -1;
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+  }
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80104300:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80104307:	eb 4a                	jmp    80104353 <piperead+0xc4>
+    if(p->nread == p->nwrite)
+80104309:	8b 45 08             	mov    0x8(%ebp),%eax
+8010430c:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
+80104312:	8b 45 08             	mov    0x8(%ebp),%eax
+80104315:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
+8010431b:	39 c2                	cmp    %eax,%edx
+8010431d:	74 3e                	je     8010435d <piperead+0xce>
+      break;
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+8010431f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104322:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104325:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
+80104328:	8b 45 08             	mov    0x8(%ebp),%eax
+8010432b:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
+80104331:	89 c3                	mov    %eax,%ebx
+80104333:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
+80104339:	8b 55 08             	mov    0x8(%ebp),%edx
+8010433c:	0f b6 54 1a 34       	movzbl 0x34(%edx,%ebx,1),%edx
+80104341:	88 11                	mov    %dl,(%ecx)
+80104343:	8d 50 01             	lea    0x1(%eax),%edx
+80104346:	8b 45 08             	mov    0x8(%ebp),%eax
+80104349:	89 90 34 02 00 00    	mov    %edx,0x234(%eax)
+      release(&p->lock);
+      return -1;
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+  }
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+8010434f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80104353:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104356:	3b 45 10             	cmp    0x10(%ebp),%eax
+80104359:	7c ae                	jl     80104309 <piperead+0x7a>
+8010435b:	eb 01                	jmp    8010435e <piperead+0xcf>
+    if(p->nread == p->nwrite)
+      break;
+8010435d:	90                   	nop
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+  }
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+8010435e:	8b 45 08             	mov    0x8(%ebp),%eax
+80104361:	05 38 02 00 00       	add    $0x238,%eax
+80104366:	89 04 24             	mov    %eax,(%esp)
+80104369:	e8 80 0a 00 00       	call   80104dee <wakeup>
+  release(&p->lock);
+8010436e:	8b 45 08             	mov    0x8(%ebp),%eax
+80104371:	89 04 24             	mov    %eax,(%esp)
+80104374:	e8 dc 0c 00 00       	call   80105055 <release>
+  return i;
+80104379:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+8010437c:	83 c4 24             	add    $0x24,%esp
+8010437f:	5b                   	pop    %ebx
+80104380:	5d                   	pop    %ebp
+80104381:	c3                   	ret    
+	...
+
+80104384 <readeflags>:
+  asm volatile("ltr %0" : : "r" (sel));
+}
+
+static inline uint
+readeflags(void)
+{
+80104384:	55                   	push   %ebp
+80104385:	89 e5                	mov    %esp,%ebp
+80104387:	53                   	push   %ebx
+80104388:	83 ec 10             	sub    $0x10,%esp
+  uint eflags;
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+8010438b:	9c                   	pushf  
+8010438c:	5b                   	pop    %ebx
+8010438d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+  return eflags;
+80104390:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80104393:	83 c4 10             	add    $0x10,%esp
+80104396:	5b                   	pop    %ebx
+80104397:	5d                   	pop    %ebp
+80104398:	c3                   	ret    
+
+80104399 <sti>:
+  asm volatile("cli");
+}
+
+static inline void
+sti(void)
+{
+80104399:	55                   	push   %ebp
+8010439a:	89 e5                	mov    %esp,%ebp
+  asm volatile("sti");
+8010439c:	fb                   	sti    
+}
+8010439d:	5d                   	pop    %ebp
+8010439e:	c3                   	ret    
+
+8010439f <set_priority>:
+extern void forkret(void);
+extern void trapret(void);
+
+static void wakeup1(void *chan);
+
+void set_priority(int pid,int priority) {
+8010439f:	55                   	push   %ebp
+801043a0:	89 e5                	mov    %esp,%ebp
+801043a2:	83 ec 10             	sub    $0x10,%esp
+   struct proc *p;
+   p = ptable.proc;
+801043a5:	c7 45 fc d4 29 11 80 	movl   $0x801129d4,-0x4(%ebp)
+   while(p < &ptable.proc[NPROC]) {
+801043ac:	eb 18                	jmp    801043c6 <set_priority+0x27>
+      if(p->pid == pid) {
+801043ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801043b1:	8b 40 10             	mov    0x10(%eax),%eax
+801043b4:	3b 45 08             	cmp    0x8(%ebp),%eax
+801043b7:	75 09                	jne    801043c2 <set_priority+0x23>
+        p->process_priority = priority;
+801043b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801043bc:	8b 55 0c             	mov    0xc(%ebp),%edx
+801043bf:	89 50 7c             	mov    %edx,0x7c(%eax)
+      }
+	 p++; 
+801043c2:	83 6d fc 80          	subl   $0xffffff80,-0x4(%ebp)
+static void wakeup1(void *chan);
+
+void set_priority(int pid,int priority) {
+   struct proc *p;
+   p = ptable.proc;
+   while(p < &ptable.proc[NPROC]) {
+801043c6:	81 7d fc d4 49 11 80 	cmpl   $0x801149d4,-0x4(%ebp)
+801043cd:	72 df                	jb     801043ae <set_priority+0xf>
+      if(p->pid == pid) {
+        p->process_priority = priority;
+      }
+	 p++; 
+   }
+}
+801043cf:	c9                   	leave  
+801043d0:	c3                   	ret    
+
+801043d1 <pinit>:
+
+
+void
+pinit(void)
+{
+801043d1:	55                   	push   %ebp
+801043d2:	89 e5                	mov    %esp,%ebp
+801043d4:	83 ec 18             	sub    $0x18,%esp
+  initlock(&ptable.lock, "ptable");
+801043d7:	c7 44 24 04 11 8a 10 	movl   $0x80108a11,0x4(%esp)
+801043de:	80 
+801043df:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+801043e6:	e8 e7 0b 00 00       	call   80104fd2 <initlock>
+}
+801043eb:	c9                   	leave  
+801043ec:	c3                   	ret    
+
+801043ed <allocproc>:
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+801043ed:	55                   	push   %ebp
+801043ee:	89 e5                	mov    %esp,%ebp
+801043f0:	83 ec 28             	sub    $0x28,%esp
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+801043f3:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+801043fa:	e8 f4 0b 00 00       	call   80104ff3 <acquire>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801043ff:	c7 45 f4 d4 29 11 80 	movl   $0x801129d4,-0xc(%ebp)
+80104406:	eb 0e                	jmp    80104416 <allocproc+0x29>
+    if(p->state == UNUSED)
+80104408:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010440b:	8b 40 0c             	mov    0xc(%eax),%eax
+8010440e:	85 c0                	test   %eax,%eax
+80104410:	74 23                	je     80104435 <allocproc+0x48>
+{
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80104412:	83 6d f4 80          	subl   $0xffffff80,-0xc(%ebp)
+80104416:	81 7d f4 d4 49 11 80 	cmpl   $0x801149d4,-0xc(%ebp)
+8010441d:	72 e9                	jb     80104408 <allocproc+0x1b>
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+8010441f:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104426:	e8 2a 0c 00 00       	call   80105055 <release>
+  return 0;
+8010442b:	b8 00 00 00 00       	mov    $0x0,%eax
+80104430:	e9 b5 00 00 00       	jmp    801044ea <allocproc+0xfd>
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+80104435:	90                   	nop
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+80104436:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104439:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
+  p->pid = nextpid++;
+80104440:	a1 08 b0 10 80       	mov    0x8010b008,%eax
+80104445:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104448:	89 42 10             	mov    %eax,0x10(%edx)
+8010444b:	83 c0 01             	add    $0x1,%eax
+8010444e:	a3 08 b0 10 80       	mov    %eax,0x8010b008
+  release(&ptable.lock);
+80104453:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+8010445a:	e8 f6 0b 00 00       	call   80105055 <release>
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+8010445f:	e8 e7 e6 ff ff       	call   80102b4b <kalloc>
+80104464:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104467:	89 42 08             	mov    %eax,0x8(%edx)
+8010446a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010446d:	8b 40 08             	mov    0x8(%eax),%eax
+80104470:	85 c0                	test   %eax,%eax
+80104472:	75 11                	jne    80104485 <allocproc+0x98>
+    p->state = UNUSED;
+80104474:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104477:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+    return 0;
+8010447e:	b8 00 00 00 00       	mov    $0x0,%eax
+80104483:	eb 65                	jmp    801044ea <allocproc+0xfd>
+  }
+  sp = p->kstack + KSTACKSIZE;
+80104485:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104488:	8b 40 08             	mov    0x8(%eax),%eax
+8010448b:	05 00 10 00 00       	add    $0x1000,%eax
+80104490:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+80104493:	83 6d f0 4c          	subl   $0x4c,-0x10(%ebp)
+  p->tf = (struct trapframe*)sp;
+80104497:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010449a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010449d:	89 50 18             	mov    %edx,0x18(%eax)
+  
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+801044a0:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
+  *(uint*)sp = (uint)trapret;
+801044a4:	ba bc 67 10 80       	mov    $0x801067bc,%edx
+801044a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801044ac:	89 10                	mov    %edx,(%eax)
+
+  sp -= sizeof *p->context;
+801044ae:	83 6d f0 14          	subl   $0x14,-0x10(%ebp)
+  p->context = (struct context*)sp;
+801044b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801044b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
+801044b8:	89 50 1c             	mov    %edx,0x1c(%eax)
+  memset(p->context, 0, sizeof *p->context);
+801044bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801044be:	8b 40 1c             	mov    0x1c(%eax),%eax
+801044c1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
+801044c8:	00 
+801044c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801044d0:	00 
+801044d1:	89 04 24             	mov    %eax,(%esp)
+801044d4:	e8 75 0d 00 00       	call   8010524e <memset>
+  p->context->eip = (uint)forkret;
+801044d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801044dc:	8b 40 1c             	mov    0x1c(%eax),%eax
+801044df:	ba e9 4c 10 80       	mov    $0x80104ce9,%edx
+801044e4:	89 50 10             	mov    %edx,0x10(%eax)
+
+  return p;
+801044e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+801044ea:	c9                   	leave  
+801044eb:	c3                   	ret    
+
+801044ec <userinit>:
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+801044ec:	55                   	push   %ebp
+801044ed:	89 e5                	mov    %esp,%ebp
+801044ef:	83 ec 28             	sub    $0x28,%esp
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+  p = allocproc();
+801044f2:	e8 f6 fe ff ff       	call   801043ed <allocproc>
+801044f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  initproc = p;
+801044fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801044fd:	a3 70 b6 10 80       	mov    %eax,0x8010b670
+  if((p->pgdir = setupkvm()) == 0)
+80104502:	e8 c0 39 00 00       	call   80107ec7 <setupkvm>
+80104507:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010450a:	89 42 04             	mov    %eax,0x4(%edx)
+8010450d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104510:	8b 40 04             	mov    0x4(%eax),%eax
+80104513:	85 c0                	test   %eax,%eax
+80104515:	75 0c                	jne    80104523 <userinit+0x37>
+    panic("userinit: out of memory?");
+80104517:	c7 04 24 18 8a 10 80 	movl   $0x80108a18,(%esp)
+8010451e:	e8 23 c0 ff ff       	call   80100546 <panic>
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+80104523:	ba 2c 00 00 00       	mov    $0x2c,%edx
+80104528:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010452b:	8b 40 04             	mov    0x4(%eax),%eax
+8010452e:	89 54 24 08          	mov    %edx,0x8(%esp)
+80104532:	c7 44 24 04 00 b5 10 	movl   $0x8010b500,0x4(%esp)
+80104539:	80 
+8010453a:	89 04 24             	mov    %eax,(%esp)
+8010453d:	e8 dd 3b 00 00       	call   8010811f <inituvm>
+  p->sz = PGSIZE;
+80104542:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104545:	c7 00 00 10 00 00    	movl   $0x1000,(%eax)
+  memset(p->tf, 0, sizeof(*p->tf));
+8010454b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010454e:	8b 40 18             	mov    0x18(%eax),%eax
+80104551:	c7 44 24 08 4c 00 00 	movl   $0x4c,0x8(%esp)
+80104558:	00 
+80104559:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80104560:	00 
+80104561:	89 04 24             	mov    %eax,(%esp)
+80104564:	e8 e5 0c 00 00       	call   8010524e <memset>
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+80104569:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010456c:	8b 40 18             	mov    0x18(%eax),%eax
+8010456f:	66 c7 40 3c 23 00    	movw   $0x23,0x3c(%eax)
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+80104575:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104578:	8b 40 18             	mov    0x18(%eax),%eax
+8010457b:	66 c7 40 2c 2b 00    	movw   $0x2b,0x2c(%eax)
+  p->tf->es = p->tf->ds;
+80104581:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104584:	8b 40 18             	mov    0x18(%eax),%eax
+80104587:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010458a:	8b 52 18             	mov    0x18(%edx),%edx
+8010458d:	0f b7 52 2c          	movzwl 0x2c(%edx),%edx
+80104591:	66 89 50 28          	mov    %dx,0x28(%eax)
+  p->tf->ss = p->tf->ds;
+80104595:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104598:	8b 40 18             	mov    0x18(%eax),%eax
+8010459b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010459e:	8b 52 18             	mov    0x18(%edx),%edx
+801045a1:	0f b7 52 2c          	movzwl 0x2c(%edx),%edx
+801045a5:	66 89 50 48          	mov    %dx,0x48(%eax)
+  p->tf->eflags = FL_IF;
+801045a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801045ac:	8b 40 18             	mov    0x18(%eax),%eax
+801045af:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
+  p->tf->esp = PGSIZE;
+801045b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801045b9:	8b 40 18             	mov    0x18(%eax),%eax
+801045bc:	c7 40 44 00 10 00 00 	movl   $0x1000,0x44(%eax)
+  p->tf->eip = 0;  // beginning of initcode.S
+801045c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801045c6:	8b 40 18             	mov    0x18(%eax),%eax
+801045c9:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+801045d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801045d3:	83 c0 6c             	add    $0x6c,%eax
+801045d6:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+801045dd:	00 
+801045de:	c7 44 24 04 31 8a 10 	movl   $0x80108a31,0x4(%esp)
+801045e5:	80 
+801045e6:	89 04 24             	mov    %eax,(%esp)
+801045e9:	e8 90 0e 00 00       	call   8010547e <safestrcpy>
+  p->cwd = namei("/");
+801045ee:	c7 04 24 3a 8a 10 80 	movl   $0x80108a3a,(%esp)
+801045f5:	e8 5e de ff ff       	call   80102458 <namei>
+801045fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801045fd:	89 42 68             	mov    %eax,0x68(%edx)
+
+  p->state = RUNNABLE;
+80104600:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104603:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+}
+8010460a:	c9                   	leave  
+8010460b:	c3                   	ret    
+
+8010460c <growproc>:
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+8010460c:	55                   	push   %ebp
+8010460d:	89 e5                	mov    %esp,%ebp
+8010460f:	83 ec 28             	sub    $0x28,%esp
+  uint sz;
+  
+  sz = proc->sz;
+80104612:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104618:	8b 00                	mov    (%eax),%eax
+8010461a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(n > 0){
+8010461d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80104621:	7e 34                	jle    80104657 <growproc+0x4b>
+    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+80104623:	8b 55 08             	mov    0x8(%ebp),%edx
+80104626:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104629:	01 c2                	add    %eax,%edx
+8010462b:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104631:	8b 40 04             	mov    0x4(%eax),%eax
+80104634:	89 54 24 08          	mov    %edx,0x8(%esp)
+80104638:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010463b:	89 54 24 04          	mov    %edx,0x4(%esp)
+8010463f:	89 04 24             	mov    %eax,(%esp)
+80104642:	e8 52 3c 00 00       	call   80108299 <allocuvm>
+80104647:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010464a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010464e:	75 41                	jne    80104691 <growproc+0x85>
+      return -1;
+80104650:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104655:	eb 58                	jmp    801046af <growproc+0xa3>
+  } else if(n < 0){
+80104657:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+8010465b:	79 34                	jns    80104691 <growproc+0x85>
+    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+8010465d:	8b 55 08             	mov    0x8(%ebp),%edx
+80104660:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104663:	01 c2                	add    %eax,%edx
+80104665:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010466b:	8b 40 04             	mov    0x4(%eax),%eax
+8010466e:	89 54 24 08          	mov    %edx,0x8(%esp)
+80104672:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104675:	89 54 24 04          	mov    %edx,0x4(%esp)
+80104679:	89 04 24             	mov    %eax,(%esp)
+8010467c:	e8 f2 3c 00 00       	call   80108373 <deallocuvm>
+80104681:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80104684:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80104688:	75 07                	jne    80104691 <growproc+0x85>
+      return -1;
+8010468a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010468f:	eb 1e                	jmp    801046af <growproc+0xa3>
+  }
+  proc->sz = sz;
+80104691:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104697:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010469a:	89 10                	mov    %edx,(%eax)
+  switchuvm(proc);
+8010469c:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801046a2:	89 04 24             	mov    %eax,(%esp)
+801046a5:	e8 0e 39 00 00       	call   80107fb8 <switchuvm>
+  return 0;
+801046aa:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801046af:	c9                   	leave  
+801046b0:	c3                   	ret    
+
+801046b1 <fork>:
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+fork(void)
+{
+801046b1:	55                   	push   %ebp
+801046b2:	89 e5                	mov    %esp,%ebp
+801046b4:	57                   	push   %edi
+801046b5:	56                   	push   %esi
+801046b6:	53                   	push   %ebx
+801046b7:	83 ec 2c             	sub    $0x2c,%esp
+  int i, pid;
+  struct proc *np;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+801046ba:	e8 2e fd ff ff       	call   801043ed <allocproc>
+801046bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
+801046c2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+801046c6:	75 0a                	jne    801046d2 <fork+0x21>
+    return -1;
+801046c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801046cd:	e9 53 01 00 00       	jmp    80104825 <fork+0x174>
+
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+801046d2:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801046d8:	8b 10                	mov    (%eax),%edx
+801046da:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801046e0:	8b 40 04             	mov    0x4(%eax),%eax
+801046e3:	89 54 24 04          	mov    %edx,0x4(%esp)
+801046e7:	89 04 24             	mov    %eax,(%esp)
+801046ea:	e8 20 3e 00 00       	call   8010850f <copyuvm>
+801046ef:	8b 55 e0             	mov    -0x20(%ebp),%edx
+801046f2:	89 42 04             	mov    %eax,0x4(%edx)
+801046f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801046f8:	8b 40 04             	mov    0x4(%eax),%eax
+801046fb:	85 c0                	test   %eax,%eax
+801046fd:	75 2c                	jne    8010472b <fork+0x7a>
+    kfree(np->kstack);
+801046ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104702:	8b 40 08             	mov    0x8(%eax),%eax
+80104705:	89 04 24             	mov    %eax,(%esp)
+80104708:	e8 a5 e3 ff ff       	call   80102ab2 <kfree>
+    np->kstack = 0;
+8010470d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104710:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+    np->state = UNUSED;
+80104717:	8b 45 e0             	mov    -0x20(%ebp),%eax
+8010471a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+    return -1;
+80104721:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104726:	e9 fa 00 00 00       	jmp    80104825 <fork+0x174>
+  }
+  np->sz = proc->sz;
+8010472b:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104731:	8b 10                	mov    (%eax),%edx
+80104733:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104736:	89 10                	mov    %edx,(%eax)
+  np->parent = proc;
+80104738:	65 8b 15 04 00 00 00 	mov    %gs:0x4,%edx
+8010473f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104742:	89 50 14             	mov    %edx,0x14(%eax)
+  *np->tf = *proc->tf;
+80104745:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104748:	8b 50 18             	mov    0x18(%eax),%edx
+8010474b:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104751:	8b 40 18             	mov    0x18(%eax),%eax
+80104754:	89 c3                	mov    %eax,%ebx
+80104756:	b8 13 00 00 00       	mov    $0x13,%eax
+8010475b:	89 d7                	mov    %edx,%edi
+8010475d:	89 de                	mov    %ebx,%esi
+8010475f:	89 c1                	mov    %eax,%ecx
+80104761:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  np->process_priority = 2;
+80104763:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104766:	c7 40 7c 02 00 00 00 	movl   $0x2,0x7c(%eax)
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+8010476d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104770:	8b 40 18             	mov    0x18(%eax),%eax
+80104773:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+
+  for(i = 0; i < NOFILE; i++)
+8010477a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+80104781:	eb 3d                	jmp    801047c0 <fork+0x10f>
+    if(proc->ofile[i])
+80104783:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104789:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+8010478c:	83 c2 08             	add    $0x8,%edx
+8010478f:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80104793:	85 c0                	test   %eax,%eax
+80104795:	74 25                	je     801047bc <fork+0x10b>
+      np->ofile[i] = filedup(proc->ofile[i]);
+80104797:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010479d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+801047a0:	83 c2 08             	add    $0x8,%edx
+801047a3:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+801047a7:	89 04 24             	mov    %eax,(%esp)
+801047aa:	e8 01 c8 ff ff       	call   80100fb0 <filedup>
+801047af:	8b 55 e0             	mov    -0x20(%ebp),%edx
+801047b2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801047b5:	83 c1 08             	add    $0x8,%ecx
+801047b8:	89 44 8a 08          	mov    %eax,0x8(%edx,%ecx,4)
+  *np->tf = *proc->tf;
+  np->process_priority = 2;
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+801047bc:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+801047c0:	83 7d e4 0f          	cmpl   $0xf,-0x1c(%ebp)
+801047c4:	7e bd                	jle    80104783 <fork+0xd2>
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+801047c6:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801047cc:	8b 40 68             	mov    0x68(%eax),%eax
+801047cf:	89 04 24             	mov    %eax,(%esp)
+801047d2:	e8 9e d0 ff ff       	call   80101875 <idup>
+801047d7:	8b 55 e0             	mov    -0x20(%ebp),%edx
+801047da:	89 42 68             	mov    %eax,0x68(%edx)
+
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+801047dd:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801047e3:	8d 50 6c             	lea    0x6c(%eax),%edx
+801047e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801047e9:	83 c0 6c             	add    $0x6c,%eax
+801047ec:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+801047f3:	00 
+801047f4:	89 54 24 04          	mov    %edx,0x4(%esp)
+801047f8:	89 04 24             	mov    %eax,(%esp)
+801047fb:	e8 7e 0c 00 00       	call   8010547e <safestrcpy>
+
+  pid = np->pid;
+80104800:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104803:	8b 40 10             	mov    0x10(%eax),%eax
+80104806:	89 45 dc             	mov    %eax,-0x24(%ebp)
+
+  np->state = RUNNABLE;
+80104809:	8b 45 e0             	mov    -0x20(%ebp),%eax
+8010480c:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+  if(win == 1) {
+80104813:	a1 84 29 11 80       	mov    0x80112984,%eax
+80104818:	83 f8 01             	cmp    $0x1,%eax
+8010481b:	75 05                	jne    80104822 <fork+0x171>
+	yield();
+8010481d:	e8 73 04 00 00       	call   80104c95 <yield>
+  }
+
+  return pid;
+80104822:	8b 45 dc             	mov    -0x24(%ebp),%eax
+}
+80104825:	83 c4 2c             	add    $0x2c,%esp
+80104828:	5b                   	pop    %ebx
+80104829:	5e                   	pop    %esi
+8010482a:	5f                   	pop    %edi
+8010482b:	5d                   	pop    %ebp
+8010482c:	c3                   	ret    
+
+8010482d <exit>:
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+8010482d:	55                   	push   %ebp
+8010482e:	89 e5                	mov    %esp,%ebp
+80104830:	83 ec 28             	sub    $0x28,%esp
+  struct proc *p;
+  int fd;
+
+  if(proc == initproc)
+80104833:	65 8b 15 04 00 00 00 	mov    %gs:0x4,%edx
+8010483a:	a1 70 b6 10 80       	mov    0x8010b670,%eax
+8010483f:	39 c2                	cmp    %eax,%edx
+80104841:	75 0c                	jne    8010484f <exit+0x22>
+    panic("init exiting");
+80104843:	c7 04 24 3c 8a 10 80 	movl   $0x80108a3c,(%esp)
+8010484a:	e8 f7 bc ff ff       	call   80100546 <panic>
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+8010484f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80104856:	eb 44                	jmp    8010489c <exit+0x6f>
+    if(proc->ofile[fd]){
+80104858:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010485e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104861:	83 c2 08             	add    $0x8,%edx
+80104864:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80104868:	85 c0                	test   %eax,%eax
+8010486a:	74 2c                	je     80104898 <exit+0x6b>
+      fileclose(proc->ofile[fd]);
+8010486c:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104872:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104875:	83 c2 08             	add    $0x8,%edx
+80104878:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+8010487c:	89 04 24             	mov    %eax,(%esp)
+8010487f:	e8 74 c7 ff ff       	call   80100ff8 <fileclose>
+      proc->ofile[fd] = 0;
+80104884:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010488a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010488d:	83 c2 08             	add    $0x8,%edx
+80104890:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
+80104897:	00 
+
+  if(proc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+80104898:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+8010489c:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
+801048a0:	7e b6                	jle    80104858 <exit+0x2b>
+      fileclose(proc->ofile[fd]);
+      proc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+801048a2:	e8 01 ec ff ff       	call   801034a8 <begin_op>
+  iput(proc->cwd);
+801048a7:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801048ad:	8b 40 68             	mov    0x68(%eax),%eax
+801048b0:	89 04 24             	mov    %eax,(%esp)
+801048b3:	e8 a2 d1 ff ff       	call   80101a5a <iput>
+  end_op();
+801048b8:	e8 6c ec ff ff       	call   80103529 <end_op>
+  proc->cwd = 0;
+801048bd:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801048c3:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
+
+  acquire(&ptable.lock);
+801048ca:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+801048d1:	e8 1d 07 00 00       	call   80104ff3 <acquire>
+
+  // Parent might be sleeping in wait().
+  wakeup1(proc->parent);
+801048d6:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801048dc:	8b 40 14             	mov    0x14(%eax),%eax
+801048df:	89 04 24             	mov    %eax,(%esp)
+801048e2:	e8 c9 04 00 00       	call   80104db0 <wakeup1>
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801048e7:	c7 45 f4 d4 29 11 80 	movl   $0x801129d4,-0xc(%ebp)
+801048ee:	eb 38                	jmp    80104928 <exit+0xfb>
+    if(p->parent == proc){
+801048f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801048f3:	8b 50 14             	mov    0x14(%eax),%edx
+801048f6:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801048fc:	39 c2                	cmp    %eax,%edx
+801048fe:	75 24                	jne    80104924 <exit+0xf7>
+      p->parent = initproc;
+80104900:	8b 15 70 b6 10 80    	mov    0x8010b670,%edx
+80104906:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104909:	89 50 14             	mov    %edx,0x14(%eax)
+      if(p->state == ZOMBIE)
+8010490c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010490f:	8b 40 0c             	mov    0xc(%eax),%eax
+80104912:	83 f8 05             	cmp    $0x5,%eax
+80104915:	75 0d                	jne    80104924 <exit+0xf7>
+        wakeup1(initproc);
+80104917:	a1 70 b6 10 80       	mov    0x8010b670,%eax
+8010491c:	89 04 24             	mov    %eax,(%esp)
+8010491f:	e8 8c 04 00 00       	call   80104db0 <wakeup1>
+
+  // Parent might be sleeping in wait().
+  wakeup1(proc->parent);
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104924:	83 6d f4 80          	subl   $0xffffff80,-0xc(%ebp)
+80104928:	81 7d f4 d4 49 11 80 	cmpl   $0x801149d4,-0xc(%ebp)
+8010492f:	72 bf                	jb     801048f0 <exit+0xc3>
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  proc->state = ZOMBIE;
+80104931:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104937:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
+  sched();
+8010493e:	e8 a0 02 00 00       	call   80104be3 <sched>
+  panic("zombie exit");
+80104943:	c7 04 24 49 8a 10 80 	movl   $0x80108a49,(%esp)
+8010494a:	e8 f7 bb ff ff       	call   80100546 <panic>
+
+8010494f <wait>:
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+8010494f:	55                   	push   %ebp
+80104950:	89 e5                	mov    %esp,%ebp
+80104952:	83 ec 28             	sub    $0x28,%esp
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+80104955:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+8010495c:	e8 92 06 00 00       	call   80104ff3 <acquire>
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+80104961:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104968:	c7 45 f4 d4 29 11 80 	movl   $0x801129d4,-0xc(%ebp)
+8010496f:	e9 9a 00 00 00       	jmp    80104a0e <wait+0xbf>
+      if(p->parent != proc)
+80104974:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104977:	8b 50 14             	mov    0x14(%eax),%edx
+8010497a:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104980:	39 c2                	cmp    %eax,%edx
+80104982:	0f 85 81 00 00 00    	jne    80104a09 <wait+0xba>
+        continue;
+      havekids = 1;
+80104988:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+      if(p->state == ZOMBIE){
+8010498f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104992:	8b 40 0c             	mov    0xc(%eax),%eax
+80104995:	83 f8 05             	cmp    $0x5,%eax
+80104998:	75 70                	jne    80104a0a <wait+0xbb>
+        // Found one.
+        pid = p->pid;
+8010499a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010499d:	8b 40 10             	mov    0x10(%eax),%eax
+801049a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        kfree(p->kstack);
+801049a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049a6:	8b 40 08             	mov    0x8(%eax),%eax
+801049a9:	89 04 24             	mov    %eax,(%esp)
+801049ac:	e8 01 e1 ff ff       	call   80102ab2 <kfree>
+        p->kstack = 0;
+801049b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+        freevm(p->pgdir);
+801049bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049be:	8b 40 04             	mov    0x4(%eax),%eax
+801049c1:	89 04 24             	mov    %eax,(%esp)
+801049c4:	e8 66 3a 00 00       	call   8010842f <freevm>
+        p->state = UNUSED;
+801049c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049cc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+        p->pid = 0;
+801049d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049d6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+        p->parent = 0;
+801049dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049e0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+        p->name[0] = 0;
+801049e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049ea:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
+        p->killed = 0;
+801049ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049f1:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
+        release(&ptable.lock);
+801049f8:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+801049ff:	e8 51 06 00 00       	call   80105055 <release>
+        return pid;
+80104a04:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104a07:	eb 53                	jmp    80104a5c <wait+0x10d>
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+80104a09:	90                   	nop
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104a0a:	83 6d f4 80          	subl   $0xffffff80,-0xc(%ebp)
+80104a0e:	81 7d f4 d4 49 11 80 	cmpl   $0x801149d4,-0xc(%ebp)
+80104a15:	0f 82 59 ff ff ff    	jb     80104974 <wait+0x25>
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+80104a1b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80104a1f:	74 0d                	je     80104a2e <wait+0xdf>
+80104a21:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104a27:	8b 40 24             	mov    0x24(%eax),%eax
+80104a2a:	85 c0                	test   %eax,%eax
+80104a2c:	74 13                	je     80104a41 <wait+0xf2>
+      release(&ptable.lock);
+80104a2e:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104a35:	e8 1b 06 00 00       	call   80105055 <release>
+      return -1;
+80104a3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104a3f:	eb 1b                	jmp    80104a5c <wait+0x10d>
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+80104a41:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104a47:	c7 44 24 04 a0 29 11 	movl   $0x801129a0,0x4(%esp)
+80104a4e:	80 
+80104a4f:	89 04 24             	mov    %eax,(%esp)
+80104a52:	e8 be 02 00 00       	call   80104d15 <sleep>
+  }
+80104a57:	e9 05 ff ff ff       	jmp    80104961 <wait+0x12>
+}
+80104a5c:	c9                   	leave  
+80104a5d:	c3                   	ret    
+
+80104a5e <scheduler>:
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+80104a5e:	55                   	push   %ebp
+80104a5f:	89 e5                	mov    %esp,%ebp
+80104a61:	83 ec 28             	sub    $0x28,%esp
+  struct proc *p;
+  for(;;){
+    sti();
+80104a64:	e8 30 f9 ff ff       	call   80104399 <sti>
+  if(schd_choice == 0) {
+80104a69:	a1 6c b6 10 80       	mov    0x8010b66c,%eax
+80104a6e:	85 c0                	test   %eax,%eax
+80104a70:	0f 85 8e 00 00 00    	jne    80104b04 <scheduler+0xa6>
+    acquire(&ptable.lock);
+80104a76:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104a7d:	e8 71 05 00 00       	call   80104ff3 <acquire>
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104a82:	c7 45 f4 d4 29 11 80 	movl   $0x801129d4,-0xc(%ebp)
+80104a89:	eb 5f                	jmp    80104aea <scheduler+0x8c>
+      if(p->state != RUNNABLE)
+80104a8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104a8e:	8b 40 0c             	mov    0xc(%eax),%eax
+80104a91:	83 f8 03             	cmp    $0x3,%eax
+80104a94:	75 4f                	jne    80104ae5 <scheduler+0x87>
+        continue;
+
+      proc = p;
+80104a96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104a99:	65 a3 04 00 00 00    	mov    %eax,%gs:0x4
+      switchuvm(p);
+80104a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104aa2:	89 04 24             	mov    %eax,(%esp)
+80104aa5:	e8 0e 35 00 00       	call   80107fb8 <switchuvm>
+      p->state = RUNNING;
+80104aaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104aad:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
+      swtch(&cpu->scheduler, proc->context);
+80104ab4:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104aba:	8b 40 1c             	mov    0x1c(%eax),%eax
+80104abd:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+80104ac4:	83 c2 04             	add    $0x4,%edx
+80104ac7:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104acb:	89 14 24             	mov    %edx,(%esp)
+80104ace:	e8 21 0a 00 00       	call   801054f4 <swtch>
+      switchkvm();
+80104ad3:	e8 c3 34 00 00       	call   80107f9b <switchkvm>
+
+      proc = 0;
+80104ad8:	65 c7 05 04 00 00 00 	movl   $0x0,%gs:0x4
+80104adf:	00 00 00 00 
+80104ae3:	eb 01                	jmp    80104ae6 <scheduler+0x88>
+    sti();
+  if(schd_choice == 0) {
+    acquire(&ptable.lock);
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+80104ae5:	90                   	nop
+  struct proc *p;
+  for(;;){
+    sti();
+  if(schd_choice == 0) {
+    acquire(&ptable.lock);
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104ae6:	83 6d f4 80          	subl   $0xffffff80,-0xc(%ebp)
+80104aea:	81 7d f4 d4 49 11 80 	cmpl   $0x801149d4,-0xc(%ebp)
+80104af1:	72 98                	jb     80104a8b <scheduler+0x2d>
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      proc = 0;
+    }
+    release(&ptable.lock);
+80104af3:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104afa:	e8 56 05 00 00       	call   80105055 <release>
+    }
+    if((flag == 0))
+       maximum--;
+    release(&ptable.lock);
+  }
+ }
+80104aff:	e9 60 ff ff ff       	jmp    80104a64 <scheduler+0x6>
+    }
+    release(&ptable.lock);
+
+  }
+  else {
+    acquire(&ptable.lock);
+80104b04:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104b0b:	e8 e3 04 00 00       	call   80104ff3 <acquire>
+    int flag = 0;
+80104b10:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+
+    for(p = &ptable.proc[NPROC - 1]; p >= ptable.proc; p--){
+80104b17:	c7 45 f4 54 49 11 80 	movl   $0x80114954,-0xc(%ebp)
+80104b1e:	e9 8f 00 00 00       	jmp    80104bb2 <scheduler+0x154>
+      if((p->state != RUNNABLE))
+80104b23:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b26:	8b 40 0c             	mov    0xc(%eax),%eax
+80104b29:	83 f8 03             	cmp    $0x3,%eax
+80104b2c:	75 7f                	jne    80104bad <scheduler+0x14f>
+        continue;
+      if(p->process_priority > maximum)
+80104b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b31:	8b 50 7c             	mov    0x7c(%eax),%edx
+80104b34:	a1 04 b0 10 80       	mov    0x8010b004,%eax
+80104b39:	39 c2                	cmp    %eax,%edx
+80104b3b:	7e 0b                	jle    80104b48 <scheduler+0xea>
+           maximum = p->process_priority;
+80104b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b40:	8b 40 7c             	mov    0x7c(%eax),%eax
+80104b43:	a3 04 b0 10 80       	mov    %eax,0x8010b004
+      if((p->process_priority == maximum)) {
+80104b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b4b:	8b 50 7c             	mov    0x7c(%eax),%edx
+80104b4e:	a1 04 b0 10 80       	mov    0x8010b004,%eax
+80104b53:	39 c2                	cmp    %eax,%edx
+80104b55:	75 57                	jne    80104bae <scheduler+0x150>
+      proc = p;
+80104b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b5a:	65 a3 04 00 00 00    	mov    %eax,%gs:0x4
+      switchuvm(p);
+80104b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b63:	89 04 24             	mov    %eax,(%esp)
+80104b66:	e8 4d 34 00 00       	call   80107fb8 <switchuvm>
+      p->state = RUNNING;
+80104b6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104b6e:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
+      swtch(&cpu->scheduler, proc->context);
+80104b75:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104b7b:	8b 40 1c             	mov    0x1c(%eax),%eax
+80104b7e:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+80104b85:	83 c2 04             	add    $0x4,%edx
+80104b88:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104b8c:	89 14 24             	mov    %edx,(%esp)
+80104b8f:	e8 60 09 00 00       	call   801054f4 <swtch>
+      switchkvm();
+80104b94:	e8 02 34 00 00       	call   80107f9b <switchkvm>
+      proc = 0;
+80104b99:	65 c7 05 04 00 00 00 	movl   $0x0,%gs:0x4
+80104ba0:	00 00 00 00 
+      flag = 1;
+80104ba4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+80104bab:	eb 01                	jmp    80104bae <scheduler+0x150>
+    acquire(&ptable.lock);
+    int flag = 0;
+
+    for(p = &ptable.proc[NPROC - 1]; p >= ptable.proc; p--){
+      if((p->state != RUNNABLE))
+        continue;
+80104bad:	90                   	nop
+  }
+  else {
+    acquire(&ptable.lock);
+    int flag = 0;
+
+    for(p = &ptable.proc[NPROC - 1]; p >= ptable.proc; p--){
+80104bae:	83 45 f4 80          	addl   $0xffffff80,-0xc(%ebp)
+80104bb2:	81 7d f4 d4 29 11 80 	cmpl   $0x801129d4,-0xc(%ebp)
+80104bb9:	0f 83 64 ff ff ff    	jae    80104b23 <scheduler+0xc5>
+      switchkvm();
+      proc = 0;
+      flag = 1;
+     }
+    }
+    if((flag == 0))
+80104bbf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80104bc3:	75 0d                	jne    80104bd2 <scheduler+0x174>
+       maximum--;
+80104bc5:	a1 04 b0 10 80       	mov    0x8010b004,%eax
+80104bca:	83 e8 01             	sub    $0x1,%eax
+80104bcd:	a3 04 b0 10 80       	mov    %eax,0x8010b004
+    release(&ptable.lock);
+80104bd2:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104bd9:	e8 77 04 00 00       	call   80105055 <release>
+  }
+ }
+80104bde:	e9 81 fe ff ff       	jmp    80104a64 <scheduler+0x6>
+
+80104be3 <sched>:
+
+// Enter scheduler.  Must hold only ptable.lock
+// and have changed proc->state.
+void
+sched(void)
+{
+80104be3:	55                   	push   %ebp
+80104be4:	89 e5                	mov    %esp,%ebp
+80104be6:	83 ec 28             	sub    $0x28,%esp
+  int intena;
+
+  if(!holding(&ptable.lock))
+80104be9:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104bf0:	e8 28 05 00 00       	call   8010511d <holding>
+80104bf5:	85 c0                	test   %eax,%eax
+80104bf7:	75 0c                	jne    80104c05 <sched+0x22>
+    panic("sched ptable.lock");
+80104bf9:	c7 04 24 55 8a 10 80 	movl   $0x80108a55,(%esp)
+80104c00:	e8 41 b9 ff ff       	call   80100546 <panic>
+  if(cpu->ncli != 1)
+80104c05:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80104c0b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
+80104c11:	83 f8 01             	cmp    $0x1,%eax
+80104c14:	74 0c                	je     80104c22 <sched+0x3f>
+    panic("sched locks");
+80104c16:	c7 04 24 67 8a 10 80 	movl   $0x80108a67,(%esp)
+80104c1d:	e8 24 b9 ff ff       	call   80100546 <panic>
+  if(proc->state == RUNNING)
+80104c22:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104c28:	8b 40 0c             	mov    0xc(%eax),%eax
+80104c2b:	83 f8 04             	cmp    $0x4,%eax
+80104c2e:	75 0c                	jne    80104c3c <sched+0x59>
+    panic("sched running");
+80104c30:	c7 04 24 73 8a 10 80 	movl   $0x80108a73,(%esp)
+80104c37:	e8 0a b9 ff ff       	call   80100546 <panic>
+  if(readeflags()&FL_IF)
+80104c3c:	e8 43 f7 ff ff       	call   80104384 <readeflags>
+80104c41:	25 00 02 00 00       	and    $0x200,%eax
+80104c46:	85 c0                	test   %eax,%eax
+80104c48:	74 0c                	je     80104c56 <sched+0x73>
+    panic("sched interruptible");
+80104c4a:	c7 04 24 81 8a 10 80 	movl   $0x80108a81,(%esp)
+80104c51:	e8 f0 b8 ff ff       	call   80100546 <panic>
+  intena = cpu->intena;
+80104c56:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80104c5c:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
+80104c62:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  swtch(&proc->context, cpu->scheduler);
+80104c65:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80104c6b:	8b 40 04             	mov    0x4(%eax),%eax
+80104c6e:	65 8b 15 04 00 00 00 	mov    %gs:0x4,%edx
+80104c75:	83 c2 1c             	add    $0x1c,%edx
+80104c78:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104c7c:	89 14 24             	mov    %edx,(%esp)
+80104c7f:	e8 70 08 00 00       	call   801054f4 <swtch>
+  cpu->intena = intena;
+80104c84:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80104c8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104c8d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
+}
+80104c93:	c9                   	leave  
+80104c94:	c3                   	ret    
+
+80104c95 <yield>:
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+80104c95:	55                   	push   %ebp
+80104c96:	89 e5                	mov    %esp,%ebp
+80104c98:	83 ec 18             	sub    $0x18,%esp
+  if (sched_trace_enabled)
+80104c9b:	a1 68 b6 10 80       	mov    0x8010b668,%eax
+80104ca0:	85 c0                	test   %eax,%eax
+80104ca2:	74 19                	je     80104cbd <yield+0x28>
+  {
+    cprintf("[%d]", proc->pid);
+80104ca4:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104caa:	8b 40 10             	mov    0x10(%eax),%eax
+80104cad:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104cb1:	c7 04 24 95 8a 10 80 	movl   $0x80108a95,(%esp)
+80104cb8:	e8 ed b6 ff ff       	call   801003aa <cprintf>
+  }
+
+  acquire(&ptable.lock);  //DOC: yieldlock
+80104cbd:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104cc4:	e8 2a 03 00 00       	call   80104ff3 <acquire>
+  proc->state = RUNNABLE;
+80104cc9:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104ccf:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+  sched();
+80104cd6:	e8 08 ff ff ff       	call   80104be3 <sched>
+  release(&ptable.lock);
+80104cdb:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104ce2:	e8 6e 03 00 00       	call   80105055 <release>
+}
+80104ce7:	c9                   	leave  
+80104ce8:	c3                   	ret    
+
+80104ce9 <forkret>:
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+80104ce9:	55                   	push   %ebp
+80104cea:	89 e5                	mov    %esp,%ebp
+80104cec:	83 ec 18             	sub    $0x18,%esp
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+80104cef:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104cf6:	e8 5a 03 00 00       	call   80105055 <release>
+
+  if (first) {
+80104cfb:	a1 28 b0 10 80       	mov    0x8010b028,%eax
+80104d00:	85 c0                	test   %eax,%eax
+80104d02:	74 0f                	je     80104d13 <forkret+0x2a>
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot 
+    // be run from main().
+    first = 0;
+80104d04:	c7 05 28 b0 10 80 00 	movl   $0x0,0x8010b028
+80104d0b:	00 00 00 
+    initlog();
+80104d0e:	e8 85 e5 ff ff       	call   80103298 <initlog>
+  }
+  
+  // Return to "caller", actually trapret (see allocproc).
+}
+80104d13:	c9                   	leave  
+80104d14:	c3                   	ret    
+
+80104d15 <sleep>:
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+80104d15:	55                   	push   %ebp
+80104d16:	89 e5                	mov    %esp,%ebp
+80104d18:	83 ec 18             	sub    $0x18,%esp
+  if(proc == 0)
+80104d1b:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104d21:	85 c0                	test   %eax,%eax
+80104d23:	75 0c                	jne    80104d31 <sleep+0x1c>
+    panic("sleep");
+80104d25:	c7 04 24 9a 8a 10 80 	movl   $0x80108a9a,(%esp)
+80104d2c:	e8 15 b8 ff ff       	call   80100546 <panic>
+
+  if(lk == 0)
+80104d31:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+80104d35:	75 0c                	jne    80104d43 <sleep+0x2e>
+    panic("sleep without lk");
+80104d37:	c7 04 24 a0 8a 10 80 	movl   $0x80108aa0,(%esp)
+80104d3e:	e8 03 b8 ff ff       	call   80100546 <panic>
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+80104d43:	81 7d 0c a0 29 11 80 	cmpl   $0x801129a0,0xc(%ebp)
+80104d4a:	74 17                	je     80104d63 <sleep+0x4e>
+    acquire(&ptable.lock);  //DOC: sleeplock1
+80104d4c:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104d53:	e8 9b 02 00 00       	call   80104ff3 <acquire>
+    release(lk);
+80104d58:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104d5b:	89 04 24             	mov    %eax,(%esp)
+80104d5e:	e8 f2 02 00 00       	call   80105055 <release>
+  }
+
+  // Go to sleep.
+  proc->chan = chan;
+80104d63:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104d69:	8b 55 08             	mov    0x8(%ebp),%edx
+80104d6c:	89 50 20             	mov    %edx,0x20(%eax)
+  proc->state = SLEEPING;
+80104d6f:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104d75:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
+  sched();
+80104d7c:	e8 62 fe ff ff       	call   80104be3 <sched>
+
+  // Tidy up.
+  proc->chan = 0;
+80104d81:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80104d87:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+80104d8e:	81 7d 0c a0 29 11 80 	cmpl   $0x801129a0,0xc(%ebp)
+80104d95:	74 17                	je     80104dae <sleep+0x99>
+    release(&ptable.lock);
+80104d97:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104d9e:	e8 b2 02 00 00       	call   80105055 <release>
+    acquire(lk);
+80104da3:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104da6:	89 04 24             	mov    %eax,(%esp)
+80104da9:	e8 45 02 00 00       	call   80104ff3 <acquire>
+  }
+}
+80104dae:	c9                   	leave  
+80104daf:	c3                   	ret    
+
+80104db0 <wakeup1>:
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+80104db0:	55                   	push   %ebp
+80104db1:	89 e5                	mov    %esp,%ebp
+80104db3:	83 ec 10             	sub    $0x10,%esp
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80104db6:	c7 45 fc d4 29 11 80 	movl   $0x801129d4,-0x4(%ebp)
+80104dbd:	eb 24                	jmp    80104de3 <wakeup1+0x33>
+    if(p->state == SLEEPING && p->chan == chan)
+80104dbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80104dc2:	8b 40 0c             	mov    0xc(%eax),%eax
+80104dc5:	83 f8 02             	cmp    $0x2,%eax
+80104dc8:	75 15                	jne    80104ddf <wakeup1+0x2f>
+80104dca:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80104dcd:	8b 40 20             	mov    0x20(%eax),%eax
+80104dd0:	3b 45 08             	cmp    0x8(%ebp),%eax
+80104dd3:	75 0a                	jne    80104ddf <wakeup1+0x2f>
+      p->state = RUNNABLE;
+80104dd5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80104dd8:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80104ddf:	83 6d fc 80          	subl   $0xffffff80,-0x4(%ebp)
+80104de3:	81 7d fc d4 49 11 80 	cmpl   $0x801149d4,-0x4(%ebp)
+80104dea:	72 d3                	jb     80104dbf <wakeup1+0xf>
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
+}
+80104dec:	c9                   	leave  
+80104ded:	c3                   	ret    
+
+80104dee <wakeup>:
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+80104dee:	55                   	push   %ebp
+80104def:	89 e5                	mov    %esp,%ebp
+80104df1:	83 ec 18             	sub    $0x18,%esp
+  acquire(&ptable.lock);
+80104df4:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104dfb:	e8 f3 01 00 00       	call   80104ff3 <acquire>
+  wakeup1(chan);
+80104e00:	8b 45 08             	mov    0x8(%ebp),%eax
+80104e03:	89 04 24             	mov    %eax,(%esp)
+80104e06:	e8 a5 ff ff ff       	call   80104db0 <wakeup1>
+  release(&ptable.lock);
+80104e0b:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104e12:	e8 3e 02 00 00       	call   80105055 <release>
+}
+80104e17:	c9                   	leave  
+80104e18:	c3                   	ret    
+
+80104e19 <kill>:
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+80104e19:	55                   	push   %ebp
+80104e1a:	89 e5                	mov    %esp,%ebp
+80104e1c:	83 ec 28             	sub    $0x28,%esp
+  struct proc *p;
+
+  acquire(&ptable.lock);
+80104e1f:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104e26:	e8 c8 01 00 00       	call   80104ff3 <acquire>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104e2b:	c7 45 f4 d4 29 11 80 	movl   $0x801129d4,-0xc(%ebp)
+80104e32:	eb 41                	jmp    80104e75 <kill+0x5c>
+    if(p->pid == pid){
+80104e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e37:	8b 40 10             	mov    0x10(%eax),%eax
+80104e3a:	3b 45 08             	cmp    0x8(%ebp),%eax
+80104e3d:	75 32                	jne    80104e71 <kill+0x58>
+      p->killed = 1;
+80104e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e42:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+80104e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e4c:	8b 40 0c             	mov    0xc(%eax),%eax
+80104e4f:	83 f8 02             	cmp    $0x2,%eax
+80104e52:	75 0a                	jne    80104e5e <kill+0x45>
+        p->state = RUNNABLE;
+80104e54:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e57:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+      release(&ptable.lock);
+80104e5e:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104e65:	e8 eb 01 00 00       	call   80105055 <release>
+      return 0;
+80104e6a:	b8 00 00 00 00       	mov    $0x0,%eax
+80104e6f:	eb 1e                	jmp    80104e8f <kill+0x76>
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104e71:	83 6d f4 80          	subl   $0xffffff80,-0xc(%ebp)
+80104e75:	81 7d f4 d4 49 11 80 	cmpl   $0x801149d4,-0xc(%ebp)
+80104e7c:	72 b6                	jb     80104e34 <kill+0x1b>
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+80104e7e:	c7 04 24 a0 29 11 80 	movl   $0x801129a0,(%esp)
+80104e85:	e8 cb 01 00 00       	call   80105055 <release>
+  return -1;
+80104e8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104e8f:	c9                   	leave  
+80104e90:	c3                   	ret    
+
+80104e91 <procdump>:
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+80104e91:	55                   	push   %ebp
+80104e92:	89 e5                	mov    %esp,%ebp
+80104e94:	83 ec 58             	sub    $0x58,%esp
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104e97:	c7 45 f0 d4 29 11 80 	movl   $0x801129d4,-0x10(%ebp)
+80104e9e:	e9 d8 00 00 00       	jmp    80104f7b <procdump+0xea>
+    if(p->state == UNUSED)
+80104ea3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104ea6:	8b 40 0c             	mov    0xc(%eax),%eax
+80104ea9:	85 c0                	test   %eax,%eax
+80104eab:	0f 84 c5 00 00 00    	je     80104f76 <procdump+0xe5>
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+80104eb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104eb4:	8b 40 0c             	mov    0xc(%eax),%eax
+80104eb7:	83 f8 05             	cmp    $0x5,%eax
+80104eba:	77 23                	ja     80104edf <procdump+0x4e>
+80104ebc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104ebf:	8b 40 0c             	mov    0xc(%eax),%eax
+80104ec2:	8b 04 85 10 b0 10 80 	mov    -0x7fef4ff0(,%eax,4),%eax
+80104ec9:	85 c0                	test   %eax,%eax
+80104ecb:	74 12                	je     80104edf <procdump+0x4e>
+      state = states[p->state];
+80104ecd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104ed0:	8b 40 0c             	mov    0xc(%eax),%eax
+80104ed3:	8b 04 85 10 b0 10 80 	mov    -0x7fef4ff0(,%eax,4),%eax
+80104eda:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80104edd:	eb 07                	jmp    80104ee6 <procdump+0x55>
+    else
+      state = "???";
+80104edf:	c7 45 ec b1 8a 10 80 	movl   $0x80108ab1,-0x14(%ebp)
+    cprintf("%d %s %s", p->pid, state, p->name);
+80104ee6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104ee9:	8d 50 6c             	lea    0x6c(%eax),%edx
+80104eec:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104eef:	8b 40 10             	mov    0x10(%eax),%eax
+80104ef2:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80104ef6:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80104ef9:	89 54 24 08          	mov    %edx,0x8(%esp)
+80104efd:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104f01:	c7 04 24 b5 8a 10 80 	movl   $0x80108ab5,(%esp)
+80104f08:	e8 9d b4 ff ff       	call   801003aa <cprintf>
+    if(p->state == SLEEPING){
+80104f0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104f10:	8b 40 0c             	mov    0xc(%eax),%eax
+80104f13:	83 f8 02             	cmp    $0x2,%eax
+80104f16:	75 50                	jne    80104f68 <procdump+0xd7>
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+80104f18:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104f1b:	8b 40 1c             	mov    0x1c(%eax),%eax
+80104f1e:	8b 40 0c             	mov    0xc(%eax),%eax
+80104f21:	83 c0 08             	add    $0x8,%eax
+80104f24:	8d 55 c4             	lea    -0x3c(%ebp),%edx
+80104f27:	89 54 24 04          	mov    %edx,0x4(%esp)
+80104f2b:	89 04 24             	mov    %eax,(%esp)
+80104f2e:	e8 71 01 00 00       	call   801050a4 <getcallerpcs>
+      for(i=0; i<10 && pc[i] != 0; i++)
+80104f33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80104f3a:	eb 1b                	jmp    80104f57 <procdump+0xc6>
+        cprintf(" %p", pc[i]);
+80104f3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104f3f:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
+80104f43:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104f47:	c7 04 24 be 8a 10 80 	movl   $0x80108abe,(%esp)
+80104f4e:	e8 57 b4 ff ff       	call   801003aa <cprintf>
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+80104f53:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80104f57:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+80104f5b:	7f 0b                	jg     80104f68 <procdump+0xd7>
+80104f5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104f60:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
+80104f64:	85 c0                	test   %eax,%eax
+80104f66:	75 d4                	jne    80104f3c <procdump+0xab>
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+80104f68:	c7 04 24 c2 8a 10 80 	movl   $0x80108ac2,(%esp)
+80104f6f:	e8 36 b4 ff ff       	call   801003aa <cprintf>
+80104f74:	eb 01                	jmp    80104f77 <procdump+0xe6>
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+80104f76:	90                   	nop
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104f77:	83 6d f0 80          	subl   $0xffffff80,-0x10(%ebp)
+80104f7b:	81 7d f0 d4 49 11 80 	cmpl   $0x801149d4,-0x10(%ebp)
+80104f82:	0f 82 1b ff ff ff    	jb     80104ea3 <procdump+0x12>
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+  }
+}
+80104f88:	c9                   	leave  
+80104f89:	c3                   	ret    
+	...
+
+80104f8c <readeflags>:
+  asm volatile("ltr %0" : : "r" (sel));
+}
+
+static inline uint
+readeflags(void)
+{
+80104f8c:	55                   	push   %ebp
+80104f8d:	89 e5                	mov    %esp,%ebp
+80104f8f:	53                   	push   %ebx
+80104f90:	83 ec 10             	sub    $0x10,%esp
+  uint eflags;
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80104f93:	9c                   	pushf  
+80104f94:	5b                   	pop    %ebx
+80104f95:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+  return eflags;
+80104f98:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80104f9b:	83 c4 10             	add    $0x10,%esp
+80104f9e:	5b                   	pop    %ebx
+80104f9f:	5d                   	pop    %ebp
+80104fa0:	c3                   	ret    
+
+80104fa1 <cli>:
+  asm volatile("movw %0, %%gs" : : "r" (v));
+}
+
+static inline void
+cli(void)
+{
+80104fa1:	55                   	push   %ebp
+80104fa2:	89 e5                	mov    %esp,%ebp
+  asm volatile("cli");
+80104fa4:	fa                   	cli    
+}
+80104fa5:	5d                   	pop    %ebp
+80104fa6:	c3                   	ret    
+
+80104fa7 <sti>:
+
+static inline void
+sti(void)
+{
+80104fa7:	55                   	push   %ebp
+80104fa8:	89 e5                	mov    %esp,%ebp
+  asm volatile("sti");
+80104faa:	fb                   	sti    
+}
+80104fab:	5d                   	pop    %ebp
+80104fac:	c3                   	ret    
+
+80104fad <xchg>:
+
+static inline uint
+xchg(volatile uint *addr, uint newval)
+{
+80104fad:	55                   	push   %ebp
+80104fae:	89 e5                	mov    %esp,%ebp
+80104fb0:	53                   	push   %ebx
+80104fb1:	83 ec 10             	sub    $0x10,%esp
+  uint result;
+  
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+               "+m" (*addr), "=a" (result) :
+80104fb4:	8b 55 08             	mov    0x8(%ebp),%edx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+  
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+80104fb7:	8b 45 0c             	mov    0xc(%ebp),%eax
+               "+m" (*addr), "=a" (result) :
+80104fba:	8b 4d 08             	mov    0x8(%ebp),%ecx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+  
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+80104fbd:	89 c3                	mov    %eax,%ebx
+80104fbf:	89 d8                	mov    %ebx,%eax
+80104fc1:	f0 87 02             	lock xchg %eax,(%edx)
+80104fc4:	89 c3                	mov    %eax,%ebx
+80104fc6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+               "+m" (*addr), "=a" (result) :
+               "1" (newval) :
+               "cc");
+  return result;
+80104fc9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80104fcc:	83 c4 10             	add    $0x10,%esp
+80104fcf:	5b                   	pop    %ebx
+80104fd0:	5d                   	pop    %ebp
+80104fd1:	c3                   	ret    
+
+80104fd2 <initlock>:
+#include "proc.h"
+#include "spinlock.h"
+
+void
+initlock(struct spinlock *lk, char *name)
+{
+80104fd2:	55                   	push   %ebp
+80104fd3:	89 e5                	mov    %esp,%ebp
+  lk->name = name;
+80104fd5:	8b 45 08             	mov    0x8(%ebp),%eax
+80104fd8:	8b 55 0c             	mov    0xc(%ebp),%edx
+80104fdb:	89 50 04             	mov    %edx,0x4(%eax)
+  lk->locked = 0;
+80104fde:	8b 45 08             	mov    0x8(%ebp),%eax
+80104fe1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->cpu = 0;
+80104fe7:	8b 45 08             	mov    0x8(%ebp),%eax
+80104fea:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+}
+80104ff1:	5d                   	pop    %ebp
+80104ff2:	c3                   	ret    
+
+80104ff3 <acquire>:
+// Loops (spins) until the lock is acquired.
+// Holding a lock for a long time may cause
+// other CPUs to waste time spinning to acquire it.
+void
+acquire(struct spinlock *lk)
+{
+80104ff3:	55                   	push   %ebp
+80104ff4:	89 e5                	mov    %esp,%ebp
+80104ff6:	83 ec 18             	sub    $0x18,%esp
+  pushcli(); // disable interrupts to avoid deadlock.
+80104ff9:	e8 49 01 00 00       	call   80105147 <pushcli>
+  if(holding(lk))
+80104ffe:	8b 45 08             	mov    0x8(%ebp),%eax
+80105001:	89 04 24             	mov    %eax,(%esp)
+80105004:	e8 14 01 00 00       	call   8010511d <holding>
+80105009:	85 c0                	test   %eax,%eax
+8010500b:	74 0c                	je     80105019 <acquire+0x26>
+    panic("acquire");
+8010500d:	c7 04 24 ee 8a 10 80 	movl   $0x80108aee,(%esp)
+80105014:	e8 2d b5 ff ff       	call   80100546 <panic>
+
+  // The xchg is atomic.
+  // It also serializes, so that reads after acquire are not
+  // reordered before it. 
+  while(xchg(&lk->locked, 1) != 0)
+80105019:	90                   	nop
+8010501a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010501d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80105024:	00 
+80105025:	89 04 24             	mov    %eax,(%esp)
+80105028:	e8 80 ff ff ff       	call   80104fad <xchg>
+8010502d:	85 c0                	test   %eax,%eax
+8010502f:	75 e9                	jne    8010501a <acquire+0x27>
+    ;
+
+  // Record info about lock acquisition for debugging.
+  lk->cpu = cpu;
+80105031:	8b 45 08             	mov    0x8(%ebp),%eax
+80105034:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+8010503b:	89 50 08             	mov    %edx,0x8(%eax)
+  getcallerpcs(&lk, lk->pcs);
+8010503e:	8b 45 08             	mov    0x8(%ebp),%eax
+80105041:	83 c0 0c             	add    $0xc,%eax
+80105044:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105048:	8d 45 08             	lea    0x8(%ebp),%eax
+8010504b:	89 04 24             	mov    %eax,(%esp)
+8010504e:	e8 51 00 00 00       	call   801050a4 <getcallerpcs>
+}
+80105053:	c9                   	leave  
+80105054:	c3                   	ret    
+
+80105055 <release>:
+
+// Release the lock.
+void
+release(struct spinlock *lk)
+{
+80105055:	55                   	push   %ebp
+80105056:	89 e5                	mov    %esp,%ebp
+80105058:	83 ec 18             	sub    $0x18,%esp
+  if(!holding(lk))
+8010505b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010505e:	89 04 24             	mov    %eax,(%esp)
+80105061:	e8 b7 00 00 00       	call   8010511d <holding>
+80105066:	85 c0                	test   %eax,%eax
+80105068:	75 0c                	jne    80105076 <release+0x21>
+    panic("release");
+8010506a:	c7 04 24 f6 8a 10 80 	movl   $0x80108af6,(%esp)
+80105071:	e8 d0 b4 ff ff       	call   80100546 <panic>
+
+  lk->pcs[0] = 0;
+80105076:	8b 45 08             	mov    0x8(%ebp),%eax
+80105079:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+  lk->cpu = 0;
+80105080:	8b 45 08             	mov    0x8(%ebp),%eax
+80105083:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+  // But the 2007 Intel 64 Architecture Memory Ordering White
+  // Paper says that Intel 64 and IA-32 will not move a load
+  // after a store. So lock->locked = 0 would work here.
+  // The xchg being asm volatile ensures gcc emits it after
+  // the above assignments (and after the critical section).
+  xchg(&lk->locked, 0);
+8010508a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010508d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80105094:	00 
+80105095:	89 04 24             	mov    %eax,(%esp)
+80105098:	e8 10 ff ff ff       	call   80104fad <xchg>
+
+  popcli();
+8010509d:	e8 ed 00 00 00       	call   8010518f <popcli>
+}
+801050a2:	c9                   	leave  
+801050a3:	c3                   	ret    
+
+801050a4 <getcallerpcs>:
+
+// Record the current call stack in pcs[] by following the %ebp chain.
+void
+getcallerpcs(void *v, uint pcs[])
+{
+801050a4:	55                   	push   %ebp
+801050a5:	89 e5                	mov    %esp,%ebp
+801050a7:	83 ec 10             	sub    $0x10,%esp
+  uint *ebp;
+  int i;
+  
+  ebp = (uint*)v - 2;
+801050aa:	8b 45 08             	mov    0x8(%ebp),%eax
+801050ad:	83 e8 08             	sub    $0x8,%eax
+801050b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  for(i = 0; i < 10; i++){
+801050b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+801050ba:	eb 38                	jmp    801050f4 <getcallerpcs+0x50>
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+801050bc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+801050c0:	74 53                	je     80105115 <getcallerpcs+0x71>
+801050c2:	81 7d fc ff ff ff 7f 	cmpl   $0x7fffffff,-0x4(%ebp)
+801050c9:	76 4a                	jbe    80105115 <getcallerpcs+0x71>
+801050cb:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
+801050cf:	74 44                	je     80105115 <getcallerpcs+0x71>
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+801050d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+801050d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+801050db:	8b 45 0c             	mov    0xc(%ebp),%eax
+801050de:	01 c2                	add    %eax,%edx
+801050e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801050e3:	8b 40 04             	mov    0x4(%eax),%eax
+801050e6:	89 02                	mov    %eax,(%edx)
+    ebp = (uint*)ebp[0]; // saved %ebp
+801050e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801050eb:	8b 00                	mov    (%eax),%eax
+801050ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
+{
+  uint *ebp;
+  int i;
+  
+  ebp = (uint*)v - 2;
+  for(i = 0; i < 10; i++){
+801050f0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+801050f4:	83 7d f8 09          	cmpl   $0x9,-0x8(%ebp)
+801050f8:	7e c2                	jle    801050bc <getcallerpcs+0x18>
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+    ebp = (uint*)ebp[0]; // saved %ebp
+  }
+  for(; i < 10; i++)
+801050fa:	eb 19                	jmp    80105115 <getcallerpcs+0x71>
+    pcs[i] = 0;
+801050fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+801050ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80105106:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105109:	01 d0                	add    %edx,%eax
+8010510b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+    ebp = (uint*)ebp[0]; // saved %ebp
+  }
+  for(; i < 10; i++)
+80105111:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+80105115:	83 7d f8 09          	cmpl   $0x9,-0x8(%ebp)
+80105119:	7e e1                	jle    801050fc <getcallerpcs+0x58>
+    pcs[i] = 0;
+}
+8010511b:	c9                   	leave  
+8010511c:	c3                   	ret    
+
+8010511d <holding>:
+
+// Check whether this cpu is holding the lock.
+int
+holding(struct spinlock *lock)
+{
+8010511d:	55                   	push   %ebp
+8010511e:	89 e5                	mov    %esp,%ebp
+  return lock->locked && lock->cpu == cpu;
+80105120:	8b 45 08             	mov    0x8(%ebp),%eax
+80105123:	8b 00                	mov    (%eax),%eax
+80105125:	85 c0                	test   %eax,%eax
+80105127:	74 17                	je     80105140 <holding+0x23>
+80105129:	8b 45 08             	mov    0x8(%ebp),%eax
+8010512c:	8b 50 08             	mov    0x8(%eax),%edx
+8010512f:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80105135:	39 c2                	cmp    %eax,%edx
+80105137:	75 07                	jne    80105140 <holding+0x23>
+80105139:	b8 01 00 00 00       	mov    $0x1,%eax
+8010513e:	eb 05                	jmp    80105145 <holding+0x28>
+80105140:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105145:	5d                   	pop    %ebp
+80105146:	c3                   	ret    
+
+80105147 <pushcli>:
+// it takes two popcli to undo two pushcli.  Also, if interrupts
+// are off, then pushcli, popcli leaves them off.
+
+void
+pushcli(void)
+{
+80105147:	55                   	push   %ebp
+80105148:	89 e5                	mov    %esp,%ebp
+8010514a:	83 ec 10             	sub    $0x10,%esp
+  int eflags;
+  
+  eflags = readeflags();
+8010514d:	e8 3a fe ff ff       	call   80104f8c <readeflags>
+80105152:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  cli();
+80105155:	e8 47 fe ff ff       	call   80104fa1 <cli>
+  if(cpu->ncli++ == 0)
+8010515a:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80105160:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
+80105166:	85 d2                	test   %edx,%edx
+80105168:	0f 94 c1             	sete   %cl
+8010516b:	83 c2 01             	add    $0x1,%edx
+8010516e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
+80105174:	84 c9                	test   %cl,%cl
+80105176:	74 15                	je     8010518d <pushcli+0x46>
+    cpu->intena = eflags & FL_IF;
+80105178:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+8010517e:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80105181:	81 e2 00 02 00 00    	and    $0x200,%edx
+80105187:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
+}
+8010518d:	c9                   	leave  
+8010518e:	c3                   	ret    
+
+8010518f <popcli>:
+
+void
+popcli(void)
+{
+8010518f:	55                   	push   %ebp
+80105190:	89 e5                	mov    %esp,%ebp
+80105192:	83 ec 18             	sub    $0x18,%esp
+  if(readeflags()&FL_IF)
+80105195:	e8 f2 fd ff ff       	call   80104f8c <readeflags>
+8010519a:	25 00 02 00 00       	and    $0x200,%eax
+8010519f:	85 c0                	test   %eax,%eax
+801051a1:	74 0c                	je     801051af <popcli+0x20>
+    panic("popcli - interruptible");
+801051a3:	c7 04 24 fe 8a 10 80 	movl   $0x80108afe,(%esp)
+801051aa:	e8 97 b3 ff ff       	call   80100546 <panic>
+  if(--cpu->ncli < 0)
+801051af:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801051b5:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
+801051bb:	83 ea 01             	sub    $0x1,%edx
+801051be:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
+801051c4:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
+801051ca:	85 c0                	test   %eax,%eax
+801051cc:	79 0c                	jns    801051da <popcli+0x4b>
+    panic("popcli");
+801051ce:	c7 04 24 15 8b 10 80 	movl   $0x80108b15,(%esp)
+801051d5:	e8 6c b3 ff ff       	call   80100546 <panic>
+  if(cpu->ncli == 0 && cpu->intena)
+801051da:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801051e0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
+801051e6:	85 c0                	test   %eax,%eax
+801051e8:	75 15                	jne    801051ff <popcli+0x70>
+801051ea:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801051f0:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
+801051f6:	85 c0                	test   %eax,%eax
+801051f8:	74 05                	je     801051ff <popcli+0x70>
+    sti();
+801051fa:	e8 a8 fd ff ff       	call   80104fa7 <sti>
+}
+801051ff:	c9                   	leave  
+80105200:	c3                   	ret    
+80105201:	00 00                	add    %al,(%eax)
+	...
+
+80105204 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+80105204:	55                   	push   %ebp
+80105205:	89 e5                	mov    %esp,%ebp
+80105207:	57                   	push   %edi
+80105208:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+80105209:	8b 4d 08             	mov    0x8(%ebp),%ecx
+8010520c:	8b 55 10             	mov    0x10(%ebp),%edx
+8010520f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105212:	89 cb                	mov    %ecx,%ebx
+80105214:	89 df                	mov    %ebx,%edi
+80105216:	89 d1                	mov    %edx,%ecx
+80105218:	fc                   	cld    
+80105219:	f3 aa                	rep stos %al,%es:(%edi)
+8010521b:	89 ca                	mov    %ecx,%edx
+8010521d:	89 fb                	mov    %edi,%ebx
+8010521f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+80105222:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+80105225:	5b                   	pop    %ebx
+80105226:	5f                   	pop    %edi
+80105227:	5d                   	pop    %ebp
+80105228:	c3                   	ret    
+
+80105229 <stosl>:
+
+static inline void
+stosl(void *addr, int data, int cnt)
+{
+80105229:	55                   	push   %ebp
+8010522a:	89 e5                	mov    %esp,%ebp
+8010522c:	57                   	push   %edi
+8010522d:	53                   	push   %ebx
+  asm volatile("cld; rep stosl" :
+8010522e:	8b 4d 08             	mov    0x8(%ebp),%ecx
+80105231:	8b 55 10             	mov    0x10(%ebp),%edx
+80105234:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105237:	89 cb                	mov    %ecx,%ebx
+80105239:	89 df                	mov    %ebx,%edi
+8010523b:	89 d1                	mov    %edx,%ecx
+8010523d:	fc                   	cld    
+8010523e:	f3 ab                	rep stos %eax,%es:(%edi)
+80105240:	89 ca                	mov    %ecx,%edx
+80105242:	89 fb                	mov    %edi,%ebx
+80105244:	89 5d 08             	mov    %ebx,0x8(%ebp)
+80105247:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+8010524a:	5b                   	pop    %ebx
+8010524b:	5f                   	pop    %edi
+8010524c:	5d                   	pop    %ebp
+8010524d:	c3                   	ret    
+
+8010524e <memset>:
+#include "types.h"
+#include "x86.h"
+
+void*
+memset(void *dst, int c, uint n)
+{
+8010524e:	55                   	push   %ebp
+8010524f:	89 e5                	mov    %esp,%ebp
+80105251:	83 ec 0c             	sub    $0xc,%esp
+  if ((int)dst%4 == 0 && n%4 == 0){
+80105254:	8b 45 08             	mov    0x8(%ebp),%eax
+80105257:	83 e0 03             	and    $0x3,%eax
+8010525a:	85 c0                	test   %eax,%eax
+8010525c:	75 49                	jne    801052a7 <memset+0x59>
+8010525e:	8b 45 10             	mov    0x10(%ebp),%eax
+80105261:	83 e0 03             	and    $0x3,%eax
+80105264:	85 c0                	test   %eax,%eax
+80105266:	75 3f                	jne    801052a7 <memset+0x59>
+    c &= 0xFF;
+80105268:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+8010526f:	8b 45 10             	mov    0x10(%ebp),%eax
+80105272:	c1 e8 02             	shr    $0x2,%eax
+80105275:	89 c2                	mov    %eax,%edx
+80105277:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010527a:	89 c1                	mov    %eax,%ecx
+8010527c:	c1 e1 18             	shl    $0x18,%ecx
+8010527f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105282:	c1 e0 10             	shl    $0x10,%eax
+80105285:	09 c1                	or     %eax,%ecx
+80105287:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010528a:	c1 e0 08             	shl    $0x8,%eax
+8010528d:	09 c8                	or     %ecx,%eax
+8010528f:	0b 45 0c             	or     0xc(%ebp),%eax
+80105292:	89 54 24 08          	mov    %edx,0x8(%esp)
+80105296:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010529a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010529d:	89 04 24             	mov    %eax,(%esp)
+801052a0:	e8 84 ff ff ff       	call   80105229 <stosl>
+801052a5:	eb 19                	jmp    801052c0 <memset+0x72>
+  } else
+    stosb(dst, c, n);
+801052a7:	8b 45 10             	mov    0x10(%ebp),%eax
+801052aa:	89 44 24 08          	mov    %eax,0x8(%esp)
+801052ae:	8b 45 0c             	mov    0xc(%ebp),%eax
+801052b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+801052b5:	8b 45 08             	mov    0x8(%ebp),%eax
+801052b8:	89 04 24             	mov    %eax,(%esp)
+801052bb:	e8 44 ff ff ff       	call   80105204 <stosb>
+  return dst;
+801052c0:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+801052c3:	c9                   	leave  
+801052c4:	c3                   	ret    
+
+801052c5 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, uint n)
+{
+801052c5:	55                   	push   %ebp
+801052c6:	89 e5                	mov    %esp,%ebp
+801052c8:	83 ec 10             	sub    $0x10,%esp
+  const uchar *s1, *s2;
+  
+  s1 = v1;
+801052cb:	8b 45 08             	mov    0x8(%ebp),%eax
+801052ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  s2 = v2;
+801052d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+801052d4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0){
+801052d7:	eb 32                	jmp    8010530b <memcmp+0x46>
+    if(*s1 != *s2)
+801052d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801052dc:	0f b6 10             	movzbl (%eax),%edx
+801052df:	8b 45 f8             	mov    -0x8(%ebp),%eax
+801052e2:	0f b6 00             	movzbl (%eax),%eax
+801052e5:	38 c2                	cmp    %al,%dl
+801052e7:	74 1a                	je     80105303 <memcmp+0x3e>
+      return *s1 - *s2;
+801052e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801052ec:	0f b6 00             	movzbl (%eax),%eax
+801052ef:	0f b6 d0             	movzbl %al,%edx
+801052f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+801052f5:	0f b6 00             	movzbl (%eax),%eax
+801052f8:	0f b6 c0             	movzbl %al,%eax
+801052fb:	89 d1                	mov    %edx,%ecx
+801052fd:	29 c1                	sub    %eax,%ecx
+801052ff:	89 c8                	mov    %ecx,%eax
+80105301:	eb 1c                	jmp    8010531f <memcmp+0x5a>
+    s1++, s2++;
+80105303:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+80105307:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  const uchar *s1, *s2;
+  
+  s1 = v1;
+  s2 = v2;
+  while(n-- > 0){
+8010530b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010530f:	0f 95 c0             	setne  %al
+80105312:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105316:	84 c0                	test   %al,%al
+80105318:	75 bf                	jne    801052d9 <memcmp+0x14>
+    if(*s1 != *s2)
+      return *s1 - *s2;
+    s1++, s2++;
+  }
+
+  return 0;
+8010531a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010531f:	c9                   	leave  
+80105320:	c3                   	ret    
+
+80105321 <memmove>:
+
+void*
+memmove(void *dst, const void *src, uint n)
+{
+80105321:	55                   	push   %ebp
+80105322:	89 e5                	mov    %esp,%ebp
+80105324:	83 ec 10             	sub    $0x10,%esp
+  const char *s;
+  char *d;
+
+  s = src;
+80105327:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010532a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  d = dst;
+8010532d:	8b 45 08             	mov    0x8(%ebp),%eax
+80105330:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  if(s < d && s + n > d){
+80105333:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105336:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+80105339:	73 54                	jae    8010538f <memmove+0x6e>
+8010533b:	8b 45 10             	mov    0x10(%ebp),%eax
+8010533e:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80105341:	01 d0                	add    %edx,%eax
+80105343:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+80105346:	76 47                	jbe    8010538f <memmove+0x6e>
+    s += n;
+80105348:	8b 45 10             	mov    0x10(%ebp),%eax
+8010534b:	01 45 fc             	add    %eax,-0x4(%ebp)
+    d += n;
+8010534e:	8b 45 10             	mov    0x10(%ebp),%eax
+80105351:	01 45 f8             	add    %eax,-0x8(%ebp)
+    while(n-- > 0)
+80105354:	eb 13                	jmp    80105369 <memmove+0x48>
+      *--d = *--s;
+80105356:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
+8010535a:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+8010535e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105361:	0f b6 10             	movzbl (%eax),%edx
+80105364:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105367:	88 10                	mov    %dl,(%eax)
+  s = src;
+  d = dst;
+  if(s < d && s + n > d){
+    s += n;
+    d += n;
+    while(n-- > 0)
+80105369:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010536d:	0f 95 c0             	setne  %al
+80105370:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105374:	84 c0                	test   %al,%al
+80105376:	75 de                	jne    80105356 <memmove+0x35>
+  const char *s;
+  char *d;
+
+  s = src;
+  d = dst;
+  if(s < d && s + n > d){
+80105378:	eb 25                	jmp    8010539f <memmove+0x7e>
+    d += n;
+    while(n-- > 0)
+      *--d = *--s;
+  } else
+    while(n-- > 0)
+      *d++ = *s++;
+8010537a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010537d:	0f b6 10             	movzbl (%eax),%edx
+80105380:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105383:	88 10                	mov    %dl,(%eax)
+80105385:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+80105389:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+8010538d:	eb 01                	jmp    80105390 <memmove+0x6f>
+    s += n;
+    d += n;
+    while(n-- > 0)
+      *--d = *--s;
+  } else
+    while(n-- > 0)
+8010538f:	90                   	nop
+80105390:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105394:	0f 95 c0             	setne  %al
+80105397:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+8010539b:	84 c0                	test   %al,%al
+8010539d:	75 db                	jne    8010537a <memmove+0x59>
+      *d++ = *s++;
+
+  return dst;
+8010539f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+801053a2:	c9                   	leave  
+801053a3:	c3                   	ret    
+
+801053a4 <memcpy>:
+
+// memcpy exists to placate GCC.  Use memmove.
+void*
+memcpy(void *dst, const void *src, uint n)
+{
+801053a4:	55                   	push   %ebp
+801053a5:	89 e5                	mov    %esp,%ebp
+801053a7:	83 ec 0c             	sub    $0xc,%esp
+  return memmove(dst, src, n);
+801053aa:	8b 45 10             	mov    0x10(%ebp),%eax
+801053ad:	89 44 24 08          	mov    %eax,0x8(%esp)
+801053b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+801053b4:	89 44 24 04          	mov    %eax,0x4(%esp)
+801053b8:	8b 45 08             	mov    0x8(%ebp),%eax
+801053bb:	89 04 24             	mov    %eax,(%esp)
+801053be:	e8 5e ff ff ff       	call   80105321 <memmove>
+}
+801053c3:	c9                   	leave  
+801053c4:	c3                   	ret    
+
+801053c5 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+801053c5:	55                   	push   %ebp
+801053c6:	89 e5                	mov    %esp,%ebp
+  while(n > 0 && *p && *p == *q)
+801053c8:	eb 0c                	jmp    801053d6 <strncmp+0x11>
+    n--, p++, q++;
+801053ca:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+801053ce:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+801053d2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+  while(n > 0 && *p && *p == *q)
+801053d6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+801053da:	74 1a                	je     801053f6 <strncmp+0x31>
+801053dc:	8b 45 08             	mov    0x8(%ebp),%eax
+801053df:	0f b6 00             	movzbl (%eax),%eax
+801053e2:	84 c0                	test   %al,%al
+801053e4:	74 10                	je     801053f6 <strncmp+0x31>
+801053e6:	8b 45 08             	mov    0x8(%ebp),%eax
+801053e9:	0f b6 10             	movzbl (%eax),%edx
+801053ec:	8b 45 0c             	mov    0xc(%ebp),%eax
+801053ef:	0f b6 00             	movzbl (%eax),%eax
+801053f2:	38 c2                	cmp    %al,%dl
+801053f4:	74 d4                	je     801053ca <strncmp+0x5>
+    n--, p++, q++;
+  if(n == 0)
+801053f6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+801053fa:	75 07                	jne    80105403 <strncmp+0x3e>
+    return 0;
+801053fc:	b8 00 00 00 00       	mov    $0x0,%eax
+80105401:	eb 18                	jmp    8010541b <strncmp+0x56>
+  return (uchar)*p - (uchar)*q;
+80105403:	8b 45 08             	mov    0x8(%ebp),%eax
+80105406:	0f b6 00             	movzbl (%eax),%eax
+80105409:	0f b6 d0             	movzbl %al,%edx
+8010540c:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010540f:	0f b6 00             	movzbl (%eax),%eax
+80105412:	0f b6 c0             	movzbl %al,%eax
+80105415:	89 d1                	mov    %edx,%ecx
+80105417:	29 c1                	sub    %eax,%ecx
+80105419:	89 c8                	mov    %ecx,%eax
+}
+8010541b:	5d                   	pop    %ebp
+8010541c:	c3                   	ret    
+
+8010541d <strncpy>:
+
+char*
+strncpy(char *s, const char *t, int n)
+{
+8010541d:	55                   	push   %ebp
+8010541e:	89 e5                	mov    %esp,%ebp
+80105420:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+  
+  os = s;
+80105423:	8b 45 08             	mov    0x8(%ebp),%eax
+80105426:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while(n-- > 0 && (*s++ = *t++) != 0)
+80105429:	90                   	nop
+8010542a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010542e:	0f 9f c0             	setg   %al
+80105431:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105435:	84 c0                	test   %al,%al
+80105437:	74 30                	je     80105469 <strncpy+0x4c>
+80105439:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010543c:	0f b6 10             	movzbl (%eax),%edx
+8010543f:	8b 45 08             	mov    0x8(%ebp),%eax
+80105442:	88 10                	mov    %dl,(%eax)
+80105444:	8b 45 08             	mov    0x8(%ebp),%eax
+80105447:	0f b6 00             	movzbl (%eax),%eax
+8010544a:	84 c0                	test   %al,%al
+8010544c:	0f 95 c0             	setne  %al
+8010544f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+80105453:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+80105457:	84 c0                	test   %al,%al
+80105459:	75 cf                	jne    8010542a <strncpy+0xd>
+    ;
+  while(n-- > 0)
+8010545b:	eb 0c                	jmp    80105469 <strncpy+0x4c>
+    *s++ = 0;
+8010545d:	8b 45 08             	mov    0x8(%ebp),%eax
+80105460:	c6 00 00             	movb   $0x0,(%eax)
+80105463:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+80105467:	eb 01                	jmp    8010546a <strncpy+0x4d>
+  char *os;
+  
+  os = s;
+  while(n-- > 0 && (*s++ = *t++) != 0)
+    ;
+  while(n-- > 0)
+80105469:	90                   	nop
+8010546a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010546e:	0f 9f c0             	setg   %al
+80105471:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105475:	84 c0                	test   %al,%al
+80105477:	75 e4                	jne    8010545d <strncpy+0x40>
+    *s++ = 0;
+  return os;
+80105479:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+8010547c:	c9                   	leave  
+8010547d:	c3                   	ret    
+
+8010547e <safestrcpy>:
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+8010547e:	55                   	push   %ebp
+8010547f:	89 e5                	mov    %esp,%ebp
+80105481:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+  
+  os = s;
+80105484:	8b 45 08             	mov    0x8(%ebp),%eax
+80105487:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  if(n <= 0)
+8010548a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010548e:	7f 05                	jg     80105495 <safestrcpy+0x17>
+    return os;
+80105490:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105493:	eb 35                	jmp    801054ca <safestrcpy+0x4c>
+  while(--n > 0 && (*s++ = *t++) != 0)
+80105495:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105499:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010549d:	7e 22                	jle    801054c1 <safestrcpy+0x43>
+8010549f:	8b 45 0c             	mov    0xc(%ebp),%eax
+801054a2:	0f b6 10             	movzbl (%eax),%edx
+801054a5:	8b 45 08             	mov    0x8(%ebp),%eax
+801054a8:	88 10                	mov    %dl,(%eax)
+801054aa:	8b 45 08             	mov    0x8(%ebp),%eax
+801054ad:	0f b6 00             	movzbl (%eax),%eax
+801054b0:	84 c0                	test   %al,%al
+801054b2:	0f 95 c0             	setne  %al
+801054b5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+801054b9:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+801054bd:	84 c0                	test   %al,%al
+801054bf:	75 d4                	jne    80105495 <safestrcpy+0x17>
+    ;
+  *s = 0;
+801054c1:	8b 45 08             	mov    0x8(%ebp),%eax
+801054c4:	c6 00 00             	movb   $0x0,(%eax)
+  return os;
+801054c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+801054ca:	c9                   	leave  
+801054cb:	c3                   	ret    
+
+801054cc <strlen>:
+
+int
+strlen(const char *s)
+{
+801054cc:	55                   	push   %ebp
+801054cd:	89 e5                	mov    %esp,%ebp
+801054cf:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+801054d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+801054d9:	eb 04                	jmp    801054df <strlen+0x13>
+801054db:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+801054df:	8b 55 fc             	mov    -0x4(%ebp),%edx
+801054e2:	8b 45 08             	mov    0x8(%ebp),%eax
+801054e5:	01 d0                	add    %edx,%eax
+801054e7:	0f b6 00             	movzbl (%eax),%eax
+801054ea:	84 c0                	test   %al,%al
+801054ec:	75 ed                	jne    801054db <strlen+0xf>
+    ;
+  return n;
+801054ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+801054f1:	c9                   	leave  
+801054f2:	c3                   	ret    
+	...
+
+801054f4 <swtch>:
+# Save current register context in old
+# and then load register context from new.
+
+.globl swtch
+swtch:
+  movl 4(%esp), %eax
+801054f4:	8b 44 24 04          	mov    0x4(%esp),%eax
+  movl 8(%esp), %edx
+801054f8:	8b 54 24 08          	mov    0x8(%esp),%edx
+
+  # Save old callee-save registers
+  pushl %ebp
+801054fc:	55                   	push   %ebp
+  pushl %ebx
+801054fd:	53                   	push   %ebx
+  pushl %esi
+801054fe:	56                   	push   %esi
+  pushl %edi
+801054ff:	57                   	push   %edi
+
+  # Switch stacks
+  movl %esp, (%eax)
+80105500:	89 20                	mov    %esp,(%eax)
+  movl %edx, %esp
+80105502:	89 d4                	mov    %edx,%esp
+
+  # Load new callee-save registers
+  popl %edi
+80105504:	5f                   	pop    %edi
+  popl %esi
+80105505:	5e                   	pop    %esi
+  popl %ebx
+80105506:	5b                   	pop    %ebx
+  popl %ebp
+80105507:	5d                   	pop    %ebp
+  ret
+80105508:	c3                   	ret    
+80105509:	00 00                	add    %al,(%eax)
+	...
+
+8010550c <fetchint>:
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+8010550c:	55                   	push   %ebp
+8010550d:	89 e5                	mov    %esp,%ebp
+  if(addr >= proc->sz || addr+4 > proc->sz)
+8010550f:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80105515:	8b 00                	mov    (%eax),%eax
+80105517:	3b 45 08             	cmp    0x8(%ebp),%eax
+8010551a:	76 12                	jbe    8010552e <fetchint+0x22>
+8010551c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010551f:	8d 50 04             	lea    0x4(%eax),%edx
+80105522:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80105528:	8b 00                	mov    (%eax),%eax
+8010552a:	39 c2                	cmp    %eax,%edx
+8010552c:	76 07                	jbe    80105535 <fetchint+0x29>
+    return -1;
+8010552e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105533:	eb 0f                	jmp    80105544 <fetchint+0x38>
+  *ip = *(int*)(addr);
+80105535:	8b 45 08             	mov    0x8(%ebp),%eax
+80105538:	8b 10                	mov    (%eax),%edx
+8010553a:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010553d:	89 10                	mov    %edx,(%eax)
+  return 0;
+8010553f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105544:	5d                   	pop    %ebp
+80105545:	c3                   	ret    
+
+80105546 <fetchstr>:
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+80105546:	55                   	push   %ebp
+80105547:	89 e5                	mov    %esp,%ebp
+80105549:	83 ec 10             	sub    $0x10,%esp
+  char *s, *ep;
+
+  if(addr >= proc->sz)
+8010554c:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80105552:	8b 00                	mov    (%eax),%eax
+80105554:	3b 45 08             	cmp    0x8(%ebp),%eax
+80105557:	77 07                	ja     80105560 <fetchstr+0x1a>
+    return -1;
+80105559:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010555e:	eb 48                	jmp    801055a8 <fetchstr+0x62>
+  *pp = (char*)addr;
+80105560:	8b 55 08             	mov    0x8(%ebp),%edx
+80105563:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105566:	89 10                	mov    %edx,(%eax)
+  ep = (char*)proc->sz;
+80105568:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010556e:	8b 00                	mov    (%eax),%eax
+80105570:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(s = *pp; s < ep; s++)
+80105573:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105576:	8b 00                	mov    (%eax),%eax
+80105578:	89 45 fc             	mov    %eax,-0x4(%ebp)
+8010557b:	eb 1e                	jmp    8010559b <fetchstr+0x55>
+    if(*s == 0)
+8010557d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105580:	0f b6 00             	movzbl (%eax),%eax
+80105583:	84 c0                	test   %al,%al
+80105585:	75 10                	jne    80105597 <fetchstr+0x51>
+      return s - *pp;
+80105587:	8b 55 fc             	mov    -0x4(%ebp),%edx
+8010558a:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010558d:	8b 00                	mov    (%eax),%eax
+8010558f:	89 d1                	mov    %edx,%ecx
+80105591:	29 c1                	sub    %eax,%ecx
+80105593:	89 c8                	mov    %ecx,%eax
+80105595:	eb 11                	jmp    801055a8 <fetchstr+0x62>
+
+  if(addr >= proc->sz)
+    return -1;
+  *pp = (char*)addr;
+  ep = (char*)proc->sz;
+  for(s = *pp; s < ep; s++)
+80105597:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+8010559b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010559e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+801055a1:	72 da                	jb     8010557d <fetchstr+0x37>
+    if(*s == 0)
+      return s - *pp;
+  return -1;
+801055a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801055a8:	c9                   	leave  
+801055a9:	c3                   	ret    
+
+801055aa <argint>:
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+801055aa:	55                   	push   %ebp
+801055ab:	89 e5                	mov    %esp,%ebp
+801055ad:	83 ec 08             	sub    $0x8,%esp
+  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+801055b0:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801055b6:	8b 40 18             	mov    0x18(%eax),%eax
+801055b9:	8b 50 44             	mov    0x44(%eax),%edx
+801055bc:	8b 45 08             	mov    0x8(%ebp),%eax
+801055bf:	c1 e0 02             	shl    $0x2,%eax
+801055c2:	01 d0                	add    %edx,%eax
+801055c4:	8d 50 04             	lea    0x4(%eax),%edx
+801055c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+801055ca:	89 44 24 04          	mov    %eax,0x4(%esp)
+801055ce:	89 14 24             	mov    %edx,(%esp)
+801055d1:	e8 36 ff ff ff       	call   8010550c <fetchint>
+}
+801055d6:	c9                   	leave  
+801055d7:	c3                   	ret    
+
+801055d8 <argptr>:
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size n bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+801055d8:	55                   	push   %ebp
+801055d9:	89 e5                	mov    %esp,%ebp
+801055db:	83 ec 18             	sub    $0x18,%esp
+  int i;
+  
+  if(argint(n, &i) < 0)
+801055de:	8d 45 fc             	lea    -0x4(%ebp),%eax
+801055e1:	89 44 24 04          	mov    %eax,0x4(%esp)
+801055e5:	8b 45 08             	mov    0x8(%ebp),%eax
+801055e8:	89 04 24             	mov    %eax,(%esp)
+801055eb:	e8 ba ff ff ff       	call   801055aa <argint>
+801055f0:	85 c0                	test   %eax,%eax
+801055f2:	79 07                	jns    801055fb <argptr+0x23>
+    return -1;
+801055f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801055f9:	eb 3d                	jmp    80105638 <argptr+0x60>
+  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+801055fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801055fe:	89 c2                	mov    %eax,%edx
+80105600:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80105606:	8b 00                	mov    (%eax),%eax
+80105608:	39 c2                	cmp    %eax,%edx
+8010560a:	73 16                	jae    80105622 <argptr+0x4a>
+8010560c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010560f:	89 c2                	mov    %eax,%edx
+80105611:	8b 45 10             	mov    0x10(%ebp),%eax
+80105614:	01 c2                	add    %eax,%edx
+80105616:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010561c:	8b 00                	mov    (%eax),%eax
+8010561e:	39 c2                	cmp    %eax,%edx
+80105620:	76 07                	jbe    80105629 <argptr+0x51>
+    return -1;
+80105622:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105627:	eb 0f                	jmp    80105638 <argptr+0x60>
+  *pp = (char*)i;
+80105629:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010562c:	89 c2                	mov    %eax,%edx
+8010562e:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105631:	89 10                	mov    %edx,(%eax)
+  return 0;
+80105633:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105638:	c9                   	leave  
+80105639:	c3                   	ret    
+
+8010563a <argstr>:
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+8010563a:	55                   	push   %ebp
+8010563b:	89 e5                	mov    %esp,%ebp
+8010563d:	83 ec 18             	sub    $0x18,%esp
+  int addr;
+  if(argint(n, &addr) < 0)
+80105640:	8d 45 fc             	lea    -0x4(%ebp),%eax
+80105643:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105647:	8b 45 08             	mov    0x8(%ebp),%eax
+8010564a:	89 04 24             	mov    %eax,(%esp)
+8010564d:	e8 58 ff ff ff       	call   801055aa <argint>
+80105652:	85 c0                	test   %eax,%eax
+80105654:	79 07                	jns    8010565d <argstr+0x23>
+    return -1;
+80105656:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010565b:	eb 12                	jmp    8010566f <argstr+0x35>
+  return fetchstr(addr, pp);
+8010565d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105660:	8b 55 0c             	mov    0xc(%ebp),%edx
+80105663:	89 54 24 04          	mov    %edx,0x4(%esp)
+80105667:	89 04 24             	mov    %eax,(%esp)
+8010566a:	e8 d7 fe ff ff       	call   80105546 <fetchstr>
+}
+8010566f:	c9                   	leave  
+80105670:	c3                   	ret    
+
+80105671 <syscall>:
+[SYS_set_priority]  sys_set_priority,
+};
+
+void
+syscall(void)
+{
+80105671:	55                   	push   %ebp
+80105672:	89 e5                	mov    %esp,%ebp
+80105674:	53                   	push   %ebx
+80105675:	83 ec 24             	sub    $0x24,%esp
+  int num;
+
+  num = proc->tf->eax;
+80105678:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010567e:	8b 40 18             	mov    0x18(%eax),%eax
+80105681:	8b 40 1c             	mov    0x1c(%eax),%eax
+80105684:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+80105687:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010568b:	7e 30                	jle    801056bd <syscall+0x4c>
+8010568d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105690:	83 f8 1a             	cmp    $0x1a,%eax
+80105693:	77 28                	ja     801056bd <syscall+0x4c>
+80105695:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105698:	8b 04 85 40 b0 10 80 	mov    -0x7fef4fc0(,%eax,4),%eax
+8010569f:	85 c0                	test   %eax,%eax
+801056a1:	74 1a                	je     801056bd <syscall+0x4c>
+    proc->tf->eax = syscalls[num]();
+801056a3:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801056a9:	8b 58 18             	mov    0x18(%eax),%ebx
+801056ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801056af:	8b 04 85 40 b0 10 80 	mov    -0x7fef4fc0(,%eax,4),%eax
+801056b6:	ff d0                	call   *%eax
+801056b8:	89 43 1c             	mov    %eax,0x1c(%ebx)
+801056bb:	eb 3d                	jmp    801056fa <syscall+0x89>
+  } else {
+    cprintf("%d %s: unknown sys call %d\n",
+            proc->pid, proc->name, num);
+801056bd:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801056c3:	8d 48 6c             	lea    0x6c(%eax),%ecx
+801056c6:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+
+  num = proc->tf->eax;
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+    proc->tf->eax = syscalls[num]();
+  } else {
+    cprintf("%d %s: unknown sys call %d\n",
+801056cc:	8b 40 10             	mov    0x10(%eax),%eax
+801056cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801056d2:	89 54 24 0c          	mov    %edx,0xc(%esp)
+801056d6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+801056da:	89 44 24 04          	mov    %eax,0x4(%esp)
+801056de:	c7 04 24 1c 8b 10 80 	movl   $0x80108b1c,(%esp)
+801056e5:	e8 c0 ac ff ff       	call   801003aa <cprintf>
+            proc->pid, proc->name, num);
+    proc->tf->eax = -1;
+801056ea:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801056f0:	8b 40 18             	mov    0x18(%eax),%eax
+801056f3:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
+  }
+}
+801056fa:	83 c4 24             	add    $0x24,%esp
+801056fd:	5b                   	pop    %ebx
+801056fe:	5d                   	pop    %ebp
+801056ff:	c3                   	ret    
+
+80105700 <argfd>:
+
+// Fetch the nth word-sized system call argument as a file descriptor
+// and return both the descriptor and the corresponding struct file.
+static int
+argfd(int n, int *pfd, struct file **pf)
+{
+80105700:	55                   	push   %ebp
+80105701:	89 e5                	mov    %esp,%ebp
+80105703:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  struct file *f;
+
+  if(argint(n, &fd) < 0)
+80105706:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105709:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010570d:	8b 45 08             	mov    0x8(%ebp),%eax
+80105710:	89 04 24             	mov    %eax,(%esp)
+80105713:	e8 92 fe ff ff       	call   801055aa <argint>
+80105718:	85 c0                	test   %eax,%eax
+8010571a:	79 07                	jns    80105723 <argfd+0x23>
+    return -1;
+8010571c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105721:	eb 50                	jmp    80105773 <argfd+0x73>
+  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
+80105723:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105726:	85 c0                	test   %eax,%eax
+80105728:	78 21                	js     8010574b <argfd+0x4b>
+8010572a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010572d:	83 f8 0f             	cmp    $0xf,%eax
+80105730:	7f 19                	jg     8010574b <argfd+0x4b>
+80105732:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80105738:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010573b:	83 c2 08             	add    $0x8,%edx
+8010573e:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80105742:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105745:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105749:	75 07                	jne    80105752 <argfd+0x52>
+    return -1;
+8010574b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105750:	eb 21                	jmp    80105773 <argfd+0x73>
+  if(pfd)
+80105752:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+80105756:	74 08                	je     80105760 <argfd+0x60>
+    *pfd = fd;
+80105758:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010575b:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010575e:	89 10                	mov    %edx,(%eax)
+  if(pf)
+80105760:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105764:	74 08                	je     8010576e <argfd+0x6e>
+    *pf = f;
+80105766:	8b 45 10             	mov    0x10(%ebp),%eax
+80105769:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010576c:	89 10                	mov    %edx,(%eax)
+  return 0;
+8010576e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105773:	c9                   	leave  
+80105774:	c3                   	ret    
+
+80105775 <fdalloc>:
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+80105775:	55                   	push   %ebp
+80105776:	89 e5                	mov    %esp,%ebp
+80105778:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+
+  for(fd = 0; fd < NOFILE; fd++){
+8010577b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+80105782:	eb 30                	jmp    801057b4 <fdalloc+0x3f>
+    if(proc->ofile[fd] == 0){
+80105784:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010578a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+8010578d:	83 c2 08             	add    $0x8,%edx
+80105790:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80105794:	85 c0                	test   %eax,%eax
+80105796:	75 18                	jne    801057b0 <fdalloc+0x3b>
+      proc->ofile[fd] = f;
+80105798:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010579e:	8b 55 fc             	mov    -0x4(%ebp),%edx
+801057a1:	8d 4a 08             	lea    0x8(%edx),%ecx
+801057a4:	8b 55 08             	mov    0x8(%ebp),%edx
+801057a7:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
+      return fd;
+801057ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801057ae:	eb 0f                	jmp    801057bf <fdalloc+0x4a>
+static int
+fdalloc(struct file *f)
+{
+  int fd;
+
+  for(fd = 0; fd < NOFILE; fd++){
+801057b0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+801057b4:	83 7d fc 0f          	cmpl   $0xf,-0x4(%ebp)
+801057b8:	7e ca                	jle    80105784 <fdalloc+0xf>
+    if(proc->ofile[fd] == 0){
+      proc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+801057ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801057bf:	c9                   	leave  
+801057c0:	c3                   	ret    
+
+801057c1 <sys_dup>:
+
+int
+sys_dup(void)
+{
+801057c1:	55                   	push   %ebp
+801057c2:	89 e5                	mov    %esp,%ebp
+801057c4:	83 ec 28             	sub    $0x28,%esp
+  struct file *f;
+  int fd;
+  
+  if(argfd(0, 0, &f) < 0)
+801057c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801057ca:	89 44 24 08          	mov    %eax,0x8(%esp)
+801057ce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801057d5:	00 
+801057d6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801057dd:	e8 1e ff ff ff       	call   80105700 <argfd>
+801057e2:	85 c0                	test   %eax,%eax
+801057e4:	79 07                	jns    801057ed <sys_dup+0x2c>
+    return -1;
+801057e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801057eb:	eb 29                	jmp    80105816 <sys_dup+0x55>
+  if((fd=fdalloc(f)) < 0)
+801057ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801057f0:	89 04 24             	mov    %eax,(%esp)
+801057f3:	e8 7d ff ff ff       	call   80105775 <fdalloc>
+801057f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801057fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801057ff:	79 07                	jns    80105808 <sys_dup+0x47>
+    return -1;
+80105801:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105806:	eb 0e                	jmp    80105816 <sys_dup+0x55>
+  filedup(f);
+80105808:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010580b:	89 04 24             	mov    %eax,(%esp)
+8010580e:	e8 9d b7 ff ff       	call   80100fb0 <filedup>
+  return fd;
+80105813:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80105816:	c9                   	leave  
+80105817:	c3                   	ret    
+
+80105818 <sys_read>:
+
+int
+sys_read(void)
+{
+80105818:	55                   	push   %ebp
+80105819:	89 e5                	mov    %esp,%ebp
+8010581b:	83 ec 28             	sub    $0x28,%esp
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+8010581e:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105821:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105825:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+8010582c:	00 
+8010582d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105834:	e8 c7 fe ff ff       	call   80105700 <argfd>
+80105839:	85 c0                	test   %eax,%eax
+8010583b:	78 35                	js     80105872 <sys_read+0x5a>
+8010583d:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105840:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105844:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+8010584b:	e8 5a fd ff ff       	call   801055aa <argint>
+80105850:	85 c0                	test   %eax,%eax
+80105852:	78 1e                	js     80105872 <sys_read+0x5a>
+80105854:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105857:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010585b:	8d 45 ec             	lea    -0x14(%ebp),%eax
+8010585e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105862:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80105869:	e8 6a fd ff ff       	call   801055d8 <argptr>
+8010586e:	85 c0                	test   %eax,%eax
+80105870:	79 07                	jns    80105879 <sys_read+0x61>
+    return -1;
+80105872:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105877:	eb 19                	jmp    80105892 <sys_read+0x7a>
+  return fileread(f, p, n);
+80105879:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+8010587c:	8b 55 ec             	mov    -0x14(%ebp),%edx
+8010587f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105882:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+80105886:	89 54 24 04          	mov    %edx,0x4(%esp)
+8010588a:	89 04 24             	mov    %eax,(%esp)
+8010588d:	e8 8b b8 ff ff       	call   8010111d <fileread>
+}
+80105892:	c9                   	leave  
+80105893:	c3                   	ret    
+
+80105894 <sys_write>:
+
+int
+sys_write(void)
+{
+80105894:	55                   	push   %ebp
+80105895:	89 e5                	mov    %esp,%ebp
+80105897:	83 ec 28             	sub    $0x28,%esp
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+8010589a:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010589d:	89 44 24 08          	mov    %eax,0x8(%esp)
+801058a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801058a8:	00 
+801058a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801058b0:	e8 4b fe ff ff       	call   80105700 <argfd>
+801058b5:	85 c0                	test   %eax,%eax
+801058b7:	78 35                	js     801058ee <sys_write+0x5a>
+801058b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801058bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+801058c0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+801058c7:	e8 de fc ff ff       	call   801055aa <argint>
+801058cc:	85 c0                	test   %eax,%eax
+801058ce:	78 1e                	js     801058ee <sys_write+0x5a>
+801058d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801058d3:	89 44 24 08          	mov    %eax,0x8(%esp)
+801058d7:	8d 45 ec             	lea    -0x14(%ebp),%eax
+801058da:	89 44 24 04          	mov    %eax,0x4(%esp)
+801058de:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801058e5:	e8 ee fc ff ff       	call   801055d8 <argptr>
+801058ea:	85 c0                	test   %eax,%eax
+801058ec:	79 07                	jns    801058f5 <sys_write+0x61>
+    return -1;
+801058ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801058f3:	eb 19                	jmp    8010590e <sys_write+0x7a>
+  return filewrite(f, p, n);
+801058f5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+801058f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801058fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801058fe:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+80105902:	89 54 24 04          	mov    %edx,0x4(%esp)
+80105906:	89 04 24             	mov    %eax,(%esp)
+80105909:	e8 cb b8 ff ff       	call   801011d9 <filewrite>
+}
+8010590e:	c9                   	leave  
+8010590f:	c3                   	ret    
+
+80105910 <sys_close>:
+
+int
+sys_close(void)
+{
+80105910:	55                   	push   %ebp
+80105911:	89 e5                	mov    %esp,%ebp
+80105913:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  struct file *f;
+  
+  if(argfd(0, &fd, &f) < 0)
+80105916:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105919:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010591d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105920:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105924:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010592b:	e8 d0 fd ff ff       	call   80105700 <argfd>
+80105930:	85 c0                	test   %eax,%eax
+80105932:	79 07                	jns    8010593b <sys_close+0x2b>
+    return -1;
+80105934:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105939:	eb 24                	jmp    8010595f <sys_close+0x4f>
+  proc->ofile[fd] = 0;
+8010593b:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80105941:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105944:	83 c2 08             	add    $0x8,%edx
+80105947:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
+8010594e:	00 
+  fileclose(f);
+8010594f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105952:	89 04 24             	mov    %eax,(%esp)
+80105955:	e8 9e b6 ff ff       	call   80100ff8 <fileclose>
+  return 0;
+8010595a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010595f:	c9                   	leave  
+80105960:	c3                   	ret    
+
+80105961 <sys_fstat>:
+
+int
+sys_fstat(void)
+{
+80105961:	55                   	push   %ebp
+80105962:	89 e5                	mov    %esp,%ebp
+80105964:	83 ec 28             	sub    $0x28,%esp
+  struct file *f;
+  struct stat *st;
+  
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+80105967:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010596a:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010596e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80105975:	00 
+80105976:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010597d:	e8 7e fd ff ff       	call   80105700 <argfd>
+80105982:	85 c0                	test   %eax,%eax
+80105984:	78 1f                	js     801059a5 <sys_fstat+0x44>
+80105986:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
+8010598d:	00 
+8010598e:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105991:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105995:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+8010599c:	e8 37 fc ff ff       	call   801055d8 <argptr>
+801059a1:	85 c0                	test   %eax,%eax
+801059a3:	79 07                	jns    801059ac <sys_fstat+0x4b>
+    return -1;
+801059a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801059aa:	eb 12                	jmp    801059be <sys_fstat+0x5d>
+  return filestat(f, st);
+801059ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
+801059af:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801059b2:	89 54 24 04          	mov    %edx,0x4(%esp)
+801059b6:	89 04 24             	mov    %eax,(%esp)
+801059b9:	e8 10 b7 ff ff       	call   801010ce <filestat>
+}
+801059be:	c9                   	leave  
+801059bf:	c3                   	ret    
+
+801059c0 <sys_link>:
+
+// Create the path new as a link to the same inode as old.
+int
+sys_link(void)
+{
+801059c0:	55                   	push   %ebp
+801059c1:	89 e5                	mov    %esp,%ebp
+801059c3:	83 ec 38             	sub    $0x38,%esp
+  char name[DIRSIZ], *new, *old;
+  struct inode *dp, *ip;
+
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+801059c6:	8d 45 d8             	lea    -0x28(%ebp),%eax
+801059c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+801059cd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801059d4:	e8 61 fc ff ff       	call   8010563a <argstr>
+801059d9:	85 c0                	test   %eax,%eax
+801059db:	78 17                	js     801059f4 <sys_link+0x34>
+801059dd:	8d 45 dc             	lea    -0x24(%ebp),%eax
+801059e0:	89 44 24 04          	mov    %eax,0x4(%esp)
+801059e4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801059eb:	e8 4a fc ff ff       	call   8010563a <argstr>
+801059f0:	85 c0                	test   %eax,%eax
+801059f2:	79 0a                	jns    801059fe <sys_link+0x3e>
+    return -1;
+801059f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801059f9:	e9 41 01 00 00       	jmp    80105b3f <sys_link+0x17f>
+
+  begin_op();
+801059fe:	e8 a5 da ff ff       	call   801034a8 <begin_op>
+  if((ip = namei(old)) == 0){
+80105a03:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80105a06:	89 04 24             	mov    %eax,(%esp)
+80105a09:	e8 4a ca ff ff       	call   80102458 <namei>
+80105a0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105a11:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105a15:	75 0f                	jne    80105a26 <sys_link+0x66>
+    end_op();
+80105a17:	e8 0d db ff ff       	call   80103529 <end_op>
+    return -1;
+80105a1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105a21:	e9 19 01 00 00       	jmp    80105b3f <sys_link+0x17f>
+  }
+
+  ilock(ip);
+80105a26:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a29:	89 04 24             	mov    %eax,(%esp)
+80105a2c:	e8 76 be ff ff       	call   801018a7 <ilock>
+  if(ip->type == T_DIR){
+80105a31:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a34:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80105a38:	66 83 f8 01          	cmp    $0x1,%ax
+80105a3c:	75 1a                	jne    80105a58 <sys_link+0x98>
+    iunlockput(ip);
+80105a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a41:	89 04 24             	mov    %eax,(%esp)
+80105a44:	e8 e2 c0 ff ff       	call   80101b2b <iunlockput>
+    end_op();
+80105a49:	e8 db da ff ff       	call   80103529 <end_op>
+    return -1;
+80105a4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105a53:	e9 e7 00 00 00       	jmp    80105b3f <sys_link+0x17f>
+  }
+
+  ip->nlink++;
+80105a58:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a5b:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80105a5f:	8d 50 01             	lea    0x1(%eax),%edx
+80105a62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a65:	66 89 50 16          	mov    %dx,0x16(%eax)
+  iupdate(ip);
+80105a69:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a6c:	89 04 24             	mov    %eax,(%esp)
+80105a6f:	e8 77 bc ff ff       	call   801016eb <iupdate>
+  iunlock(ip);
+80105a74:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105a77:	89 04 24             	mov    %eax,(%esp)
+80105a7a:	e8 76 bf ff ff       	call   801019f5 <iunlock>
+
+  if((dp = nameiparent(new, name)) == 0)
+80105a7f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80105a82:	8d 55 e2             	lea    -0x1e(%ebp),%edx
+80105a85:	89 54 24 04          	mov    %edx,0x4(%esp)
+80105a89:	89 04 24             	mov    %eax,(%esp)
+80105a8c:	e8 e9 c9 ff ff       	call   8010247a <nameiparent>
+80105a91:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80105a94:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80105a98:	74 68                	je     80105b02 <sys_link+0x142>
+    goto bad;
+  ilock(dp);
+80105a9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105a9d:	89 04 24             	mov    %eax,(%esp)
+80105aa0:	e8 02 be ff ff       	call   801018a7 <ilock>
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+80105aa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105aa8:	8b 10                	mov    (%eax),%edx
+80105aaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105aad:	8b 00                	mov    (%eax),%eax
+80105aaf:	39 c2                	cmp    %eax,%edx
+80105ab1:	75 20                	jne    80105ad3 <sys_link+0x113>
+80105ab3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ab6:	8b 40 04             	mov    0x4(%eax),%eax
+80105ab9:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105abd:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+80105ac0:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105ac4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ac7:	89 04 24             	mov    %eax,(%esp)
+80105aca:	e8 c6 c6 ff ff       	call   80102195 <dirlink>
+80105acf:	85 c0                	test   %eax,%eax
+80105ad1:	79 0d                	jns    80105ae0 <sys_link+0x120>
+    iunlockput(dp);
+80105ad3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ad6:	89 04 24             	mov    %eax,(%esp)
+80105ad9:	e8 4d c0 ff ff       	call   80101b2b <iunlockput>
+    goto bad;
+80105ade:	eb 23                	jmp    80105b03 <sys_link+0x143>
+  }
+  iunlockput(dp);
+80105ae0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ae3:	89 04 24             	mov    %eax,(%esp)
+80105ae6:	e8 40 c0 ff ff       	call   80101b2b <iunlockput>
+  iput(ip);
+80105aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105aee:	89 04 24             	mov    %eax,(%esp)
+80105af1:	e8 64 bf ff ff       	call   80101a5a <iput>
+
+  end_op();
+80105af6:	e8 2e da ff ff       	call   80103529 <end_op>
+
+  return 0;
+80105afb:	b8 00 00 00 00       	mov    $0x0,%eax
+80105b00:	eb 3d                	jmp    80105b3f <sys_link+0x17f>
+  ip->nlink++;
+  iupdate(ip);
+  iunlock(ip);
+
+  if((dp = nameiparent(new, name)) == 0)
+    goto bad;
+80105b02:	90                   	nop
+  end_op();
+
+  return 0;
+
+bad:
+  ilock(ip);
+80105b03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b06:	89 04 24             	mov    %eax,(%esp)
+80105b09:	e8 99 bd ff ff       	call   801018a7 <ilock>
+  ip->nlink--;
+80105b0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b11:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80105b15:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105b18:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b1b:	66 89 50 16          	mov    %dx,0x16(%eax)
+  iupdate(ip);
+80105b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b22:	89 04 24             	mov    %eax,(%esp)
+80105b25:	e8 c1 bb ff ff       	call   801016eb <iupdate>
+  iunlockput(ip);
+80105b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b2d:	89 04 24             	mov    %eax,(%esp)
+80105b30:	e8 f6 bf ff ff       	call   80101b2b <iunlockput>
+  end_op();
+80105b35:	e8 ef d9 ff ff       	call   80103529 <end_op>
+  return -1;
+80105b3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105b3f:	c9                   	leave  
+80105b40:	c3                   	ret    
+
+80105b41 <isdirempty>:
+
+// Is the directory dp empty except for "." and ".." ?
+static int
+isdirempty(struct inode *dp)
+{
+80105b41:	55                   	push   %ebp
+80105b42:	89 e5                	mov    %esp,%ebp
+80105b44:	83 ec 38             	sub    $0x38,%esp
+  int off;
+  struct dirent de;
+
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+80105b47:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%ebp)
+80105b4e:	eb 4b                	jmp    80105b9b <isdirempty+0x5a>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80105b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b53:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80105b5a:	00 
+80105b5b:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105b5f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80105b62:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105b66:	8b 45 08             	mov    0x8(%ebp),%eax
+80105b69:	89 04 24             	mov    %eax,(%esp)
+80105b6c:	e8 43 c2 ff ff       	call   80101db4 <readi>
+80105b71:	83 f8 10             	cmp    $0x10,%eax
+80105b74:	74 0c                	je     80105b82 <isdirempty+0x41>
+      panic("isdirempty: readi");
+80105b76:	c7 04 24 38 8b 10 80 	movl   $0x80108b38,(%esp)
+80105b7d:	e8 c4 a9 ff ff       	call   80100546 <panic>
+    if(de.inum != 0)
+80105b82:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+80105b86:	66 85 c0             	test   %ax,%ax
+80105b89:	74 07                	je     80105b92 <isdirempty+0x51>
+      return 0;
+80105b8b:	b8 00 00 00 00       	mov    $0x0,%eax
+80105b90:	eb 1b                	jmp    80105bad <isdirempty+0x6c>
+isdirempty(struct inode *dp)
+{
+  int off;
+  struct dirent de;
+
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+80105b92:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105b95:	83 c0 10             	add    $0x10,%eax
+80105b98:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105b9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105b9e:	8b 45 08             	mov    0x8(%ebp),%eax
+80105ba1:	8b 40 18             	mov    0x18(%eax),%eax
+80105ba4:	39 c2                	cmp    %eax,%edx
+80105ba6:	72 a8                	jb     80105b50 <isdirempty+0xf>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("isdirempty: readi");
+    if(de.inum != 0)
+      return 0;
+  }
+  return 1;
+80105ba8:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+80105bad:	c9                   	leave  
+80105bae:	c3                   	ret    
+
+80105baf <sys_unlink>:
+
+//PAGEBREAK!
+int
+sys_unlink(void)
+{
+80105baf:	55                   	push   %ebp
+80105bb0:	89 e5                	mov    %esp,%ebp
+80105bb2:	83 ec 48             	sub    $0x48,%esp
+  struct inode *ip, *dp;
+  struct dirent de;
+  char name[DIRSIZ], *path;
+  uint off;
+
+  if(argstr(0, &path) < 0)
+80105bb5:	8d 45 cc             	lea    -0x34(%ebp),%eax
+80105bb8:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105bbc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105bc3:	e8 72 fa ff ff       	call   8010563a <argstr>
+80105bc8:	85 c0                	test   %eax,%eax
+80105bca:	79 0a                	jns    80105bd6 <sys_unlink+0x27>
+    return -1;
+80105bcc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105bd1:	e9 af 01 00 00       	jmp    80105d85 <sys_unlink+0x1d6>
+
+  begin_op();
+80105bd6:	e8 cd d8 ff ff       	call   801034a8 <begin_op>
+  if((dp = nameiparent(path, name)) == 0){
+80105bdb:	8b 45 cc             	mov    -0x34(%ebp),%eax
+80105bde:	8d 55 d2             	lea    -0x2e(%ebp),%edx
+80105be1:	89 54 24 04          	mov    %edx,0x4(%esp)
+80105be5:	89 04 24             	mov    %eax,(%esp)
+80105be8:	e8 8d c8 ff ff       	call   8010247a <nameiparent>
+80105bed:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105bf0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105bf4:	75 0f                	jne    80105c05 <sys_unlink+0x56>
+    end_op();
+80105bf6:	e8 2e d9 ff ff       	call   80103529 <end_op>
+    return -1;
+80105bfb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105c00:	e9 80 01 00 00       	jmp    80105d85 <sys_unlink+0x1d6>
+  }
+
+  ilock(dp);
+80105c05:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105c08:	89 04 24             	mov    %eax,(%esp)
+80105c0b:	e8 97 bc ff ff       	call   801018a7 <ilock>
+
+  // Cannot unlink "." or "..".
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+80105c10:	c7 44 24 04 4a 8b 10 	movl   $0x80108b4a,0x4(%esp)
+80105c17:	80 
+80105c18:	8d 45 d2             	lea    -0x2e(%ebp),%eax
+80105c1b:	89 04 24             	mov    %eax,(%esp)
+80105c1e:	e8 88 c4 ff ff       	call   801020ab <namecmp>
+80105c23:	85 c0                	test   %eax,%eax
+80105c25:	0f 84 45 01 00 00    	je     80105d70 <sys_unlink+0x1c1>
+80105c2b:	c7 44 24 04 4c 8b 10 	movl   $0x80108b4c,0x4(%esp)
+80105c32:	80 
+80105c33:	8d 45 d2             	lea    -0x2e(%ebp),%eax
+80105c36:	89 04 24             	mov    %eax,(%esp)
+80105c39:	e8 6d c4 ff ff       	call   801020ab <namecmp>
+80105c3e:	85 c0                	test   %eax,%eax
+80105c40:	0f 84 2a 01 00 00    	je     80105d70 <sys_unlink+0x1c1>
+    goto bad;
+
+  if((ip = dirlookup(dp, name, &off)) == 0)
+80105c46:	8d 45 c8             	lea    -0x38(%ebp),%eax
+80105c49:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105c4d:	8d 45 d2             	lea    -0x2e(%ebp),%eax
+80105c50:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105c54:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105c57:	89 04 24             	mov    %eax,(%esp)
+80105c5a:	e8 6e c4 ff ff       	call   801020cd <dirlookup>
+80105c5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80105c62:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80105c66:	0f 84 03 01 00 00    	je     80105d6f <sys_unlink+0x1c0>
+    goto bad;
+  ilock(ip);
+80105c6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105c6f:	89 04 24             	mov    %eax,(%esp)
+80105c72:	e8 30 bc ff ff       	call   801018a7 <ilock>
+
+  if(ip->nlink < 1)
+80105c77:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105c7a:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80105c7e:	66 85 c0             	test   %ax,%ax
+80105c81:	7f 0c                	jg     80105c8f <sys_unlink+0xe0>
+    panic("unlink: nlink < 1");
+80105c83:	c7 04 24 4f 8b 10 80 	movl   $0x80108b4f,(%esp)
+80105c8a:	e8 b7 a8 ff ff       	call   80100546 <panic>
+  if(ip->type == T_DIR && !isdirempty(ip)){
+80105c8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105c92:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80105c96:	66 83 f8 01          	cmp    $0x1,%ax
+80105c9a:	75 1f                	jne    80105cbb <sys_unlink+0x10c>
+80105c9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105c9f:	89 04 24             	mov    %eax,(%esp)
+80105ca2:	e8 9a fe ff ff       	call   80105b41 <isdirempty>
+80105ca7:	85 c0                	test   %eax,%eax
+80105ca9:	75 10                	jne    80105cbb <sys_unlink+0x10c>
+    iunlockput(ip);
+80105cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105cae:	89 04 24             	mov    %eax,(%esp)
+80105cb1:	e8 75 be ff ff       	call   80101b2b <iunlockput>
+    goto bad;
+80105cb6:	e9 b5 00 00 00       	jmp    80105d70 <sys_unlink+0x1c1>
+  }
+
+  memset(&de, 0, sizeof(de));
+80105cbb:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80105cc2:	00 
+80105cc3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80105cca:	00 
+80105ccb:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80105cce:	89 04 24             	mov    %eax,(%esp)
+80105cd1:	e8 78 f5 ff ff       	call   8010524e <memset>
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80105cd6:	8b 45 c8             	mov    -0x38(%ebp),%eax
+80105cd9:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80105ce0:	00 
+80105ce1:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105ce5:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80105ce8:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105cec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105cef:	89 04 24             	mov    %eax,(%esp)
+80105cf2:	e8 23 c2 ff ff       	call   80101f1a <writei>
+80105cf7:	83 f8 10             	cmp    $0x10,%eax
+80105cfa:	74 0c                	je     80105d08 <sys_unlink+0x159>
+    panic("unlink: writei");
+80105cfc:	c7 04 24 61 8b 10 80 	movl   $0x80108b61,(%esp)
+80105d03:	e8 3e a8 ff ff       	call   80100546 <panic>
+  if(ip->type == T_DIR){
+80105d08:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d0b:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80105d0f:	66 83 f8 01          	cmp    $0x1,%ax
+80105d13:	75 1c                	jne    80105d31 <sys_unlink+0x182>
+    dp->nlink--;
+80105d15:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d18:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80105d1c:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105d1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d22:	66 89 50 16          	mov    %dx,0x16(%eax)
+    iupdate(dp);
+80105d26:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d29:	89 04 24             	mov    %eax,(%esp)
+80105d2c:	e8 ba b9 ff ff       	call   801016eb <iupdate>
+  }
+  iunlockput(dp);
+80105d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d34:	89 04 24             	mov    %eax,(%esp)
+80105d37:	e8 ef bd ff ff       	call   80101b2b <iunlockput>
+
+  ip->nlink--;
+80105d3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d3f:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80105d43:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105d46:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d49:	66 89 50 16          	mov    %dx,0x16(%eax)
+  iupdate(ip);
+80105d4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d50:	89 04 24             	mov    %eax,(%esp)
+80105d53:	e8 93 b9 ff ff       	call   801016eb <iupdate>
+  iunlockput(ip);
+80105d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d5b:	89 04 24             	mov    %eax,(%esp)
+80105d5e:	e8 c8 bd ff ff       	call   80101b2b <iunlockput>
+
+  end_op();
+80105d63:	e8 c1 d7 ff ff       	call   80103529 <end_op>
+
+  return 0;
+80105d68:	b8 00 00 00 00       	mov    $0x0,%eax
+80105d6d:	eb 16                	jmp    80105d85 <sys_unlink+0x1d6>
+  // Cannot unlink "." or "..".
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+    goto bad;
+
+  if((ip = dirlookup(dp, name, &off)) == 0)
+    goto bad;
+80105d6f:	90                   	nop
+  end_op();
+
+  return 0;
+
+bad:
+  iunlockput(dp);
+80105d70:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d73:	89 04 24             	mov    %eax,(%esp)
+80105d76:	e8 b0 bd ff ff       	call   80101b2b <iunlockput>
+  end_op();
+80105d7b:	e8 a9 d7 ff ff       	call   80103529 <end_op>
+  return -1;
+80105d80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105d85:	c9                   	leave  
+80105d86:	c3                   	ret    
+
+80105d87 <create>:
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+80105d87:	55                   	push   %ebp
+80105d88:	89 e5                	mov    %esp,%ebp
+80105d8a:	83 ec 48             	sub    $0x48,%esp
+80105d8d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80105d90:	8b 55 10             	mov    0x10(%ebp),%edx
+80105d93:	8b 45 14             	mov    0x14(%ebp),%eax
+80105d96:	66 89 4d d4          	mov    %cx,-0x2c(%ebp)
+80105d9a:	66 89 55 d0          	mov    %dx,-0x30(%ebp)
+80105d9e:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
+  uint off;
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+80105da2:	8d 45 de             	lea    -0x22(%ebp),%eax
+80105da5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105da9:	8b 45 08             	mov    0x8(%ebp),%eax
+80105dac:	89 04 24             	mov    %eax,(%esp)
+80105daf:	e8 c6 c6 ff ff       	call   8010247a <nameiparent>
+80105db4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105db7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105dbb:	75 0a                	jne    80105dc7 <create+0x40>
+    return 0;
+80105dbd:	b8 00 00 00 00       	mov    $0x0,%eax
+80105dc2:	e9 7e 01 00 00       	jmp    80105f45 <create+0x1be>
+  ilock(dp);
+80105dc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105dca:	89 04 24             	mov    %eax,(%esp)
+80105dcd:	e8 d5 ba ff ff       	call   801018a7 <ilock>
+
+  if((ip = dirlookup(dp, name, &off)) != 0){
+80105dd2:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80105dd5:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105dd9:	8d 45 de             	lea    -0x22(%ebp),%eax
+80105ddc:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105de0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105de3:	89 04 24             	mov    %eax,(%esp)
+80105de6:	e8 e2 c2 ff ff       	call   801020cd <dirlookup>
+80105deb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80105dee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80105df2:	74 47                	je     80105e3b <create+0xb4>
+    iunlockput(dp);
+80105df4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105df7:	89 04 24             	mov    %eax,(%esp)
+80105dfa:	e8 2c bd ff ff       	call   80101b2b <iunlockput>
+    ilock(ip);
+80105dff:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e02:	89 04 24             	mov    %eax,(%esp)
+80105e05:	e8 9d ba ff ff       	call   801018a7 <ilock>
+    if(type == T_FILE && ip->type == T_FILE)
+80105e0a:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
+80105e0f:	75 15                	jne    80105e26 <create+0x9f>
+80105e11:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e14:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80105e18:	66 83 f8 02          	cmp    $0x2,%ax
+80105e1c:	75 08                	jne    80105e26 <create+0x9f>
+      return ip;
+80105e1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e21:	e9 1f 01 00 00       	jmp    80105f45 <create+0x1be>
+    iunlockput(ip);
+80105e26:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e29:	89 04 24             	mov    %eax,(%esp)
+80105e2c:	e8 fa bc ff ff       	call   80101b2b <iunlockput>
+    return 0;
+80105e31:	b8 00 00 00 00       	mov    $0x0,%eax
+80105e36:	e9 0a 01 00 00       	jmp    80105f45 <create+0x1be>
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+80105e3b:	0f bf 55 d4          	movswl -0x2c(%ebp),%edx
+80105e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105e42:	8b 00                	mov    (%eax),%eax
+80105e44:	89 54 24 04          	mov    %edx,0x4(%esp)
+80105e48:	89 04 24             	mov    %eax,(%esp)
+80105e4b:	e8 bc b7 ff ff       	call   8010160c <ialloc>
+80105e50:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80105e53:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80105e57:	75 0c                	jne    80105e65 <create+0xde>
+    panic("create: ialloc");
+80105e59:	c7 04 24 70 8b 10 80 	movl   $0x80108b70,(%esp)
+80105e60:	e8 e1 a6 ff ff       	call   80100546 <panic>
+
+  ilock(ip);
+80105e65:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e68:	89 04 24             	mov    %eax,(%esp)
+80105e6b:	e8 37 ba ff ff       	call   801018a7 <ilock>
+  ip->major = major;
+80105e70:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e73:	0f b7 55 d0          	movzwl -0x30(%ebp),%edx
+80105e77:	66 89 50 12          	mov    %dx,0x12(%eax)
+  ip->minor = minor;
+80105e7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e7e:	0f b7 55 cc          	movzwl -0x34(%ebp),%edx
+80105e82:	66 89 50 14          	mov    %dx,0x14(%eax)
+  ip->nlink = 1;
+80105e86:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e89:	66 c7 40 16 01 00    	movw   $0x1,0x16(%eax)
+  iupdate(ip);
+80105e8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e92:	89 04 24             	mov    %eax,(%esp)
+80105e95:	e8 51 b8 ff ff       	call   801016eb <iupdate>
+
+  if(type == T_DIR){  // Create . and .. entries.
+80105e9a:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
+80105e9f:	75 6a                	jne    80105f0b <create+0x184>
+    dp->nlink++;  // for ".."
+80105ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ea4:	0f b7 40 16          	movzwl 0x16(%eax),%eax
+80105ea8:	8d 50 01             	lea    0x1(%eax),%edx
+80105eab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105eae:	66 89 50 16          	mov    %dx,0x16(%eax)
+    iupdate(dp);
+80105eb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105eb5:	89 04 24             	mov    %eax,(%esp)
+80105eb8:	e8 2e b8 ff ff       	call   801016eb <iupdate>
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+80105ebd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ec0:	8b 40 04             	mov    0x4(%eax),%eax
+80105ec3:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105ec7:	c7 44 24 04 4a 8b 10 	movl   $0x80108b4a,0x4(%esp)
+80105ece:	80 
+80105ecf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ed2:	89 04 24             	mov    %eax,(%esp)
+80105ed5:	e8 bb c2 ff ff       	call   80102195 <dirlink>
+80105eda:	85 c0                	test   %eax,%eax
+80105edc:	78 21                	js     80105eff <create+0x178>
+80105ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ee1:	8b 40 04             	mov    0x4(%eax),%eax
+80105ee4:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105ee8:	c7 44 24 04 4c 8b 10 	movl   $0x80108b4c,0x4(%esp)
+80105eef:	80 
+80105ef0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ef3:	89 04 24             	mov    %eax,(%esp)
+80105ef6:	e8 9a c2 ff ff       	call   80102195 <dirlink>
+80105efb:	85 c0                	test   %eax,%eax
+80105efd:	79 0c                	jns    80105f0b <create+0x184>
+      panic("create dots");
+80105eff:	c7 04 24 7f 8b 10 80 	movl   $0x80108b7f,(%esp)
+80105f06:	e8 3b a6 ff ff       	call   80100546 <panic>
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+80105f0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105f0e:	8b 40 04             	mov    0x4(%eax),%eax
+80105f11:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105f15:	8d 45 de             	lea    -0x22(%ebp),%eax
+80105f18:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105f1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105f1f:	89 04 24             	mov    %eax,(%esp)
+80105f22:	e8 6e c2 ff ff       	call   80102195 <dirlink>
+80105f27:	85 c0                	test   %eax,%eax
+80105f29:	79 0c                	jns    80105f37 <create+0x1b0>
+    panic("create: dirlink");
+80105f2b:	c7 04 24 8b 8b 10 80 	movl   $0x80108b8b,(%esp)
+80105f32:	e8 0f a6 ff ff       	call   80100546 <panic>
+
+  iunlockput(dp);
+80105f37:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105f3a:	89 04 24             	mov    %eax,(%esp)
+80105f3d:	e8 e9 bb ff ff       	call   80101b2b <iunlockput>
+
+  return ip;
+80105f42:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+80105f45:	c9                   	leave  
+80105f46:	c3                   	ret    
+
+80105f47 <sys_open>:
+
+int
+sys_open(void)
+{
+80105f47:	55                   	push   %ebp
+80105f48:	89 e5                	mov    %esp,%ebp
+80105f4a:	83 ec 38             	sub    $0x38,%esp
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+80105f4d:	8d 45 e8             	lea    -0x18(%ebp),%eax
+80105f50:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105f54:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105f5b:	e8 da f6 ff ff       	call   8010563a <argstr>
+80105f60:	85 c0                	test   %eax,%eax
+80105f62:	78 17                	js     80105f7b <sys_open+0x34>
+80105f64:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80105f67:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105f6b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80105f72:	e8 33 f6 ff ff       	call   801055aa <argint>
+80105f77:	85 c0                	test   %eax,%eax
+80105f79:	79 0a                	jns    80105f85 <sys_open+0x3e>
+    return -1;
+80105f7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105f80:	e9 5c 01 00 00       	jmp    801060e1 <sys_open+0x19a>
+
+  begin_op();
+80105f85:	e8 1e d5 ff ff       	call   801034a8 <begin_op>
+
+  if(omode & O_CREATE){
+80105f8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80105f8d:	25 00 02 00 00       	and    $0x200,%eax
+80105f92:	85 c0                	test   %eax,%eax
+80105f94:	74 3b                	je     80105fd1 <sys_open+0x8a>
+    ip = create(path, T_FILE, 0, 0);
+80105f96:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80105f99:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+80105fa0:	00 
+80105fa1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+80105fa8:	00 
+80105fa9:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+80105fb0:	00 
+80105fb1:	89 04 24             	mov    %eax,(%esp)
+80105fb4:	e8 ce fd ff ff       	call   80105d87 <create>
+80105fb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(ip == 0){
+80105fbc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105fc0:	75 6b                	jne    8010602d <sys_open+0xe6>
+      end_op();
+80105fc2:	e8 62 d5 ff ff       	call   80103529 <end_op>
+      return -1;
+80105fc7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105fcc:	e9 10 01 00 00       	jmp    801060e1 <sys_open+0x19a>
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+80105fd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80105fd4:	89 04 24             	mov    %eax,(%esp)
+80105fd7:	e8 7c c4 ff ff       	call   80102458 <namei>
+80105fdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105fdf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105fe3:	75 0f                	jne    80105ff4 <sys_open+0xad>
+      end_op();
+80105fe5:	e8 3f d5 ff ff       	call   80103529 <end_op>
+      return -1;
+80105fea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105fef:	e9 ed 00 00 00       	jmp    801060e1 <sys_open+0x19a>
+    }
+    ilock(ip);
+80105ff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ff7:	89 04 24             	mov    %eax,(%esp)
+80105ffa:	e8 a8 b8 ff ff       	call   801018a7 <ilock>
+    if(ip->type == T_DIR && omode != O_RDONLY){
+80105fff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106002:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80106006:	66 83 f8 01          	cmp    $0x1,%ax
+8010600a:	75 21                	jne    8010602d <sys_open+0xe6>
+8010600c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+8010600f:	85 c0                	test   %eax,%eax
+80106011:	74 1a                	je     8010602d <sys_open+0xe6>
+      iunlockput(ip);
+80106013:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106016:	89 04 24             	mov    %eax,(%esp)
+80106019:	e8 0d bb ff ff       	call   80101b2b <iunlockput>
+      end_op();
+8010601e:	e8 06 d5 ff ff       	call   80103529 <end_op>
+      return -1;
+80106023:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106028:	e9 b4 00 00 00       	jmp    801060e1 <sys_open+0x19a>
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+8010602d:	e8 1e af ff ff       	call   80100f50 <filealloc>
+80106032:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80106035:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106039:	74 14                	je     8010604f <sys_open+0x108>
+8010603b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010603e:	89 04 24             	mov    %eax,(%esp)
+80106041:	e8 2f f7 ff ff       	call   80105775 <fdalloc>
+80106046:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80106049:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+8010604d:	79 28                	jns    80106077 <sys_open+0x130>
+    if(f)
+8010604f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106053:	74 0b                	je     80106060 <sys_open+0x119>
+      fileclose(f);
+80106055:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106058:	89 04 24             	mov    %eax,(%esp)
+8010605b:	e8 98 af ff ff       	call   80100ff8 <fileclose>
+    iunlockput(ip);
+80106060:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106063:	89 04 24             	mov    %eax,(%esp)
+80106066:	e8 c0 ba ff ff       	call   80101b2b <iunlockput>
+    end_op();
+8010606b:	e8 b9 d4 ff ff       	call   80103529 <end_op>
+    return -1;
+80106070:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106075:	eb 6a                	jmp    801060e1 <sys_open+0x19a>
+  }
+  iunlock(ip);
+80106077:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010607a:	89 04 24             	mov    %eax,(%esp)
+8010607d:	e8 73 b9 ff ff       	call   801019f5 <iunlock>
+  end_op();
+80106082:	e8 a2 d4 ff ff       	call   80103529 <end_op>
+
+  f->type = FD_INODE;
+80106087:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010608a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
+  f->ip = ip;
+80106090:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106093:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106096:	89 50 10             	mov    %edx,0x10(%eax)
+  f->off = 0;
+80106099:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010609c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+  f->readable = !(omode & O_WRONLY);
+801060a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801060a6:	83 e0 01             	and    $0x1,%eax
+801060a9:	85 c0                	test   %eax,%eax
+801060ab:	0f 94 c0             	sete   %al
+801060ae:	89 c2                	mov    %eax,%edx
+801060b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801060b3:	88 50 08             	mov    %dl,0x8(%eax)
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+801060b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801060b9:	83 e0 01             	and    $0x1,%eax
+801060bc:	85 c0                	test   %eax,%eax
+801060be:	75 0a                	jne    801060ca <sys_open+0x183>
+801060c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801060c3:	83 e0 02             	and    $0x2,%eax
+801060c6:	85 c0                	test   %eax,%eax
+801060c8:	74 07                	je     801060d1 <sys_open+0x18a>
+801060ca:	b8 01 00 00 00       	mov    $0x1,%eax
+801060cf:	eb 05                	jmp    801060d6 <sys_open+0x18f>
+801060d1:	b8 00 00 00 00       	mov    $0x0,%eax
+801060d6:	89 c2                	mov    %eax,%edx
+801060d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801060db:	88 50 09             	mov    %dl,0x9(%eax)
+  return fd;
+801060de:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+801060e1:	c9                   	leave  
+801060e2:	c3                   	ret    
+
+801060e3 <sys_mkdir>:
+
+int
+sys_mkdir(void)
+{
+801060e3:	55                   	push   %ebp
+801060e4:	89 e5                	mov    %esp,%ebp
+801060e6:	83 ec 28             	sub    $0x28,%esp
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+801060e9:	e8 ba d3 ff ff       	call   801034a8 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+801060ee:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801060f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+801060f5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801060fc:	e8 39 f5 ff ff       	call   8010563a <argstr>
+80106101:	85 c0                	test   %eax,%eax
+80106103:	78 2c                	js     80106131 <sys_mkdir+0x4e>
+80106105:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106108:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+8010610f:	00 
+80106110:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+80106117:	00 
+80106118:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+8010611f:	00 
+80106120:	89 04 24             	mov    %eax,(%esp)
+80106123:	e8 5f fc ff ff       	call   80105d87 <create>
+80106128:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010612b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010612f:	75 0c                	jne    8010613d <sys_mkdir+0x5a>
+    end_op();
+80106131:	e8 f3 d3 ff ff       	call   80103529 <end_op>
+    return -1;
+80106136:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010613b:	eb 15                	jmp    80106152 <sys_mkdir+0x6f>
+  }
+  iunlockput(ip);
+8010613d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106140:	89 04 24             	mov    %eax,(%esp)
+80106143:	e8 e3 b9 ff ff       	call   80101b2b <iunlockput>
+  end_op();
+80106148:	e8 dc d3 ff ff       	call   80103529 <end_op>
+  return 0;
+8010614d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106152:	c9                   	leave  
+80106153:	c3                   	ret    
+
+80106154 <sys_mknod>:
+
+int
+sys_mknod(void)
+{
+80106154:	55                   	push   %ebp
+80106155:	89 e5                	mov    %esp,%ebp
+80106157:	83 ec 38             	sub    $0x38,%esp
+  struct inode *ip;
+  char *path;
+  int len;
+  int major, minor;
+  
+  begin_op();
+8010615a:	e8 49 d3 ff ff       	call   801034a8 <begin_op>
+  if((len=argstr(0, &path)) < 0 ||
+8010615f:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80106162:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106166:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010616d:	e8 c8 f4 ff ff       	call   8010563a <argstr>
+80106172:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80106175:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80106179:	78 5e                	js     801061d9 <sys_mknod+0x85>
+     argint(1, &major) < 0 ||
+8010617b:	8d 45 e8             	lea    -0x18(%ebp),%eax
+8010617e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106182:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80106189:	e8 1c f4 ff ff       	call   801055aa <argint>
+  char *path;
+  int len;
+  int major, minor;
+  
+  begin_op();
+  if((len=argstr(0, &path)) < 0 ||
+8010618e:	85 c0                	test   %eax,%eax
+80106190:	78 47                	js     801061d9 <sys_mknod+0x85>
+     argint(1, &major) < 0 ||
+     argint(2, &minor) < 0 ||
+80106192:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80106195:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106199:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+801061a0:	e8 05 f4 ff ff       	call   801055aa <argint>
+  int len;
+  int major, minor;
+  
+  begin_op();
+  if((len=argstr(0, &path)) < 0 ||
+     argint(1, &major) < 0 ||
+801061a5:	85 c0                	test   %eax,%eax
+801061a7:	78 30                	js     801061d9 <sys_mknod+0x85>
+     argint(2, &minor) < 0 ||
+     (ip = create(path, T_DEV, major, minor)) == 0){
+801061a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801061ac:	0f bf c8             	movswl %ax,%ecx
+801061af:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801061b2:	0f bf d0             	movswl %ax,%edx
+801061b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  int major, minor;
+  
+  begin_op();
+  if((len=argstr(0, &path)) < 0 ||
+     argint(1, &major) < 0 ||
+     argint(2, &minor) < 0 ||
+801061b8:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+801061bc:	89 54 24 08          	mov    %edx,0x8(%esp)
+801061c0:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+801061c7:	00 
+801061c8:	89 04 24             	mov    %eax,(%esp)
+801061cb:	e8 b7 fb ff ff       	call   80105d87 <create>
+801061d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801061d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801061d7:	75 0c                	jne    801061e5 <sys_mknod+0x91>
+     (ip = create(path, T_DEV, major, minor)) == 0){
+    end_op();
+801061d9:	e8 4b d3 ff ff       	call   80103529 <end_op>
+    return -1;
+801061de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801061e3:	eb 15                	jmp    801061fa <sys_mknod+0xa6>
+  }
+  iunlockput(ip);
+801061e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801061e8:	89 04 24             	mov    %eax,(%esp)
+801061eb:	e8 3b b9 ff ff       	call   80101b2b <iunlockput>
+  end_op();
+801061f0:	e8 34 d3 ff ff       	call   80103529 <end_op>
+  return 0;
+801061f5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801061fa:	c9                   	leave  
+801061fb:	c3                   	ret    
+
+801061fc <sys_chdir>:
+
+int
+sys_chdir(void)
+{
+801061fc:	55                   	push   %ebp
+801061fd:	89 e5                	mov    %esp,%ebp
+801061ff:	83 ec 28             	sub    $0x28,%esp
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+80106202:	e8 a1 d2 ff ff       	call   801034a8 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+80106207:	8d 45 f0             	lea    -0x10(%ebp),%eax
+8010620a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010620e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80106215:	e8 20 f4 ff ff       	call   8010563a <argstr>
+8010621a:	85 c0                	test   %eax,%eax
+8010621c:	78 14                	js     80106232 <sys_chdir+0x36>
+8010621e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106221:	89 04 24             	mov    %eax,(%esp)
+80106224:	e8 2f c2 ff ff       	call   80102458 <namei>
+80106229:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010622c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80106230:	75 0c                	jne    8010623e <sys_chdir+0x42>
+    end_op();
+80106232:	e8 f2 d2 ff ff       	call   80103529 <end_op>
+    return -1;
+80106237:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010623c:	eb 61                	jmp    8010629f <sys_chdir+0xa3>
+  }
+  ilock(ip);
+8010623e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106241:	89 04 24             	mov    %eax,(%esp)
+80106244:	e8 5e b6 ff ff       	call   801018a7 <ilock>
+  if(ip->type != T_DIR){
+80106249:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010624c:	0f b7 40 10          	movzwl 0x10(%eax),%eax
+80106250:	66 83 f8 01          	cmp    $0x1,%ax
+80106254:	74 17                	je     8010626d <sys_chdir+0x71>
+    iunlockput(ip);
+80106256:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106259:	89 04 24             	mov    %eax,(%esp)
+8010625c:	e8 ca b8 ff ff       	call   80101b2b <iunlockput>
+    end_op();
+80106261:	e8 c3 d2 ff ff       	call   80103529 <end_op>
+    return -1;
+80106266:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010626b:	eb 32                	jmp    8010629f <sys_chdir+0xa3>
+  }
+  iunlock(ip);
+8010626d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106270:	89 04 24             	mov    %eax,(%esp)
+80106273:	e8 7d b7 ff ff       	call   801019f5 <iunlock>
+  iput(proc->cwd);
+80106278:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010627e:	8b 40 68             	mov    0x68(%eax),%eax
+80106281:	89 04 24             	mov    %eax,(%esp)
+80106284:	e8 d1 b7 ff ff       	call   80101a5a <iput>
+  end_op();
+80106289:	e8 9b d2 ff ff       	call   80103529 <end_op>
+  proc->cwd = ip;
+8010628e:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106294:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106297:	89 50 68             	mov    %edx,0x68(%eax)
+  return 0;
+8010629a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010629f:	c9                   	leave  
+801062a0:	c3                   	ret    
+
+801062a1 <sys_exec>:
+
+int
+sys_exec(void)
+{
+801062a1:	55                   	push   %ebp
+801062a2:	89 e5                	mov    %esp,%ebp
+801062a4:	81 ec a8 00 00 00    	sub    $0xa8,%esp
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+801062aa:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801062ad:	89 44 24 04          	mov    %eax,0x4(%esp)
+801062b1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801062b8:	e8 7d f3 ff ff       	call   8010563a <argstr>
+801062bd:	85 c0                	test   %eax,%eax
+801062bf:	78 1a                	js     801062db <sys_exec+0x3a>
+801062c1:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
+801062c7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801062cb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801062d2:	e8 d3 f2 ff ff       	call   801055aa <argint>
+801062d7:	85 c0                	test   %eax,%eax
+801062d9:	79 0a                	jns    801062e5 <sys_exec+0x44>
+    return -1;
+801062db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801062e0:	e9 c8 00 00 00       	jmp    801063ad <sys_exec+0x10c>
+  }
+  memset(argv, 0, sizeof(argv));
+801062e5:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
+801062ec:	00 
+801062ed:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801062f4:	00 
+801062f5:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
+801062fb:	89 04 24             	mov    %eax,(%esp)
+801062fe:	e8 4b ef ff ff       	call   8010524e <memset>
+  for(i=0;; i++){
+80106303:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if(i >= NELEM(argv))
+8010630a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010630d:	83 f8 1f             	cmp    $0x1f,%eax
+80106310:	76 0a                	jbe    8010631c <sys_exec+0x7b>
+      return -1;
+80106312:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106317:	e9 91 00 00 00       	jmp    801063ad <sys_exec+0x10c>
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+8010631c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010631f:	c1 e0 02             	shl    $0x2,%eax
+80106322:	89 c2                	mov    %eax,%edx
+80106324:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
+8010632a:	01 c2                	add    %eax,%edx
+8010632c:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+80106332:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106336:	89 14 24             	mov    %edx,(%esp)
+80106339:	e8 ce f1 ff ff       	call   8010550c <fetchint>
+8010633e:	85 c0                	test   %eax,%eax
+80106340:	79 07                	jns    80106349 <sys_exec+0xa8>
+      return -1;
+80106342:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106347:	eb 64                	jmp    801063ad <sys_exec+0x10c>
+    if(uarg == 0){
+80106349:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
+8010634f:	85 c0                	test   %eax,%eax
+80106351:	75 26                	jne    80106379 <sys_exec+0xd8>
+      argv[i] = 0;
+80106353:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106356:	c7 84 85 70 ff ff ff 	movl   $0x0,-0x90(%ebp,%eax,4)
+8010635d:	00 00 00 00 
+      break;
+80106361:	90                   	nop
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+      return -1;
+  }
+  return exec(path, argv);
+80106362:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106365:	8d 95 70 ff ff ff    	lea    -0x90(%ebp),%edx
+8010636b:	89 54 24 04          	mov    %edx,0x4(%esp)
+8010636f:	89 04 24             	mov    %eax,(%esp)
+80106372:	e8 91 a7 ff ff       	call   80100b08 <exec>
+80106377:	eb 34                	jmp    801063ad <sys_exec+0x10c>
+      return -1;
+    if(uarg == 0){
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+80106379:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
+8010637f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106382:	c1 e2 02             	shl    $0x2,%edx
+80106385:	01 c2                	add    %eax,%edx
+80106387:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
+8010638d:	89 54 24 04          	mov    %edx,0x4(%esp)
+80106391:	89 04 24             	mov    %eax,(%esp)
+80106394:	e8 ad f1 ff ff       	call   80105546 <fetchstr>
+80106399:	85 c0                	test   %eax,%eax
+8010639b:	79 07                	jns    801063a4 <sys_exec+0x103>
+      return -1;
+8010639d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801063a2:	eb 09                	jmp    801063ad <sys_exec+0x10c>
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+    return -1;
+  }
+  memset(argv, 0, sizeof(argv));
+  for(i=0;; i++){
+801063a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+      return -1;
+  }
+801063a8:	e9 5d ff ff ff       	jmp    8010630a <sys_exec+0x69>
+  return exec(path, argv);
+}
+801063ad:	c9                   	leave  
+801063ae:	c3                   	ret    
+
+801063af <sys_pipe>:
+
+int
+sys_pipe(void)
+{
+801063af:	55                   	push   %ebp
+801063b0:	89 e5                	mov    %esp,%ebp
+801063b2:	83 ec 38             	sub    $0x38,%esp
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+801063b5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
+801063bc:	00 
+801063bd:	8d 45 ec             	lea    -0x14(%ebp),%eax
+801063c0:	89 44 24 04          	mov    %eax,0x4(%esp)
+801063c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801063cb:	e8 08 f2 ff ff       	call   801055d8 <argptr>
+801063d0:	85 c0                	test   %eax,%eax
+801063d2:	79 0a                	jns    801063de <sys_pipe+0x2f>
+    return -1;
+801063d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801063d9:	e9 9b 00 00 00       	jmp    80106479 <sys_pipe+0xca>
+  if(pipealloc(&rf, &wf) < 0)
+801063de:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+801063e1:	89 44 24 04          	mov    %eax,0x4(%esp)
+801063e5:	8d 45 e8             	lea    -0x18(%ebp),%eax
+801063e8:	89 04 24             	mov    %eax,(%esp)
+801063eb:	e8 d8 db ff ff       	call   80103fc8 <pipealloc>
+801063f0:	85 c0                	test   %eax,%eax
+801063f2:	79 07                	jns    801063fb <sys_pipe+0x4c>
+    return -1;
+801063f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801063f9:	eb 7e                	jmp    80106479 <sys_pipe+0xca>
+  fd0 = -1;
+801063fb:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+80106402:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80106405:	89 04 24             	mov    %eax,(%esp)
+80106408:	e8 68 f3 ff ff       	call   80105775 <fdalloc>
+8010640d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80106410:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80106414:	78 14                	js     8010642a <sys_pipe+0x7b>
+80106416:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106419:	89 04 24             	mov    %eax,(%esp)
+8010641c:	e8 54 f3 ff ff       	call   80105775 <fdalloc>
+80106421:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80106424:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106428:	79 37                	jns    80106461 <sys_pipe+0xb2>
+    if(fd0 >= 0)
+8010642a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010642e:	78 14                	js     80106444 <sys_pipe+0x95>
+      proc->ofile[fd0] = 0;
+80106430:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106436:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106439:	83 c2 08             	add    $0x8,%edx
+8010643c:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
+80106443:	00 
+    fileclose(rf);
+80106444:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80106447:	89 04 24             	mov    %eax,(%esp)
+8010644a:	e8 a9 ab ff ff       	call   80100ff8 <fileclose>
+    fileclose(wf);
+8010644f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106452:	89 04 24             	mov    %eax,(%esp)
+80106455:	e8 9e ab ff ff       	call   80100ff8 <fileclose>
+    return -1;
+8010645a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010645f:	eb 18                	jmp    80106479 <sys_pipe+0xca>
+  }
+  fd[0] = fd0;
+80106461:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80106464:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106467:	89 10                	mov    %edx,(%eax)
+  fd[1] = fd1;
+80106469:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010646c:	8d 50 04             	lea    0x4(%eax),%edx
+8010646f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106472:	89 02                	mov    %eax,(%edx)
+  return 0;
+80106474:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106479:	c9                   	leave  
+8010647a:	c3                   	ret    
+	...
+
+8010647c <outw>:
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+}
+
+static inline void
+outw(ushort port, ushort data)
+{
+8010647c:	55                   	push   %ebp
+8010647d:	89 e5                	mov    %esp,%ebp
+8010647f:	83 ec 08             	sub    $0x8,%esp
+80106482:	8b 55 08             	mov    0x8(%ebp),%edx
+80106485:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106488:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+8010648c:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80106490:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
+80106494:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80106498:	66 ef                	out    %ax,(%dx)
+}
+8010649a:	c9                   	leave  
+8010649b:	c3                   	ret    
+
+8010649c <sys_set_sched>:
+#include "proc.h"
+
+extern int schd_choice;
+int
+sys_set_sched(void)
+{
+8010649c:	55                   	push   %ebp
+8010649d:	89 e5                	mov    %esp,%ebp
+8010649f:	83 ec 18             	sub    $0x18,%esp
+   if (argint(0, &schd_choice) < 0) {
+801064a2:	c7 44 24 04 6c b6 10 	movl   $0x8010b66c,0x4(%esp)
+801064a9:	80 
+801064aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801064b1:	e8 f4 f0 ff ff       	call   801055aa <argint>
+801064b6:	85 c0                	test   %eax,%eax
+801064b8:	79 0c                	jns    801064c6 <sys_set_sched+0x2a>
+       cprintf("set_sched() failed!\n");
+801064ba:	c7 04 24 9b 8b 10 80 	movl   $0x80108b9b,(%esp)
+801064c1:	e8 e4 9e ff ff       	call   801003aa <cprintf>
+    }
+   return 0;
+801064c6:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801064cb:	c9                   	leave  
+801064cc:	c3                   	ret    
+
+801064cd <sys_set_priority>:
+extern int process_id;
+extern int process_priority;
+extern void set_priority(int pid,int priority);
+int
+sys_set_priority(void)
+{
+801064cd:	55                   	push   %ebp
+801064ce:	89 e5                	mov    %esp,%ebp
+801064d0:	83 ec 18             	sub    $0x18,%esp
+   if ((argint(0, &process_id) < 0)||(argint(1, &process_priority) < 0)) {
+801064d3:	c7 44 24 04 80 29 11 	movl   $0x80112980,0x4(%esp)
+801064da:	80 
+801064db:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801064e2:	e8 c3 f0 ff ff       	call   801055aa <argint>
+801064e7:	85 c0                	test   %eax,%eax
+801064e9:	78 18                	js     80106503 <sys_set_priority+0x36>
+801064eb:	c7 44 24 04 0c b0 10 	movl   $0x8010b00c,0x4(%esp)
+801064f2:	80 
+801064f3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801064fa:	e8 ab f0 ff ff       	call   801055aa <argint>
+801064ff:	85 c0                	test   %eax,%eax
+80106501:	79 13                	jns    80106516 <sys_set_priority+0x49>
+       cprintf("set_priority() failed!\n");
+80106503:	c7 04 24 b0 8b 10 80 	movl   $0x80108bb0,(%esp)
+8010650a:	e8 9b 9e ff ff       	call   801003aa <cprintf>
+        return -1;
+8010650f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106514:	eb 1c                	jmp    80106532 <sys_set_priority+0x65>
+    }
+   set_priority(process_id,process_priority);
+80106516:	8b 15 0c b0 10 80    	mov    0x8010b00c,%edx
+8010651c:	a1 80 29 11 80       	mov    0x80112980,%eax
+80106521:	89 54 24 04          	mov    %edx,0x4(%esp)
+80106525:	89 04 24             	mov    %eax,(%esp)
+80106528:	e8 72 de ff ff       	call   8010439f <set_priority>
+   return 0;
+8010652d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106532:	c9                   	leave  
+80106533:	c3                   	ret    
+
+80106534 <sys_fork_winner>:
+extern int win;
+int
+sys_fork_winner(void)
+{
+80106534:	55                   	push   %ebp
+80106535:	89 e5                	mov    %esp,%ebp
+80106537:	83 ec 18             	sub    $0x18,%esp
+   if (argint(0, &win) < 0) {
+8010653a:	c7 44 24 04 84 29 11 	movl   $0x80112984,0x4(%esp)
+80106541:	80 
+80106542:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80106549:	e8 5c f0 ff ff       	call   801055aa <argint>
+8010654e:	85 c0                	test   %eax,%eax
+80106550:	79 0c                	jns    8010655e <sys_fork_winner+0x2a>
+       cprintf("fork_winner() failed!\n");
+80106552:	c7 04 24 c8 8b 10 80 	movl   $0x80108bc8,(%esp)
+80106559:	e8 4c 9e ff ff       	call   801003aa <cprintf>
+    }
+    return 0;
+8010655e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106563:	c9                   	leave  
+80106564:	c3                   	ret    
+
+80106565 <sys_shutdown>:
+int
+sys_shutdown(void)
+{
+80106565:	55                   	push   %ebp
+80106566:	89 e5                	mov    %esp,%ebp
+80106568:	83 ec 08             	sub    $0x8,%esp
+   outw(0xB004, 0x0|0x2000);
+8010656b:	c7 44 24 04 00 20 00 	movl   $0x2000,0x4(%esp)
+80106572:	00 
+80106573:	c7 04 24 04 b0 00 00 	movl   $0xb004,(%esp)
+8010657a:	e8 fd fe ff ff       	call   8010647c <outw>
+   return 0;
+8010657f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106584:	c9                   	leave  
+80106585:	c3                   	ret    
+
+80106586 <sys_fork>:
+int
+sys_fork(void)
+{
+80106586:	55                   	push   %ebp
+80106587:	89 e5                	mov    %esp,%ebp
+80106589:	83 ec 08             	sub    $0x8,%esp
+  return fork();
+8010658c:	e8 20 e1 ff ff       	call   801046b1 <fork>
+}
+80106591:	c9                   	leave  
+80106592:	c3                   	ret    
+
+80106593 <sys_exit>:
+
+int
+sys_exit(void)
+{
+80106593:	55                   	push   %ebp
+80106594:	89 e5                	mov    %esp,%ebp
+80106596:	83 ec 08             	sub    $0x8,%esp
+  exit();
+80106599:	e8 8f e2 ff ff       	call   8010482d <exit>
+  return 0;  // not reached
+8010659e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801065a3:	c9                   	leave  
+801065a4:	c3                   	ret    
+
+801065a5 <sys_wait>:
+
+int
+sys_wait(void)
+{
+801065a5:	55                   	push   %ebp
+801065a6:	89 e5                	mov    %esp,%ebp
+801065a8:	83 ec 08             	sub    $0x8,%esp
+  return wait();
+801065ab:	e8 9f e3 ff ff       	call   8010494f <wait>
+}
+801065b0:	c9                   	leave  
+801065b1:	c3                   	ret    
+
+801065b2 <sys_kill>:
+
+int
+sys_kill(void)
+{
+801065b2:	55                   	push   %ebp
+801065b3:	89 e5                	mov    %esp,%ebp
+801065b5:	83 ec 28             	sub    $0x28,%esp
+  int pid;
+
+  if(argint(0, &pid) < 0)
+801065b8:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801065bb:	89 44 24 04          	mov    %eax,0x4(%esp)
+801065bf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801065c6:	e8 df ef ff ff       	call   801055aa <argint>
+801065cb:	85 c0                	test   %eax,%eax
+801065cd:	79 07                	jns    801065d6 <sys_kill+0x24>
+    return -1;
+801065cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801065d4:	eb 0b                	jmp    801065e1 <sys_kill+0x2f>
+  return kill(pid);
+801065d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801065d9:	89 04 24             	mov    %eax,(%esp)
+801065dc:	e8 38 e8 ff ff       	call   80104e19 <kill>
+}
+801065e1:	c9                   	leave  
+801065e2:	c3                   	ret    
+
+801065e3 <sys_getpid>:
+
+int
+sys_getpid(void)
+{
+801065e3:	55                   	push   %ebp
+801065e4:	89 e5                	mov    %esp,%ebp
+  return proc->pid;
+801065e6:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801065ec:	8b 40 10             	mov    0x10(%eax),%eax
+}
+801065ef:	5d                   	pop    %ebp
+801065f0:	c3                   	ret    
+
+801065f1 <sys_sbrk>:
+
+int
+sys_sbrk(void)
+{
+801065f1:	55                   	push   %ebp
+801065f2:	89 e5                	mov    %esp,%ebp
+801065f4:	83 ec 28             	sub    $0x28,%esp
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+801065f7:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801065fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+801065fe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80106605:	e8 a0 ef ff ff       	call   801055aa <argint>
+8010660a:	85 c0                	test   %eax,%eax
+8010660c:	79 07                	jns    80106615 <sys_sbrk+0x24>
+    return -1;
+8010660e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106613:	eb 24                	jmp    80106639 <sys_sbrk+0x48>
+  addr = proc->sz;
+80106615:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010661b:	8b 00                	mov    (%eax),%eax
+8010661d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(growproc(n) < 0)
+80106620:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106623:	89 04 24             	mov    %eax,(%esp)
+80106626:	e8 e1 df ff ff       	call   8010460c <growproc>
+8010662b:	85 c0                	test   %eax,%eax
+8010662d:	79 07                	jns    80106636 <sys_sbrk+0x45>
+    return -1;
+8010662f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106634:	eb 03                	jmp    80106639 <sys_sbrk+0x48>
+  return addr;
+80106636:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80106639:	c9                   	leave  
+8010663a:	c3                   	ret    
+
+8010663b <sys_sleep>:
+
+int
+sys_sleep(void)
+{
+8010663b:	55                   	push   %ebp
+8010663c:	89 e5                	mov    %esp,%ebp
+8010663e:	83 ec 28             	sub    $0x28,%esp
+  int n;
+  uint ticks0;
+  
+  if(argint(0, &n) < 0)
+80106641:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80106644:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106648:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010664f:	e8 56 ef ff ff       	call   801055aa <argint>
+80106654:	85 c0                	test   %eax,%eax
+80106656:	79 07                	jns    8010665f <sys_sleep+0x24>
+    return -1;
+80106658:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010665d:	eb 6c                	jmp    801066cb <sys_sleep+0x90>
+  acquire(&tickslock);
+8010665f:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+80106666:	e8 88 e9 ff ff       	call   80104ff3 <acquire>
+  ticks0 = ticks;
+8010666b:	a1 20 52 11 80       	mov    0x80115220,%eax
+80106670:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(ticks - ticks0 < n){
+80106673:	eb 34                	jmp    801066a9 <sys_sleep+0x6e>
+    if(proc->killed){
+80106675:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+8010667b:	8b 40 24             	mov    0x24(%eax),%eax
+8010667e:	85 c0                	test   %eax,%eax
+80106680:	74 13                	je     80106695 <sys_sleep+0x5a>
+      release(&tickslock);
+80106682:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+80106689:	e8 c7 e9 ff ff       	call   80105055 <release>
+      return -1;
+8010668e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106693:	eb 36                	jmp    801066cb <sys_sleep+0x90>
+    }
+    sleep(&ticks, &tickslock);
+80106695:	c7 44 24 04 e0 49 11 	movl   $0x801149e0,0x4(%esp)
+8010669c:	80 
+8010669d:	c7 04 24 20 52 11 80 	movl   $0x80115220,(%esp)
+801066a4:	e8 6c e6 ff ff       	call   80104d15 <sleep>
+  
+  if(argint(0, &n) < 0)
+    return -1;
+  acquire(&tickslock);
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+801066a9:	a1 20 52 11 80       	mov    0x80115220,%eax
+801066ae:	89 c2                	mov    %eax,%edx
+801066b0:	2b 55 f4             	sub    -0xc(%ebp),%edx
+801066b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801066b6:	39 c2                	cmp    %eax,%edx
+801066b8:	72 bb                	jb     80106675 <sys_sleep+0x3a>
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+  }
+  release(&tickslock);
+801066ba:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+801066c1:	e8 8f e9 ff ff       	call   80105055 <release>
+  return 0;
+801066c6:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801066cb:	c9                   	leave  
+801066cc:	c3                   	ret    
+
+801066cd <sys_uptime>:
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+801066cd:	55                   	push   %ebp
+801066ce:	89 e5                	mov    %esp,%ebp
+801066d0:	83 ec 28             	sub    $0x28,%esp
+  uint xticks;
+  
+  acquire(&tickslock);
+801066d3:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+801066da:	e8 14 e9 ff ff       	call   80104ff3 <acquire>
+  xticks = ticks;
+801066df:	a1 20 52 11 80       	mov    0x80115220,%eax
+801066e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  release(&tickslock);
+801066e7:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+801066ee:	e8 62 e9 ff ff       	call   80105055 <release>
+  return xticks;
+801066f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+801066f6:	c9                   	leave  
+801066f7:	c3                   	ret    
+
+801066f8 <sys_enable_sched_trace>:
+extern int sched_trace_enabled;
+//extern int sched_trace_enabled;
+int sys_enable_sched_trace(void)
+{
+801066f8:	55                   	push   %ebp
+801066f9:	89 e5                	mov    %esp,%ebp
+801066fb:	83 ec 18             	sub    $0x18,%esp
+  if (argint(0, &sched_trace_enabled) < 0)
+801066fe:	c7 44 24 04 68 b6 10 	movl   $0x8010b668,0x4(%esp)
+80106705:	80 
+80106706:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010670d:	e8 98 ee ff ff       	call   801055aa <argint>
+80106712:	85 c0                	test   %eax,%eax
+80106714:	79 0c                	jns    80106722 <sys_enable_sched_trace+0x2a>
+  {
+    cprintf("enable_sched_trace() failed!\n");
+80106716:	c7 04 24 df 8b 10 80 	movl   $0x80108bdf,(%esp)
+8010671d:	e8 88 9c ff ff       	call   801003aa <cprintf>
+  }
+
+  return 0;
+80106722:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106727:	c9                   	leave  
+80106728:	c3                   	ret    
+80106729:	00 00                	add    %al,(%eax)
+	...
+
+8010672c <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+8010672c:	55                   	push   %ebp
+8010672d:	89 e5                	mov    %esp,%ebp
+8010672f:	83 ec 08             	sub    $0x8,%esp
+80106732:	8b 55 08             	mov    0x8(%ebp),%edx
+80106735:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106738:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+8010673c:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010673f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80106743:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80106747:	ee                   	out    %al,(%dx)
+}
+80106748:	c9                   	leave  
+80106749:	c3                   	ret    
+
+8010674a <timerinit>:
+#define TIMER_RATEGEN   0x04    // mode 2, rate generator
+#define TIMER_16BIT     0x30    // r/w counter 16 bits, LSB first
+
+void
+timerinit(void)
+{
+8010674a:	55                   	push   %ebp
+8010674b:	89 e5                	mov    %esp,%ebp
+8010674d:	83 ec 18             	sub    $0x18,%esp
+  // Interrupt 100 times/sec.
+  outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+80106750:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
+80106757:	00 
+80106758:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
+8010675f:	e8 c8 ff ff ff       	call   8010672c <outb>
+  outb(IO_TIMER1, TIMER_DIV(100) % 256);
+80106764:	c7 44 24 04 9c 00 00 	movl   $0x9c,0x4(%esp)
+8010676b:	00 
+8010676c:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
+80106773:	e8 b4 ff ff ff       	call   8010672c <outb>
+  outb(IO_TIMER1, TIMER_DIV(100) / 256);
+80106778:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
+8010677f:	00 
+80106780:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
+80106787:	e8 a0 ff ff ff       	call   8010672c <outb>
+  picenable(IRQ_TIMER);
+8010678c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80106793:	e8 b9 d6 ff ff       	call   80103e51 <picenable>
+}
+80106798:	c9                   	leave  
+80106799:	c3                   	ret    
+	...
+
+8010679c <alltraps>:
+
+  # vectors.S sends all traps here.
+.globl alltraps
+alltraps:
+  # Build trap frame.
+  pushl %ds
+8010679c:	1e                   	push   %ds
+  pushl %es
+8010679d:	06                   	push   %es
+  pushl %fs
+8010679e:	0f a0                	push   %fs
+  pushl %gs
+801067a0:	0f a8                	push   %gs
+  pushal
+801067a2:	60                   	pusha  
+  
+  # Set up data and per-cpu segments.
+  movw $(SEG_KDATA<<3), %ax
+801067a3:	66 b8 10 00          	mov    $0x10,%ax
+  movw %ax, %ds
+801067a7:	8e d8                	mov    %eax,%ds
+  movw %ax, %es
+801067a9:	8e c0                	mov    %eax,%es
+  movw $(SEG_KCPU<<3), %ax
+801067ab:	66 b8 18 00          	mov    $0x18,%ax
+  movw %ax, %fs
+801067af:	8e e0                	mov    %eax,%fs
+  movw %ax, %gs
+801067b1:	8e e8                	mov    %eax,%gs
+
+  # Call trap(tf), where tf=%esp
+  pushl %esp
+801067b3:	54                   	push   %esp
+  call trap
+801067b4:	e8 de 01 00 00       	call   80106997 <trap>
+  addl $4, %esp
+801067b9:	83 c4 04             	add    $0x4,%esp
+
+801067bc <trapret>:
+
+  # Return falls through to trapret...
+.globl trapret
+trapret:
+  popal
+801067bc:	61                   	popa   
+  popl %gs
+801067bd:	0f a9                	pop    %gs
+  popl %fs
+801067bf:	0f a1                	pop    %fs
+  popl %es
+801067c1:	07                   	pop    %es
+  popl %ds
+801067c2:	1f                   	pop    %ds
+  addl $0x8, %esp  # trapno and errcode
+801067c3:	83 c4 08             	add    $0x8,%esp
+  iret
+801067c6:	cf                   	iret   
+	...
+
+801067c8 <lidt>:
+
+struct gatedesc;
+
+static inline void
+lidt(struct gatedesc *p, int size)
+{
+801067c8:	55                   	push   %ebp
+801067c9:	89 e5                	mov    %esp,%ebp
+801067cb:	83 ec 10             	sub    $0x10,%esp
+  volatile ushort pd[3];
+
+  pd[0] = size-1;
+801067ce:	8b 45 0c             	mov    0xc(%ebp),%eax
+801067d1:	83 e8 01             	sub    $0x1,%eax
+801067d4:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+  pd[1] = (uint)p;
+801067d8:	8b 45 08             	mov    0x8(%ebp),%eax
+801067db:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  pd[2] = (uint)p >> 16;
+801067df:	8b 45 08             	mov    0x8(%ebp),%eax
+801067e2:	c1 e8 10             	shr    $0x10,%eax
+801067e5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+
+  asm volatile("lidt (%0)" : : "r" (pd));
+801067e9:	8d 45 fa             	lea    -0x6(%ebp),%eax
+801067ec:	0f 01 18             	lidtl  (%eax)
+}
+801067ef:	c9                   	leave  
+801067f0:	c3                   	ret    
+
+801067f1 <rcr2>:
+  return result;
+}
+
+static inline uint
+rcr2(void)
+{
+801067f1:	55                   	push   %ebp
+801067f2:	89 e5                	mov    %esp,%ebp
+801067f4:	53                   	push   %ebx
+801067f5:	83 ec 10             	sub    $0x10,%esp
+  uint val;
+  asm volatile("movl %%cr2,%0" : "=r" (val));
+801067f8:	0f 20 d3             	mov    %cr2,%ebx
+801067fb:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+  return val;
+801067fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80106801:	83 c4 10             	add    $0x10,%esp
+80106804:	5b                   	pop    %ebx
+80106805:	5d                   	pop    %ebp
+80106806:	c3                   	ret    
+
+80106807 <tvinit>:
+struct spinlock tickslock;
+uint ticks;
+
+void
+tvinit(void)
+{
+80106807:	55                   	push   %ebp
+80106808:	89 e5                	mov    %esp,%ebp
+8010680a:	83 ec 28             	sub    $0x28,%esp
+  int i;
+
+  for(i = 0; i < 256; i++)
+8010680d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80106814:	e9 c3 00 00 00       	jmp    801068dc <tvinit+0xd5>
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+80106819:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010681c:	8b 04 85 ac b0 10 80 	mov    -0x7fef4f54(,%eax,4),%eax
+80106823:	89 c2                	mov    %eax,%edx
+80106825:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106828:	66 89 14 c5 20 4a 11 	mov    %dx,-0x7feeb5e0(,%eax,8)
+8010682f:	80 
+80106830:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106833:	66 c7 04 c5 22 4a 11 	movw   $0x8,-0x7feeb5de(,%eax,8)
+8010683a:	80 08 00 
+8010683d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106840:	0f b6 14 c5 24 4a 11 	movzbl -0x7feeb5dc(,%eax,8),%edx
+80106847:	80 
+80106848:	83 e2 e0             	and    $0xffffffe0,%edx
+8010684b:	88 14 c5 24 4a 11 80 	mov    %dl,-0x7feeb5dc(,%eax,8)
+80106852:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106855:	0f b6 14 c5 24 4a 11 	movzbl -0x7feeb5dc(,%eax,8),%edx
+8010685c:	80 
+8010685d:	83 e2 1f             	and    $0x1f,%edx
+80106860:	88 14 c5 24 4a 11 80 	mov    %dl,-0x7feeb5dc(,%eax,8)
+80106867:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010686a:	0f b6 14 c5 25 4a 11 	movzbl -0x7feeb5db(,%eax,8),%edx
+80106871:	80 
+80106872:	83 e2 f0             	and    $0xfffffff0,%edx
+80106875:	83 ca 0e             	or     $0xe,%edx
+80106878:	88 14 c5 25 4a 11 80 	mov    %dl,-0x7feeb5db(,%eax,8)
+8010687f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106882:	0f b6 14 c5 25 4a 11 	movzbl -0x7feeb5db(,%eax,8),%edx
+80106889:	80 
+8010688a:	83 e2 ef             	and    $0xffffffef,%edx
+8010688d:	88 14 c5 25 4a 11 80 	mov    %dl,-0x7feeb5db(,%eax,8)
+80106894:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106897:	0f b6 14 c5 25 4a 11 	movzbl -0x7feeb5db(,%eax,8),%edx
+8010689e:	80 
+8010689f:	83 e2 9f             	and    $0xffffff9f,%edx
+801068a2:	88 14 c5 25 4a 11 80 	mov    %dl,-0x7feeb5db(,%eax,8)
+801068a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801068ac:	0f b6 14 c5 25 4a 11 	movzbl -0x7feeb5db(,%eax,8),%edx
+801068b3:	80 
+801068b4:	83 ca 80             	or     $0xffffff80,%edx
+801068b7:	88 14 c5 25 4a 11 80 	mov    %dl,-0x7feeb5db(,%eax,8)
+801068be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801068c1:	8b 04 85 ac b0 10 80 	mov    -0x7fef4f54(,%eax,4),%eax
+801068c8:	c1 e8 10             	shr    $0x10,%eax
+801068cb:	89 c2                	mov    %eax,%edx
+801068cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801068d0:	66 89 14 c5 26 4a 11 	mov    %dx,-0x7feeb5da(,%eax,8)
+801068d7:	80 
+void
+tvinit(void)
+{
+  int i;
+
+  for(i = 0; i < 256; i++)
+801068d8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801068dc:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
+801068e3:	0f 8e 30 ff ff ff    	jle    80106819 <tvinit+0x12>
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+801068e9:	a1 ac b1 10 80       	mov    0x8010b1ac,%eax
+801068ee:	66 a3 20 4c 11 80    	mov    %ax,0x80114c20
+801068f4:	66 c7 05 22 4c 11 80 	movw   $0x8,0x80114c22
+801068fb:	08 00 
+801068fd:	0f b6 05 24 4c 11 80 	movzbl 0x80114c24,%eax
+80106904:	83 e0 e0             	and    $0xffffffe0,%eax
+80106907:	a2 24 4c 11 80       	mov    %al,0x80114c24
+8010690c:	0f b6 05 24 4c 11 80 	movzbl 0x80114c24,%eax
+80106913:	83 e0 1f             	and    $0x1f,%eax
+80106916:	a2 24 4c 11 80       	mov    %al,0x80114c24
+8010691b:	0f b6 05 25 4c 11 80 	movzbl 0x80114c25,%eax
+80106922:	83 c8 0f             	or     $0xf,%eax
+80106925:	a2 25 4c 11 80       	mov    %al,0x80114c25
+8010692a:	0f b6 05 25 4c 11 80 	movzbl 0x80114c25,%eax
+80106931:	83 e0 ef             	and    $0xffffffef,%eax
+80106934:	a2 25 4c 11 80       	mov    %al,0x80114c25
+80106939:	0f b6 05 25 4c 11 80 	movzbl 0x80114c25,%eax
+80106940:	83 c8 60             	or     $0x60,%eax
+80106943:	a2 25 4c 11 80       	mov    %al,0x80114c25
+80106948:	0f b6 05 25 4c 11 80 	movzbl 0x80114c25,%eax
+8010694f:	83 c8 80             	or     $0xffffff80,%eax
+80106952:	a2 25 4c 11 80       	mov    %al,0x80114c25
+80106957:	a1 ac b1 10 80       	mov    0x8010b1ac,%eax
+8010695c:	c1 e8 10             	shr    $0x10,%eax
+8010695f:	66 a3 26 4c 11 80    	mov    %ax,0x80114c26
+  
+  initlock(&tickslock, "time");
+80106965:	c7 44 24 04 00 8c 10 	movl   $0x80108c00,0x4(%esp)
+8010696c:	80 
+8010696d:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+80106974:	e8 59 e6 ff ff       	call   80104fd2 <initlock>
+}
+80106979:	c9                   	leave  
+8010697a:	c3                   	ret    
+
+8010697b <idtinit>:
+
+void
+idtinit(void)
+{
+8010697b:	55                   	push   %ebp
+8010697c:	89 e5                	mov    %esp,%ebp
+8010697e:	83 ec 08             	sub    $0x8,%esp
+  lidt(idt, sizeof(idt));
+80106981:	c7 44 24 04 00 08 00 	movl   $0x800,0x4(%esp)
+80106988:	00 
+80106989:	c7 04 24 20 4a 11 80 	movl   $0x80114a20,(%esp)
+80106990:	e8 33 fe ff ff       	call   801067c8 <lidt>
+}
+80106995:	c9                   	leave  
+80106996:	c3                   	ret    
+
+80106997 <trap>:
+
+//PAGEBREAK: 41
+void
+trap(struct trapframe *tf)
+{
+80106997:	55                   	push   %ebp
+80106998:	89 e5                	mov    %esp,%ebp
+8010699a:	57                   	push   %edi
+8010699b:	56                   	push   %esi
+8010699c:	53                   	push   %ebx
+8010699d:	83 ec 3c             	sub    $0x3c,%esp
+  if(tf->trapno == T_SYSCALL){
+801069a0:	8b 45 08             	mov    0x8(%ebp),%eax
+801069a3:	8b 40 30             	mov    0x30(%eax),%eax
+801069a6:	83 f8 40             	cmp    $0x40,%eax
+801069a9:	75 3e                	jne    801069e9 <trap+0x52>
+    if(proc->killed)
+801069ab:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801069b1:	8b 40 24             	mov    0x24(%eax),%eax
+801069b4:	85 c0                	test   %eax,%eax
+801069b6:	74 05                	je     801069bd <trap+0x26>
+      exit();
+801069b8:	e8 70 de ff ff       	call   8010482d <exit>
+    proc->tf = tf;
+801069bd:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801069c3:	8b 55 08             	mov    0x8(%ebp),%edx
+801069c6:	89 50 18             	mov    %edx,0x18(%eax)
+    syscall();
+801069c9:	e8 a3 ec ff ff       	call   80105671 <syscall>
+    if(proc->killed)
+801069ce:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+801069d4:	8b 40 24             	mov    0x24(%eax),%eax
+801069d7:	85 c0                	test   %eax,%eax
+801069d9:	0f 84 34 02 00 00    	je     80106c13 <trap+0x27c>
+      exit();
+801069df:	e8 49 de ff ff       	call   8010482d <exit>
+    return;
+801069e4:	e9 2a 02 00 00       	jmp    80106c13 <trap+0x27c>
+  }
+
+  switch(tf->trapno){
+801069e9:	8b 45 08             	mov    0x8(%ebp),%eax
+801069ec:	8b 40 30             	mov    0x30(%eax),%eax
+801069ef:	83 e8 20             	sub    $0x20,%eax
+801069f2:	83 f8 1f             	cmp    $0x1f,%eax
+801069f5:	0f 87 bc 00 00 00    	ja     80106ab7 <trap+0x120>
+801069fb:	8b 04 85 a8 8c 10 80 	mov    -0x7fef7358(,%eax,4),%eax
+80106a02:	ff e0                	jmp    *%eax
+  case T_IRQ0 + IRQ_TIMER:
+    if(cpu->id == 0){
+80106a04:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80106a0a:	0f b6 00             	movzbl (%eax),%eax
+80106a0d:	84 c0                	test   %al,%al
+80106a0f:	75 31                	jne    80106a42 <trap+0xab>
+      acquire(&tickslock);
+80106a11:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+80106a18:	e8 d6 e5 ff ff       	call   80104ff3 <acquire>
+      ticks++;
+80106a1d:	a1 20 52 11 80       	mov    0x80115220,%eax
+80106a22:	83 c0 01             	add    $0x1,%eax
+80106a25:	a3 20 52 11 80       	mov    %eax,0x80115220
+      wakeup(&ticks);
+80106a2a:	c7 04 24 20 52 11 80 	movl   $0x80115220,(%esp)
+80106a31:	e8 b8 e3 ff ff       	call   80104dee <wakeup>
+      release(&tickslock);
+80106a36:	c7 04 24 e0 49 11 80 	movl   $0x801149e0,(%esp)
+80106a3d:	e8 13 e6 ff ff       	call   80105055 <release>
+    }
+    lapiceoi();
+80106a42:	e8 1c c5 ff ff       	call   80102f63 <lapiceoi>
+    break;
+80106a47:	e9 41 01 00 00       	jmp    80106b8d <trap+0x1f6>
+  case T_IRQ0 + IRQ_IDE:
+    ideintr();
+80106a4c:	e8 ec bc ff ff       	call   8010273d <ideintr>
+    lapiceoi();
+80106a51:	e8 0d c5 ff ff       	call   80102f63 <lapiceoi>
+    break;
+80106a56:	e9 32 01 00 00       	jmp    80106b8d <trap+0x1f6>
+  case T_IRQ0 + IRQ_IDE+1:
+    // Bochs generates spurious IDE1 interrupts.
+    break;
+  case T_IRQ0 + IRQ_KBD:
+    kbdintr();
+80106a5b:	e8 b5 c2 ff ff       	call   80102d15 <kbdintr>
+    lapiceoi();
+80106a60:	e8 fe c4 ff ff       	call   80102f63 <lapiceoi>
+    break;
+80106a65:	e9 23 01 00 00       	jmp    80106b8d <trap+0x1f6>
+  case T_IRQ0 + IRQ_COM1:
+    uartintr();
+80106a6a:	e8 a9 03 00 00       	call   80106e18 <uartintr>
+    lapiceoi();
+80106a6f:	e8 ef c4 ff ff       	call   80102f63 <lapiceoi>
+    break;
+80106a74:	e9 14 01 00 00       	jmp    80106b8d <trap+0x1f6>
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+            cpu->id, tf->cs, tf->eip);
+80106a79:	8b 45 08             	mov    0x8(%ebp),%eax
+    uartintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+80106a7c:	8b 48 38             	mov    0x38(%eax),%ecx
+            cpu->id, tf->cs, tf->eip);
+80106a7f:	8b 45 08             	mov    0x8(%ebp),%eax
+80106a82:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+    uartintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+80106a86:	0f b7 d0             	movzwl %ax,%edx
+            cpu->id, tf->cs, tf->eip);
+80106a89:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80106a8f:	0f b6 00             	movzbl (%eax),%eax
+    uartintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+80106a92:	0f b6 c0             	movzbl %al,%eax
+80106a95:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+80106a99:	89 54 24 08          	mov    %edx,0x8(%esp)
+80106a9d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106aa1:	c7 04 24 08 8c 10 80 	movl   $0x80108c08,(%esp)
+80106aa8:	e8 fd 98 ff ff       	call   801003aa <cprintf>
+            cpu->id, tf->cs, tf->eip);
+    lapiceoi();
+80106aad:	e8 b1 c4 ff ff       	call   80102f63 <lapiceoi>
+    break;
+80106ab2:	e9 d6 00 00 00       	jmp    80106b8d <trap+0x1f6>
+   
+  //PAGEBREAK: 13
+  default:
+    if(proc == 0 || (tf->cs&3) == 0){
+80106ab7:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106abd:	85 c0                	test   %eax,%eax
+80106abf:	74 11                	je     80106ad2 <trap+0x13b>
+80106ac1:	8b 45 08             	mov    0x8(%ebp),%eax
+80106ac4:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+80106ac8:	0f b7 c0             	movzwl %ax,%eax
+80106acb:	83 e0 03             	and    $0x3,%eax
+80106ace:	85 c0                	test   %eax,%eax
+80106ad0:	75 46                	jne    80106b18 <trap+0x181>
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80106ad2:	e8 1a fd ff ff       	call   801067f1 <rcr2>
+              tf->trapno, cpu->id, tf->eip, rcr2());
+80106ad7:	8b 55 08             	mov    0x8(%ebp),%edx
+   
+  //PAGEBREAK: 13
+  default:
+    if(proc == 0 || (tf->cs&3) == 0){
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80106ada:	8b 5a 38             	mov    0x38(%edx),%ebx
+              tf->trapno, cpu->id, tf->eip, rcr2());
+80106add:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+80106ae4:	0f b6 12             	movzbl (%edx),%edx
+   
+  //PAGEBREAK: 13
+  default:
+    if(proc == 0 || (tf->cs&3) == 0){
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80106ae7:	0f b6 ca             	movzbl %dl,%ecx
+              tf->trapno, cpu->id, tf->eip, rcr2());
+80106aea:	8b 55 08             	mov    0x8(%ebp),%edx
+   
+  //PAGEBREAK: 13
+  default:
+    if(proc == 0 || (tf->cs&3) == 0){
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80106aed:	8b 52 30             	mov    0x30(%edx),%edx
+80106af0:	89 44 24 10          	mov    %eax,0x10(%esp)
+80106af4:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+80106af8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+80106afc:	89 54 24 04          	mov    %edx,0x4(%esp)
+80106b00:	c7 04 24 2c 8c 10 80 	movl   $0x80108c2c,(%esp)
+80106b07:	e8 9e 98 ff ff       	call   801003aa <cprintf>
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+80106b0c:	c7 04 24 5e 8c 10 80 	movl   $0x80108c5e,(%esp)
+80106b13:	e8 2e 9a ff ff       	call   80100546 <panic>
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80106b18:	e8 d4 fc ff ff       	call   801067f1 <rcr2>
+80106b1d:	89 c2                	mov    %eax,%edx
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+80106b1f:	8b 45 08             	mov    0x8(%ebp),%eax
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80106b22:	8b 78 38             	mov    0x38(%eax),%edi
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+80106b25:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80106b2b:	0f b6 00             	movzbl (%eax),%eax
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80106b2e:	0f b6 f0             	movzbl %al,%esi
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+80106b31:	8b 45 08             	mov    0x8(%ebp),%eax
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80106b34:	8b 58 34             	mov    0x34(%eax),%ebx
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+80106b37:	8b 45 08             	mov    0x8(%ebp),%eax
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80106b3a:	8b 48 30             	mov    0x30(%eax),%ecx
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+80106b3d:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106b43:	83 c0 6c             	add    $0x6c,%eax
+80106b46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80106b49:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpu->id, tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80106b4f:	8b 40 10             	mov    0x10(%eax),%eax
+80106b52:	89 54 24 1c          	mov    %edx,0x1c(%esp)
+80106b56:	89 7c 24 18          	mov    %edi,0x18(%esp)
+80106b5a:	89 74 24 14          	mov    %esi,0x14(%esp)
+80106b5e:	89 5c 24 10          	mov    %ebx,0x10(%esp)
+80106b62:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+80106b66:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80106b69:	89 54 24 08          	mov    %edx,0x8(%esp)
+80106b6d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106b71:	c7 04 24 64 8c 10 80 	movl   $0x80108c64,(%esp)
+80106b78:	e8 2d 98 ff ff       	call   801003aa <cprintf>
+            "eip 0x%x addr 0x%x--kill proc\n",
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+            rcr2());
+    proc->killed = 1;
+80106b7d:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106b83:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
+80106b8a:	eb 01                	jmp    80106b8d <trap+0x1f6>
+    ideintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_IDE+1:
+    // Bochs generates spurious IDE1 interrupts.
+    break;
+80106b8c:	90                   	nop
+  }
+
+  // Force process exit if it has been killed and is in user space.
+  // (If it is still executing in the kernel, let it keep running 
+  // until it gets to the regular system call return.)
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+80106b8d:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106b93:	85 c0                	test   %eax,%eax
+80106b95:	74 24                	je     80106bbb <trap+0x224>
+80106b97:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106b9d:	8b 40 24             	mov    0x24(%eax),%eax
+80106ba0:	85 c0                	test   %eax,%eax
+80106ba2:	74 17                	je     80106bbb <trap+0x224>
+80106ba4:	8b 45 08             	mov    0x8(%ebp),%eax
+80106ba7:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+80106bab:	0f b7 c0             	movzwl %ax,%eax
+80106bae:	83 e0 03             	and    $0x3,%eax
+80106bb1:	83 f8 03             	cmp    $0x3,%eax
+80106bb4:	75 05                	jne    80106bbb <trap+0x224>
+    exit();
+80106bb6:	e8 72 dc ff ff       	call   8010482d <exit>
+
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+80106bbb:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106bc1:	85 c0                	test   %eax,%eax
+80106bc3:	74 1e                	je     80106be3 <trap+0x24c>
+80106bc5:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106bcb:	8b 40 0c             	mov    0xc(%eax),%eax
+80106bce:	83 f8 04             	cmp    $0x4,%eax
+80106bd1:	75 10                	jne    80106be3 <trap+0x24c>
+80106bd3:	8b 45 08             	mov    0x8(%ebp),%eax
+80106bd6:	8b 40 30             	mov    0x30(%eax),%eax
+80106bd9:	83 f8 20             	cmp    $0x20,%eax
+80106bdc:	75 05                	jne    80106be3 <trap+0x24c>
+    yield();
+80106bde:	e8 b2 e0 ff ff       	call   80104c95 <yield>
+
+  // Check if the process has been killed since we yielded
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+80106be3:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106be9:	85 c0                	test   %eax,%eax
+80106beb:	74 27                	je     80106c14 <trap+0x27d>
+80106bed:	65 a1 04 00 00 00    	mov    %gs:0x4,%eax
+80106bf3:	8b 40 24             	mov    0x24(%eax),%eax
+80106bf6:	85 c0                	test   %eax,%eax
+80106bf8:	74 1a                	je     80106c14 <trap+0x27d>
+80106bfa:	8b 45 08             	mov    0x8(%ebp),%eax
+80106bfd:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+80106c01:	0f b7 c0             	movzwl %ax,%eax
+80106c04:	83 e0 03             	and    $0x3,%eax
+80106c07:	83 f8 03             	cmp    $0x3,%eax
+80106c0a:	75 08                	jne    80106c14 <trap+0x27d>
+    exit();
+80106c0c:	e8 1c dc ff ff       	call   8010482d <exit>
+80106c11:	eb 01                	jmp    80106c14 <trap+0x27d>
+      exit();
+    proc->tf = tf;
+    syscall();
+    if(proc->killed)
+      exit();
+    return;
+80106c13:	90                   	nop
+    yield();
+
+  // Check if the process has been killed since we yielded
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+    exit();
+}
+80106c14:	83 c4 3c             	add    $0x3c,%esp
+80106c17:	5b                   	pop    %ebx
+80106c18:	5e                   	pop    %esi
+80106c19:	5f                   	pop    %edi
+80106c1a:	5d                   	pop    %ebp
+80106c1b:	c3                   	ret    
+
+80106c1c <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+80106c1c:	55                   	push   %ebp
+80106c1d:	89 e5                	mov    %esp,%ebp
+80106c1f:	53                   	push   %ebx
+80106c20:	83 ec 14             	sub    $0x14,%esp
+80106c23:	8b 45 08             	mov    0x8(%ebp),%eax
+80106c26:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80106c2a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+80106c2e:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+80106c32:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+80106c36:	ec                   	in     (%dx),%al
+80106c37:	89 c3                	mov    %eax,%ebx
+80106c39:	88 5d fb             	mov    %bl,-0x5(%ebp)
+  return data;
+80106c3c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+}
+80106c40:	83 c4 14             	add    $0x14,%esp
+80106c43:	5b                   	pop    %ebx
+80106c44:	5d                   	pop    %ebp
+80106c45:	c3                   	ret    
+
+80106c46 <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+80106c46:	55                   	push   %ebp
+80106c47:	89 e5                	mov    %esp,%ebp
+80106c49:	83 ec 08             	sub    $0x8,%esp
+80106c4c:	8b 55 08             	mov    0x8(%ebp),%edx
+80106c4f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106c52:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
+80106c56:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80106c59:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80106c5d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80106c61:	ee                   	out    %al,(%dx)
+}
+80106c62:	c9                   	leave  
+80106c63:	c3                   	ret    
+
+80106c64 <uartinit>:
+
+static int uart;    // is there a uart?
+
+void
+uartinit(void)
+{
+80106c64:	55                   	push   %ebp
+80106c65:	89 e5                	mov    %esp,%ebp
+80106c67:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+
+  // Turn off the FIFO
+  outb(COM1+2, 0);
+80106c6a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106c71:	00 
+80106c72:	c7 04 24 fa 03 00 00 	movl   $0x3fa,(%esp)
+80106c79:	e8 c8 ff ff ff       	call   80106c46 <outb>
+  
+  // 9600 baud, 8 data bits, 1 stop bit, parity off.
+  outb(COM1+3, 0x80);    // Unlock divisor
+80106c7e:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
+80106c85:	00 
+80106c86:	c7 04 24 fb 03 00 00 	movl   $0x3fb,(%esp)
+80106c8d:	e8 b4 ff ff ff       	call   80106c46 <outb>
+  outb(COM1+0, 115200/9600);
+80106c92:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
+80106c99:	00 
+80106c9a:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+80106ca1:	e8 a0 ff ff ff       	call   80106c46 <outb>
+  outb(COM1+1, 0);
+80106ca6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106cad:	00 
+80106cae:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp)
+80106cb5:	e8 8c ff ff ff       	call   80106c46 <outb>
+  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
+80106cba:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+80106cc1:	00 
+80106cc2:	c7 04 24 fb 03 00 00 	movl   $0x3fb,(%esp)
+80106cc9:	e8 78 ff ff ff       	call   80106c46 <outb>
+  outb(COM1+4, 0);
+80106cce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106cd5:	00 
+80106cd6:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
+80106cdd:	e8 64 ff ff ff       	call   80106c46 <outb>
+  outb(COM1+1, 0x01);    // Enable receive interrupts.
+80106ce2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80106ce9:	00 
+80106cea:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp)
+80106cf1:	e8 50 ff ff ff       	call   80106c46 <outb>
+
+  // If status is 0xFF, no serial port.
+  if(inb(COM1+5) == 0xFF)
+80106cf6:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
+80106cfd:	e8 1a ff ff ff       	call   80106c1c <inb>
+80106d02:	3c ff                	cmp    $0xff,%al
+80106d04:	74 6c                	je     80106d72 <uartinit+0x10e>
+    return;
+  uart = 1;
+80106d06:	c7 05 74 b6 10 80 01 	movl   $0x1,0x8010b674
+80106d0d:	00 00 00 
+
+  // Acknowledge pre-existing interrupt conditions;
+  // enable interrupts.
+  inb(COM1+2);
+80106d10:	c7 04 24 fa 03 00 00 	movl   $0x3fa,(%esp)
+80106d17:	e8 00 ff ff ff       	call   80106c1c <inb>
+  inb(COM1+0);
+80106d1c:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+80106d23:	e8 f4 fe ff ff       	call   80106c1c <inb>
+  picenable(IRQ_COM1);
+80106d28:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+80106d2f:	e8 1d d1 ff ff       	call   80103e51 <picenable>
+  ioapicenable(IRQ_COM1, 0);
+80106d34:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106d3b:	00 
+80106d3c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+80106d43:	e8 7a bc ff ff       	call   801029c2 <ioapicenable>
+  
+  // Announce that we're here.
+  for(p="xv6...\n"; *p; p++)
+80106d48:	c7 45 f4 28 8d 10 80 	movl   $0x80108d28,-0xc(%ebp)
+80106d4f:	eb 15                	jmp    80106d66 <uartinit+0x102>
+    uartputc(*p);
+80106d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106d54:	0f b6 00             	movzbl (%eax),%eax
+80106d57:	0f be c0             	movsbl %al,%eax
+80106d5a:	89 04 24             	mov    %eax,(%esp)
+80106d5d:	e8 13 00 00 00       	call   80106d75 <uartputc>
+  inb(COM1+0);
+  picenable(IRQ_COM1);
+  ioapicenable(IRQ_COM1, 0);
+  
+  // Announce that we're here.
+  for(p="xv6...\n"; *p; p++)
+80106d62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80106d66:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106d69:	0f b6 00             	movzbl (%eax),%eax
+80106d6c:	84 c0                	test   %al,%al
+80106d6e:	75 e1                	jne    80106d51 <uartinit+0xed>
+80106d70:	eb 01                	jmp    80106d73 <uartinit+0x10f>
+  outb(COM1+4, 0);
+  outb(COM1+1, 0x01);    // Enable receive interrupts.
+
+  // If status is 0xFF, no serial port.
+  if(inb(COM1+5) == 0xFF)
+    return;
+80106d72:	90                   	nop
+  ioapicenable(IRQ_COM1, 0);
+  
+  // Announce that we're here.
+  for(p="xv6...\n"; *p; p++)
+    uartputc(*p);
+}
+80106d73:	c9                   	leave  
+80106d74:	c3                   	ret    
+
+80106d75 <uartputc>:
+
+void
+uartputc(int c)
+{
+80106d75:	55                   	push   %ebp
+80106d76:	89 e5                	mov    %esp,%ebp
+80106d78:	83 ec 28             	sub    $0x28,%esp
+  int i;
+
+  if(!uart)
+80106d7b:	a1 74 b6 10 80       	mov    0x8010b674,%eax
+80106d80:	85 c0                	test   %eax,%eax
+80106d82:	74 4d                	je     80106dd1 <uartputc+0x5c>
+    return;
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+80106d84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80106d8b:	eb 10                	jmp    80106d9d <uartputc+0x28>
+    microdelay(10);
+80106d8d:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+80106d94:	e8 ef c1 ff ff       	call   80102f88 <microdelay>
+{
+  int i;
+
+  if(!uart)
+    return;
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+80106d99:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80106d9d:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
+80106da1:	7f 16                	jg     80106db9 <uartputc+0x44>
+80106da3:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
+80106daa:	e8 6d fe ff ff       	call   80106c1c <inb>
+80106daf:	0f b6 c0             	movzbl %al,%eax
+80106db2:	83 e0 20             	and    $0x20,%eax
+80106db5:	85 c0                	test   %eax,%eax
+80106db7:	74 d4                	je     80106d8d <uartputc+0x18>
+    microdelay(10);
+  outb(COM1+0, c);
+80106db9:	8b 45 08             	mov    0x8(%ebp),%eax
+80106dbc:	0f b6 c0             	movzbl %al,%eax
+80106dbf:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106dc3:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+80106dca:	e8 77 fe ff ff       	call   80106c46 <outb>
+80106dcf:	eb 01                	jmp    80106dd2 <uartputc+0x5d>
+uartputc(int c)
+{
+  int i;
+
+  if(!uart)
+    return;
+80106dd1:	90                   	nop
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+    microdelay(10);
+  outb(COM1+0, c);
+}
+80106dd2:	c9                   	leave  
+80106dd3:	c3                   	ret    
+
+80106dd4 <uartgetc>:
+
+static int
+uartgetc(void)
+{
+80106dd4:	55                   	push   %ebp
+80106dd5:	89 e5                	mov    %esp,%ebp
+80106dd7:	83 ec 04             	sub    $0x4,%esp
+  if(!uart)
+80106dda:	a1 74 b6 10 80       	mov    0x8010b674,%eax
+80106ddf:	85 c0                	test   %eax,%eax
+80106de1:	75 07                	jne    80106dea <uartgetc+0x16>
+    return -1;
+80106de3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106de8:	eb 2c                	jmp    80106e16 <uartgetc+0x42>
+  if(!(inb(COM1+5) & 0x01))
+80106dea:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
+80106df1:	e8 26 fe ff ff       	call   80106c1c <inb>
+80106df6:	0f b6 c0             	movzbl %al,%eax
+80106df9:	83 e0 01             	and    $0x1,%eax
+80106dfc:	85 c0                	test   %eax,%eax
+80106dfe:	75 07                	jne    80106e07 <uartgetc+0x33>
+    return -1;
+80106e00:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106e05:	eb 0f                	jmp    80106e16 <uartgetc+0x42>
+  return inb(COM1+0);
+80106e07:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+80106e0e:	e8 09 fe ff ff       	call   80106c1c <inb>
+80106e13:	0f b6 c0             	movzbl %al,%eax
+}
+80106e16:	c9                   	leave  
+80106e17:	c3                   	ret    
+
+80106e18 <uartintr>:
+
+void
+uartintr(void)
+{
+80106e18:	55                   	push   %ebp
+80106e19:	89 e5                	mov    %esp,%ebp
+80106e1b:	83 ec 18             	sub    $0x18,%esp
+  consoleintr(uartgetc);
+80106e1e:	c7 04 24 d4 6d 10 80 	movl   $0x80106dd4,(%esp)
+80106e25:	e8 8c 99 ff ff       	call   801007b6 <consoleintr>
+}
+80106e2a:	c9                   	leave  
+80106e2b:	c3                   	ret    
+
+80106e2c <vector0>:
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+80106e2c:	6a 00                	push   $0x0
+  pushl $0
+80106e2e:	6a 00                	push   $0x0
+  jmp alltraps
+80106e30:	e9 67 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e35 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+80106e35:	6a 00                	push   $0x0
+  pushl $1
+80106e37:	6a 01                	push   $0x1
+  jmp alltraps
+80106e39:	e9 5e f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e3e <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+80106e3e:	6a 00                	push   $0x0
+  pushl $2
+80106e40:	6a 02                	push   $0x2
+  jmp alltraps
+80106e42:	e9 55 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e47 <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+80106e47:	6a 00                	push   $0x0
+  pushl $3
+80106e49:	6a 03                	push   $0x3
+  jmp alltraps
+80106e4b:	e9 4c f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e50 <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+80106e50:	6a 00                	push   $0x0
+  pushl $4
+80106e52:	6a 04                	push   $0x4
+  jmp alltraps
+80106e54:	e9 43 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e59 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+80106e59:	6a 00                	push   $0x0
+  pushl $5
+80106e5b:	6a 05                	push   $0x5
+  jmp alltraps
+80106e5d:	e9 3a f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e62 <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+80106e62:	6a 00                	push   $0x0
+  pushl $6
+80106e64:	6a 06                	push   $0x6
+  jmp alltraps
+80106e66:	e9 31 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e6b <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+80106e6b:	6a 00                	push   $0x0
+  pushl $7
+80106e6d:	6a 07                	push   $0x7
+  jmp alltraps
+80106e6f:	e9 28 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e74 <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+80106e74:	6a 08                	push   $0x8
+  jmp alltraps
+80106e76:	e9 21 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e7b <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+80106e7b:	6a 00                	push   $0x0
+  pushl $9
+80106e7d:	6a 09                	push   $0x9
+  jmp alltraps
+80106e7f:	e9 18 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e84 <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+80106e84:	6a 0a                	push   $0xa
+  jmp alltraps
+80106e86:	e9 11 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e8b <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+80106e8b:	6a 0b                	push   $0xb
+  jmp alltraps
+80106e8d:	e9 0a f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e92 <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+80106e92:	6a 0c                	push   $0xc
+  jmp alltraps
+80106e94:	e9 03 f9 ff ff       	jmp    8010679c <alltraps>
+
+80106e99 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+80106e99:	6a 0d                	push   $0xd
+  jmp alltraps
+80106e9b:	e9 fc f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ea0 <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+80106ea0:	6a 0e                	push   $0xe
+  jmp alltraps
+80106ea2:	e9 f5 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ea7 <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+80106ea7:	6a 00                	push   $0x0
+  pushl $15
+80106ea9:	6a 0f                	push   $0xf
+  jmp alltraps
+80106eab:	e9 ec f8 ff ff       	jmp    8010679c <alltraps>
+
+80106eb0 <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+80106eb0:	6a 00                	push   $0x0
+  pushl $16
+80106eb2:	6a 10                	push   $0x10
+  jmp alltraps
+80106eb4:	e9 e3 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106eb9 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+80106eb9:	6a 11                	push   $0x11
+  jmp alltraps
+80106ebb:	e9 dc f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ec0 <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+80106ec0:	6a 00                	push   $0x0
+  pushl $18
+80106ec2:	6a 12                	push   $0x12
+  jmp alltraps
+80106ec4:	e9 d3 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ec9 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+80106ec9:	6a 00                	push   $0x0
+  pushl $19
+80106ecb:	6a 13                	push   $0x13
+  jmp alltraps
+80106ecd:	e9 ca f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ed2 <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+80106ed2:	6a 00                	push   $0x0
+  pushl $20
+80106ed4:	6a 14                	push   $0x14
+  jmp alltraps
+80106ed6:	e9 c1 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106edb <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+80106edb:	6a 00                	push   $0x0
+  pushl $21
+80106edd:	6a 15                	push   $0x15
+  jmp alltraps
+80106edf:	e9 b8 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ee4 <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+80106ee4:	6a 00                	push   $0x0
+  pushl $22
+80106ee6:	6a 16                	push   $0x16
+  jmp alltraps
+80106ee8:	e9 af f8 ff ff       	jmp    8010679c <alltraps>
+
+80106eed <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+80106eed:	6a 00                	push   $0x0
+  pushl $23
+80106eef:	6a 17                	push   $0x17
+  jmp alltraps
+80106ef1:	e9 a6 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106ef6 <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+80106ef6:	6a 00                	push   $0x0
+  pushl $24
+80106ef8:	6a 18                	push   $0x18
+  jmp alltraps
+80106efa:	e9 9d f8 ff ff       	jmp    8010679c <alltraps>
+
+80106eff <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+80106eff:	6a 00                	push   $0x0
+  pushl $25
+80106f01:	6a 19                	push   $0x19
+  jmp alltraps
+80106f03:	e9 94 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f08 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+80106f08:	6a 00                	push   $0x0
+  pushl $26
+80106f0a:	6a 1a                	push   $0x1a
+  jmp alltraps
+80106f0c:	e9 8b f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f11 <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+80106f11:	6a 00                	push   $0x0
+  pushl $27
+80106f13:	6a 1b                	push   $0x1b
+  jmp alltraps
+80106f15:	e9 82 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f1a <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+80106f1a:	6a 00                	push   $0x0
+  pushl $28
+80106f1c:	6a 1c                	push   $0x1c
+  jmp alltraps
+80106f1e:	e9 79 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f23 <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+80106f23:	6a 00                	push   $0x0
+  pushl $29
+80106f25:	6a 1d                	push   $0x1d
+  jmp alltraps
+80106f27:	e9 70 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f2c <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+80106f2c:	6a 00                	push   $0x0
+  pushl $30
+80106f2e:	6a 1e                	push   $0x1e
+  jmp alltraps
+80106f30:	e9 67 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f35 <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+80106f35:	6a 00                	push   $0x0
+  pushl $31
+80106f37:	6a 1f                	push   $0x1f
+  jmp alltraps
+80106f39:	e9 5e f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f3e <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+80106f3e:	6a 00                	push   $0x0
+  pushl $32
+80106f40:	6a 20                	push   $0x20
+  jmp alltraps
+80106f42:	e9 55 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f47 <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+80106f47:	6a 00                	push   $0x0
+  pushl $33
+80106f49:	6a 21                	push   $0x21
+  jmp alltraps
+80106f4b:	e9 4c f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f50 <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+80106f50:	6a 00                	push   $0x0
+  pushl $34
+80106f52:	6a 22                	push   $0x22
+  jmp alltraps
+80106f54:	e9 43 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f59 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+80106f59:	6a 00                	push   $0x0
+  pushl $35
+80106f5b:	6a 23                	push   $0x23
+  jmp alltraps
+80106f5d:	e9 3a f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f62 <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+80106f62:	6a 00                	push   $0x0
+  pushl $36
+80106f64:	6a 24                	push   $0x24
+  jmp alltraps
+80106f66:	e9 31 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f6b <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+80106f6b:	6a 00                	push   $0x0
+  pushl $37
+80106f6d:	6a 25                	push   $0x25
+  jmp alltraps
+80106f6f:	e9 28 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f74 <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+80106f74:	6a 00                	push   $0x0
+  pushl $38
+80106f76:	6a 26                	push   $0x26
+  jmp alltraps
+80106f78:	e9 1f f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f7d <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+80106f7d:	6a 00                	push   $0x0
+  pushl $39
+80106f7f:	6a 27                	push   $0x27
+  jmp alltraps
+80106f81:	e9 16 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f86 <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+80106f86:	6a 00                	push   $0x0
+  pushl $40
+80106f88:	6a 28                	push   $0x28
+  jmp alltraps
+80106f8a:	e9 0d f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f8f <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+80106f8f:	6a 00                	push   $0x0
+  pushl $41
+80106f91:	6a 29                	push   $0x29
+  jmp alltraps
+80106f93:	e9 04 f8 ff ff       	jmp    8010679c <alltraps>
+
+80106f98 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+80106f98:	6a 00                	push   $0x0
+  pushl $42
+80106f9a:	6a 2a                	push   $0x2a
+  jmp alltraps
+80106f9c:	e9 fb f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fa1 <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+80106fa1:	6a 00                	push   $0x0
+  pushl $43
+80106fa3:	6a 2b                	push   $0x2b
+  jmp alltraps
+80106fa5:	e9 f2 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106faa <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+80106faa:	6a 00                	push   $0x0
+  pushl $44
+80106fac:	6a 2c                	push   $0x2c
+  jmp alltraps
+80106fae:	e9 e9 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fb3 <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+80106fb3:	6a 00                	push   $0x0
+  pushl $45
+80106fb5:	6a 2d                	push   $0x2d
+  jmp alltraps
+80106fb7:	e9 e0 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fbc <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+80106fbc:	6a 00                	push   $0x0
+  pushl $46
+80106fbe:	6a 2e                	push   $0x2e
+  jmp alltraps
+80106fc0:	e9 d7 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fc5 <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+80106fc5:	6a 00                	push   $0x0
+  pushl $47
+80106fc7:	6a 2f                	push   $0x2f
+  jmp alltraps
+80106fc9:	e9 ce f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fce <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+80106fce:	6a 00                	push   $0x0
+  pushl $48
+80106fd0:	6a 30                	push   $0x30
+  jmp alltraps
+80106fd2:	e9 c5 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fd7 <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+80106fd7:	6a 00                	push   $0x0
+  pushl $49
+80106fd9:	6a 31                	push   $0x31
+  jmp alltraps
+80106fdb:	e9 bc f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fe0 <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+80106fe0:	6a 00                	push   $0x0
+  pushl $50
+80106fe2:	6a 32                	push   $0x32
+  jmp alltraps
+80106fe4:	e9 b3 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106fe9 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+80106fe9:	6a 00                	push   $0x0
+  pushl $51
+80106feb:	6a 33                	push   $0x33
+  jmp alltraps
+80106fed:	e9 aa f7 ff ff       	jmp    8010679c <alltraps>
+
+80106ff2 <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+80106ff2:	6a 00                	push   $0x0
+  pushl $52
+80106ff4:	6a 34                	push   $0x34
+  jmp alltraps
+80106ff6:	e9 a1 f7 ff ff       	jmp    8010679c <alltraps>
+
+80106ffb <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+80106ffb:	6a 00                	push   $0x0
+  pushl $53
+80106ffd:	6a 35                	push   $0x35
+  jmp alltraps
+80106fff:	e9 98 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107004 <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+80107004:	6a 00                	push   $0x0
+  pushl $54
+80107006:	6a 36                	push   $0x36
+  jmp alltraps
+80107008:	e9 8f f7 ff ff       	jmp    8010679c <alltraps>
+
+8010700d <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+8010700d:	6a 00                	push   $0x0
+  pushl $55
+8010700f:	6a 37                	push   $0x37
+  jmp alltraps
+80107011:	e9 86 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107016 <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+80107016:	6a 00                	push   $0x0
+  pushl $56
+80107018:	6a 38                	push   $0x38
+  jmp alltraps
+8010701a:	e9 7d f7 ff ff       	jmp    8010679c <alltraps>
+
+8010701f <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+8010701f:	6a 00                	push   $0x0
+  pushl $57
+80107021:	6a 39                	push   $0x39
+  jmp alltraps
+80107023:	e9 74 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107028 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+80107028:	6a 00                	push   $0x0
+  pushl $58
+8010702a:	6a 3a                	push   $0x3a
+  jmp alltraps
+8010702c:	e9 6b f7 ff ff       	jmp    8010679c <alltraps>
+
+80107031 <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+80107031:	6a 00                	push   $0x0
+  pushl $59
+80107033:	6a 3b                	push   $0x3b
+  jmp alltraps
+80107035:	e9 62 f7 ff ff       	jmp    8010679c <alltraps>
+
+8010703a <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+8010703a:	6a 00                	push   $0x0
+  pushl $60
+8010703c:	6a 3c                	push   $0x3c
+  jmp alltraps
+8010703e:	e9 59 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107043 <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+80107043:	6a 00                	push   $0x0
+  pushl $61
+80107045:	6a 3d                	push   $0x3d
+  jmp alltraps
+80107047:	e9 50 f7 ff ff       	jmp    8010679c <alltraps>
+
+8010704c <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+8010704c:	6a 00                	push   $0x0
+  pushl $62
+8010704e:	6a 3e                	push   $0x3e
+  jmp alltraps
+80107050:	e9 47 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107055 <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+80107055:	6a 00                	push   $0x0
+  pushl $63
+80107057:	6a 3f                	push   $0x3f
+  jmp alltraps
+80107059:	e9 3e f7 ff ff       	jmp    8010679c <alltraps>
+
+8010705e <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+8010705e:	6a 00                	push   $0x0
+  pushl $64
+80107060:	6a 40                	push   $0x40
+  jmp alltraps
+80107062:	e9 35 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107067 <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+80107067:	6a 00                	push   $0x0
+  pushl $65
+80107069:	6a 41                	push   $0x41
+  jmp alltraps
+8010706b:	e9 2c f7 ff ff       	jmp    8010679c <alltraps>
+
+80107070 <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+80107070:	6a 00                	push   $0x0
+  pushl $66
+80107072:	6a 42                	push   $0x42
+  jmp alltraps
+80107074:	e9 23 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107079 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+80107079:	6a 00                	push   $0x0
+  pushl $67
+8010707b:	6a 43                	push   $0x43
+  jmp alltraps
+8010707d:	e9 1a f7 ff ff       	jmp    8010679c <alltraps>
+
+80107082 <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+80107082:	6a 00                	push   $0x0
+  pushl $68
+80107084:	6a 44                	push   $0x44
+  jmp alltraps
+80107086:	e9 11 f7 ff ff       	jmp    8010679c <alltraps>
+
+8010708b <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+8010708b:	6a 00                	push   $0x0
+  pushl $69
+8010708d:	6a 45                	push   $0x45
+  jmp alltraps
+8010708f:	e9 08 f7 ff ff       	jmp    8010679c <alltraps>
+
+80107094 <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+80107094:	6a 00                	push   $0x0
+  pushl $70
+80107096:	6a 46                	push   $0x46
+  jmp alltraps
+80107098:	e9 ff f6 ff ff       	jmp    8010679c <alltraps>
+
+8010709d <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+8010709d:	6a 00                	push   $0x0
+  pushl $71
+8010709f:	6a 47                	push   $0x47
+  jmp alltraps
+801070a1:	e9 f6 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070a6 <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+801070a6:	6a 00                	push   $0x0
+  pushl $72
+801070a8:	6a 48                	push   $0x48
+  jmp alltraps
+801070aa:	e9 ed f6 ff ff       	jmp    8010679c <alltraps>
+
+801070af <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+801070af:	6a 00                	push   $0x0
+  pushl $73
+801070b1:	6a 49                	push   $0x49
+  jmp alltraps
+801070b3:	e9 e4 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070b8 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+801070b8:	6a 00                	push   $0x0
+  pushl $74
+801070ba:	6a 4a                	push   $0x4a
+  jmp alltraps
+801070bc:	e9 db f6 ff ff       	jmp    8010679c <alltraps>
+
+801070c1 <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+801070c1:	6a 00                	push   $0x0
+  pushl $75
+801070c3:	6a 4b                	push   $0x4b
+  jmp alltraps
+801070c5:	e9 d2 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070ca <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+801070ca:	6a 00                	push   $0x0
+  pushl $76
+801070cc:	6a 4c                	push   $0x4c
+  jmp alltraps
+801070ce:	e9 c9 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070d3 <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+801070d3:	6a 00                	push   $0x0
+  pushl $77
+801070d5:	6a 4d                	push   $0x4d
+  jmp alltraps
+801070d7:	e9 c0 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070dc <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+801070dc:	6a 00                	push   $0x0
+  pushl $78
+801070de:	6a 4e                	push   $0x4e
+  jmp alltraps
+801070e0:	e9 b7 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070e5 <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+801070e5:	6a 00                	push   $0x0
+  pushl $79
+801070e7:	6a 4f                	push   $0x4f
+  jmp alltraps
+801070e9:	e9 ae f6 ff ff       	jmp    8010679c <alltraps>
+
+801070ee <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+801070ee:	6a 00                	push   $0x0
+  pushl $80
+801070f0:	6a 50                	push   $0x50
+  jmp alltraps
+801070f2:	e9 a5 f6 ff ff       	jmp    8010679c <alltraps>
+
+801070f7 <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+801070f7:	6a 00                	push   $0x0
+  pushl $81
+801070f9:	6a 51                	push   $0x51
+  jmp alltraps
+801070fb:	e9 9c f6 ff ff       	jmp    8010679c <alltraps>
+
+80107100 <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+80107100:	6a 00                	push   $0x0
+  pushl $82
+80107102:	6a 52                	push   $0x52
+  jmp alltraps
+80107104:	e9 93 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107109 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+80107109:	6a 00                	push   $0x0
+  pushl $83
+8010710b:	6a 53                	push   $0x53
+  jmp alltraps
+8010710d:	e9 8a f6 ff ff       	jmp    8010679c <alltraps>
+
+80107112 <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+80107112:	6a 00                	push   $0x0
+  pushl $84
+80107114:	6a 54                	push   $0x54
+  jmp alltraps
+80107116:	e9 81 f6 ff ff       	jmp    8010679c <alltraps>
+
+8010711b <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+8010711b:	6a 00                	push   $0x0
+  pushl $85
+8010711d:	6a 55                	push   $0x55
+  jmp alltraps
+8010711f:	e9 78 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107124 <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+80107124:	6a 00                	push   $0x0
+  pushl $86
+80107126:	6a 56                	push   $0x56
+  jmp alltraps
+80107128:	e9 6f f6 ff ff       	jmp    8010679c <alltraps>
+
+8010712d <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+8010712d:	6a 00                	push   $0x0
+  pushl $87
+8010712f:	6a 57                	push   $0x57
+  jmp alltraps
+80107131:	e9 66 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107136 <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+80107136:	6a 00                	push   $0x0
+  pushl $88
+80107138:	6a 58                	push   $0x58
+  jmp alltraps
+8010713a:	e9 5d f6 ff ff       	jmp    8010679c <alltraps>
+
+8010713f <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+8010713f:	6a 00                	push   $0x0
+  pushl $89
+80107141:	6a 59                	push   $0x59
+  jmp alltraps
+80107143:	e9 54 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107148 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+80107148:	6a 00                	push   $0x0
+  pushl $90
+8010714a:	6a 5a                	push   $0x5a
+  jmp alltraps
+8010714c:	e9 4b f6 ff ff       	jmp    8010679c <alltraps>
+
+80107151 <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+80107151:	6a 00                	push   $0x0
+  pushl $91
+80107153:	6a 5b                	push   $0x5b
+  jmp alltraps
+80107155:	e9 42 f6 ff ff       	jmp    8010679c <alltraps>
+
+8010715a <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+8010715a:	6a 00                	push   $0x0
+  pushl $92
+8010715c:	6a 5c                	push   $0x5c
+  jmp alltraps
+8010715e:	e9 39 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107163 <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+80107163:	6a 00                	push   $0x0
+  pushl $93
+80107165:	6a 5d                	push   $0x5d
+  jmp alltraps
+80107167:	e9 30 f6 ff ff       	jmp    8010679c <alltraps>
+
+8010716c <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+8010716c:	6a 00                	push   $0x0
+  pushl $94
+8010716e:	6a 5e                	push   $0x5e
+  jmp alltraps
+80107170:	e9 27 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107175 <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+80107175:	6a 00                	push   $0x0
+  pushl $95
+80107177:	6a 5f                	push   $0x5f
+  jmp alltraps
+80107179:	e9 1e f6 ff ff       	jmp    8010679c <alltraps>
+
+8010717e <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+8010717e:	6a 00                	push   $0x0
+  pushl $96
+80107180:	6a 60                	push   $0x60
+  jmp alltraps
+80107182:	e9 15 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107187 <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+80107187:	6a 00                	push   $0x0
+  pushl $97
+80107189:	6a 61                	push   $0x61
+  jmp alltraps
+8010718b:	e9 0c f6 ff ff       	jmp    8010679c <alltraps>
+
+80107190 <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+80107190:	6a 00                	push   $0x0
+  pushl $98
+80107192:	6a 62                	push   $0x62
+  jmp alltraps
+80107194:	e9 03 f6 ff ff       	jmp    8010679c <alltraps>
+
+80107199 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+80107199:	6a 00                	push   $0x0
+  pushl $99
+8010719b:	6a 63                	push   $0x63
+  jmp alltraps
+8010719d:	e9 fa f5 ff ff       	jmp    8010679c <alltraps>
+
+801071a2 <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+801071a2:	6a 00                	push   $0x0
+  pushl $100
+801071a4:	6a 64                	push   $0x64
+  jmp alltraps
+801071a6:	e9 f1 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071ab <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+801071ab:	6a 00                	push   $0x0
+  pushl $101
+801071ad:	6a 65                	push   $0x65
+  jmp alltraps
+801071af:	e9 e8 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071b4 <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+801071b4:	6a 00                	push   $0x0
+  pushl $102
+801071b6:	6a 66                	push   $0x66
+  jmp alltraps
+801071b8:	e9 df f5 ff ff       	jmp    8010679c <alltraps>
+
+801071bd <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+801071bd:	6a 00                	push   $0x0
+  pushl $103
+801071bf:	6a 67                	push   $0x67
+  jmp alltraps
+801071c1:	e9 d6 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071c6 <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+801071c6:	6a 00                	push   $0x0
+  pushl $104
+801071c8:	6a 68                	push   $0x68
+  jmp alltraps
+801071ca:	e9 cd f5 ff ff       	jmp    8010679c <alltraps>
+
+801071cf <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+801071cf:	6a 00                	push   $0x0
+  pushl $105
+801071d1:	6a 69                	push   $0x69
+  jmp alltraps
+801071d3:	e9 c4 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071d8 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+801071d8:	6a 00                	push   $0x0
+  pushl $106
+801071da:	6a 6a                	push   $0x6a
+  jmp alltraps
+801071dc:	e9 bb f5 ff ff       	jmp    8010679c <alltraps>
+
+801071e1 <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+801071e1:	6a 00                	push   $0x0
+  pushl $107
+801071e3:	6a 6b                	push   $0x6b
+  jmp alltraps
+801071e5:	e9 b2 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071ea <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+801071ea:	6a 00                	push   $0x0
+  pushl $108
+801071ec:	6a 6c                	push   $0x6c
+  jmp alltraps
+801071ee:	e9 a9 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071f3 <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+801071f3:	6a 00                	push   $0x0
+  pushl $109
+801071f5:	6a 6d                	push   $0x6d
+  jmp alltraps
+801071f7:	e9 a0 f5 ff ff       	jmp    8010679c <alltraps>
+
+801071fc <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+801071fc:	6a 00                	push   $0x0
+  pushl $110
+801071fe:	6a 6e                	push   $0x6e
+  jmp alltraps
+80107200:	e9 97 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107205 <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+80107205:	6a 00                	push   $0x0
+  pushl $111
+80107207:	6a 6f                	push   $0x6f
+  jmp alltraps
+80107209:	e9 8e f5 ff ff       	jmp    8010679c <alltraps>
+
+8010720e <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+8010720e:	6a 00                	push   $0x0
+  pushl $112
+80107210:	6a 70                	push   $0x70
+  jmp alltraps
+80107212:	e9 85 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107217 <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+80107217:	6a 00                	push   $0x0
+  pushl $113
+80107219:	6a 71                	push   $0x71
+  jmp alltraps
+8010721b:	e9 7c f5 ff ff       	jmp    8010679c <alltraps>
+
+80107220 <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+80107220:	6a 00                	push   $0x0
+  pushl $114
+80107222:	6a 72                	push   $0x72
+  jmp alltraps
+80107224:	e9 73 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107229 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+80107229:	6a 00                	push   $0x0
+  pushl $115
+8010722b:	6a 73                	push   $0x73
+  jmp alltraps
+8010722d:	e9 6a f5 ff ff       	jmp    8010679c <alltraps>
+
+80107232 <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+80107232:	6a 00                	push   $0x0
+  pushl $116
+80107234:	6a 74                	push   $0x74
+  jmp alltraps
+80107236:	e9 61 f5 ff ff       	jmp    8010679c <alltraps>
+
+8010723b <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+8010723b:	6a 00                	push   $0x0
+  pushl $117
+8010723d:	6a 75                	push   $0x75
+  jmp alltraps
+8010723f:	e9 58 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107244 <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+80107244:	6a 00                	push   $0x0
+  pushl $118
+80107246:	6a 76                	push   $0x76
+  jmp alltraps
+80107248:	e9 4f f5 ff ff       	jmp    8010679c <alltraps>
+
+8010724d <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+8010724d:	6a 00                	push   $0x0
+  pushl $119
+8010724f:	6a 77                	push   $0x77
+  jmp alltraps
+80107251:	e9 46 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107256 <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+80107256:	6a 00                	push   $0x0
+  pushl $120
+80107258:	6a 78                	push   $0x78
+  jmp alltraps
+8010725a:	e9 3d f5 ff ff       	jmp    8010679c <alltraps>
+
+8010725f <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+8010725f:	6a 00                	push   $0x0
+  pushl $121
+80107261:	6a 79                	push   $0x79
+  jmp alltraps
+80107263:	e9 34 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107268 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+80107268:	6a 00                	push   $0x0
+  pushl $122
+8010726a:	6a 7a                	push   $0x7a
+  jmp alltraps
+8010726c:	e9 2b f5 ff ff       	jmp    8010679c <alltraps>
+
+80107271 <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+80107271:	6a 00                	push   $0x0
+  pushl $123
+80107273:	6a 7b                	push   $0x7b
+  jmp alltraps
+80107275:	e9 22 f5 ff ff       	jmp    8010679c <alltraps>
+
+8010727a <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+8010727a:	6a 00                	push   $0x0
+  pushl $124
+8010727c:	6a 7c                	push   $0x7c
+  jmp alltraps
+8010727e:	e9 19 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107283 <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+80107283:	6a 00                	push   $0x0
+  pushl $125
+80107285:	6a 7d                	push   $0x7d
+  jmp alltraps
+80107287:	e9 10 f5 ff ff       	jmp    8010679c <alltraps>
+
+8010728c <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+8010728c:	6a 00                	push   $0x0
+  pushl $126
+8010728e:	6a 7e                	push   $0x7e
+  jmp alltraps
+80107290:	e9 07 f5 ff ff       	jmp    8010679c <alltraps>
+
+80107295 <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+80107295:	6a 00                	push   $0x0
+  pushl $127
+80107297:	6a 7f                	push   $0x7f
+  jmp alltraps
+80107299:	e9 fe f4 ff ff       	jmp    8010679c <alltraps>
+
+8010729e <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+8010729e:	6a 00                	push   $0x0
+  pushl $128
+801072a0:	68 80 00 00 00       	push   $0x80
+  jmp alltraps
+801072a5:	e9 f2 f4 ff ff       	jmp    8010679c <alltraps>
+
+801072aa <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+801072aa:	6a 00                	push   $0x0
+  pushl $129
+801072ac:	68 81 00 00 00       	push   $0x81
+  jmp alltraps
+801072b1:	e9 e6 f4 ff ff       	jmp    8010679c <alltraps>
+
+801072b6 <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+801072b6:	6a 00                	push   $0x0
+  pushl $130
+801072b8:	68 82 00 00 00       	push   $0x82
+  jmp alltraps
+801072bd:	e9 da f4 ff ff       	jmp    8010679c <alltraps>
+
+801072c2 <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+801072c2:	6a 00                	push   $0x0
+  pushl $131
+801072c4:	68 83 00 00 00       	push   $0x83
+  jmp alltraps
+801072c9:	e9 ce f4 ff ff       	jmp    8010679c <alltraps>
+
+801072ce <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+801072ce:	6a 00                	push   $0x0
+  pushl $132
+801072d0:	68 84 00 00 00       	push   $0x84
+  jmp alltraps
+801072d5:	e9 c2 f4 ff ff       	jmp    8010679c <alltraps>
+
+801072da <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+801072da:	6a 00                	push   $0x0
+  pushl $133
+801072dc:	68 85 00 00 00       	push   $0x85
+  jmp alltraps
+801072e1:	e9 b6 f4 ff ff       	jmp    8010679c <alltraps>
+
+801072e6 <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+801072e6:	6a 00                	push   $0x0
+  pushl $134
+801072e8:	68 86 00 00 00       	push   $0x86
+  jmp alltraps
+801072ed:	e9 aa f4 ff ff       	jmp    8010679c <alltraps>
+
+801072f2 <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+801072f2:	6a 00                	push   $0x0
+  pushl $135
+801072f4:	68 87 00 00 00       	push   $0x87
+  jmp alltraps
+801072f9:	e9 9e f4 ff ff       	jmp    8010679c <alltraps>
+
+801072fe <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+801072fe:	6a 00                	push   $0x0
+  pushl $136
+80107300:	68 88 00 00 00       	push   $0x88
+  jmp alltraps
+80107305:	e9 92 f4 ff ff       	jmp    8010679c <alltraps>
+
+8010730a <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+8010730a:	6a 00                	push   $0x0
+  pushl $137
+8010730c:	68 89 00 00 00       	push   $0x89
+  jmp alltraps
+80107311:	e9 86 f4 ff ff       	jmp    8010679c <alltraps>
+
+80107316 <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+80107316:	6a 00                	push   $0x0
+  pushl $138
+80107318:	68 8a 00 00 00       	push   $0x8a
+  jmp alltraps
+8010731d:	e9 7a f4 ff ff       	jmp    8010679c <alltraps>
+
+80107322 <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+80107322:	6a 00                	push   $0x0
+  pushl $139
+80107324:	68 8b 00 00 00       	push   $0x8b
+  jmp alltraps
+80107329:	e9 6e f4 ff ff       	jmp    8010679c <alltraps>
+
+8010732e <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+8010732e:	6a 00                	push   $0x0
+  pushl $140
+80107330:	68 8c 00 00 00       	push   $0x8c
+  jmp alltraps
+80107335:	e9 62 f4 ff ff       	jmp    8010679c <alltraps>
+
+8010733a <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+8010733a:	6a 00                	push   $0x0
+  pushl $141
+8010733c:	68 8d 00 00 00       	push   $0x8d
+  jmp alltraps
+80107341:	e9 56 f4 ff ff       	jmp    8010679c <alltraps>
+
+80107346 <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+80107346:	6a 00                	push   $0x0
+  pushl $142
+80107348:	68 8e 00 00 00       	push   $0x8e
+  jmp alltraps
+8010734d:	e9 4a f4 ff ff       	jmp    8010679c <alltraps>
+
+80107352 <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+80107352:	6a 00                	push   $0x0
+  pushl $143
+80107354:	68 8f 00 00 00       	push   $0x8f
+  jmp alltraps
+80107359:	e9 3e f4 ff ff       	jmp    8010679c <alltraps>
+
+8010735e <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+8010735e:	6a 00                	push   $0x0
+  pushl $144
+80107360:	68 90 00 00 00       	push   $0x90
+  jmp alltraps
+80107365:	e9 32 f4 ff ff       	jmp    8010679c <alltraps>
+
+8010736a <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+8010736a:	6a 00                	push   $0x0
+  pushl $145
+8010736c:	68 91 00 00 00       	push   $0x91
+  jmp alltraps
+80107371:	e9 26 f4 ff ff       	jmp    8010679c <alltraps>
+
+80107376 <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+80107376:	6a 00                	push   $0x0
+  pushl $146
+80107378:	68 92 00 00 00       	push   $0x92
+  jmp alltraps
+8010737d:	e9 1a f4 ff ff       	jmp    8010679c <alltraps>
+
+80107382 <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+80107382:	6a 00                	push   $0x0
+  pushl $147
+80107384:	68 93 00 00 00       	push   $0x93
+  jmp alltraps
+80107389:	e9 0e f4 ff ff       	jmp    8010679c <alltraps>
+
+8010738e <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+8010738e:	6a 00                	push   $0x0
+  pushl $148
+80107390:	68 94 00 00 00       	push   $0x94
+  jmp alltraps
+80107395:	e9 02 f4 ff ff       	jmp    8010679c <alltraps>
+
+8010739a <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+8010739a:	6a 00                	push   $0x0
+  pushl $149
+8010739c:	68 95 00 00 00       	push   $0x95
+  jmp alltraps
+801073a1:	e9 f6 f3 ff ff       	jmp    8010679c <alltraps>
+
+801073a6 <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+801073a6:	6a 00                	push   $0x0
+  pushl $150
+801073a8:	68 96 00 00 00       	push   $0x96
+  jmp alltraps
+801073ad:	e9 ea f3 ff ff       	jmp    8010679c <alltraps>
+
+801073b2 <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+801073b2:	6a 00                	push   $0x0
+  pushl $151
+801073b4:	68 97 00 00 00       	push   $0x97
+  jmp alltraps
+801073b9:	e9 de f3 ff ff       	jmp    8010679c <alltraps>
+
+801073be <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+801073be:	6a 00                	push   $0x0
+  pushl $152
+801073c0:	68 98 00 00 00       	push   $0x98
+  jmp alltraps
+801073c5:	e9 d2 f3 ff ff       	jmp    8010679c <alltraps>
+
+801073ca <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+801073ca:	6a 00                	push   $0x0
+  pushl $153
+801073cc:	68 99 00 00 00       	push   $0x99
+  jmp alltraps
+801073d1:	e9 c6 f3 ff ff       	jmp    8010679c <alltraps>
+
+801073d6 <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+801073d6:	6a 00                	push   $0x0
+  pushl $154
+801073d8:	68 9a 00 00 00       	push   $0x9a
+  jmp alltraps
+801073dd:	e9 ba f3 ff ff       	jmp    8010679c <alltraps>
+
+801073e2 <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+801073e2:	6a 00                	push   $0x0
+  pushl $155
+801073e4:	68 9b 00 00 00       	push   $0x9b
+  jmp alltraps
+801073e9:	e9 ae f3 ff ff       	jmp    8010679c <alltraps>
+
+801073ee <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+801073ee:	6a 00                	push   $0x0
+  pushl $156
+801073f0:	68 9c 00 00 00       	push   $0x9c
+  jmp alltraps
+801073f5:	e9 a2 f3 ff ff       	jmp    8010679c <alltraps>
+
+801073fa <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+801073fa:	6a 00                	push   $0x0
+  pushl $157
+801073fc:	68 9d 00 00 00       	push   $0x9d
+  jmp alltraps
+80107401:	e9 96 f3 ff ff       	jmp    8010679c <alltraps>
+
+80107406 <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+80107406:	6a 00                	push   $0x0
+  pushl $158
+80107408:	68 9e 00 00 00       	push   $0x9e
+  jmp alltraps
+8010740d:	e9 8a f3 ff ff       	jmp    8010679c <alltraps>
+
+80107412 <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+80107412:	6a 00                	push   $0x0
+  pushl $159
+80107414:	68 9f 00 00 00       	push   $0x9f
+  jmp alltraps
+80107419:	e9 7e f3 ff ff       	jmp    8010679c <alltraps>
+
+8010741e <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+8010741e:	6a 00                	push   $0x0
+  pushl $160
+80107420:	68 a0 00 00 00       	push   $0xa0
+  jmp alltraps
+80107425:	e9 72 f3 ff ff       	jmp    8010679c <alltraps>
+
+8010742a <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+8010742a:	6a 00                	push   $0x0
+  pushl $161
+8010742c:	68 a1 00 00 00       	push   $0xa1
+  jmp alltraps
+80107431:	e9 66 f3 ff ff       	jmp    8010679c <alltraps>
+
+80107436 <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+80107436:	6a 00                	push   $0x0
+  pushl $162
+80107438:	68 a2 00 00 00       	push   $0xa2
+  jmp alltraps
+8010743d:	e9 5a f3 ff ff       	jmp    8010679c <alltraps>
+
+80107442 <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+80107442:	6a 00                	push   $0x0
+  pushl $163
+80107444:	68 a3 00 00 00       	push   $0xa3
+  jmp alltraps
+80107449:	e9 4e f3 ff ff       	jmp    8010679c <alltraps>
+
+8010744e <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+8010744e:	6a 00                	push   $0x0
+  pushl $164
+80107450:	68 a4 00 00 00       	push   $0xa4
+  jmp alltraps
+80107455:	e9 42 f3 ff ff       	jmp    8010679c <alltraps>
+
+8010745a <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+8010745a:	6a 00                	push   $0x0
+  pushl $165
+8010745c:	68 a5 00 00 00       	push   $0xa5
+  jmp alltraps
+80107461:	e9 36 f3 ff ff       	jmp    8010679c <alltraps>
+
+80107466 <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+80107466:	6a 00                	push   $0x0
+  pushl $166
+80107468:	68 a6 00 00 00       	push   $0xa6
+  jmp alltraps
+8010746d:	e9 2a f3 ff ff       	jmp    8010679c <alltraps>
+
+80107472 <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+80107472:	6a 00                	push   $0x0
+  pushl $167
+80107474:	68 a7 00 00 00       	push   $0xa7
+  jmp alltraps
+80107479:	e9 1e f3 ff ff       	jmp    8010679c <alltraps>
+
+8010747e <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+8010747e:	6a 00                	push   $0x0
+  pushl $168
+80107480:	68 a8 00 00 00       	push   $0xa8
+  jmp alltraps
+80107485:	e9 12 f3 ff ff       	jmp    8010679c <alltraps>
+
+8010748a <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+8010748a:	6a 00                	push   $0x0
+  pushl $169
+8010748c:	68 a9 00 00 00       	push   $0xa9
+  jmp alltraps
+80107491:	e9 06 f3 ff ff       	jmp    8010679c <alltraps>
+
+80107496 <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+80107496:	6a 00                	push   $0x0
+  pushl $170
+80107498:	68 aa 00 00 00       	push   $0xaa
+  jmp alltraps
+8010749d:	e9 fa f2 ff ff       	jmp    8010679c <alltraps>
+
+801074a2 <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+801074a2:	6a 00                	push   $0x0
+  pushl $171
+801074a4:	68 ab 00 00 00       	push   $0xab
+  jmp alltraps
+801074a9:	e9 ee f2 ff ff       	jmp    8010679c <alltraps>
+
+801074ae <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+801074ae:	6a 00                	push   $0x0
+  pushl $172
+801074b0:	68 ac 00 00 00       	push   $0xac
+  jmp alltraps
+801074b5:	e9 e2 f2 ff ff       	jmp    8010679c <alltraps>
+
+801074ba <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+801074ba:	6a 00                	push   $0x0
+  pushl $173
+801074bc:	68 ad 00 00 00       	push   $0xad
+  jmp alltraps
+801074c1:	e9 d6 f2 ff ff       	jmp    8010679c <alltraps>
+
+801074c6 <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+801074c6:	6a 00                	push   $0x0
+  pushl $174
+801074c8:	68 ae 00 00 00       	push   $0xae
+  jmp alltraps
+801074cd:	e9 ca f2 ff ff       	jmp    8010679c <alltraps>
+
+801074d2 <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+801074d2:	6a 00                	push   $0x0
+  pushl $175
+801074d4:	68 af 00 00 00       	push   $0xaf
+  jmp alltraps
+801074d9:	e9 be f2 ff ff       	jmp    8010679c <alltraps>
+
+801074de <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+801074de:	6a 00                	push   $0x0
+  pushl $176
+801074e0:	68 b0 00 00 00       	push   $0xb0
+  jmp alltraps
+801074e5:	e9 b2 f2 ff ff       	jmp    8010679c <alltraps>
+
+801074ea <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+801074ea:	6a 00                	push   $0x0
+  pushl $177
+801074ec:	68 b1 00 00 00       	push   $0xb1
+  jmp alltraps
+801074f1:	e9 a6 f2 ff ff       	jmp    8010679c <alltraps>
+
+801074f6 <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+801074f6:	6a 00                	push   $0x0
+  pushl $178
+801074f8:	68 b2 00 00 00       	push   $0xb2
+  jmp alltraps
+801074fd:	e9 9a f2 ff ff       	jmp    8010679c <alltraps>
+
+80107502 <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+80107502:	6a 00                	push   $0x0
+  pushl $179
+80107504:	68 b3 00 00 00       	push   $0xb3
+  jmp alltraps
+80107509:	e9 8e f2 ff ff       	jmp    8010679c <alltraps>
+
+8010750e <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+8010750e:	6a 00                	push   $0x0
+  pushl $180
+80107510:	68 b4 00 00 00       	push   $0xb4
+  jmp alltraps
+80107515:	e9 82 f2 ff ff       	jmp    8010679c <alltraps>
+
+8010751a <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+8010751a:	6a 00                	push   $0x0
+  pushl $181
+8010751c:	68 b5 00 00 00       	push   $0xb5
+  jmp alltraps
+80107521:	e9 76 f2 ff ff       	jmp    8010679c <alltraps>
+
+80107526 <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+80107526:	6a 00                	push   $0x0
+  pushl $182
+80107528:	68 b6 00 00 00       	push   $0xb6
+  jmp alltraps
+8010752d:	e9 6a f2 ff ff       	jmp    8010679c <alltraps>
+
+80107532 <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+80107532:	6a 00                	push   $0x0
+  pushl $183
+80107534:	68 b7 00 00 00       	push   $0xb7
+  jmp alltraps
+80107539:	e9 5e f2 ff ff       	jmp    8010679c <alltraps>
+
+8010753e <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+8010753e:	6a 00                	push   $0x0
+  pushl $184
+80107540:	68 b8 00 00 00       	push   $0xb8
+  jmp alltraps
+80107545:	e9 52 f2 ff ff       	jmp    8010679c <alltraps>
+
+8010754a <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+8010754a:	6a 00                	push   $0x0
+  pushl $185
+8010754c:	68 b9 00 00 00       	push   $0xb9
+  jmp alltraps
+80107551:	e9 46 f2 ff ff       	jmp    8010679c <alltraps>
+
+80107556 <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+80107556:	6a 00                	push   $0x0
+  pushl $186
+80107558:	68 ba 00 00 00       	push   $0xba
+  jmp alltraps
+8010755d:	e9 3a f2 ff ff       	jmp    8010679c <alltraps>
+
+80107562 <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+80107562:	6a 00                	push   $0x0
+  pushl $187
+80107564:	68 bb 00 00 00       	push   $0xbb
+  jmp alltraps
+80107569:	e9 2e f2 ff ff       	jmp    8010679c <alltraps>
+
+8010756e <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+8010756e:	6a 00                	push   $0x0
+  pushl $188
+80107570:	68 bc 00 00 00       	push   $0xbc
+  jmp alltraps
+80107575:	e9 22 f2 ff ff       	jmp    8010679c <alltraps>
+
+8010757a <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+8010757a:	6a 00                	push   $0x0
+  pushl $189
+8010757c:	68 bd 00 00 00       	push   $0xbd
+  jmp alltraps
+80107581:	e9 16 f2 ff ff       	jmp    8010679c <alltraps>
+
+80107586 <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+80107586:	6a 00                	push   $0x0
+  pushl $190
+80107588:	68 be 00 00 00       	push   $0xbe
+  jmp alltraps
+8010758d:	e9 0a f2 ff ff       	jmp    8010679c <alltraps>
+
+80107592 <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+80107592:	6a 00                	push   $0x0
+  pushl $191
+80107594:	68 bf 00 00 00       	push   $0xbf
+  jmp alltraps
+80107599:	e9 fe f1 ff ff       	jmp    8010679c <alltraps>
+
+8010759e <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+8010759e:	6a 00                	push   $0x0
+  pushl $192
+801075a0:	68 c0 00 00 00       	push   $0xc0
+  jmp alltraps
+801075a5:	e9 f2 f1 ff ff       	jmp    8010679c <alltraps>
+
+801075aa <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+801075aa:	6a 00                	push   $0x0
+  pushl $193
+801075ac:	68 c1 00 00 00       	push   $0xc1
+  jmp alltraps
+801075b1:	e9 e6 f1 ff ff       	jmp    8010679c <alltraps>
+
+801075b6 <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+801075b6:	6a 00                	push   $0x0
+  pushl $194
+801075b8:	68 c2 00 00 00       	push   $0xc2
+  jmp alltraps
+801075bd:	e9 da f1 ff ff       	jmp    8010679c <alltraps>
+
+801075c2 <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+801075c2:	6a 00                	push   $0x0
+  pushl $195
+801075c4:	68 c3 00 00 00       	push   $0xc3
+  jmp alltraps
+801075c9:	e9 ce f1 ff ff       	jmp    8010679c <alltraps>
+
+801075ce <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+801075ce:	6a 00                	push   $0x0
+  pushl $196
+801075d0:	68 c4 00 00 00       	push   $0xc4
+  jmp alltraps
+801075d5:	e9 c2 f1 ff ff       	jmp    8010679c <alltraps>
+
+801075da <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+801075da:	6a 00                	push   $0x0
+  pushl $197
+801075dc:	68 c5 00 00 00       	push   $0xc5
+  jmp alltraps
+801075e1:	e9 b6 f1 ff ff       	jmp    8010679c <alltraps>
+
+801075e6 <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+801075e6:	6a 00                	push   $0x0
+  pushl $198
+801075e8:	68 c6 00 00 00       	push   $0xc6
+  jmp alltraps
+801075ed:	e9 aa f1 ff ff       	jmp    8010679c <alltraps>
+
+801075f2 <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+801075f2:	6a 00                	push   $0x0
+  pushl $199
+801075f4:	68 c7 00 00 00       	push   $0xc7
+  jmp alltraps
+801075f9:	e9 9e f1 ff ff       	jmp    8010679c <alltraps>
+
+801075fe <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+801075fe:	6a 00                	push   $0x0
+  pushl $200
+80107600:	68 c8 00 00 00       	push   $0xc8
+  jmp alltraps
+80107605:	e9 92 f1 ff ff       	jmp    8010679c <alltraps>
+
+8010760a <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+8010760a:	6a 00                	push   $0x0
+  pushl $201
+8010760c:	68 c9 00 00 00       	push   $0xc9
+  jmp alltraps
+80107611:	e9 86 f1 ff ff       	jmp    8010679c <alltraps>
+
+80107616 <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+80107616:	6a 00                	push   $0x0
+  pushl $202
+80107618:	68 ca 00 00 00       	push   $0xca
+  jmp alltraps
+8010761d:	e9 7a f1 ff ff       	jmp    8010679c <alltraps>
+
+80107622 <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+80107622:	6a 00                	push   $0x0
+  pushl $203
+80107624:	68 cb 00 00 00       	push   $0xcb
+  jmp alltraps
+80107629:	e9 6e f1 ff ff       	jmp    8010679c <alltraps>
+
+8010762e <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+8010762e:	6a 00                	push   $0x0
+  pushl $204
+80107630:	68 cc 00 00 00       	push   $0xcc
+  jmp alltraps
+80107635:	e9 62 f1 ff ff       	jmp    8010679c <alltraps>
+
+8010763a <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+8010763a:	6a 00                	push   $0x0
+  pushl $205
+8010763c:	68 cd 00 00 00       	push   $0xcd
+  jmp alltraps
+80107641:	e9 56 f1 ff ff       	jmp    8010679c <alltraps>
+
+80107646 <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+80107646:	6a 00                	push   $0x0
+  pushl $206
+80107648:	68 ce 00 00 00       	push   $0xce
+  jmp alltraps
+8010764d:	e9 4a f1 ff ff       	jmp    8010679c <alltraps>
+
+80107652 <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+80107652:	6a 00                	push   $0x0
+  pushl $207
+80107654:	68 cf 00 00 00       	push   $0xcf
+  jmp alltraps
+80107659:	e9 3e f1 ff ff       	jmp    8010679c <alltraps>
+
+8010765e <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+8010765e:	6a 00                	push   $0x0
+  pushl $208
+80107660:	68 d0 00 00 00       	push   $0xd0
+  jmp alltraps
+80107665:	e9 32 f1 ff ff       	jmp    8010679c <alltraps>
+
+8010766a <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+8010766a:	6a 00                	push   $0x0
+  pushl $209
+8010766c:	68 d1 00 00 00       	push   $0xd1
+  jmp alltraps
+80107671:	e9 26 f1 ff ff       	jmp    8010679c <alltraps>
+
+80107676 <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+80107676:	6a 00                	push   $0x0
+  pushl $210
+80107678:	68 d2 00 00 00       	push   $0xd2
+  jmp alltraps
+8010767d:	e9 1a f1 ff ff       	jmp    8010679c <alltraps>
+
+80107682 <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+80107682:	6a 00                	push   $0x0
+  pushl $211
+80107684:	68 d3 00 00 00       	push   $0xd3
+  jmp alltraps
+80107689:	e9 0e f1 ff ff       	jmp    8010679c <alltraps>
+
+8010768e <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+8010768e:	6a 00                	push   $0x0
+  pushl $212
+80107690:	68 d4 00 00 00       	push   $0xd4
+  jmp alltraps
+80107695:	e9 02 f1 ff ff       	jmp    8010679c <alltraps>
+
+8010769a <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+8010769a:	6a 00                	push   $0x0
+  pushl $213
+8010769c:	68 d5 00 00 00       	push   $0xd5
+  jmp alltraps
+801076a1:	e9 f6 f0 ff ff       	jmp    8010679c <alltraps>
+
+801076a6 <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+801076a6:	6a 00                	push   $0x0
+  pushl $214
+801076a8:	68 d6 00 00 00       	push   $0xd6
+  jmp alltraps
+801076ad:	e9 ea f0 ff ff       	jmp    8010679c <alltraps>
+
+801076b2 <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+801076b2:	6a 00                	push   $0x0
+  pushl $215
+801076b4:	68 d7 00 00 00       	push   $0xd7
+  jmp alltraps
+801076b9:	e9 de f0 ff ff       	jmp    8010679c <alltraps>
+
+801076be <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+801076be:	6a 00                	push   $0x0
+  pushl $216
+801076c0:	68 d8 00 00 00       	push   $0xd8
+  jmp alltraps
+801076c5:	e9 d2 f0 ff ff       	jmp    8010679c <alltraps>
+
+801076ca <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+801076ca:	6a 00                	push   $0x0
+  pushl $217
+801076cc:	68 d9 00 00 00       	push   $0xd9
+  jmp alltraps
+801076d1:	e9 c6 f0 ff ff       	jmp    8010679c <alltraps>
+
+801076d6 <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+801076d6:	6a 00                	push   $0x0
+  pushl $218
+801076d8:	68 da 00 00 00       	push   $0xda
+  jmp alltraps
+801076dd:	e9 ba f0 ff ff       	jmp    8010679c <alltraps>
+
+801076e2 <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+801076e2:	6a 00                	push   $0x0
+  pushl $219
+801076e4:	68 db 00 00 00       	push   $0xdb
+  jmp alltraps
+801076e9:	e9 ae f0 ff ff       	jmp    8010679c <alltraps>
+
+801076ee <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+801076ee:	6a 00                	push   $0x0
+  pushl $220
+801076f0:	68 dc 00 00 00       	push   $0xdc
+  jmp alltraps
+801076f5:	e9 a2 f0 ff ff       	jmp    8010679c <alltraps>
+
+801076fa <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+801076fa:	6a 00                	push   $0x0
+  pushl $221
+801076fc:	68 dd 00 00 00       	push   $0xdd
+  jmp alltraps
+80107701:	e9 96 f0 ff ff       	jmp    8010679c <alltraps>
+
+80107706 <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+80107706:	6a 00                	push   $0x0
+  pushl $222
+80107708:	68 de 00 00 00       	push   $0xde
+  jmp alltraps
+8010770d:	e9 8a f0 ff ff       	jmp    8010679c <alltraps>
+
+80107712 <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+80107712:	6a 00                	push   $0x0
+  pushl $223
+80107714:	68 df 00 00 00       	push   $0xdf
+  jmp alltraps
+80107719:	e9 7e f0 ff ff       	jmp    8010679c <alltraps>
+
+8010771e <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+8010771e:	6a 00                	push   $0x0
+  pushl $224
+80107720:	68 e0 00 00 00       	push   $0xe0
+  jmp alltraps
+80107725:	e9 72 f0 ff ff       	jmp    8010679c <alltraps>
+
+8010772a <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+8010772a:	6a 00                	push   $0x0
+  pushl $225
+8010772c:	68 e1 00 00 00       	push   $0xe1
+  jmp alltraps
+80107731:	e9 66 f0 ff ff       	jmp    8010679c <alltraps>
+
+80107736 <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+80107736:	6a 00                	push   $0x0
+  pushl $226
+80107738:	68 e2 00 00 00       	push   $0xe2
+  jmp alltraps
+8010773d:	e9 5a f0 ff ff       	jmp    8010679c <alltraps>
+
+80107742 <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+80107742:	6a 00                	push   $0x0
+  pushl $227
+80107744:	68 e3 00 00 00       	push   $0xe3
+  jmp alltraps
+80107749:	e9 4e f0 ff ff       	jmp    8010679c <alltraps>
+
+8010774e <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+8010774e:	6a 00                	push   $0x0
+  pushl $228
+80107750:	68 e4 00 00 00       	push   $0xe4
+  jmp alltraps
+80107755:	e9 42 f0 ff ff       	jmp    8010679c <alltraps>
+
+8010775a <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+8010775a:	6a 00                	push   $0x0
+  pushl $229
+8010775c:	68 e5 00 00 00       	push   $0xe5
+  jmp alltraps
+80107761:	e9 36 f0 ff ff       	jmp    8010679c <alltraps>
+
+80107766 <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+80107766:	6a 00                	push   $0x0
+  pushl $230
+80107768:	68 e6 00 00 00       	push   $0xe6
+  jmp alltraps
+8010776d:	e9 2a f0 ff ff       	jmp    8010679c <alltraps>
+
+80107772 <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+80107772:	6a 00                	push   $0x0
+  pushl $231
+80107774:	68 e7 00 00 00       	push   $0xe7
+  jmp alltraps
+80107779:	e9 1e f0 ff ff       	jmp    8010679c <alltraps>
+
+8010777e <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+8010777e:	6a 00                	push   $0x0
+  pushl $232
+80107780:	68 e8 00 00 00       	push   $0xe8
+  jmp alltraps
+80107785:	e9 12 f0 ff ff       	jmp    8010679c <alltraps>
+
+8010778a <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+8010778a:	6a 00                	push   $0x0
+  pushl $233
+8010778c:	68 e9 00 00 00       	push   $0xe9
+  jmp alltraps
+80107791:	e9 06 f0 ff ff       	jmp    8010679c <alltraps>
+
+80107796 <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+80107796:	6a 00                	push   $0x0
+  pushl $234
+80107798:	68 ea 00 00 00       	push   $0xea
+  jmp alltraps
+8010779d:	e9 fa ef ff ff       	jmp    8010679c <alltraps>
+
+801077a2 <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+801077a2:	6a 00                	push   $0x0
+  pushl $235
+801077a4:	68 eb 00 00 00       	push   $0xeb
+  jmp alltraps
+801077a9:	e9 ee ef ff ff       	jmp    8010679c <alltraps>
+
+801077ae <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+801077ae:	6a 00                	push   $0x0
+  pushl $236
+801077b0:	68 ec 00 00 00       	push   $0xec
+  jmp alltraps
+801077b5:	e9 e2 ef ff ff       	jmp    8010679c <alltraps>
+
+801077ba <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+801077ba:	6a 00                	push   $0x0
+  pushl $237
+801077bc:	68 ed 00 00 00       	push   $0xed
+  jmp alltraps
+801077c1:	e9 d6 ef ff ff       	jmp    8010679c <alltraps>
+
+801077c6 <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+801077c6:	6a 00                	push   $0x0
+  pushl $238
+801077c8:	68 ee 00 00 00       	push   $0xee
+  jmp alltraps
+801077cd:	e9 ca ef ff ff       	jmp    8010679c <alltraps>
+
+801077d2 <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+801077d2:	6a 00                	push   $0x0
+  pushl $239
+801077d4:	68 ef 00 00 00       	push   $0xef
+  jmp alltraps
+801077d9:	e9 be ef ff ff       	jmp    8010679c <alltraps>
+
+801077de <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+801077de:	6a 00                	push   $0x0
+  pushl $240
+801077e0:	68 f0 00 00 00       	push   $0xf0
+  jmp alltraps
+801077e5:	e9 b2 ef ff ff       	jmp    8010679c <alltraps>
+
+801077ea <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+801077ea:	6a 00                	push   $0x0
+  pushl $241
+801077ec:	68 f1 00 00 00       	push   $0xf1
+  jmp alltraps
+801077f1:	e9 a6 ef ff ff       	jmp    8010679c <alltraps>
+
+801077f6 <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+801077f6:	6a 00                	push   $0x0
+  pushl $242
+801077f8:	68 f2 00 00 00       	push   $0xf2
+  jmp alltraps
+801077fd:	e9 9a ef ff ff       	jmp    8010679c <alltraps>
+
+80107802 <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+80107802:	6a 00                	push   $0x0
+  pushl $243
+80107804:	68 f3 00 00 00       	push   $0xf3
+  jmp alltraps
+80107809:	e9 8e ef ff ff       	jmp    8010679c <alltraps>
+
+8010780e <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+8010780e:	6a 00                	push   $0x0
+  pushl $244
+80107810:	68 f4 00 00 00       	push   $0xf4
+  jmp alltraps
+80107815:	e9 82 ef ff ff       	jmp    8010679c <alltraps>
+
+8010781a <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+8010781a:	6a 00                	push   $0x0
+  pushl $245
+8010781c:	68 f5 00 00 00       	push   $0xf5
+  jmp alltraps
+80107821:	e9 76 ef ff ff       	jmp    8010679c <alltraps>
+
+80107826 <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+80107826:	6a 00                	push   $0x0
+  pushl $246
+80107828:	68 f6 00 00 00       	push   $0xf6
+  jmp alltraps
+8010782d:	e9 6a ef ff ff       	jmp    8010679c <alltraps>
+
+80107832 <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+80107832:	6a 00                	push   $0x0
+  pushl $247
+80107834:	68 f7 00 00 00       	push   $0xf7
+  jmp alltraps
+80107839:	e9 5e ef ff ff       	jmp    8010679c <alltraps>
+
+8010783e <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+8010783e:	6a 00                	push   $0x0
+  pushl $248
+80107840:	68 f8 00 00 00       	push   $0xf8
+  jmp alltraps
+80107845:	e9 52 ef ff ff       	jmp    8010679c <alltraps>
+
+8010784a <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+8010784a:	6a 00                	push   $0x0
+  pushl $249
+8010784c:	68 f9 00 00 00       	push   $0xf9
+  jmp alltraps
+80107851:	e9 46 ef ff ff       	jmp    8010679c <alltraps>
+
+80107856 <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+80107856:	6a 00                	push   $0x0
+  pushl $250
+80107858:	68 fa 00 00 00       	push   $0xfa
+  jmp alltraps
+8010785d:	e9 3a ef ff ff       	jmp    8010679c <alltraps>
+
+80107862 <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+80107862:	6a 00                	push   $0x0
+  pushl $251
+80107864:	68 fb 00 00 00       	push   $0xfb
+  jmp alltraps
+80107869:	e9 2e ef ff ff       	jmp    8010679c <alltraps>
+
+8010786e <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+8010786e:	6a 00                	push   $0x0
+  pushl $252
+80107870:	68 fc 00 00 00       	push   $0xfc
+  jmp alltraps
+80107875:	e9 22 ef ff ff       	jmp    8010679c <alltraps>
+
+8010787a <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+8010787a:	6a 00                	push   $0x0
+  pushl $253
+8010787c:	68 fd 00 00 00       	push   $0xfd
+  jmp alltraps
+80107881:	e9 16 ef ff ff       	jmp    8010679c <alltraps>
+
+80107886 <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+80107886:	6a 00                	push   $0x0
+  pushl $254
+80107888:	68 fe 00 00 00       	push   $0xfe
+  jmp alltraps
+8010788d:	e9 0a ef ff ff       	jmp    8010679c <alltraps>
+
+80107892 <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+80107892:	6a 00                	push   $0x0
+  pushl $255
+80107894:	68 ff 00 00 00       	push   $0xff
+  jmp alltraps
+80107899:	e9 fe ee ff ff       	jmp    8010679c <alltraps>
+	...
+
+801078a0 <lgdt>:
+
+struct segdesc;
+
+static inline void
+lgdt(struct segdesc *p, int size)
+{
+801078a0:	55                   	push   %ebp
+801078a1:	89 e5                	mov    %esp,%ebp
+801078a3:	83 ec 10             	sub    $0x10,%esp
+  volatile ushort pd[3];
+
+  pd[0] = size-1;
+801078a6:	8b 45 0c             	mov    0xc(%ebp),%eax
+801078a9:	83 e8 01             	sub    $0x1,%eax
+801078ac:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+  pd[1] = (uint)p;
+801078b0:	8b 45 08             	mov    0x8(%ebp),%eax
+801078b3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  pd[2] = (uint)p >> 16;
+801078b7:	8b 45 08             	mov    0x8(%ebp),%eax
+801078ba:	c1 e8 10             	shr    $0x10,%eax
+801078bd:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+
+  asm volatile("lgdt (%0)" : : "r" (pd));
+801078c1:	8d 45 fa             	lea    -0x6(%ebp),%eax
+801078c4:	0f 01 10             	lgdtl  (%eax)
+}
+801078c7:	c9                   	leave  
+801078c8:	c3                   	ret    
+
+801078c9 <ltr>:
+  asm volatile("lidt (%0)" : : "r" (pd));
+}
+
+static inline void
+ltr(ushort sel)
+{
+801078c9:	55                   	push   %ebp
+801078ca:	89 e5                	mov    %esp,%ebp
+801078cc:	83 ec 04             	sub    $0x4,%esp
+801078cf:	8b 45 08             	mov    0x8(%ebp),%eax
+801078d2:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  asm volatile("ltr %0" : : "r" (sel));
+801078d6:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+801078da:	0f 00 d8             	ltr    %ax
+}
+801078dd:	c9                   	leave  
+801078de:	c3                   	ret    
+
+801078df <loadgs>:
+  return eflags;
+}
+
+static inline void
+loadgs(ushort v)
+{
+801078df:	55                   	push   %ebp
+801078e0:	89 e5                	mov    %esp,%ebp
+801078e2:	83 ec 04             	sub    $0x4,%esp
+801078e5:	8b 45 08             	mov    0x8(%ebp),%eax
+801078e8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  asm volatile("movw %0, %%gs" : : "r" (v));
+801078ec:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+801078f0:	8e e8                	mov    %eax,%gs
+}
+801078f2:	c9                   	leave  
+801078f3:	c3                   	ret    
+
+801078f4 <lcr3>:
+  return val;
+}
+
+static inline void
+lcr3(uint val) 
+{
+801078f4:	55                   	push   %ebp
+801078f5:	89 e5                	mov    %esp,%ebp
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+801078f7:	8b 45 08             	mov    0x8(%ebp),%eax
+801078fa:	0f 22 d8             	mov    %eax,%cr3
+}
+801078fd:	5d                   	pop    %ebp
+801078fe:	c3                   	ret    
+
+801078ff <v2p>:
+#define KERNBASE 0x80000000         // First kernel virtual address
+#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+
+#ifndef __ASSEMBLER__
+
+static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
+801078ff:	55                   	push   %ebp
+80107900:	89 e5                	mov    %esp,%ebp
+80107902:	8b 45 08             	mov    0x8(%ebp),%eax
+80107905:	05 00 00 00 80       	add    $0x80000000,%eax
+8010790a:	5d                   	pop    %ebp
+8010790b:	c3                   	ret    
+
+8010790c <p2v>:
+static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
+8010790c:	55                   	push   %ebp
+8010790d:	89 e5                	mov    %esp,%ebp
+8010790f:	8b 45 08             	mov    0x8(%ebp),%eax
+80107912:	05 00 00 00 80       	add    $0x80000000,%eax
+80107917:	5d                   	pop    %ebp
+80107918:	c3                   	ret    
+
+80107919 <seginit>:
+
+// Set up CPU's kernel segment descriptors.
+// Run once on entry on each CPU.
+void
+seginit(void)
+{
+80107919:	55                   	push   %ebp
+8010791a:	89 e5                	mov    %esp,%ebp
+8010791c:	53                   	push   %ebx
+8010791d:	83 ec 24             	sub    $0x24,%esp
+
+  // Map "logical" addresses to virtual addresses using identity map.
+  // Cannot share a CODE descriptor for both kernel and user
+  // because it would have to have DPL_USR, but the CPU forbids
+  // an interrupt from CPL=0 to DPL=3.
+  c = &cpus[cpunum()];
+80107920:	e8 e2 b5 ff ff       	call   80102f07 <cpunum>
+80107925:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
+8010792b:	05 80 23 11 80       	add    $0x80112380,%eax
+80107930:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+80107933:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107936:	66 c7 40 78 ff ff    	movw   $0xffff,0x78(%eax)
+8010793c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010793f:	66 c7 40 7a 00 00    	movw   $0x0,0x7a(%eax)
+80107945:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107948:	c6 40 7c 00          	movb   $0x0,0x7c(%eax)
+8010794c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010794f:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+80107953:	83 e2 f0             	and    $0xfffffff0,%edx
+80107956:	83 ca 0a             	or     $0xa,%edx
+80107959:	88 50 7d             	mov    %dl,0x7d(%eax)
+8010795c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010795f:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+80107963:	83 ca 10             	or     $0x10,%edx
+80107966:	88 50 7d             	mov    %dl,0x7d(%eax)
+80107969:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010796c:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+80107970:	83 e2 9f             	and    $0xffffff9f,%edx
+80107973:	88 50 7d             	mov    %dl,0x7d(%eax)
+80107976:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107979:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+8010797d:	83 ca 80             	or     $0xffffff80,%edx
+80107980:	88 50 7d             	mov    %dl,0x7d(%eax)
+80107983:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107986:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+8010798a:	83 ca 0f             	or     $0xf,%edx
+8010798d:	88 50 7e             	mov    %dl,0x7e(%eax)
+80107990:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107993:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+80107997:	83 e2 ef             	and    $0xffffffef,%edx
+8010799a:	88 50 7e             	mov    %dl,0x7e(%eax)
+8010799d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079a0:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+801079a4:	83 e2 df             	and    $0xffffffdf,%edx
+801079a7:	88 50 7e             	mov    %dl,0x7e(%eax)
+801079aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079ad:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+801079b1:	83 ca 40             	or     $0x40,%edx
+801079b4:	88 50 7e             	mov    %dl,0x7e(%eax)
+801079b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079ba:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+801079be:	83 ca 80             	or     $0xffffff80,%edx
+801079c1:	88 50 7e             	mov    %dl,0x7e(%eax)
+801079c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079c7:	c6 40 7f 00          	movb   $0x0,0x7f(%eax)
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+801079cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079ce:	66 c7 80 80 00 00 00 	movw   $0xffff,0x80(%eax)
+801079d5:	ff ff 
+801079d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079da:	66 c7 80 82 00 00 00 	movw   $0x0,0x82(%eax)
+801079e1:	00 00 
+801079e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079e6:	c6 80 84 00 00 00 00 	movb   $0x0,0x84(%eax)
+801079ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801079f0:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+801079f7:	83 e2 f0             	and    $0xfffffff0,%edx
+801079fa:	83 ca 02             	or     $0x2,%edx
+801079fd:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+80107a03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a06:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+80107a0d:	83 ca 10             	or     $0x10,%edx
+80107a10:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+80107a16:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a19:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+80107a20:	83 e2 9f             	and    $0xffffff9f,%edx
+80107a23:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+80107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a2c:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+80107a33:	83 ca 80             	or     $0xffffff80,%edx
+80107a36:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+80107a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a3f:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80107a46:	83 ca 0f             	or     $0xf,%edx
+80107a49:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80107a4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a52:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80107a59:	83 e2 ef             	and    $0xffffffef,%edx
+80107a5c:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80107a62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a65:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80107a6c:	83 e2 df             	and    $0xffffffdf,%edx
+80107a6f:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80107a75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a78:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80107a7f:	83 ca 40             	or     $0x40,%edx
+80107a82:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80107a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a8b:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80107a92:	83 ca 80             	or     $0xffffff80,%edx
+80107a95:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80107a9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107a9e:	c6 80 87 00 00 00 00 	movb   $0x0,0x87(%eax)
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+80107aa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107aa8:	66 c7 80 90 00 00 00 	movw   $0xffff,0x90(%eax)
+80107aaf:	ff ff 
+80107ab1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107ab4:	66 c7 80 92 00 00 00 	movw   $0x0,0x92(%eax)
+80107abb:	00 00 
+80107abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107ac0:	c6 80 94 00 00 00 00 	movb   $0x0,0x94(%eax)
+80107ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107aca:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+80107ad1:	83 e2 f0             	and    $0xfffffff0,%edx
+80107ad4:	83 ca 0a             	or     $0xa,%edx
+80107ad7:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+80107add:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107ae0:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+80107ae7:	83 ca 10             	or     $0x10,%edx
+80107aea:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+80107af0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107af3:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+80107afa:	83 ca 60             	or     $0x60,%edx
+80107afd:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+80107b03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b06:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+80107b0d:	83 ca 80             	or     $0xffffff80,%edx
+80107b10:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+80107b16:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b19:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+80107b20:	83 ca 0f             	or     $0xf,%edx
+80107b23:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80107b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b2c:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+80107b33:	83 e2 ef             	and    $0xffffffef,%edx
+80107b36:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80107b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b3f:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+80107b46:	83 e2 df             	and    $0xffffffdf,%edx
+80107b49:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80107b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b52:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+80107b59:	83 ca 40             	or     $0x40,%edx
+80107b5c:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80107b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b65:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+80107b6c:	83 ca 80             	or     $0xffffff80,%edx
+80107b6f:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80107b75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b78:	c6 80 97 00 00 00 00 	movb   $0x0,0x97(%eax)
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+80107b7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b82:	66 c7 80 98 00 00 00 	movw   $0xffff,0x98(%eax)
+80107b89:	ff ff 
+80107b8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b8e:	66 c7 80 9a 00 00 00 	movw   $0x0,0x9a(%eax)
+80107b95:	00 00 
+80107b97:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107b9a:	c6 80 9c 00 00 00 00 	movb   $0x0,0x9c(%eax)
+80107ba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107ba4:	0f b6 90 9d 00 00 00 	movzbl 0x9d(%eax),%edx
+80107bab:	83 e2 f0             	and    $0xfffffff0,%edx
+80107bae:	83 ca 02             	or     $0x2,%edx
+80107bb1:	88 90 9d 00 00 00    	mov    %dl,0x9d(%eax)
+80107bb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107bba:	0f b6 90 9d 00 00 00 	movzbl 0x9d(%eax),%edx
+80107bc1:	83 ca 10             	or     $0x10,%edx
+80107bc4:	88 90 9d 00 00 00    	mov    %dl,0x9d(%eax)
+80107bca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107bcd:	0f b6 90 9d 00 00 00 	movzbl 0x9d(%eax),%edx
+80107bd4:	83 ca 60             	or     $0x60,%edx
+80107bd7:	88 90 9d 00 00 00    	mov    %dl,0x9d(%eax)
+80107bdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107be0:	0f b6 90 9d 00 00 00 	movzbl 0x9d(%eax),%edx
+80107be7:	83 ca 80             	or     $0xffffff80,%edx
+80107bea:	88 90 9d 00 00 00    	mov    %dl,0x9d(%eax)
+80107bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107bf3:	0f b6 90 9e 00 00 00 	movzbl 0x9e(%eax),%edx
+80107bfa:	83 ca 0f             	or     $0xf,%edx
+80107bfd:	88 90 9e 00 00 00    	mov    %dl,0x9e(%eax)
+80107c03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c06:	0f b6 90 9e 00 00 00 	movzbl 0x9e(%eax),%edx
+80107c0d:	83 e2 ef             	and    $0xffffffef,%edx
+80107c10:	88 90 9e 00 00 00    	mov    %dl,0x9e(%eax)
+80107c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c19:	0f b6 90 9e 00 00 00 	movzbl 0x9e(%eax),%edx
+80107c20:	83 e2 df             	and    $0xffffffdf,%edx
+80107c23:	88 90 9e 00 00 00    	mov    %dl,0x9e(%eax)
+80107c29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c2c:	0f b6 90 9e 00 00 00 	movzbl 0x9e(%eax),%edx
+80107c33:	83 ca 40             	or     $0x40,%edx
+80107c36:	88 90 9e 00 00 00    	mov    %dl,0x9e(%eax)
+80107c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c3f:	0f b6 90 9e 00 00 00 	movzbl 0x9e(%eax),%edx
+80107c46:	83 ca 80             	or     $0xffffff80,%edx
+80107c49:	88 90 9e 00 00 00    	mov    %dl,0x9e(%eax)
+80107c4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c52:	c6 80 9f 00 00 00 00 	movb   $0x0,0x9f(%eax)
+
+  // Map cpu, and curproc
+  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+80107c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c5c:	05 b4 00 00 00       	add    $0xb4,%eax
+80107c61:	89 c3                	mov    %eax,%ebx
+80107c63:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c66:	05 b4 00 00 00       	add    $0xb4,%eax
+80107c6b:	c1 e8 10             	shr    $0x10,%eax
+80107c6e:	89 c1                	mov    %eax,%ecx
+80107c70:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c73:	05 b4 00 00 00       	add    $0xb4,%eax
+80107c78:	c1 e8 18             	shr    $0x18,%eax
+80107c7b:	89 c2                	mov    %eax,%edx
+80107c7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c80:	66 c7 80 88 00 00 00 	movw   $0x0,0x88(%eax)
+80107c87:	00 00 
+80107c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c8c:	66 89 98 8a 00 00 00 	mov    %bx,0x8a(%eax)
+80107c93:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c96:	88 88 8c 00 00 00    	mov    %cl,0x8c(%eax)
+80107c9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107c9f:	0f b6 88 8d 00 00 00 	movzbl 0x8d(%eax),%ecx
+80107ca6:	83 e1 f0             	and    $0xfffffff0,%ecx
+80107ca9:	83 c9 02             	or     $0x2,%ecx
+80107cac:	88 88 8d 00 00 00    	mov    %cl,0x8d(%eax)
+80107cb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107cb5:	0f b6 88 8d 00 00 00 	movzbl 0x8d(%eax),%ecx
+80107cbc:	83 c9 10             	or     $0x10,%ecx
+80107cbf:	88 88 8d 00 00 00    	mov    %cl,0x8d(%eax)
+80107cc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107cc8:	0f b6 88 8d 00 00 00 	movzbl 0x8d(%eax),%ecx
+80107ccf:	83 e1 9f             	and    $0xffffff9f,%ecx
+80107cd2:	88 88 8d 00 00 00    	mov    %cl,0x8d(%eax)
+80107cd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107cdb:	0f b6 88 8d 00 00 00 	movzbl 0x8d(%eax),%ecx
+80107ce2:	83 c9 80             	or     $0xffffff80,%ecx
+80107ce5:	88 88 8d 00 00 00    	mov    %cl,0x8d(%eax)
+80107ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107cee:	0f b6 88 8e 00 00 00 	movzbl 0x8e(%eax),%ecx
+80107cf5:	83 e1 f0             	and    $0xfffffff0,%ecx
+80107cf8:	88 88 8e 00 00 00    	mov    %cl,0x8e(%eax)
+80107cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d01:	0f b6 88 8e 00 00 00 	movzbl 0x8e(%eax),%ecx
+80107d08:	83 e1 ef             	and    $0xffffffef,%ecx
+80107d0b:	88 88 8e 00 00 00    	mov    %cl,0x8e(%eax)
+80107d11:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d14:	0f b6 88 8e 00 00 00 	movzbl 0x8e(%eax),%ecx
+80107d1b:	83 e1 df             	and    $0xffffffdf,%ecx
+80107d1e:	88 88 8e 00 00 00    	mov    %cl,0x8e(%eax)
+80107d24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d27:	0f b6 88 8e 00 00 00 	movzbl 0x8e(%eax),%ecx
+80107d2e:	83 c9 40             	or     $0x40,%ecx
+80107d31:	88 88 8e 00 00 00    	mov    %cl,0x8e(%eax)
+80107d37:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d3a:	0f b6 88 8e 00 00 00 	movzbl 0x8e(%eax),%ecx
+80107d41:	83 c9 80             	or     $0xffffff80,%ecx
+80107d44:	88 88 8e 00 00 00    	mov    %cl,0x8e(%eax)
+80107d4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d4d:	88 90 8f 00 00 00    	mov    %dl,0x8f(%eax)
+
+  lgdt(c->gdt, sizeof(c->gdt));
+80107d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d56:	83 c0 70             	add    $0x70,%eax
+80107d59:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
+80107d60:	00 
+80107d61:	89 04 24             	mov    %eax,(%esp)
+80107d64:	e8 37 fb ff ff       	call   801078a0 <lgdt>
+  loadgs(SEG_KCPU << 3);
+80107d69:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
+80107d70:	e8 6a fb ff ff       	call   801078df <loadgs>
+  
+  // Initialize cpu-local storage.
+  cpu = c;
+80107d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107d78:	65 a3 00 00 00 00    	mov    %eax,%gs:0x0
+  proc = 0;
+80107d7e:	65 c7 05 04 00 00 00 	movl   $0x0,%gs:0x4
+80107d85:	00 00 00 00 
+}
+80107d89:	83 c4 24             	add    $0x24,%esp
+80107d8c:	5b                   	pop    %ebx
+80107d8d:	5d                   	pop    %ebp
+80107d8e:	c3                   	ret    
+
+80107d8f <walkpgdir>:
+// Return the address of the PTE in page table pgdir
+// that corresponds to virtual address va.  If alloc!=0,
+// create any required page table pages.
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+80107d8f:	55                   	push   %ebp
+80107d90:	89 e5                	mov    %esp,%ebp
+80107d92:	83 ec 28             	sub    $0x28,%esp
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+80107d95:	8b 45 0c             	mov    0xc(%ebp),%eax
+80107d98:	c1 e8 16             	shr    $0x16,%eax
+80107d9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80107da2:	8b 45 08             	mov    0x8(%ebp),%eax
+80107da5:	01 d0                	add    %edx,%eax
+80107da7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(*pde & PTE_P){
+80107daa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80107dad:	8b 00                	mov    (%eax),%eax
+80107daf:	83 e0 01             	and    $0x1,%eax
+80107db2:	85 c0                	test   %eax,%eax
+80107db4:	74 17                	je     80107dcd <walkpgdir+0x3e>
+    pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
+80107db6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80107db9:	8b 00                	mov    (%eax),%eax
+80107dbb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80107dc0:	89 04 24             	mov    %eax,(%esp)
+80107dc3:	e8 44 fb ff ff       	call   8010790c <p2v>
+80107dc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80107dcb:	eb 4b                	jmp    80107e18 <walkpgdir+0x89>
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+80107dcd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80107dd1:	74 0e                	je     80107de1 <walkpgdir+0x52>
+80107dd3:	e8 73 ad ff ff       	call   80102b4b <kalloc>
+80107dd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80107ddb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80107ddf:	75 07                	jne    80107de8 <walkpgdir+0x59>
+      return 0;
+80107de1:	b8 00 00 00 00       	mov    $0x0,%eax
+80107de6:	eb 47                	jmp    80107e2f <walkpgdir+0xa0>
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+80107de8:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80107def:	00 
+80107df0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80107df7:	00 
+80107df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107dfb:	89 04 24             	mov    %eax,(%esp)
+80107dfe:	e8 4b d4 ff ff       	call   8010524e <memset>
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table 
+    // entries, if necessary.
+    *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
+80107e03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107e06:	89 04 24             	mov    %eax,(%esp)
+80107e09:	e8 f1 fa ff ff       	call   801078ff <v2p>
+80107e0e:	89 c2                	mov    %eax,%edx
+80107e10:	83 ca 07             	or     $0x7,%edx
+80107e13:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80107e16:	89 10                	mov    %edx,(%eax)
+  }
+  return &pgtab[PTX(va)];
+80107e18:	8b 45 0c             	mov    0xc(%ebp),%eax
+80107e1b:	c1 e8 0c             	shr    $0xc,%eax
+80107e1e:	25 ff 03 00 00       	and    $0x3ff,%eax
+80107e23:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80107e2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107e2d:	01 d0                	add    %edx,%eax
+}
+80107e2f:	c9                   	leave  
+80107e30:	c3                   	ret    
+
+80107e31 <mappages>:
+// Create PTEs for virtual addresses starting at va that refer to
+// physical addresses starting at pa. va and size might not
+// be page-aligned.
+static int
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+{
+80107e31:	55                   	push   %ebp
+80107e32:	89 e5                	mov    %esp,%ebp
+80107e34:	83 ec 28             	sub    $0x28,%esp
+  char *a, *last;
+  pte_t *pte;
+  
+  a = (char*)PGROUNDDOWN((uint)va);
+80107e37:	8b 45 0c             	mov    0xc(%ebp),%eax
+80107e3a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80107e3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+80107e42:	8b 55 0c             	mov    0xc(%ebp),%edx
+80107e45:	8b 45 10             	mov    0x10(%ebp),%eax
+80107e48:	01 d0                	add    %edx,%eax
+80107e4a:	83 e8 01             	sub    $0x1,%eax
+80107e4d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80107e52:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(;;){
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+80107e55:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+80107e5c:	00 
+80107e5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107e60:	89 44 24 04          	mov    %eax,0x4(%esp)
+80107e64:	8b 45 08             	mov    0x8(%ebp),%eax
+80107e67:	89 04 24             	mov    %eax,(%esp)
+80107e6a:	e8 20 ff ff ff       	call   80107d8f <walkpgdir>
+80107e6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80107e72:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80107e76:	75 07                	jne    80107e7f <mappages+0x4e>
+      return -1;
+80107e78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80107e7d:	eb 46                	jmp    80107ec5 <mappages+0x94>
+    if(*pte & PTE_P)
+80107e7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80107e82:	8b 00                	mov    (%eax),%eax
+80107e84:	83 e0 01             	and    $0x1,%eax
+80107e87:	85 c0                	test   %eax,%eax
+80107e89:	74 0c                	je     80107e97 <mappages+0x66>
+      panic("remap");
+80107e8b:	c7 04 24 30 8d 10 80 	movl   $0x80108d30,(%esp)
+80107e92:	e8 af 86 ff ff       	call   80100546 <panic>
+    *pte = pa | perm | PTE_P;
+80107e97:	8b 45 18             	mov    0x18(%ebp),%eax
+80107e9a:	0b 45 14             	or     0x14(%ebp),%eax
+80107e9d:	89 c2                	mov    %eax,%edx
+80107e9f:	83 ca 01             	or     $0x1,%edx
+80107ea2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80107ea5:	89 10                	mov    %edx,(%eax)
+    if(a == last)
+80107ea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107eaa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+80107ead:	74 10                	je     80107ebf <mappages+0x8e>
+      break;
+    a += PGSIZE;
+80107eaf:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+    pa += PGSIZE;
+80107eb6:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
+  }
+80107ebd:	eb 96                	jmp    80107e55 <mappages+0x24>
+      return -1;
+    if(*pte & PTE_P)
+      panic("remap");
+    *pte = pa | perm | PTE_P;
+    if(a == last)
+      break;
+80107ebf:	90                   	nop
+    a += PGSIZE;
+    pa += PGSIZE;
+  }
+  return 0;
+80107ec0:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80107ec5:	c9                   	leave  
+80107ec6:	c3                   	ret    
+
+80107ec7 <setupkvm>:
+};
+
+// Set up kernel part of a page table.
+pde_t*
+setupkvm(void)
+{
+80107ec7:	55                   	push   %ebp
+80107ec8:	89 e5                	mov    %esp,%ebp
+80107eca:	53                   	push   %ebx
+80107ecb:	83 ec 34             	sub    $0x34,%esp
+  pde_t *pgdir;
+  struct kmap *k;
+
+  if((pgdir = (pde_t*)kalloc()) == 0)
+80107ece:	e8 78 ac ff ff       	call   80102b4b <kalloc>
+80107ed3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80107ed6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80107eda:	75 0a                	jne    80107ee6 <setupkvm+0x1f>
+    return 0;
+80107edc:	b8 00 00 00 00       	mov    $0x0,%eax
+80107ee1:	e9 98 00 00 00       	jmp    80107f7e <setupkvm+0xb7>
+  memset(pgdir, 0, PGSIZE);
+80107ee6:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80107eed:	00 
+80107eee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80107ef5:	00 
+80107ef6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80107ef9:	89 04 24             	mov    %eax,(%esp)
+80107efc:	e8 4d d3 ff ff       	call   8010524e <memset>
+  if (p2v(PHYSTOP) > (void*)DEVSPACE)
+80107f01:	c7 04 24 00 00 00 0e 	movl   $0xe000000,(%esp)
+80107f08:	e8 ff f9 ff ff       	call   8010790c <p2v>
+80107f0d:	3d 00 00 00 fe       	cmp    $0xfe000000,%eax
+80107f12:	76 0c                	jbe    80107f20 <setupkvm+0x59>
+    panic("PHYSTOP too high");
+80107f14:	c7 04 24 36 8d 10 80 	movl   $0x80108d36,(%esp)
+80107f1b:	e8 26 86 ff ff       	call   80100546 <panic>
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+80107f20:	c7 45 f4 c0 b4 10 80 	movl   $0x8010b4c0,-0xc(%ebp)
+80107f27:	eb 49                	jmp    80107f72 <setupkvm+0xab>
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
+                (uint)k->phys_start, k->perm) < 0)
+80107f29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    return 0;
+  memset(pgdir, 0, PGSIZE);
+  if (p2v(PHYSTOP) > (void*)DEVSPACE)
+    panic("PHYSTOP too high");
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
+80107f2c:	8b 48 0c             	mov    0xc(%eax),%ecx
+                (uint)k->phys_start, k->perm) < 0)
+80107f2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    return 0;
+  memset(pgdir, 0, PGSIZE);
+  if (p2v(PHYSTOP) > (void*)DEVSPACE)
+    panic("PHYSTOP too high");
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
+80107f32:	8b 50 04             	mov    0x4(%eax),%edx
+80107f35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107f38:	8b 58 08             	mov    0x8(%eax),%ebx
+80107f3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107f3e:	8b 40 04             	mov    0x4(%eax),%eax
+80107f41:	29 c3                	sub    %eax,%ebx
+80107f43:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107f46:	8b 00                	mov    (%eax),%eax
+80107f48:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+80107f4c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80107f50:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80107f54:	89 44 24 04          	mov    %eax,0x4(%esp)
+80107f58:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80107f5b:	89 04 24             	mov    %eax,(%esp)
+80107f5e:	e8 ce fe ff ff       	call   80107e31 <mappages>
+80107f63:	85 c0                	test   %eax,%eax
+80107f65:	79 07                	jns    80107f6e <setupkvm+0xa7>
+                (uint)k->phys_start, k->perm) < 0)
+      return 0;
+80107f67:	b8 00 00 00 00       	mov    $0x0,%eax
+80107f6c:	eb 10                	jmp    80107f7e <setupkvm+0xb7>
+  if((pgdir = (pde_t*)kalloc()) == 0)
+    return 0;
+  memset(pgdir, 0, PGSIZE);
+  if (p2v(PHYSTOP) > (void*)DEVSPACE)
+    panic("PHYSTOP too high");
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+80107f6e:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
+80107f72:	81 7d f4 00 b5 10 80 	cmpl   $0x8010b500,-0xc(%ebp)
+80107f79:	72 ae                	jb     80107f29 <setupkvm+0x62>
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
+                (uint)k->phys_start, k->perm) < 0)
+      return 0;
+  return pgdir;
+80107f7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+80107f7e:	83 c4 34             	add    $0x34,%esp
+80107f81:	5b                   	pop    %ebx
+80107f82:	5d                   	pop    %ebp
+80107f83:	c3                   	ret    
+
+80107f84 <kvmalloc>:
+
+// Allocate one page table for the machine for the kernel address
+// space for scheduler processes.
+void
+kvmalloc(void)
+{
+80107f84:	55                   	push   %ebp
+80107f85:	89 e5                	mov    %esp,%ebp
+80107f87:	83 ec 08             	sub    $0x8,%esp
+  kpgdir = setupkvm();
+80107f8a:	e8 38 ff ff ff       	call   80107ec7 <setupkvm>
+80107f8f:	a3 78 52 11 80       	mov    %eax,0x80115278
+  switchkvm();
+80107f94:	e8 02 00 00 00       	call   80107f9b <switchkvm>
+}
+80107f99:	c9                   	leave  
+80107f9a:	c3                   	ret    
+
+80107f9b <switchkvm>:
+
+// Switch h/w page table register to the kernel-only page table,
+// for when no process is running.
+void
+switchkvm(void)
+{
+80107f9b:	55                   	push   %ebp
+80107f9c:	89 e5                	mov    %esp,%ebp
+80107f9e:	83 ec 04             	sub    $0x4,%esp
+  lcr3(v2p(kpgdir));   // switch to the kernel page table
+80107fa1:	a1 78 52 11 80       	mov    0x80115278,%eax
+80107fa6:	89 04 24             	mov    %eax,(%esp)
+80107fa9:	e8 51 f9 ff ff       	call   801078ff <v2p>
+80107fae:	89 04 24             	mov    %eax,(%esp)
+80107fb1:	e8 3e f9 ff ff       	call   801078f4 <lcr3>
+}
+80107fb6:	c9                   	leave  
+80107fb7:	c3                   	ret    
+
+80107fb8 <switchuvm>:
+
+// Switch TSS and h/w page table to correspond to process p.
+void
+switchuvm(struct proc *p)
+{
+80107fb8:	55                   	push   %ebp
+80107fb9:	89 e5                	mov    %esp,%ebp
+80107fbb:	53                   	push   %ebx
+80107fbc:	83 ec 14             	sub    $0x14,%esp
+  pushcli();
+80107fbf:	e8 83 d1 ff ff       	call   80105147 <pushcli>
+  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
+80107fc4:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+80107fca:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+80107fd1:	83 c2 08             	add    $0x8,%edx
+80107fd4:	89 d3                	mov    %edx,%ebx
+80107fd6:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+80107fdd:	83 c2 08             	add    $0x8,%edx
+80107fe0:	c1 ea 10             	shr    $0x10,%edx
+80107fe3:	89 d1                	mov    %edx,%ecx
+80107fe5:	65 8b 15 00 00 00 00 	mov    %gs:0x0,%edx
+80107fec:	83 c2 08             	add    $0x8,%edx
+80107fef:	c1 ea 18             	shr    $0x18,%edx
+80107ff2:	66 c7 80 a0 00 00 00 	movw   $0x67,0xa0(%eax)
+80107ff9:	67 00 
+80107ffb:	66 89 98 a2 00 00 00 	mov    %bx,0xa2(%eax)
+80108002:	88 88 a4 00 00 00    	mov    %cl,0xa4(%eax)
+80108008:	0f b6 88 a5 00 00 00 	movzbl 0xa5(%eax),%ecx
+8010800f:	83 e1 f0             	and    $0xfffffff0,%ecx
+80108012:	83 c9 09             	or     $0x9,%ecx
+80108015:	88 88 a5 00 00 00    	mov    %cl,0xa5(%eax)
+8010801b:	0f b6 88 a5 00 00 00 	movzbl 0xa5(%eax),%ecx
+80108022:	83 c9 10             	or     $0x10,%ecx
+80108025:	88 88 a5 00 00 00    	mov    %cl,0xa5(%eax)
+8010802b:	0f b6 88 a5 00 00 00 	movzbl 0xa5(%eax),%ecx
+80108032:	83 e1 9f             	and    $0xffffff9f,%ecx
+80108035:	88 88 a5 00 00 00    	mov    %cl,0xa5(%eax)
+8010803b:	0f b6 88 a5 00 00 00 	movzbl 0xa5(%eax),%ecx
+80108042:	83 c9 80             	or     $0xffffff80,%ecx
+80108045:	88 88 a5 00 00 00    	mov    %cl,0xa5(%eax)
+8010804b:	0f b6 88 a6 00 00 00 	movzbl 0xa6(%eax),%ecx
+80108052:	83 e1 f0             	and    $0xfffffff0,%ecx
+80108055:	88 88 a6 00 00 00    	mov    %cl,0xa6(%eax)
+8010805b:	0f b6 88 a6 00 00 00 	movzbl 0xa6(%eax),%ecx
+80108062:	83 e1 ef             	and    $0xffffffef,%ecx
+80108065:	88 88 a6 00 00 00    	mov    %cl,0xa6(%eax)
+8010806b:	0f b6 88 a6 00 00 00 	movzbl 0xa6(%eax),%ecx
+80108072:	83 e1 df             	and    $0xffffffdf,%ecx
+80108075:	88 88 a6 00 00 00    	mov    %cl,0xa6(%eax)
+8010807b:	0f b6 88 a6 00 00 00 	movzbl 0xa6(%eax),%ecx
+80108082:	83 c9 40             	or     $0x40,%ecx
+80108085:	88 88 a6 00 00 00    	mov    %cl,0xa6(%eax)
+8010808b:	0f b6 88 a6 00 00 00 	movzbl 0xa6(%eax),%ecx
+80108092:	83 e1 7f             	and    $0x7f,%ecx
+80108095:	88 88 a6 00 00 00    	mov    %cl,0xa6(%eax)
+8010809b:	88 90 a7 00 00 00    	mov    %dl,0xa7(%eax)
+  cpu->gdt[SEG_TSS].s = 0;
+801080a1:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801080a7:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%eax),%edx
+801080ae:	83 e2 ef             	and    $0xffffffef,%edx
+801080b1:	88 90 a5 00 00 00    	mov    %dl,0xa5(%eax)
+  cpu->ts.ss0 = SEG_KDATA << 3;
+801080b7:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801080bd:	66 c7 40 10 10 00    	movw   $0x10,0x10(%eax)
+  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
+801080c3:	65 a1 00 00 00 00    	mov    %gs:0x0,%eax
+801080c9:	65 8b 15 04 00 00 00 	mov    %gs:0x4,%edx
+801080d0:	8b 52 08             	mov    0x8(%edx),%edx
+801080d3:	81 c2 00 10 00 00    	add    $0x1000,%edx
+801080d9:	89 50 0c             	mov    %edx,0xc(%eax)
+  ltr(SEG_TSS << 3);
+801080dc:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+801080e3:	e8 e1 f7 ff ff       	call   801078c9 <ltr>
+  if(p->pgdir == 0)
+801080e8:	8b 45 08             	mov    0x8(%ebp),%eax
+801080eb:	8b 40 04             	mov    0x4(%eax),%eax
+801080ee:	85 c0                	test   %eax,%eax
+801080f0:	75 0c                	jne    801080fe <switchuvm+0x146>
+    panic("switchuvm: no pgdir");
+801080f2:	c7 04 24 47 8d 10 80 	movl   $0x80108d47,(%esp)
+801080f9:	e8 48 84 ff ff       	call   80100546 <panic>
+  lcr3(v2p(p->pgdir));  // switch to new address space
+801080fe:	8b 45 08             	mov    0x8(%ebp),%eax
+80108101:	8b 40 04             	mov    0x4(%eax),%eax
+80108104:	89 04 24             	mov    %eax,(%esp)
+80108107:	e8 f3 f7 ff ff       	call   801078ff <v2p>
+8010810c:	89 04 24             	mov    %eax,(%esp)
+8010810f:	e8 e0 f7 ff ff       	call   801078f4 <lcr3>
+  popcli();
+80108114:	e8 76 d0 ff ff       	call   8010518f <popcli>
+}
+80108119:	83 c4 14             	add    $0x14,%esp
+8010811c:	5b                   	pop    %ebx
+8010811d:	5d                   	pop    %ebp
+8010811e:	c3                   	ret    
+
+8010811f <inituvm>:
+
+// Load the initcode into address 0 of pgdir.
+// sz must be less than a page.
+void
+inituvm(pde_t *pgdir, char *init, uint sz)
+{
+8010811f:	55                   	push   %ebp
+80108120:	89 e5                	mov    %esp,%ebp
+80108122:	83 ec 38             	sub    $0x38,%esp
+  char *mem;
+  
+  if(sz >= PGSIZE)
+80108125:	81 7d 10 ff 0f 00 00 	cmpl   $0xfff,0x10(%ebp)
+8010812c:	76 0c                	jbe    8010813a <inituvm+0x1b>
+    panic("inituvm: more than a page");
+8010812e:	c7 04 24 5b 8d 10 80 	movl   $0x80108d5b,(%esp)
+80108135:	e8 0c 84 ff ff       	call   80100546 <panic>
+  mem = kalloc();
+8010813a:	e8 0c aa ff ff       	call   80102b4b <kalloc>
+8010813f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(mem, 0, PGSIZE);
+80108142:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80108149:	00 
+8010814a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80108151:	00 
+80108152:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108155:	89 04 24             	mov    %eax,(%esp)
+80108158:	e8 f1 d0 ff ff       	call   8010524e <memset>
+  mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
+8010815d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108160:	89 04 24             	mov    %eax,(%esp)
+80108163:	e8 97 f7 ff ff       	call   801078ff <v2p>
+80108168:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%esp)
+8010816f:	00 
+80108170:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80108174:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+8010817b:	00 
+8010817c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80108183:	00 
+80108184:	8b 45 08             	mov    0x8(%ebp),%eax
+80108187:	89 04 24             	mov    %eax,(%esp)
+8010818a:	e8 a2 fc ff ff       	call   80107e31 <mappages>
+  memmove(mem, init, sz);
+8010818f:	8b 45 10             	mov    0x10(%ebp),%eax
+80108192:	89 44 24 08          	mov    %eax,0x8(%esp)
+80108196:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108199:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010819d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081a0:	89 04 24             	mov    %eax,(%esp)
+801081a3:	e8 79 d1 ff ff       	call   80105321 <memmove>
+}
+801081a8:	c9                   	leave  
+801081a9:	c3                   	ret    
+
+801081aa <loaduvm>:
+
+// Load a program segment into pgdir.  addr must be page-aligned
+// and the pages from addr to addr+sz must already be mapped.
+int
+loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+{
+801081aa:	55                   	push   %ebp
+801081ab:	89 e5                	mov    %esp,%ebp
+801081ad:	53                   	push   %ebx
+801081ae:	83 ec 24             	sub    $0x24,%esp
+  uint i, pa, n;
+  pte_t *pte;
+
+  if((uint) addr % PGSIZE != 0)
+801081b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+801081b4:	25 ff 0f 00 00       	and    $0xfff,%eax
+801081b9:	85 c0                	test   %eax,%eax
+801081bb:	74 0c                	je     801081c9 <loaduvm+0x1f>
+    panic("loaduvm: addr must be page aligned");
+801081bd:	c7 04 24 78 8d 10 80 	movl   $0x80108d78,(%esp)
+801081c4:	e8 7d 83 ff ff       	call   80100546 <panic>
+  for(i = 0; i < sz; i += PGSIZE){
+801081c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801081d0:	e9 ad 00 00 00       	jmp    80108282 <loaduvm+0xd8>
+    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+801081d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081d8:	8b 55 0c             	mov    0xc(%ebp),%edx
+801081db:	01 d0                	add    %edx,%eax
+801081dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801081e4:	00 
+801081e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+801081e9:	8b 45 08             	mov    0x8(%ebp),%eax
+801081ec:	89 04 24             	mov    %eax,(%esp)
+801081ef:	e8 9b fb ff ff       	call   80107d8f <walkpgdir>
+801081f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+801081f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+801081fb:	75 0c                	jne    80108209 <loaduvm+0x5f>
+      panic("loaduvm: address should exist");
+801081fd:	c7 04 24 9b 8d 10 80 	movl   $0x80108d9b,(%esp)
+80108204:	e8 3d 83 ff ff       	call   80100546 <panic>
+    pa = PTE_ADDR(*pte);
+80108209:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010820c:	8b 00                	mov    (%eax),%eax
+8010820e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108213:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(sz - i < PGSIZE)
+80108216:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108219:	8b 55 18             	mov    0x18(%ebp),%edx
+8010821c:	89 d1                	mov    %edx,%ecx
+8010821e:	29 c1                	sub    %eax,%ecx
+80108220:	89 c8                	mov    %ecx,%eax
+80108222:	3d ff 0f 00 00       	cmp    $0xfff,%eax
+80108227:	77 11                	ja     8010823a <loaduvm+0x90>
+      n = sz - i;
+80108229:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010822c:	8b 55 18             	mov    0x18(%ebp),%edx
+8010822f:	89 d1                	mov    %edx,%ecx
+80108231:	29 c1                	sub    %eax,%ecx
+80108233:	89 c8                	mov    %ecx,%eax
+80108235:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80108238:	eb 07                	jmp    80108241 <loaduvm+0x97>
+    else
+      n = PGSIZE;
+8010823a:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+    if(readi(ip, p2v(pa), offset+i, n) != n)
+80108241:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108244:	8b 55 14             	mov    0x14(%ebp),%edx
+80108247:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+8010824a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+8010824d:	89 04 24             	mov    %eax,(%esp)
+80108250:	e8 b7 f6 ff ff       	call   8010790c <p2v>
+80108255:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80108258:	89 54 24 0c          	mov    %edx,0xc(%esp)
+8010825c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80108260:	89 44 24 04          	mov    %eax,0x4(%esp)
+80108264:	8b 45 10             	mov    0x10(%ebp),%eax
+80108267:	89 04 24             	mov    %eax,(%esp)
+8010826a:	e8 45 9b ff ff       	call   80101db4 <readi>
+8010826f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+80108272:	74 07                	je     8010827b <loaduvm+0xd1>
+      return -1;
+80108274:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80108279:	eb 18                	jmp    80108293 <loaduvm+0xe9>
+  uint i, pa, n;
+  pte_t *pte;
+
+  if((uint) addr % PGSIZE != 0)
+    panic("loaduvm: addr must be page aligned");
+  for(i = 0; i < sz; i += PGSIZE){
+8010827b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80108282:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108285:	3b 45 18             	cmp    0x18(%ebp),%eax
+80108288:	0f 82 47 ff ff ff    	jb     801081d5 <loaduvm+0x2b>
+    else
+      n = PGSIZE;
+    if(readi(ip, p2v(pa), offset+i, n) != n)
+      return -1;
+  }
+  return 0;
+8010828e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80108293:	83 c4 24             	add    $0x24,%esp
+80108296:	5b                   	pop    %ebx
+80108297:	5d                   	pop    %ebp
+80108298:	c3                   	ret    
+
+80108299 <allocuvm>:
+
+// Allocate page tables and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+int
+allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+80108299:	55                   	push   %ebp
+8010829a:	89 e5                	mov    %esp,%ebp
+8010829c:	83 ec 38             	sub    $0x38,%esp
+  char *mem;
+  uint a;
+
+  if(newsz >= KERNBASE)
+8010829f:	8b 45 10             	mov    0x10(%ebp),%eax
+801082a2:	85 c0                	test   %eax,%eax
+801082a4:	79 0a                	jns    801082b0 <allocuvm+0x17>
+    return 0;
+801082a6:	b8 00 00 00 00       	mov    $0x0,%eax
+801082ab:	e9 c1 00 00 00       	jmp    80108371 <allocuvm+0xd8>
+  if(newsz < oldsz)
+801082b0:	8b 45 10             	mov    0x10(%ebp),%eax
+801082b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
+801082b6:	73 08                	jae    801082c0 <allocuvm+0x27>
+    return oldsz;
+801082b8:	8b 45 0c             	mov    0xc(%ebp),%eax
+801082bb:	e9 b1 00 00 00       	jmp    80108371 <allocuvm+0xd8>
+
+  a = PGROUNDUP(oldsz);
+801082c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+801082c3:	05 ff 0f 00 00       	add    $0xfff,%eax
+801082c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+801082cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(; a < newsz; a += PGSIZE){
+801082d0:	e9 8d 00 00 00       	jmp    80108362 <allocuvm+0xc9>
+    mem = kalloc();
+801082d5:	e8 71 a8 ff ff       	call   80102b4b <kalloc>
+801082da:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(mem == 0){
+801082dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801082e1:	75 2c                	jne    8010830f <allocuvm+0x76>
+      cprintf("allocuvm out of memory\n");
+801082e3:	c7 04 24 b9 8d 10 80 	movl   $0x80108db9,(%esp)
+801082ea:	e8 bb 80 ff ff       	call   801003aa <cprintf>
+      deallocuvm(pgdir, newsz, oldsz);
+801082ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+801082f2:	89 44 24 08          	mov    %eax,0x8(%esp)
+801082f6:	8b 45 10             	mov    0x10(%ebp),%eax
+801082f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+801082fd:	8b 45 08             	mov    0x8(%ebp),%eax
+80108300:	89 04 24             	mov    %eax,(%esp)
+80108303:	e8 6b 00 00 00       	call   80108373 <deallocuvm>
+      return 0;
+80108308:	b8 00 00 00 00       	mov    $0x0,%eax
+8010830d:	eb 62                	jmp    80108371 <allocuvm+0xd8>
+    }
+    memset(mem, 0, PGSIZE);
+8010830f:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80108316:	00 
+80108317:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+8010831e:	00 
+8010831f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108322:	89 04 24             	mov    %eax,(%esp)
+80108325:	e8 24 cf ff ff       	call   8010524e <memset>
+    mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
+8010832a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010832d:	89 04 24             	mov    %eax,(%esp)
+80108330:	e8 ca f5 ff ff       	call   801078ff <v2p>
+80108335:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80108338:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%esp)
+8010833f:	00 
+80108340:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80108344:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+8010834b:	00 
+8010834c:	89 54 24 04          	mov    %edx,0x4(%esp)
+80108350:	8b 45 08             	mov    0x8(%ebp),%eax
+80108353:	89 04 24             	mov    %eax,(%esp)
+80108356:	e8 d6 fa ff ff       	call   80107e31 <mappages>
+    return 0;
+  if(newsz < oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(oldsz);
+  for(; a < newsz; a += PGSIZE){
+8010835b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80108362:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108365:	3b 45 10             	cmp    0x10(%ebp),%eax
+80108368:	0f 82 67 ff ff ff    	jb     801082d5 <allocuvm+0x3c>
+      return 0;
+    }
+    memset(mem, 0, PGSIZE);
+    mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
+  }
+  return newsz;
+8010836e:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+80108371:	c9                   	leave  
+80108372:	c3                   	ret    
+
+80108373 <deallocuvm>:
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+int
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+80108373:	55                   	push   %ebp
+80108374:	89 e5                	mov    %esp,%ebp
+80108376:	83 ec 28             	sub    $0x28,%esp
+  pte_t *pte;
+  uint a, pa;
+
+  if(newsz >= oldsz)
+80108379:	8b 45 10             	mov    0x10(%ebp),%eax
+8010837c:	3b 45 0c             	cmp    0xc(%ebp),%eax
+8010837f:	72 08                	jb     80108389 <deallocuvm+0x16>
+    return oldsz;
+80108381:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108384:	e9 a4 00 00 00       	jmp    8010842d <deallocuvm+0xba>
+
+  a = PGROUNDUP(newsz);
+80108389:	8b 45 10             	mov    0x10(%ebp),%eax
+8010838c:	05 ff 0f 00 00       	add    $0xfff,%eax
+80108391:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108396:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(; a  < oldsz; a += PGSIZE){
+80108399:	e9 80 00 00 00       	jmp    8010841e <deallocuvm+0xab>
+    pte = walkpgdir(pgdir, (char*)a, 0);
+8010839e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801083a1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801083a8:	00 
+801083a9:	89 44 24 04          	mov    %eax,0x4(%esp)
+801083ad:	8b 45 08             	mov    0x8(%ebp),%eax
+801083b0:	89 04 24             	mov    %eax,(%esp)
+801083b3:	e8 d7 f9 ff ff       	call   80107d8f <walkpgdir>
+801083b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(!pte)
+801083bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801083bf:	75 09                	jne    801083ca <deallocuvm+0x57>
+      a += (NPTENTRIES - 1) * PGSIZE;
+801083c1:	81 45 f4 00 f0 3f 00 	addl   $0x3ff000,-0xc(%ebp)
+801083c8:	eb 4d                	jmp    80108417 <deallocuvm+0xa4>
+    else if((*pte & PTE_P) != 0){
+801083ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801083cd:	8b 00                	mov    (%eax),%eax
+801083cf:	83 e0 01             	and    $0x1,%eax
+801083d2:	85 c0                	test   %eax,%eax
+801083d4:	74 41                	je     80108417 <deallocuvm+0xa4>
+      pa = PTE_ADDR(*pte);
+801083d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801083d9:	8b 00                	mov    (%eax),%eax
+801083db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+801083e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+      if(pa == 0)
+801083e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+801083e7:	75 0c                	jne    801083f5 <deallocuvm+0x82>
+        panic("kfree");
+801083e9:	c7 04 24 d1 8d 10 80 	movl   $0x80108dd1,(%esp)
+801083f0:	e8 51 81 ff ff       	call   80100546 <panic>
+      char *v = p2v(pa);
+801083f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801083f8:	89 04 24             	mov    %eax,(%esp)
+801083fb:	e8 0c f5 ff ff       	call   8010790c <p2v>
+80108400:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      kfree(v);
+80108403:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80108406:	89 04 24             	mov    %eax,(%esp)
+80108409:	e8 a4 a6 ff ff       	call   80102ab2 <kfree>
+      *pte = 0;
+8010840e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108411:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+  for(; a  < oldsz; a += PGSIZE){
+80108417:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+8010841e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108421:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80108424:	0f 82 74 ff ff ff    	jb     8010839e <deallocuvm+0x2b>
+      char *v = p2v(pa);
+      kfree(v);
+      *pte = 0;
+    }
+  }
+  return newsz;
+8010842a:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+8010842d:	c9                   	leave  
+8010842e:	c3                   	ret    
+
+8010842f <freevm>:
+
+// Free a page table and all the physical memory pages
+// in the user part.
+void
+freevm(pde_t *pgdir)
+{
+8010842f:	55                   	push   %ebp
+80108430:	89 e5                	mov    %esp,%ebp
+80108432:	83 ec 28             	sub    $0x28,%esp
+  uint i;
+
+  if(pgdir == 0)
+80108435:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80108439:	75 0c                	jne    80108447 <freevm+0x18>
+    panic("freevm: no pgdir");
+8010843b:	c7 04 24 d7 8d 10 80 	movl   $0x80108dd7,(%esp)
+80108442:	e8 ff 80 ff ff       	call   80100546 <panic>
+  deallocuvm(pgdir, KERNBASE, 0);
+80108447:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+8010844e:	00 
+8010844f:	c7 44 24 04 00 00 00 	movl   $0x80000000,0x4(%esp)
+80108456:	80 
+80108457:	8b 45 08             	mov    0x8(%ebp),%eax
+8010845a:	89 04 24             	mov    %eax,(%esp)
+8010845d:	e8 11 ff ff ff       	call   80108373 <deallocuvm>
+  for(i = 0; i < NPDENTRIES; i++){
+80108462:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80108469:	eb 48                	jmp    801084b3 <freevm+0x84>
+    if(pgdir[i] & PTE_P){
+8010846b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010846e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80108475:	8b 45 08             	mov    0x8(%ebp),%eax
+80108478:	01 d0                	add    %edx,%eax
+8010847a:	8b 00                	mov    (%eax),%eax
+8010847c:	83 e0 01             	and    $0x1,%eax
+8010847f:	85 c0                	test   %eax,%eax
+80108481:	74 2c                	je     801084af <freevm+0x80>
+      char * v = p2v(PTE_ADDR(pgdir[i]));
+80108483:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108486:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+8010848d:	8b 45 08             	mov    0x8(%ebp),%eax
+80108490:	01 d0                	add    %edx,%eax
+80108492:	8b 00                	mov    (%eax),%eax
+80108494:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108499:	89 04 24             	mov    %eax,(%esp)
+8010849c:	e8 6b f4 ff ff       	call   8010790c <p2v>
+801084a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      kfree(v);
+801084a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801084a7:	89 04 24             	mov    %eax,(%esp)
+801084aa:	e8 03 a6 ff ff       	call   80102ab2 <kfree>
+  uint i;
+
+  if(pgdir == 0)
+    panic("freevm: no pgdir");
+  deallocuvm(pgdir, KERNBASE, 0);
+  for(i = 0; i < NPDENTRIES; i++){
+801084af:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801084b3:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
+801084ba:	76 af                	jbe    8010846b <freevm+0x3c>
+    if(pgdir[i] & PTE_P){
+      char * v = p2v(PTE_ADDR(pgdir[i]));
+      kfree(v);
+    }
+  }
+  kfree((char*)pgdir);
+801084bc:	8b 45 08             	mov    0x8(%ebp),%eax
+801084bf:	89 04 24             	mov    %eax,(%esp)
+801084c2:	e8 eb a5 ff ff       	call   80102ab2 <kfree>
+}
+801084c7:	c9                   	leave  
+801084c8:	c3                   	ret    
+
+801084c9 <clearpteu>:
+
+// Clear PTE_U on a page. Used to create an inaccessible
+// page beneath the user stack.
+void
+clearpteu(pde_t *pgdir, char *uva)
+{
+801084c9:	55                   	push   %ebp
+801084ca:	89 e5                	mov    %esp,%ebp
+801084cc:	83 ec 28             	sub    $0x28,%esp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+801084cf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801084d6:	00 
+801084d7:	8b 45 0c             	mov    0xc(%ebp),%eax
+801084da:	89 44 24 04          	mov    %eax,0x4(%esp)
+801084de:	8b 45 08             	mov    0x8(%ebp),%eax
+801084e1:	89 04 24             	mov    %eax,(%esp)
+801084e4:	e8 a6 f8 ff ff       	call   80107d8f <walkpgdir>
+801084e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pte == 0)
+801084ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801084f0:	75 0c                	jne    801084fe <clearpteu+0x35>
+    panic("clearpteu");
+801084f2:	c7 04 24 e8 8d 10 80 	movl   $0x80108de8,(%esp)
+801084f9:	e8 48 80 ff ff       	call   80100546 <panic>
+  *pte &= ~PTE_U;
+801084fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108501:	8b 00                	mov    (%eax),%eax
+80108503:	89 c2                	mov    %eax,%edx
+80108505:	83 e2 fb             	and    $0xfffffffb,%edx
+80108508:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010850b:	89 10                	mov    %edx,(%eax)
+}
+8010850d:	c9                   	leave  
+8010850e:	c3                   	ret    
+
+8010850f <copyuvm>:
+
+// Given a parent process's page table, create a copy
+// of it for a child.
+pde_t*
+copyuvm(pde_t *pgdir, uint sz)
+{
+8010850f:	55                   	push   %ebp
+80108510:	89 e5                	mov    %esp,%ebp
+80108512:	53                   	push   %ebx
+80108513:	83 ec 44             	sub    $0x44,%esp
+  pde_t *d;
+  pte_t *pte;
+  uint pa, i, flags;
+  char *mem;
+
+  if((d = setupkvm()) == 0)
+80108516:	e8 ac f9 ff ff       	call   80107ec7 <setupkvm>
+8010851b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010851e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80108522:	75 0a                	jne    8010852e <copyuvm+0x1f>
+    return 0;
+80108524:	b8 00 00 00 00       	mov    $0x0,%eax
+80108529:	e9 fd 00 00 00       	jmp    8010862b <copyuvm+0x11c>
+  for(i = 0; i < sz; i += PGSIZE){
+8010852e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80108535:	e9 cc 00 00 00       	jmp    80108606 <copyuvm+0xf7>
+    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+8010853a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010853d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+80108544:	00 
+80108545:	89 44 24 04          	mov    %eax,0x4(%esp)
+80108549:	8b 45 08             	mov    0x8(%ebp),%eax
+8010854c:	89 04 24             	mov    %eax,(%esp)
+8010854f:	e8 3b f8 ff ff       	call   80107d8f <walkpgdir>
+80108554:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80108557:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+8010855b:	75 0c                	jne    80108569 <copyuvm+0x5a>
+      panic("copyuvm: pte should exist");
+8010855d:	c7 04 24 f2 8d 10 80 	movl   $0x80108df2,(%esp)
+80108564:	e8 dd 7f ff ff       	call   80100546 <panic>
+    if(!(*pte & PTE_P))
+80108569:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010856c:	8b 00                	mov    (%eax),%eax
+8010856e:	83 e0 01             	and    $0x1,%eax
+80108571:	85 c0                	test   %eax,%eax
+80108573:	75 0c                	jne    80108581 <copyuvm+0x72>
+      panic("copyuvm: page not present");
+80108575:	c7 04 24 0c 8e 10 80 	movl   $0x80108e0c,(%esp)
+8010857c:	e8 c5 7f ff ff       	call   80100546 <panic>
+    pa = PTE_ADDR(*pte);
+80108581:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108584:	8b 00                	mov    (%eax),%eax
+80108586:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+8010858b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    flags = PTE_FLAGS(*pte);
+8010858e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108591:	8b 00                	mov    (%eax),%eax
+80108593:	25 ff 0f 00 00       	and    $0xfff,%eax
+80108598:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if((mem = kalloc()) == 0)
+8010859b:	e8 ab a5 ff ff       	call   80102b4b <kalloc>
+801085a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+801085a3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+801085a7:	74 6e                	je     80108617 <copyuvm+0x108>
+      goto bad;
+    memmove(mem, (char*)p2v(pa), PGSIZE);
+801085a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801085ac:	89 04 24             	mov    %eax,(%esp)
+801085af:	e8 58 f3 ff ff       	call   8010790c <p2v>
+801085b4:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+801085bb:	00 
+801085bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+801085c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801085c3:	89 04 24             	mov    %eax,(%esp)
+801085c6:	e8 56 cd ff ff       	call   80105321 <memmove>
+    if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
+801085cb:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+801085ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801085d1:	89 04 24             	mov    %eax,(%esp)
+801085d4:	e8 26 f3 ff ff       	call   801078ff <v2p>
+801085d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801085dc:	89 5c 24 10          	mov    %ebx,0x10(%esp)
+801085e0:	89 44 24 0c          	mov    %eax,0xc(%esp)
+801085e4:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+801085eb:	00 
+801085ec:	89 54 24 04          	mov    %edx,0x4(%esp)
+801085f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801085f3:	89 04 24             	mov    %eax,(%esp)
+801085f6:	e8 36 f8 ff ff       	call   80107e31 <mappages>
+801085fb:	85 c0                	test   %eax,%eax
+801085fd:	78 1b                	js     8010861a <copyuvm+0x10b>
+  uint pa, i, flags;
+  char *mem;
+
+  if((d = setupkvm()) == 0)
+    return 0;
+  for(i = 0; i < sz; i += PGSIZE){
+801085ff:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80108606:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108609:	3b 45 0c             	cmp    0xc(%ebp),%eax
+8010860c:	0f 82 28 ff ff ff    	jb     8010853a <copyuvm+0x2b>
+      goto bad;
+    memmove(mem, (char*)p2v(pa), PGSIZE);
+    if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
+      goto bad;
+  }
+  return d;
+80108612:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108615:	eb 14                	jmp    8010862b <copyuvm+0x11c>
+    if(!(*pte & PTE_P))
+      panic("copyuvm: page not present");
+    pa = PTE_ADDR(*pte);
+    flags = PTE_FLAGS(*pte);
+    if((mem = kalloc()) == 0)
+      goto bad;
+80108617:	90                   	nop
+80108618:	eb 01                	jmp    8010861b <copyuvm+0x10c>
+    memmove(mem, (char*)p2v(pa), PGSIZE);
+    if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
+      goto bad;
+8010861a:	90                   	nop
+  }
+  return d;
+
+bad:
+  freevm(d);
+8010861b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010861e:	89 04 24             	mov    %eax,(%esp)
+80108621:	e8 09 fe ff ff       	call   8010842f <freevm>
+  return 0;
+80108626:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010862b:	83 c4 44             	add    $0x44,%esp
+8010862e:	5b                   	pop    %ebx
+8010862f:	5d                   	pop    %ebp
+80108630:	c3                   	ret    
+
+80108631 <uva2ka>:
+
+//PAGEBREAK!
+// Map user virtual address to kernel address.
+char*
+uva2ka(pde_t *pgdir, char *uva)
+{
+80108631:	55                   	push   %ebp
+80108632:	89 e5                	mov    %esp,%ebp
+80108634:	83 ec 28             	sub    $0x28,%esp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+80108637:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+8010863e:	00 
+8010863f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108642:	89 44 24 04          	mov    %eax,0x4(%esp)
+80108646:	8b 45 08             	mov    0x8(%ebp),%eax
+80108649:	89 04 24             	mov    %eax,(%esp)
+8010864c:	e8 3e f7 ff ff       	call   80107d8f <walkpgdir>
+80108651:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if((*pte & PTE_P) == 0)
+80108654:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108657:	8b 00                	mov    (%eax),%eax
+80108659:	83 e0 01             	and    $0x1,%eax
+8010865c:	85 c0                	test   %eax,%eax
+8010865e:	75 07                	jne    80108667 <uva2ka+0x36>
+    return 0;
+80108660:	b8 00 00 00 00       	mov    $0x0,%eax
+80108665:	eb 25                	jmp    8010868c <uva2ka+0x5b>
+  if((*pte & PTE_U) == 0)
+80108667:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010866a:	8b 00                	mov    (%eax),%eax
+8010866c:	83 e0 04             	and    $0x4,%eax
+8010866f:	85 c0                	test   %eax,%eax
+80108671:	75 07                	jne    8010867a <uva2ka+0x49>
+    return 0;
+80108673:	b8 00 00 00 00       	mov    $0x0,%eax
+80108678:	eb 12                	jmp    8010868c <uva2ka+0x5b>
+  return (char*)p2v(PTE_ADDR(*pte));
+8010867a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010867d:	8b 00                	mov    (%eax),%eax
+8010867f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108684:	89 04 24             	mov    %eax,(%esp)
+80108687:	e8 80 f2 ff ff       	call   8010790c <p2v>
+}
+8010868c:	c9                   	leave  
+8010868d:	c3                   	ret    
+
+8010868e <copyout>:
+// Copy len bytes from p to user address va in page table pgdir.
+// Most useful when pgdir is not the current page table.
+// uva2ka ensures this only works for PTE_U pages.
+int
+copyout(pde_t *pgdir, uint va, void *p, uint len)
+{
+8010868e:	55                   	push   %ebp
+8010868f:	89 e5                	mov    %esp,%ebp
+80108691:	83 ec 28             	sub    $0x28,%esp
+  char *buf, *pa0;
+  uint n, va0;
+
+  buf = (char*)p;
+80108694:	8b 45 10             	mov    0x10(%ebp),%eax
+80108697:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(len > 0){
+8010869a:	e9 89 00 00 00       	jmp    80108728 <copyout+0x9a>
+    va0 = (uint)PGROUNDDOWN(va);
+8010869f:	8b 45 0c             	mov    0xc(%ebp),%eax
+801086a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+801086a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    pa0 = uva2ka(pgdir, (char*)va0);
+801086aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801086ad:	89 44 24 04          	mov    %eax,0x4(%esp)
+801086b1:	8b 45 08             	mov    0x8(%ebp),%eax
+801086b4:	89 04 24             	mov    %eax,(%esp)
+801086b7:	e8 75 ff ff ff       	call   80108631 <uva2ka>
+801086bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pa0 == 0)
+801086bf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+801086c3:	75 07                	jne    801086cc <copyout+0x3e>
+      return -1;
+801086c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801086ca:	eb 6b                	jmp    80108737 <copyout+0xa9>
+    n = PGSIZE - (va - va0);
+801086cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+801086cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801086d2:	89 d1                	mov    %edx,%ecx
+801086d4:	29 c1                	sub    %eax,%ecx
+801086d6:	89 c8                	mov    %ecx,%eax
+801086d8:	05 00 10 00 00       	add    $0x1000,%eax
+801086dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(n > len)
+801086e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801086e3:	3b 45 14             	cmp    0x14(%ebp),%eax
+801086e6:	76 06                	jbe    801086ee <copyout+0x60>
+      n = len;
+801086e8:	8b 45 14             	mov    0x14(%ebp),%eax
+801086eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    memmove(pa0 + (va - va0), buf, n);
+801086ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801086f1:	8b 55 0c             	mov    0xc(%ebp),%edx
+801086f4:	29 c2                	sub    %eax,%edx
+801086f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801086f9:	01 c2                	add    %eax,%edx
+801086fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801086fe:	89 44 24 08          	mov    %eax,0x8(%esp)
+80108702:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108705:	89 44 24 04          	mov    %eax,0x4(%esp)
+80108709:	89 14 24             	mov    %edx,(%esp)
+8010870c:	e8 10 cc ff ff       	call   80105321 <memmove>
+    len -= n;
+80108711:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108714:	29 45 14             	sub    %eax,0x14(%ebp)
+    buf += n;
+80108717:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010871a:	01 45 f4             	add    %eax,-0xc(%ebp)
+    va = va0 + PGSIZE;
+8010871d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108720:	05 00 10 00 00       	add    $0x1000,%eax
+80108725:	89 45 0c             	mov    %eax,0xc(%ebp)
+{
+  char *buf, *pa0;
+  uint n, va0;
+
+  buf = (char*)p;
+  while(len > 0){
+80108728:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+8010872c:	0f 85 6d ff ff ff    	jne    8010869f <copyout+0x11>
+    memmove(pa0 + (va - va0), buf, n);
+    len -= n;
+    buf += n;
+    va = va0 + PGSIZE;
+  }
+  return 0;
+80108732:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80108737:	c9                   	leave  
+80108738:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/kernel.sym cs550-16s-proj1-working/kernel.sym
--- cs550-16s-proj1-base/kernel.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kernel.sym	2016-03-04 15:55:05.900517142 -0500
@@ -0,0 +1,591 @@
+80100000 .text
+8010873c .rodata
+80108e26 .stab
+80108e27 .stabstr
+80109000 .data
+8010b5c0 .bss
+00000000 .debug_line
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_aranges
+00000000 .debug_loc
+00000000 .debug_str
+00000000 .comment
+00000000 .debug_ranges
+00000000 bio.c
+801000b0 bget
+00000000 console.c
+801002b0 inb
+801002da outb
+801002f8 cli
+8010b5c0 panicked
+8010b5e0 cons
+801002fe printint
+80109004 digits.1502
+80100759 consputc
+80109000 crt
+801005d6 cgaputc
+00000000 exec.c
+00000000 file.c
+00000000 fs.c
+80101366 bzero
+801013b7 balloc
+80101513 bfree
+801017a3 iget
+80101c56 itrunc
+80101b49 bmap
+8010228d skipelem
+80102341 namex
+00000000 ide.c
+8010249c inb
+801024c6 insl
+801024eb outb
+80102509 outsl
+8010b620 idelock
+8010b654 idequeue
+8010b658 havedisk1
+8010252e idewait
+80102618 idestart
+00000000 ioapic.c
+801028dc ioapicread
+801028f3 ioapicwrite
+00000000 kalloc.c
+80102a10 v2p
+00000000 kbd.c
+80102b98 inb
+80109020 shiftcode
+80109120 togglecode
+80109220 normalmap
+80109320 shiftmap
+80109420 ctlmap
+8010b65c shift.1340
+80109520 charcode.1341
+00000000 lapic.c
+80102d2c inb
+80102d56 outb
+80102d74 readeflags
+80102d89 lapicw
+8010b660 n.1421
+80103087 cmos_read
+801030c0 fill_rtcdate
+00000000 log.c
+80103487 recover_from_log
+801032ef install_trans
+8010339d read_head
+8010340c write_head
+80103681 commit
+801035d3 write_log
+00000000 main.c
+80103764 v2p
+80103771 p2v
+8010377e xchg
+801038b4 startothers
+8010386d mpmain
+80103853 mpenter
+00000000 mp.c
+80103998 p2v
+801039a5 inb
+801039cf outb
+8010b664 bcpu
+80103a0d sum
+80103a45 mpsearch1
+80103aba mpsearch
+80103b74 mpconfig
+00000000 picirq.c
+80103de8 outb
+8010b000 irqmask
+80103e06 picsetmask
+00000000 pipe.c
+00000000 proc.c
+80104384 readeflags
+80104399 sti
+8010b670 initproc
+801043ed allocproc
+80104db0 wakeup1
+8010b028 first.1550
+8010b010 states.1575
+00000000 spinlock.c
+80104f8c readeflags
+80104fa1 cli
+80104fa7 sti
+80104fad xchg
+00000000 string.c
+80105204 stosb
+80105229 stosl
+00000000 syscall.c
+8010b040 syscalls
+00000000 sysfile.c
+80105700 argfd
+80105775 fdalloc
+80105b41 isdirempty
+80105d87 create
+00000000 sysproc.c
+8010647c outw
+00000000 timer.c
+8010672c outb
+00000000 trap.c
+801067c8 lidt
+801067f1 rcr2
+00000000 uart.c
+80106c1c inb
+80106c46 outb
+8010b674 uart
+80106dd4 uartgetc
+00000000 vm.c
+801078a0 lgdt
+801078c9 ltr
+801078df loadgs
+801078f4 lcr3
+801078ff v2p
+8010790c p2v
+80107d8f walkpgdir
+80107e31 mappages
+8010b4c0 kmap
+8010092e consoleread
+801077f6 vector242
+8010724d vector119
+8010000c entry
+8010712d vector87
+80107124 vector86
+8010547e safestrcpy
+80105910 sys_close
+80107862 vector251
+80107151 vector91
+80106f47 vector33
+80107436 vector162
+80104c95 yield
+80112280 log
+80112240 kmem
+8010769a vector213
+801071ea vector108
+80106c64 uartinit
+80106fa1 vector43
+80102f63 lapiceoi
+8010674a timerinit
+8010745a vector165
+8010754a vector185
+8010290d ioapicinit
+80107229 vector115
+8010b668 sched_trace_enabled
+8010111d fileread
+80107268 vector122
+801065f1 sys_sbrk
+80112360 ioapicid
+801073ee vector156
+8010781a vector245
+80112234 ioapic
+8010757a vector189
+80106e6b vector7
+80107043 vector61
+80106ef6 vector24
+80107205 vector111
+801075fe vector200
+80107079 vector67
+80107316 vector138
+801070b8 vector74
+80104be3 sched
+80105321 memmove
+8010701f vector57
+80105671 syscall
+801076a6 vector214
+80107199 vector99
+80101f1a writei
+8010733a vector141
+80106586 sys_fork
+8010c680 bcache
+801074ae vector172
+801077ea vector241
+80112364 ismp
+801050a4 getcallerpcs
+801060e3 sys_mkdir
+8010787a vector253
+80106e47 vector3
+80106e3e vector2
+801020ab namecmp
+80107742 vector227
+80107676 vector210
+8010563a argstr
+8010771e vector224
+80106f8f vector41
+801003aa cprintf
+80100fb0 filedup
+80102458 namei
+80106edb vector21
+80100034 binit
+801074ea vector177
+80107244 vector118
+80107094 vector70
+8010708b vector69
+801077ba vector237
+8010705e vector64
+80106f11 vector27
+801072ce vector132
+80107556 vector186
+80105818 sys_read
+801076ca vector217
+8010550c fetchint
+80107ec7 setupkvm
+801053a4 memcpy
+8010842f freevm
+80106e35 vector1
+801074f6 vector178
+80106f74 vector38
+80102ab2 kfree
+801077c6 vector238
+8010b004 maximum
+80101a5a iput
+801072da vector133
+801070af vector73
+8010735e vector144
+80107886 vector254
+80101320 readsb
+8010b008 nextpid
+801071ab vector101
+80107682 vector211
+80103c21 mpinit
+801074c6 vector174
+80107802 vector243
+80102f07 cpunum
+80100f34 fileinit
+80115240 gdt
+80104fd2 initlock
+8010729e vector128
+8010868e copyout
+801070f7 vector81
+80104d15 sleep
+80102f88 microdelay
+80106e99 vector13
+80106fe9 vector51
+80106eb0 vector16
+801107a0 input
+801077de vector240
+80107004 vector54
+80106ec9 vector19
+8010715a vector92
+8010780e vector244
+80101d6f stati
+8010732e vector140
+801065b2 sys_kill
+80106fb3 vector45
+801070e5 vector79
+8010410b pipeclose
+8010775a vector229
+80107406 vector158
+80105961 sys_fstat
+80100a2f consolewrite
+80106f7d vector39
+8010747e vector168
+80103529 end_op
+80106f59 vector35
+80107217 vector113
+80102a79 freerange
+80107283 vector125
+8010439f set_priority
+80108299 allocuvm
+801067bc trapret
+801076be vector216
+80107055 vector63
+80106f08 vector26
+801075aa vector193
+80102daa lapicinit
+801075ce vector196
+8010766a vector209
+80106e50 vector4
+80107496 vector170
+8010b680 stack
+801072fe vector136
+80106e84 vector10
+80107646 vector206
+801019f5 iunlock
+8010663b sys_sleep
+80107892 vector255
+8010751a vector181
+80107031 vector59
+8010711b vector85
+80107112 vector84
+80107532 vector183
+80107412 vector159
+8010768e vector212
+801059c0 sys_link
+80106fc5 vector47
+8010774e vector228
+80106f98 vector42
+80107220 vector114
+80108631 uva2ka
+801074d2 vector175
+80107352 vector143
+80100f50 filealloc
+80104dee wakeup
+801072b6 vector130
+80107826 vector246
+80106e7b vector9
+80107346 vector142
+801071a2 vector100
+8010760a vector201
+801084c9 clearpteu
+80106807 tvinit
+8010703a vector60
+80106eed vector23
+80101875 idup
+801077ae vector236
+80102d15 kbdintr
+80106534 sys_fork_winner
+80105f47 sys_open
+80107772 vector231
+801066f8 sys_enable_sched_trace
+80107070 vector66
+80106f23 vector29
+80101db4 readi
+801072f2 vector135
+801007b6 consoleintr
+80104e19 kill
+801070d3 vector77
+8010160c ialloc
+8010750e vector180
+80115278 kpgdir
+8010765e vector208
+80103133 cmostime
+80106e18 uartintr
+80107190 vector98
+80107187 vector97
+801074de vector176
+801075b6 vector194
+80106f3e vector32
+8011527c end
+801075f2 vector199
+80112980 process_id
+801072c2 vector131
+8010786e vector252
+801011d9 filewrite
+80106e2c vector0
+801055aa argint
+80100b08 exec
+8010736a vector145
+80105894 sys_write
+80105055 release
+80105546 fetchstr
+801071e1 vector107
+80106f86 vector40
+8010494f wait
+801071b4 vector102
+8010a000 entrypgdir
+80112984 win
+0010000c _start
+80107016 vector56
+80107082 vector68
+80106e62 vector6
+8010b52c _binary_initcode_end
+80100000 multiboot_header
+801072aa vector129
+80104a5e scheduler
+801020cd dirlookup
+801075da vector197
+80100ff8 fileclose
+801034a8 begin_op
+801073be vector152
+80107f84 kvmalloc
+80107766 vector230
+801053c5 strncmp
+80106f6b vector37
+8010763a vector205
+8010742a vector161
+801149e0 tickslock
+8010419d pipewrite
+8010541d strncpy
+8010709d vector71
+8010850f copyuvm
+80110860 ftable
+8010741e vector160
+801055d8 argptr
+801076b2 vector215
+801073fa vector157
+801057c1 sys_dup
+8010720e vector112
+80100546 panic
+80104ce9 forkret
+80107526 vector182
+8010b66c schd_choice
+80106e92 vector12
+801052c5 memcmp
+80102bc2 kbdgetc
+801071f3 vector109
+80106ed2 vector20
+801046b1 fork
+80106ffb vector53
+80106ec0 vector18
+0000008a _binary_entryother_size
+80112380 cpus
+80107175 vector95
+8010511d holding
+80104ff3 acquire
+80107736 vector226
+8010247a nameiparent
+80106fd7 vector49
+80106faa vector44
+8011227c lapic
+801070dc vector78
+8010679c alltraps
+801074ba vector173
+8010723b vector117
+80107100 vector82
+80103e51 picenable
+8010b00c process_priority
+80107706 vector222
+80106e74 vector8
+8010739a vector149
+801016eb iupdate
+80109000 data
+8010524e memset
+8010777e vector232
+801037a3 main
+80107f9b switchkvm
+801071d8 vector106
+801076ee vector220
+80107148 vector90
+80107442 vector163
+80107796 vector234
+801036b0 log_write
+80105baf sys_unlink
+8010704c vector62
+80106eff vector25
+801075e6 vector198
+80107256 vector120
+8010b52c _binary_entryother_start
+80102a1d kinit1
+80106fe0 vector50
+80106ea7 vector15
+801073b2 vector151
+80107109 vector83
+8010713f vector89
+80107136 vector88
+80106565 sys_shutdown
+80106997 trap
+801066cd sys_uptime
+80107502 vector179
+80106f50 vector34
+80106fbc vector46
+801072e6 vector134
+80107712 vector223
+80114a20 idt
+801076d6 vector218
+801043d1 pinit
+80108373 deallocuvm
+8010772a vector225
+80107562 vector187
+8010460c growproc
+80112960 ncpu
+80106f2c vector30
+801044ec userinit
+801001a6 bread
+80107295 vector127
+8010428f piperead
+80115220 ticks
+8010759e vector192
+80107466 vector166
+80100a98 consoleinit
+801070ca vector76
+801070c1 vector75
+8010273d ideintr
+801075c2 vector195
+801064cd sys_set_priority
+801073a6 vector150
+80107028 vector58
+8010783e vector248
+80107271 vector123
+8010717e vector96
+80106f35 vector31
+80107622 vector203
+80107322 vector139
+801073ca vector153
+8010744e vector164
+80104e91 procdump
+8010725f vector121
+80106d75 uartputc
+80106e59 vector5
+80107472 vector167
+801073e2 vector155
+8010784a vector249
+80100217 brelse
+80107856 vector250
+8010727a vector124
+801071fc vector110
+8010762e vector204
+801018a7 ilock
+801062a1 sys_exec
+8010730a vector137
+8010b500 _binary_initcode_start
+801054f4 swtch
+80107832 vector247
+80106ee4 vector22
+80107616 vector202
+80107919 seginit
+80101b2b iunlockput
+801070a6 vector72
+8010700d vector55
+8010728c vector126
+80107067 vector65
+80106f1a vector28
+8010b5b6 _binary_entryother_end
+8010748a vector169
+801001dd bwrite
+8010778a vector233
+8010697b idtinit
+8010482d exit
+801065a5 sys_wait
+80106593 sys_exit
+80102195 dirlink
+0000002c _binary_initcode_size
+80107382 vector147
+80102572 ideinit
+801081aa loaduvm
+801071c6 vector104
+80107232 vector116
+801129a0 ptable
+801029c2 ioapicenable
+8010518f popcli
+8010b0ac vectors
+80106ff2 vector52
+80106eb9 vector17
+8010753e vector184
+801054cc strlen
+801039ed mpbcpu
+801063af sys_pipe
+801015f0 iinit
+80103e86 picinit
+80107652 vector207
+8010811f inituvm
+80107586 vector190
+801077d2 vector239
+8010716c vector94
+80107163 vector93
+80103298 initlog
+8010756e vector188
+80106fce vector48
+80102800 iderw
+8010649c sys_set_sched
+801076e2 vector219
+8010738e vector148
+801076fa vector221
+80102b4b kalloc
+80111200 devsw
+801065e3 sys_getpid
+801070ee vector80
+801074a2 vector171
+801073d6 vector154
+80106f62 vector36
+80103fc8 pipealloc
+801077a2 vector235
+801071cf vector105
+801061fc sys_chdir
+80111260 icache
+80107376 vector146
+80107592 vector191
+801071bd vector103
+80106154 sys_mknod
+80102f8d lapicstartap
+80107fb8 switchuvm
+80105147 pushcli
+80102a55 kinit2
+80106e8b vector11
+80106ea0 vector14
+801010ce filestat
Binary files cs550-16s-proj1-base/_kill and cs550-16s-proj1-working/_kill differ
diff -uNr cs550-16s-proj1-base/kill.asm cs550-16s-proj1-working/kill.asm
--- cs550-16s-proj1-base/kill.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kill.asm	2016-03-04 14:36:59.000000000 -0500
@@ -0,0 +1,1214 @@
+
+_kill:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 20             	sub    $0x20,%esp
+  int i;
+
+  if(argc < 1){
+   9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+   d:	7f 19                	jg     28 <main+0x28>
+    printf(2, "usage: kill pid...\n");
+   f:	c7 44 24 04 45 08 00 	movl   $0x845,0x4(%esp)
+  16:	00 
+  17:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  1e:	e8 52 04 00 00       	call   475 <printf>
+    exit();
+  23:	e8 a8 02 00 00       	call   2d0 <exit>
+  }
+  for(i=1; i<argc; i++)
+  28:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+  2f:	00 
+  30:	eb 27                	jmp    59 <main+0x59>
+    kill(atoi(argv[i]));
+  32:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  36:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  3d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  40:	01 d0                	add    %edx,%eax
+  42:	8b 00                	mov    (%eax),%eax
+  44:	89 04 24             	mov    %eax,(%esp)
+  47:	e8 f5 01 00 00       	call   241 <atoi>
+  4c:	89 04 24             	mov    %eax,(%esp)
+  4f:	e8 ac 02 00 00       	call   300 <kill>
+
+  if(argc < 1){
+    printf(2, "usage: kill pid...\n");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+  54:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+  59:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  5d:	3b 45 08             	cmp    0x8(%ebp),%eax
+  60:	7c d0                	jl     32 <main+0x32>
+    kill(atoi(argv[i]));
+  exit();
+  62:	e8 69 02 00 00       	call   2d0 <exit>
+  67:	90                   	nop
+
+00000068 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  68:	55                   	push   %ebp
+  69:	89 e5                	mov    %esp,%ebp
+  6b:	57                   	push   %edi
+  6c:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  6d:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  70:	8b 55 10             	mov    0x10(%ebp),%edx
+  73:	8b 45 0c             	mov    0xc(%ebp),%eax
+  76:	89 cb                	mov    %ecx,%ebx
+  78:	89 df                	mov    %ebx,%edi
+  7a:	89 d1                	mov    %edx,%ecx
+  7c:	fc                   	cld    
+  7d:	f3 aa                	rep stos %al,%es:(%edi)
+  7f:	89 ca                	mov    %ecx,%edx
+  81:	89 fb                	mov    %edi,%ebx
+  83:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  86:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  89:	5b                   	pop    %ebx
+  8a:	5f                   	pop    %edi
+  8b:	5d                   	pop    %ebp
+  8c:	c3                   	ret    
+
+0000008d <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  8d:	55                   	push   %ebp
+  8e:	89 e5                	mov    %esp,%ebp
+  90:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  93:	8b 45 08             	mov    0x8(%ebp),%eax
+  96:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  99:	90                   	nop
+  9a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  9d:	0f b6 10             	movzbl (%eax),%edx
+  a0:	8b 45 08             	mov    0x8(%ebp),%eax
+  a3:	88 10                	mov    %dl,(%eax)
+  a5:	8b 45 08             	mov    0x8(%ebp),%eax
+  a8:	0f b6 00             	movzbl (%eax),%eax
+  ab:	84 c0                	test   %al,%al
+  ad:	0f 95 c0             	setne  %al
+  b0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  b4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  b8:	84 c0                	test   %al,%al
+  ba:	75 de                	jne    9a <strcpy+0xd>
+    ;
+  return os;
+  bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  bf:	c9                   	leave  
+  c0:	c3                   	ret    
+
+000000c1 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  c1:	55                   	push   %ebp
+  c2:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  c4:	eb 08                	jmp    ce <strcmp+0xd>
+    p++, q++;
+  c6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  ca:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  d1:	0f b6 00             	movzbl (%eax),%eax
+  d4:	84 c0                	test   %al,%al
+  d6:	74 10                	je     e8 <strcmp+0x27>
+  d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  db:	0f b6 10             	movzbl (%eax),%edx
+  de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  e1:	0f b6 00             	movzbl (%eax),%eax
+  e4:	38 c2                	cmp    %al,%dl
+  e6:	74 de                	je     c6 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+  e8:	8b 45 08             	mov    0x8(%ebp),%eax
+  eb:	0f b6 00             	movzbl (%eax),%eax
+  ee:	0f b6 d0             	movzbl %al,%edx
+  f1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f4:	0f b6 00             	movzbl (%eax),%eax
+  f7:	0f b6 c0             	movzbl %al,%eax
+  fa:	89 d1                	mov    %edx,%ecx
+  fc:	29 c1                	sub    %eax,%ecx
+  fe:	89 c8                	mov    %ecx,%eax
+}
+ 100:	5d                   	pop    %ebp
+ 101:	c3                   	ret    
+
+00000102 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 102:	55                   	push   %ebp
+ 103:	89 e5                	mov    %esp,%ebp
+ 105:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 108:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 10f:	eb 04                	jmp    115 <strlen+0x13>
+ 111:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 115:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 118:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11b:	01 d0                	add    %edx,%eax
+ 11d:	0f b6 00             	movzbl (%eax),%eax
+ 120:	84 c0                	test   %al,%al
+ 122:	75 ed                	jne    111 <strlen+0xf>
+    ;
+  return n;
+ 124:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 127:	c9                   	leave  
+ 128:	c3                   	ret    
+
+00000129 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 129:	55                   	push   %ebp
+ 12a:	89 e5                	mov    %esp,%ebp
+ 12c:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 12f:	8b 45 10             	mov    0x10(%ebp),%eax
+ 132:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 136:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 139:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 13d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 140:	89 04 24             	mov    %eax,(%esp)
+ 143:	e8 20 ff ff ff       	call   68 <stosb>
+  return dst;
+ 148:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 14b:	c9                   	leave  
+ 14c:	c3                   	ret    
+
+0000014d <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 14d:	55                   	push   %ebp
+ 14e:	89 e5                	mov    %esp,%ebp
+ 150:	83 ec 04             	sub    $0x4,%esp
+ 153:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 156:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 159:	eb 14                	jmp    16f <strchr+0x22>
+    if(*s == c)
+ 15b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 15e:	0f b6 00             	movzbl (%eax),%eax
+ 161:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 164:	75 05                	jne    16b <strchr+0x1e>
+      return (char*)s;
+ 166:	8b 45 08             	mov    0x8(%ebp),%eax
+ 169:	eb 13                	jmp    17e <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 16b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 16f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 172:	0f b6 00             	movzbl (%eax),%eax
+ 175:	84 c0                	test   %al,%al
+ 177:	75 e2                	jne    15b <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 179:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 17e:	c9                   	leave  
+ 17f:	c3                   	ret    
+
+00000180 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 180:	55                   	push   %ebp
+ 181:	89 e5                	mov    %esp,%ebp
+ 183:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 186:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 18d:	eb 46                	jmp    1d5 <gets+0x55>
+    cc = read(0, &c, 1);
+ 18f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 196:	00 
+ 197:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 19a:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 19e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 1a5:	e8 3e 01 00 00       	call   2e8 <read>
+ 1aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1ad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1b1:	7e 2f                	jle    1e2 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1b6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1b9:	01 c2                	add    %eax,%edx
+ 1bb:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1bf:	88 02                	mov    %al,(%edx)
+ 1c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 1c5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1c9:	3c 0a                	cmp    $0xa,%al
+ 1cb:	74 16                	je     1e3 <gets+0x63>
+ 1cd:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d1:	3c 0d                	cmp    $0xd,%al
+ 1d3:	74 0e                	je     1e3 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1d8:	83 c0 01             	add    $0x1,%eax
+ 1db:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 1de:	7c af                	jl     18f <gets+0xf>
+ 1e0:	eb 01                	jmp    1e3 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 1e2:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 1e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1e6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1e9:	01 d0                	add    %edx,%eax
+ 1eb:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 1ee:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1f1:	c9                   	leave  
+ 1f2:	c3                   	ret    
+
+000001f3 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 1f3:	55                   	push   %ebp
+ 1f4:	89 e5                	mov    %esp,%ebp
+ 1f6:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 200:	00 
+ 201:	8b 45 08             	mov    0x8(%ebp),%eax
+ 204:	89 04 24             	mov    %eax,(%esp)
+ 207:	e8 04 01 00 00       	call   310 <open>
+ 20c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 20f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 213:	79 07                	jns    21c <stat+0x29>
+    return -1;
+ 215:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 21a:	eb 23                	jmp    23f <stat+0x4c>
+  r = fstat(fd, st);
+ 21c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 21f:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 223:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 226:	89 04 24             	mov    %eax,(%esp)
+ 229:	e8 fa 00 00 00       	call   328 <fstat>
+ 22e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 231:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 234:	89 04 24             	mov    %eax,(%esp)
+ 237:	e8 bc 00 00 00       	call   2f8 <close>
+  return r;
+ 23c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 23f:	c9                   	leave  
+ 240:	c3                   	ret    
+
+00000241 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 241:	55                   	push   %ebp
+ 242:	89 e5                	mov    %esp,%ebp
+ 244:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 247:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 24e:	eb 23                	jmp    273 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 250:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 253:	89 d0                	mov    %edx,%eax
+ 255:	c1 e0 02             	shl    $0x2,%eax
+ 258:	01 d0                	add    %edx,%eax
+ 25a:	01 c0                	add    %eax,%eax
+ 25c:	89 c2                	mov    %eax,%edx
+ 25e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 261:	0f b6 00             	movzbl (%eax),%eax
+ 264:	0f be c0             	movsbl %al,%eax
+ 267:	01 d0                	add    %edx,%eax
+ 269:	83 e8 30             	sub    $0x30,%eax
+ 26c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 26f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 273:	8b 45 08             	mov    0x8(%ebp),%eax
+ 276:	0f b6 00             	movzbl (%eax),%eax
+ 279:	3c 2f                	cmp    $0x2f,%al
+ 27b:	7e 0a                	jle    287 <atoi+0x46>
+ 27d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 280:	0f b6 00             	movzbl (%eax),%eax
+ 283:	3c 39                	cmp    $0x39,%al
+ 285:	7e c9                	jle    250 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 287:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 28a:	c9                   	leave  
+ 28b:	c3                   	ret    
+
+0000028c <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 28c:	55                   	push   %ebp
+ 28d:	89 e5                	mov    %esp,%ebp
+ 28f:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 292:	8b 45 08             	mov    0x8(%ebp),%eax
+ 295:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 298:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 29b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 29e:	eb 13                	jmp    2b3 <memmove+0x27>
+    *dst++ = *src++;
+ 2a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 2a3:	0f b6 10             	movzbl (%eax),%edx
+ 2a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2a9:	88 10                	mov    %dl,(%eax)
+ 2ab:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 2af:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2b3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 2b7:	0f 9f c0             	setg   %al
+ 2ba:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 2be:	84 c0                	test   %al,%al
+ 2c0:	75 de                	jne    2a0 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 2c2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2c5:	c9                   	leave  
+ 2c6:	c3                   	ret    
+ 2c7:	90                   	nop
+
+000002c8 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2c8:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2cd:	cd 40                	int    $0x40
+ 2cf:	c3                   	ret    
+
+000002d0 <exit>:
+SYSCALL(exit)
+ 2d0:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2d5:	cd 40                	int    $0x40
+ 2d7:	c3                   	ret    
+
+000002d8 <wait>:
+SYSCALL(wait)
+ 2d8:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2dd:	cd 40                	int    $0x40
+ 2df:	c3                   	ret    
+
+000002e0 <pipe>:
+SYSCALL(pipe)
+ 2e0:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2e5:	cd 40                	int    $0x40
+ 2e7:	c3                   	ret    
+
+000002e8 <read>:
+SYSCALL(read)
+ 2e8:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2ed:	cd 40                	int    $0x40
+ 2ef:	c3                   	ret    
+
+000002f0 <write>:
+SYSCALL(write)
+ 2f0:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2f5:	cd 40                	int    $0x40
+ 2f7:	c3                   	ret    
+
+000002f8 <close>:
+SYSCALL(close)
+ 2f8:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2fd:	cd 40                	int    $0x40
+ 2ff:	c3                   	ret    
+
+00000300 <kill>:
+SYSCALL(kill)
+ 300:	b8 06 00 00 00       	mov    $0x6,%eax
+ 305:	cd 40                	int    $0x40
+ 307:	c3                   	ret    
+
+00000308 <exec>:
+SYSCALL(exec)
+ 308:	b8 07 00 00 00       	mov    $0x7,%eax
+ 30d:	cd 40                	int    $0x40
+ 30f:	c3                   	ret    
+
+00000310 <open>:
+SYSCALL(open)
+ 310:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 315:	cd 40                	int    $0x40
+ 317:	c3                   	ret    
+
+00000318 <mknod>:
+SYSCALL(mknod)
+ 318:	b8 11 00 00 00       	mov    $0x11,%eax
+ 31d:	cd 40                	int    $0x40
+ 31f:	c3                   	ret    
+
+00000320 <unlink>:
+SYSCALL(unlink)
+ 320:	b8 12 00 00 00       	mov    $0x12,%eax
+ 325:	cd 40                	int    $0x40
+ 327:	c3                   	ret    
+
+00000328 <fstat>:
+SYSCALL(fstat)
+ 328:	b8 08 00 00 00       	mov    $0x8,%eax
+ 32d:	cd 40                	int    $0x40
+ 32f:	c3                   	ret    
+
+00000330 <link>:
+SYSCALL(link)
+ 330:	b8 13 00 00 00       	mov    $0x13,%eax
+ 335:	cd 40                	int    $0x40
+ 337:	c3                   	ret    
+
+00000338 <mkdir>:
+SYSCALL(mkdir)
+ 338:	b8 14 00 00 00       	mov    $0x14,%eax
+ 33d:	cd 40                	int    $0x40
+ 33f:	c3                   	ret    
+
+00000340 <chdir>:
+SYSCALL(chdir)
+ 340:	b8 09 00 00 00       	mov    $0x9,%eax
+ 345:	cd 40                	int    $0x40
+ 347:	c3                   	ret    
+
+00000348 <dup>:
+SYSCALL(dup)
+ 348:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 34d:	cd 40                	int    $0x40
+ 34f:	c3                   	ret    
+
+00000350 <getpid>:
+SYSCALL(getpid)
+ 350:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 355:	cd 40                	int    $0x40
+ 357:	c3                   	ret    
+
+00000358 <sbrk>:
+SYSCALL(sbrk)
+ 358:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 35d:	cd 40                	int    $0x40
+ 35f:	c3                   	ret    
+
+00000360 <sleep>:
+SYSCALL(sleep)
+ 360:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 365:	cd 40                	int    $0x40
+ 367:	c3                   	ret    
+
+00000368 <uptime>:
+SYSCALL(uptime)
+ 368:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 36d:	cd 40                	int    $0x40
+ 36f:	c3                   	ret    
+
+00000370 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 370:	b8 16 00 00 00       	mov    $0x16,%eax
+ 375:	cd 40                	int    $0x40
+ 377:	c3                   	ret    
+
+00000378 <shutdown>:
+SYSCALL(shutdown)
+ 378:	b8 17 00 00 00       	mov    $0x17,%eax
+ 37d:	cd 40                	int    $0x40
+ 37f:	c3                   	ret    
+
+00000380 <fork_winner>:
+SYSCALL(fork_winner)
+ 380:	b8 18 00 00 00       	mov    $0x18,%eax
+ 385:	cd 40                	int    $0x40
+ 387:	c3                   	ret    
+
+00000388 <set_sched>:
+SYSCALL(set_sched)
+ 388:	b8 19 00 00 00       	mov    $0x19,%eax
+ 38d:	cd 40                	int    $0x40
+ 38f:	c3                   	ret    
+
+00000390 <set_priority>:
+SYSCALL(set_priority)
+ 390:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 395:	cd 40                	int    $0x40
+ 397:	c3                   	ret    
+
+00000398 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 398:	55                   	push   %ebp
+ 399:	89 e5                	mov    %esp,%ebp
+ 39b:	83 ec 28             	sub    $0x28,%esp
+ 39e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3a1:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3a4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 3ab:	00 
+ 3ac:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3af:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 3b3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3b6:	89 04 24             	mov    %eax,(%esp)
+ 3b9:	e8 32 ff ff ff       	call   2f0 <write>
+}
+ 3be:	c9                   	leave  
+ 3bf:	c3                   	ret    
+
+000003c0 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3c0:	55                   	push   %ebp
+ 3c1:	89 e5                	mov    %esp,%ebp
+ 3c3:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3cd:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3d1:	74 17                	je     3ea <printint+0x2a>
+ 3d3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3d7:	79 11                	jns    3ea <printint+0x2a>
+    neg = 1;
+ 3d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 3e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3e3:	f7 d8                	neg    %eax
+ 3e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3e8:	eb 06                	jmp    3f0 <printint+0x30>
+  } else {
+    x = xx;
+ 3ea:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 3f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 3f7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 3fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3fd:	ba 00 00 00 00       	mov    $0x0,%edx
+ 402:	f7 f1                	div    %ecx
+ 404:	89 d0                	mov    %edx,%eax
+ 406:	0f b6 80 9c 0a 00 00 	movzbl 0xa9c(%eax),%eax
+ 40d:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 410:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 413:	01 ca                	add    %ecx,%edx
+ 415:	88 02                	mov    %al,(%edx)
+ 417:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 41b:	8b 55 10             	mov    0x10(%ebp),%edx
+ 41e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 421:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 424:	ba 00 00 00 00       	mov    $0x0,%edx
+ 429:	f7 75 d4             	divl   -0x2c(%ebp)
+ 42c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 42f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 433:	75 c2                	jne    3f7 <printint+0x37>
+  if(neg)
+ 435:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 439:	74 2e                	je     469 <printint+0xa9>
+    buf[i++] = '-';
+ 43b:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 43e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 441:	01 d0                	add    %edx,%eax
+ 443:	c6 00 2d             	movb   $0x2d,(%eax)
+ 446:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 44a:	eb 1d                	jmp    469 <printint+0xa9>
+    putc(fd, buf[i]);
+ 44c:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 44f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 452:	01 d0                	add    %edx,%eax
+ 454:	0f b6 00             	movzbl (%eax),%eax
+ 457:	0f be c0             	movsbl %al,%eax
+ 45a:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 45e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 461:	89 04 24             	mov    %eax,(%esp)
+ 464:	e8 2f ff ff ff       	call   398 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 469:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 46d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 471:	79 d9                	jns    44c <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 473:	c9                   	leave  
+ 474:	c3                   	ret    
+
+00000475 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 475:	55                   	push   %ebp
+ 476:	89 e5                	mov    %esp,%ebp
+ 478:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 47b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 482:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 485:	83 c0 04             	add    $0x4,%eax
+ 488:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 48b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 492:	e9 7d 01 00 00       	jmp    614 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 497:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 49a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 49d:	01 d0                	add    %edx,%eax
+ 49f:	0f b6 00             	movzbl (%eax),%eax
+ 4a2:	0f be c0             	movsbl %al,%eax
+ 4a5:	25 ff 00 00 00       	and    $0xff,%eax
+ 4aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4b1:	75 2c                	jne    4df <printf+0x6a>
+      if(c == '%'){
+ 4b3:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4b7:	75 0c                	jne    4c5 <printf+0x50>
+        state = '%';
+ 4b9:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4c0:	e9 4b 01 00 00       	jmp    610 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 4c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4c8:	0f be c0             	movsbl %al,%eax
+ 4cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4cf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4d2:	89 04 24             	mov    %eax,(%esp)
+ 4d5:	e8 be fe ff ff       	call   398 <putc>
+ 4da:	e9 31 01 00 00       	jmp    610 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 4df:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 4e3:	0f 85 27 01 00 00    	jne    610 <printf+0x19b>
+      if(c == 'd'){
+ 4e9:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 4ed:	75 2d                	jne    51c <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 4ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4f2:	8b 00                	mov    (%eax),%eax
+ 4f4:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 4fb:	00 
+ 4fc:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 503:	00 
+ 504:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 508:	8b 45 08             	mov    0x8(%ebp),%eax
+ 50b:	89 04 24             	mov    %eax,(%esp)
+ 50e:	e8 ad fe ff ff       	call   3c0 <printint>
+        ap++;
+ 513:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 517:	e9 ed 00 00 00       	jmp    609 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 51c:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 520:	74 06                	je     528 <printf+0xb3>
+ 522:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 526:	75 2d                	jne    555 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 528:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 52b:	8b 00                	mov    (%eax),%eax
+ 52d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 534:	00 
+ 535:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 53c:	00 
+ 53d:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 541:	8b 45 08             	mov    0x8(%ebp),%eax
+ 544:	89 04 24             	mov    %eax,(%esp)
+ 547:	e8 74 fe ff ff       	call   3c0 <printint>
+        ap++;
+ 54c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 550:	e9 b4 00 00 00       	jmp    609 <printf+0x194>
+      } else if(c == 's'){
+ 555:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 559:	75 46                	jne    5a1 <printf+0x12c>
+        s = (char*)*ap;
+ 55b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 55e:	8b 00                	mov    (%eax),%eax
+ 560:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 563:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 567:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 56b:	75 27                	jne    594 <printf+0x11f>
+          s = "(null)";
+ 56d:	c7 45 f4 59 08 00 00 	movl   $0x859,-0xc(%ebp)
+        while(*s != 0){
+ 574:	eb 1e                	jmp    594 <printf+0x11f>
+          putc(fd, *s);
+ 576:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 579:	0f b6 00             	movzbl (%eax),%eax
+ 57c:	0f be c0             	movsbl %al,%eax
+ 57f:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 583:	8b 45 08             	mov    0x8(%ebp),%eax
+ 586:	89 04 24             	mov    %eax,(%esp)
+ 589:	e8 0a fe ff ff       	call   398 <putc>
+          s++;
+ 58e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 592:	eb 01                	jmp    595 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 594:	90                   	nop
+ 595:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 598:	0f b6 00             	movzbl (%eax),%eax
+ 59b:	84 c0                	test   %al,%al
+ 59d:	75 d7                	jne    576 <printf+0x101>
+ 59f:	eb 68                	jmp    609 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5a1:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5a5:	75 1d                	jne    5c4 <printf+0x14f>
+        putc(fd, *ap);
+ 5a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5aa:	8b 00                	mov    (%eax),%eax
+ 5ac:	0f be c0             	movsbl %al,%eax
+ 5af:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5b3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5b6:	89 04 24             	mov    %eax,(%esp)
+ 5b9:	e8 da fd ff ff       	call   398 <putc>
+        ap++;
+ 5be:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5c2:	eb 45                	jmp    609 <printf+0x194>
+      } else if(c == '%'){
+ 5c4:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5c8:	75 17                	jne    5e1 <printf+0x16c>
+        putc(fd, c);
+ 5ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5cd:	0f be c0             	movsbl %al,%eax
+ 5d0:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5d4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5d7:	89 04 24             	mov    %eax,(%esp)
+ 5da:	e8 b9 fd ff ff       	call   398 <putc>
+ 5df:	eb 28                	jmp    609 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5e1:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 5e8:	00 
+ 5e9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ec:	89 04 24             	mov    %eax,(%esp)
+ 5ef:	e8 a4 fd ff ff       	call   398 <putc>
+        putc(fd, c);
+ 5f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5f7:	0f be c0             	movsbl %al,%eax
+ 5fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5fe:	8b 45 08             	mov    0x8(%ebp),%eax
+ 601:	89 04 24             	mov    %eax,(%esp)
+ 604:	e8 8f fd ff ff       	call   398 <putc>
+      }
+      state = 0;
+ 609:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 610:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 614:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 617:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 61a:	01 d0                	add    %edx,%eax
+ 61c:	0f b6 00             	movzbl (%eax),%eax
+ 61f:	84 c0                	test   %al,%al
+ 621:	0f 85 70 fe ff ff    	jne    497 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 627:	c9                   	leave  
+ 628:	c3                   	ret    
+ 629:	90                   	nop
+ 62a:	90                   	nop
+ 62b:	90                   	nop
+
+0000062c <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 62c:	55                   	push   %ebp
+ 62d:	89 e5                	mov    %esp,%ebp
+ 62f:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 632:	8b 45 08             	mov    0x8(%ebp),%eax
+ 635:	83 e8 08             	sub    $0x8,%eax
+ 638:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 63b:	a1 b8 0a 00 00       	mov    0xab8,%eax
+ 640:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 643:	eb 24                	jmp    669 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 645:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 648:	8b 00                	mov    (%eax),%eax
+ 64a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 64d:	77 12                	ja     661 <free+0x35>
+ 64f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 652:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 655:	77 24                	ja     67b <free+0x4f>
+ 657:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65a:	8b 00                	mov    (%eax),%eax
+ 65c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 65f:	77 1a                	ja     67b <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 661:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 664:	8b 00                	mov    (%eax),%eax
+ 666:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 669:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 66c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 66f:	76 d4                	jbe    645 <free+0x19>
+ 671:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 674:	8b 00                	mov    (%eax),%eax
+ 676:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 679:	76 ca                	jbe    645 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 67b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 67e:	8b 40 04             	mov    0x4(%eax),%eax
+ 681:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 688:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68b:	01 c2                	add    %eax,%edx
+ 68d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 690:	8b 00                	mov    (%eax),%eax
+ 692:	39 c2                	cmp    %eax,%edx
+ 694:	75 24                	jne    6ba <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 696:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 699:	8b 50 04             	mov    0x4(%eax),%edx
+ 69c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 69f:	8b 00                	mov    (%eax),%eax
+ 6a1:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a4:	01 c2                	add    %eax,%edx
+ 6a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6a9:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6af:	8b 00                	mov    (%eax),%eax
+ 6b1:	8b 10                	mov    (%eax),%edx
+ 6b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6b6:	89 10                	mov    %edx,(%eax)
+ 6b8:	eb 0a                	jmp    6c4 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6bd:	8b 10                	mov    (%eax),%edx
+ 6bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c2:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c7:	8b 40 04             	mov    0x4(%eax),%eax
+ 6ca:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d4:	01 d0                	add    %edx,%eax
+ 6d6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 6d9:	75 20                	jne    6fb <free+0xcf>
+    p->s.size += bp->s.size;
+ 6db:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6de:	8b 50 04             	mov    0x4(%eax),%edx
+ 6e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e4:	8b 40 04             	mov    0x4(%eax),%eax
+ 6e7:	01 c2                	add    %eax,%edx
+ 6e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ec:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f2:	8b 10                	mov    (%eax),%edx
+ 6f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f7:	89 10                	mov    %edx,(%eax)
+ 6f9:	eb 08                	jmp    703 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 6fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 701:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 703:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 706:	a3 b8 0a 00 00       	mov    %eax,0xab8
+}
+ 70b:	c9                   	leave  
+ 70c:	c3                   	ret    
+
+0000070d <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 70d:	55                   	push   %ebp
+ 70e:	89 e5                	mov    %esp,%ebp
+ 710:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 713:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 71a:	77 07                	ja     723 <morecore+0x16>
+    nu = 4096;
+ 71c:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 723:	8b 45 08             	mov    0x8(%ebp),%eax
+ 726:	c1 e0 03             	shl    $0x3,%eax
+ 729:	89 04 24             	mov    %eax,(%esp)
+ 72c:	e8 27 fc ff ff       	call   358 <sbrk>
+ 731:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 734:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 738:	75 07                	jne    741 <morecore+0x34>
+    return 0;
+ 73a:	b8 00 00 00 00       	mov    $0x0,%eax
+ 73f:	eb 22                	jmp    763 <morecore+0x56>
+  hp = (Header*)p;
+ 741:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 744:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 747:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 74a:	8b 55 08             	mov    0x8(%ebp),%edx
+ 74d:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 750:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 753:	83 c0 08             	add    $0x8,%eax
+ 756:	89 04 24             	mov    %eax,(%esp)
+ 759:	e8 ce fe ff ff       	call   62c <free>
+  return freep;
+ 75e:	a1 b8 0a 00 00       	mov    0xab8,%eax
+}
+ 763:	c9                   	leave  
+ 764:	c3                   	ret    
+
+00000765 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 765:	55                   	push   %ebp
+ 766:	89 e5                	mov    %esp,%ebp
+ 768:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 76b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 76e:	83 c0 07             	add    $0x7,%eax
+ 771:	c1 e8 03             	shr    $0x3,%eax
+ 774:	83 c0 01             	add    $0x1,%eax
+ 777:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 77a:	a1 b8 0a 00 00       	mov    0xab8,%eax
+ 77f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 782:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 786:	75 23                	jne    7ab <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 788:	c7 45 f0 b0 0a 00 00 	movl   $0xab0,-0x10(%ebp)
+ 78f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 792:	a3 b8 0a 00 00       	mov    %eax,0xab8
+ 797:	a1 b8 0a 00 00       	mov    0xab8,%eax
+ 79c:	a3 b0 0a 00 00       	mov    %eax,0xab0
+    base.s.size = 0;
+ 7a1:	c7 05 b4 0a 00 00 00 	movl   $0x0,0xab4
+ 7a8:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7ae:	8b 00                	mov    (%eax),%eax
+ 7b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7b6:	8b 40 04             	mov    0x4(%eax),%eax
+ 7b9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7bc:	72 4d                	jb     80b <malloc+0xa6>
+      if(p->s.size == nunits)
+ 7be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7c1:	8b 40 04             	mov    0x4(%eax),%eax
+ 7c4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7c7:	75 0c                	jne    7d5 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 7c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7cc:	8b 10                	mov    (%eax),%edx
+ 7ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7d1:	89 10                	mov    %edx,(%eax)
+ 7d3:	eb 26                	jmp    7fb <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 7d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d8:	8b 40 04             	mov    0x4(%eax),%eax
+ 7db:	89 c2                	mov    %eax,%edx
+ 7dd:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 7e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e3:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e9:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ec:	c1 e0 03             	shl    $0x3,%eax
+ 7ef:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 7f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 7f8:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 7fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7fe:	a3 b8 0a 00 00       	mov    %eax,0xab8
+      return (void*)(p + 1);
+ 803:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 806:	83 c0 08             	add    $0x8,%eax
+ 809:	eb 38                	jmp    843 <malloc+0xde>
+    }
+    if(p == freep)
+ 80b:	a1 b8 0a 00 00       	mov    0xab8,%eax
+ 810:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 813:	75 1b                	jne    830 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 815:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 818:	89 04 24             	mov    %eax,(%esp)
+ 81b:	e8 ed fe ff ff       	call   70d <morecore>
+ 820:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 823:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 827:	75 07                	jne    830 <malloc+0xcb>
+        return 0;
+ 829:	b8 00 00 00 00       	mov    $0x0,%eax
+ 82e:	eb 13                	jmp    843 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 830:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 833:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 836:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 839:	8b 00                	mov    (%eax),%eax
+ 83b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 83e:	e9 70 ff ff ff       	jmp    7b3 <malloc+0x4e>
+}
+ 843:	c9                   	leave  
+ 844:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/kill.c cs550-16s-proj1-working/kill.c
--- cs550-16s-proj1-base/kill.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/kill.c	2016-03-04 14:36:39.000000000 -0500
@@ -7,7 +7,7 @@
 {
   int i;
 
-  if(argc < 2){
+  if(argc < 1){
     printf(2, "usage: kill pid...\n");
     exit();
   }
diff -uNr cs550-16s-proj1-base/kill.d cs550-16s-proj1-working/kill.d
--- cs550-16s-proj1-base/kill.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kill.d	2016-03-04 14:36:59.000000000 -0500
@@ -0,0 +1 @@
+kill.o: kill.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/kill.o and cs550-16s-proj1-working/kill.o differ
diff -uNr cs550-16s-proj1-base/kill.sym cs550-16s-proj1-working/kill.sym
--- cs550-16s-proj1-base/kill.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/kill.sym	2016-03-04 14:37:00.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+00000845 .rodata
+00000860 .eh_frame
+00000a9c .data
+00000ab0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 kill.c
+00000000 ulib.c
+00000068 stosb
+00000000 printf.c
+00000398 putc
+000003c0 printint
+00000a9c digits.1028
+00000000 umalloc.c
+00000ab0 base
+00000ab8 freep
+0000070d morecore
+0000008d strcpy
+00000475 printf
+0000028c memmove
+00000318 mknod
+00000180 gets
+00000350 getpid
+00000765 malloc
+00000360 sleep
+00000390 set_priority
+000002e0 pipe
+000002f0 write
+00000328 fstat
+00000300 kill
+00000340 chdir
+00000308 exec
+000002d8 wait
+000002e8 read
+00000320 unlink
+000002c8 fork
+00000358 sbrk
+00000368 uptime
+00000ab0 __bss_start
+00000129 memset
+00000000 main
+00000370 enable_sched_trace
+000000c1 strcmp
+00000378 shutdown
+00000348 dup
+00000388 set_sched
+000001f3 stat
+00000ab0 _edata
+00000abc _end
+00000330 link
+000002d0 exit
+00000241 atoi
+00000380 fork_winner
+00000102 strlen
+00000310 open
+0000014d strchr
+00000338 mkdir
+000002f8 close
+0000062c free
diff -uNr cs550-16s-proj1-base/lapic.d cs550-16s-proj1-working/lapic.d
--- cs550-16s-proj1-base/lapic.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/lapic.d	2016-03-04 14:37:20.000000000 -0500
@@ -0,0 +1 @@
+lapic.o: lapic.c types.h defs.h date.h memlayout.h traps.h mmu.h x86.h
Binary files cs550-16s-proj1-base/lapic.o and cs550-16s-proj1-working/lapic.o differ
Binary files cs550-16s-proj1-base/_ln and cs550-16s-proj1-working/_ln differ
diff -uNr cs550-16s-proj1-base/ln.asm cs550-16s-proj1-working/ln.asm
--- cs550-16s-proj1-base/ln.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ln.asm	2016-03-04 14:37:01.000000000 -0500
@@ -0,0 +1,1214 @@
+
+_ln:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 10             	sub    $0x10,%esp
+  if(argc != 3){
+   9:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
+   d:	74 19                	je     28 <main+0x28>
+    printf(2, "Usage: ln old new\n");
+   f:	c7 44 24 04 59 08 00 	movl   $0x859,0x4(%esp)
+  16:	00 
+  17:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  1e:	e8 66 04 00 00       	call   489 <printf>
+    exit();
+  23:	e8 bc 02 00 00       	call   2e4 <exit>
+  }
+  if(link(argv[1], argv[2]) < 0)
+  28:	8b 45 0c             	mov    0xc(%ebp),%eax
+  2b:	83 c0 08             	add    $0x8,%eax
+  2e:	8b 10                	mov    (%eax),%edx
+  30:	8b 45 0c             	mov    0xc(%ebp),%eax
+  33:	83 c0 04             	add    $0x4,%eax
+  36:	8b 00                	mov    (%eax),%eax
+  38:	89 54 24 04          	mov    %edx,0x4(%esp)
+  3c:	89 04 24             	mov    %eax,(%esp)
+  3f:	e8 00 03 00 00       	call   344 <link>
+  44:	85 c0                	test   %eax,%eax
+  46:	79 2c                	jns    74 <main+0x74>
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  48:	8b 45 0c             	mov    0xc(%ebp),%eax
+  4b:	83 c0 08             	add    $0x8,%eax
+  4e:	8b 10                	mov    (%eax),%edx
+  50:	8b 45 0c             	mov    0xc(%ebp),%eax
+  53:	83 c0 04             	add    $0x4,%eax
+  56:	8b 00                	mov    (%eax),%eax
+  58:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  5c:	89 44 24 08          	mov    %eax,0x8(%esp)
+  60:	c7 44 24 04 6c 08 00 	movl   $0x86c,0x4(%esp)
+  67:	00 
+  68:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  6f:	e8 15 04 00 00       	call   489 <printf>
+  exit();
+  74:	e8 6b 02 00 00       	call   2e4 <exit>
+  79:	90                   	nop
+  7a:	90                   	nop
+  7b:	90                   	nop
+
+0000007c <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  7c:	55                   	push   %ebp
+  7d:	89 e5                	mov    %esp,%ebp
+  7f:	57                   	push   %edi
+  80:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  81:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  84:	8b 55 10             	mov    0x10(%ebp),%edx
+  87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8a:	89 cb                	mov    %ecx,%ebx
+  8c:	89 df                	mov    %ebx,%edi
+  8e:	89 d1                	mov    %edx,%ecx
+  90:	fc                   	cld    
+  91:	f3 aa                	rep stos %al,%es:(%edi)
+  93:	89 ca                	mov    %ecx,%edx
+  95:	89 fb                	mov    %edi,%ebx
+  97:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  9a:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  9d:	5b                   	pop    %ebx
+  9e:	5f                   	pop    %edi
+  9f:	5d                   	pop    %ebp
+  a0:	c3                   	ret    
+
+000000a1 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  a1:	55                   	push   %ebp
+  a2:	89 e5                	mov    %esp,%ebp
+  a4:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  a7:	8b 45 08             	mov    0x8(%ebp),%eax
+  aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  ad:	90                   	nop
+  ae:	8b 45 0c             	mov    0xc(%ebp),%eax
+  b1:	0f b6 10             	movzbl (%eax),%edx
+  b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  b7:	88 10                	mov    %dl,(%eax)
+  b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  bc:	0f b6 00             	movzbl (%eax),%eax
+  bf:	84 c0                	test   %al,%al
+  c1:	0f 95 c0             	setne  %al
+  c4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  c8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  cc:	84 c0                	test   %al,%al
+  ce:	75 de                	jne    ae <strcpy+0xd>
+    ;
+  return os;
+  d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  d3:	c9                   	leave  
+  d4:	c3                   	ret    
+
+000000d5 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  d5:	55                   	push   %ebp
+  d6:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  d8:	eb 08                	jmp    e2 <strcmp+0xd>
+    p++, q++;
+  da:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  de:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  e2:	8b 45 08             	mov    0x8(%ebp),%eax
+  e5:	0f b6 00             	movzbl (%eax),%eax
+  e8:	84 c0                	test   %al,%al
+  ea:	74 10                	je     fc <strcmp+0x27>
+  ec:	8b 45 08             	mov    0x8(%ebp),%eax
+  ef:	0f b6 10             	movzbl (%eax),%edx
+  f2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f5:	0f b6 00             	movzbl (%eax),%eax
+  f8:	38 c2                	cmp    %al,%dl
+  fa:	74 de                	je     da <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+  fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  ff:	0f b6 00             	movzbl (%eax),%eax
+ 102:	0f b6 d0             	movzbl %al,%edx
+ 105:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 108:	0f b6 00             	movzbl (%eax),%eax
+ 10b:	0f b6 c0             	movzbl %al,%eax
+ 10e:	89 d1                	mov    %edx,%ecx
+ 110:	29 c1                	sub    %eax,%ecx
+ 112:	89 c8                	mov    %ecx,%eax
+}
+ 114:	5d                   	pop    %ebp
+ 115:	c3                   	ret    
+
+00000116 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 116:	55                   	push   %ebp
+ 117:	89 e5                	mov    %esp,%ebp
+ 119:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 11c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 123:	eb 04                	jmp    129 <strlen+0x13>
+ 125:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 129:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 12c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 12f:	01 d0                	add    %edx,%eax
+ 131:	0f b6 00             	movzbl (%eax),%eax
+ 134:	84 c0                	test   %al,%al
+ 136:	75 ed                	jne    125 <strlen+0xf>
+    ;
+  return n;
+ 138:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 13b:	c9                   	leave  
+ 13c:	c3                   	ret    
+
+0000013d <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 13d:	55                   	push   %ebp
+ 13e:	89 e5                	mov    %esp,%ebp
+ 140:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 143:	8b 45 10             	mov    0x10(%ebp),%eax
+ 146:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 14a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 14d:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 151:	8b 45 08             	mov    0x8(%ebp),%eax
+ 154:	89 04 24             	mov    %eax,(%esp)
+ 157:	e8 20 ff ff ff       	call   7c <stosb>
+  return dst;
+ 15c:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 15f:	c9                   	leave  
+ 160:	c3                   	ret    
+
+00000161 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 161:	55                   	push   %ebp
+ 162:	89 e5                	mov    %esp,%ebp
+ 164:	83 ec 04             	sub    $0x4,%esp
+ 167:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 16a:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 16d:	eb 14                	jmp    183 <strchr+0x22>
+    if(*s == c)
+ 16f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 172:	0f b6 00             	movzbl (%eax),%eax
+ 175:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 178:	75 05                	jne    17f <strchr+0x1e>
+      return (char*)s;
+ 17a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17d:	eb 13                	jmp    192 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 17f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 183:	8b 45 08             	mov    0x8(%ebp),%eax
+ 186:	0f b6 00             	movzbl (%eax),%eax
+ 189:	84 c0                	test   %al,%al
+ 18b:	75 e2                	jne    16f <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 18d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 192:	c9                   	leave  
+ 193:	c3                   	ret    
+
+00000194 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 194:	55                   	push   %ebp
+ 195:	89 e5                	mov    %esp,%ebp
+ 197:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 19a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1a1:	eb 46                	jmp    1e9 <gets+0x55>
+    cc = read(0, &c, 1);
+ 1a3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 1aa:	00 
+ 1ab:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1ae:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1b2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 1b9:	e8 3e 01 00 00       	call   2fc <read>
+ 1be:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1c5:	7e 2f                	jle    1f6 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1ca:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1cd:	01 c2                	add    %eax,%edx
+ 1cf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d3:	88 02                	mov    %al,(%edx)
+ 1d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 1d9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1dd:	3c 0a                	cmp    $0xa,%al
+ 1df:	74 16                	je     1f7 <gets+0x63>
+ 1e1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1e5:	3c 0d                	cmp    $0xd,%al
+ 1e7:	74 0e                	je     1f7 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1ec:	83 c0 01             	add    $0x1,%eax
+ 1ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 1f2:	7c af                	jl     1a3 <gets+0xf>
+ 1f4:	eb 01                	jmp    1f7 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 1f6:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 1f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1fa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1fd:	01 d0                	add    %edx,%eax
+ 1ff:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 202:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 205:	c9                   	leave  
+ 206:	c3                   	ret    
+
+00000207 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 207:	55                   	push   %ebp
+ 208:	89 e5                	mov    %esp,%ebp
+ 20a:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 20d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 214:	00 
+ 215:	8b 45 08             	mov    0x8(%ebp),%eax
+ 218:	89 04 24             	mov    %eax,(%esp)
+ 21b:	e8 04 01 00 00       	call   324 <open>
+ 220:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 223:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 227:	79 07                	jns    230 <stat+0x29>
+    return -1;
+ 229:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 22e:	eb 23                	jmp    253 <stat+0x4c>
+  r = fstat(fd, st);
+ 230:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 233:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 237:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 23a:	89 04 24             	mov    %eax,(%esp)
+ 23d:	e8 fa 00 00 00       	call   33c <fstat>
+ 242:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 245:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 248:	89 04 24             	mov    %eax,(%esp)
+ 24b:	e8 bc 00 00 00       	call   30c <close>
+  return r;
+ 250:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 253:	c9                   	leave  
+ 254:	c3                   	ret    
+
+00000255 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 255:	55                   	push   %ebp
+ 256:	89 e5                	mov    %esp,%ebp
+ 258:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 25b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 262:	eb 23                	jmp    287 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 264:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 267:	89 d0                	mov    %edx,%eax
+ 269:	c1 e0 02             	shl    $0x2,%eax
+ 26c:	01 d0                	add    %edx,%eax
+ 26e:	01 c0                	add    %eax,%eax
+ 270:	89 c2                	mov    %eax,%edx
+ 272:	8b 45 08             	mov    0x8(%ebp),%eax
+ 275:	0f b6 00             	movzbl (%eax),%eax
+ 278:	0f be c0             	movsbl %al,%eax
+ 27b:	01 d0                	add    %edx,%eax
+ 27d:	83 e8 30             	sub    $0x30,%eax
+ 280:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 283:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 287:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28a:	0f b6 00             	movzbl (%eax),%eax
+ 28d:	3c 2f                	cmp    $0x2f,%al
+ 28f:	7e 0a                	jle    29b <atoi+0x46>
+ 291:	8b 45 08             	mov    0x8(%ebp),%eax
+ 294:	0f b6 00             	movzbl (%eax),%eax
+ 297:	3c 39                	cmp    $0x39,%al
+ 299:	7e c9                	jle    264 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 29b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 29e:	c9                   	leave  
+ 29f:	c3                   	ret    
+
+000002a0 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 2a0:	55                   	push   %ebp
+ 2a1:	89 e5                	mov    %esp,%ebp
+ 2a3:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 2a6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2ac:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2af:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2b2:	eb 13                	jmp    2c7 <memmove+0x27>
+    *dst++ = *src++;
+ 2b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 2b7:	0f b6 10             	movzbl (%eax),%edx
+ 2ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2bd:	88 10                	mov    %dl,(%eax)
+ 2bf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 2c3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2c7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 2cb:	0f 9f c0             	setg   %al
+ 2ce:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 2d2:	84 c0                	test   %al,%al
+ 2d4:	75 de                	jne    2b4 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 2d6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2d9:	c9                   	leave  
+ 2da:	c3                   	ret    
+ 2db:	90                   	nop
+
+000002dc <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2dc:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2e1:	cd 40                	int    $0x40
+ 2e3:	c3                   	ret    
+
+000002e4 <exit>:
+SYSCALL(exit)
+ 2e4:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2e9:	cd 40                	int    $0x40
+ 2eb:	c3                   	ret    
+
+000002ec <wait>:
+SYSCALL(wait)
+ 2ec:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2f1:	cd 40                	int    $0x40
+ 2f3:	c3                   	ret    
+
+000002f4 <pipe>:
+SYSCALL(pipe)
+ 2f4:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2f9:	cd 40                	int    $0x40
+ 2fb:	c3                   	ret    
+
+000002fc <read>:
+SYSCALL(read)
+ 2fc:	b8 05 00 00 00       	mov    $0x5,%eax
+ 301:	cd 40                	int    $0x40
+ 303:	c3                   	ret    
+
+00000304 <write>:
+SYSCALL(write)
+ 304:	b8 10 00 00 00       	mov    $0x10,%eax
+ 309:	cd 40                	int    $0x40
+ 30b:	c3                   	ret    
+
+0000030c <close>:
+SYSCALL(close)
+ 30c:	b8 15 00 00 00       	mov    $0x15,%eax
+ 311:	cd 40                	int    $0x40
+ 313:	c3                   	ret    
+
+00000314 <kill>:
+SYSCALL(kill)
+ 314:	b8 06 00 00 00       	mov    $0x6,%eax
+ 319:	cd 40                	int    $0x40
+ 31b:	c3                   	ret    
+
+0000031c <exec>:
+SYSCALL(exec)
+ 31c:	b8 07 00 00 00       	mov    $0x7,%eax
+ 321:	cd 40                	int    $0x40
+ 323:	c3                   	ret    
+
+00000324 <open>:
+SYSCALL(open)
+ 324:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 329:	cd 40                	int    $0x40
+ 32b:	c3                   	ret    
+
+0000032c <mknod>:
+SYSCALL(mknod)
+ 32c:	b8 11 00 00 00       	mov    $0x11,%eax
+ 331:	cd 40                	int    $0x40
+ 333:	c3                   	ret    
+
+00000334 <unlink>:
+SYSCALL(unlink)
+ 334:	b8 12 00 00 00       	mov    $0x12,%eax
+ 339:	cd 40                	int    $0x40
+ 33b:	c3                   	ret    
+
+0000033c <fstat>:
+SYSCALL(fstat)
+ 33c:	b8 08 00 00 00       	mov    $0x8,%eax
+ 341:	cd 40                	int    $0x40
+ 343:	c3                   	ret    
+
+00000344 <link>:
+SYSCALL(link)
+ 344:	b8 13 00 00 00       	mov    $0x13,%eax
+ 349:	cd 40                	int    $0x40
+ 34b:	c3                   	ret    
+
+0000034c <mkdir>:
+SYSCALL(mkdir)
+ 34c:	b8 14 00 00 00       	mov    $0x14,%eax
+ 351:	cd 40                	int    $0x40
+ 353:	c3                   	ret    
+
+00000354 <chdir>:
+SYSCALL(chdir)
+ 354:	b8 09 00 00 00       	mov    $0x9,%eax
+ 359:	cd 40                	int    $0x40
+ 35b:	c3                   	ret    
+
+0000035c <dup>:
+SYSCALL(dup)
+ 35c:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 361:	cd 40                	int    $0x40
+ 363:	c3                   	ret    
+
+00000364 <getpid>:
+SYSCALL(getpid)
+ 364:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 369:	cd 40                	int    $0x40
+ 36b:	c3                   	ret    
+
+0000036c <sbrk>:
+SYSCALL(sbrk)
+ 36c:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 371:	cd 40                	int    $0x40
+ 373:	c3                   	ret    
+
+00000374 <sleep>:
+SYSCALL(sleep)
+ 374:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 379:	cd 40                	int    $0x40
+ 37b:	c3                   	ret    
+
+0000037c <uptime>:
+SYSCALL(uptime)
+ 37c:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 381:	cd 40                	int    $0x40
+ 383:	c3                   	ret    
+
+00000384 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 384:	b8 16 00 00 00       	mov    $0x16,%eax
+ 389:	cd 40                	int    $0x40
+ 38b:	c3                   	ret    
+
+0000038c <shutdown>:
+SYSCALL(shutdown)
+ 38c:	b8 17 00 00 00       	mov    $0x17,%eax
+ 391:	cd 40                	int    $0x40
+ 393:	c3                   	ret    
+
+00000394 <fork_winner>:
+SYSCALL(fork_winner)
+ 394:	b8 18 00 00 00       	mov    $0x18,%eax
+ 399:	cd 40                	int    $0x40
+ 39b:	c3                   	ret    
+
+0000039c <set_sched>:
+SYSCALL(set_sched)
+ 39c:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3a1:	cd 40                	int    $0x40
+ 3a3:	c3                   	ret    
+
+000003a4 <set_priority>:
+SYSCALL(set_priority)
+ 3a4:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3a9:	cd 40                	int    $0x40
+ 3ab:	c3                   	ret    
+
+000003ac <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3ac:	55                   	push   %ebp
+ 3ad:	89 e5                	mov    %esp,%ebp
+ 3af:	83 ec 28             	sub    $0x28,%esp
+ 3b2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3b5:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3b8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 3bf:	00 
+ 3c0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3c3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 3c7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3ca:	89 04 24             	mov    %eax,(%esp)
+ 3cd:	e8 32 ff ff ff       	call   304 <write>
+}
+ 3d2:	c9                   	leave  
+ 3d3:	c3                   	ret    
+
+000003d4 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3d4:	55                   	push   %ebp
+ 3d5:	89 e5                	mov    %esp,%ebp
+ 3d7:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3e1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3e5:	74 17                	je     3fe <printint+0x2a>
+ 3e7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3eb:	79 11                	jns    3fe <printint+0x2a>
+    neg = 1;
+ 3ed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 3f4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3f7:	f7 d8                	neg    %eax
+ 3f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3fc:	eb 06                	jmp    404 <printint+0x30>
+  } else {
+    x = xx;
+ 3fe:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 401:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 404:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 40b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 40e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 411:	ba 00 00 00 00       	mov    $0x0,%edx
+ 416:	f7 f1                	div    %ecx
+ 418:	89 d0                	mov    %edx,%eax
+ 41a:	0f b6 80 c4 0a 00 00 	movzbl 0xac4(%eax),%eax
+ 421:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 424:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 427:	01 ca                	add    %ecx,%edx
+ 429:	88 02                	mov    %al,(%edx)
+ 42b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 42f:	8b 55 10             	mov    0x10(%ebp),%edx
+ 432:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 435:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 438:	ba 00 00 00 00       	mov    $0x0,%edx
+ 43d:	f7 75 d4             	divl   -0x2c(%ebp)
+ 440:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 443:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 447:	75 c2                	jne    40b <printint+0x37>
+  if(neg)
+ 449:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 44d:	74 2e                	je     47d <printint+0xa9>
+    buf[i++] = '-';
+ 44f:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 452:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 455:	01 d0                	add    %edx,%eax
+ 457:	c6 00 2d             	movb   $0x2d,(%eax)
+ 45a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 45e:	eb 1d                	jmp    47d <printint+0xa9>
+    putc(fd, buf[i]);
+ 460:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 463:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 466:	01 d0                	add    %edx,%eax
+ 468:	0f b6 00             	movzbl (%eax),%eax
+ 46b:	0f be c0             	movsbl %al,%eax
+ 46e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 472:	8b 45 08             	mov    0x8(%ebp),%eax
+ 475:	89 04 24             	mov    %eax,(%esp)
+ 478:	e8 2f ff ff ff       	call   3ac <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 47d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 481:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 485:	79 d9                	jns    460 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 487:	c9                   	leave  
+ 488:	c3                   	ret    
+
+00000489 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 489:	55                   	push   %ebp
+ 48a:	89 e5                	mov    %esp,%ebp
+ 48c:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 48f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 496:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 499:	83 c0 04             	add    $0x4,%eax
+ 49c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 49f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4a6:	e9 7d 01 00 00       	jmp    628 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 4ab:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4b1:	01 d0                	add    %edx,%eax
+ 4b3:	0f b6 00             	movzbl (%eax),%eax
+ 4b6:	0f be c0             	movsbl %al,%eax
+ 4b9:	25 ff 00 00 00       	and    $0xff,%eax
+ 4be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4c1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4c5:	75 2c                	jne    4f3 <printf+0x6a>
+      if(c == '%'){
+ 4c7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4cb:	75 0c                	jne    4d9 <printf+0x50>
+        state = '%';
+ 4cd:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4d4:	e9 4b 01 00 00       	jmp    624 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 4d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4dc:	0f be c0             	movsbl %al,%eax
+ 4df:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4e3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4e6:	89 04 24             	mov    %eax,(%esp)
+ 4e9:	e8 be fe ff ff       	call   3ac <putc>
+ 4ee:	e9 31 01 00 00       	jmp    624 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 4f3:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 4f7:	0f 85 27 01 00 00    	jne    624 <printf+0x19b>
+      if(c == 'd'){
+ 4fd:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 501:	75 2d                	jne    530 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 503:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 506:	8b 00                	mov    (%eax),%eax
+ 508:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 50f:	00 
+ 510:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 517:	00 
+ 518:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 51c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 51f:	89 04 24             	mov    %eax,(%esp)
+ 522:	e8 ad fe ff ff       	call   3d4 <printint>
+        ap++;
+ 527:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 52b:	e9 ed 00 00 00       	jmp    61d <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 530:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 534:	74 06                	je     53c <printf+0xb3>
+ 536:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 53a:	75 2d                	jne    569 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 53c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 53f:	8b 00                	mov    (%eax),%eax
+ 541:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 548:	00 
+ 549:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 550:	00 
+ 551:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 555:	8b 45 08             	mov    0x8(%ebp),%eax
+ 558:	89 04 24             	mov    %eax,(%esp)
+ 55b:	e8 74 fe ff ff       	call   3d4 <printint>
+        ap++;
+ 560:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 564:	e9 b4 00 00 00       	jmp    61d <printf+0x194>
+      } else if(c == 's'){
+ 569:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 56d:	75 46                	jne    5b5 <printf+0x12c>
+        s = (char*)*ap;
+ 56f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 572:	8b 00                	mov    (%eax),%eax
+ 574:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 577:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 57b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 57f:	75 27                	jne    5a8 <printf+0x11f>
+          s = "(null)";
+ 581:	c7 45 f4 80 08 00 00 	movl   $0x880,-0xc(%ebp)
+        while(*s != 0){
+ 588:	eb 1e                	jmp    5a8 <printf+0x11f>
+          putc(fd, *s);
+ 58a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 58d:	0f b6 00             	movzbl (%eax),%eax
+ 590:	0f be c0             	movsbl %al,%eax
+ 593:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 597:	8b 45 08             	mov    0x8(%ebp),%eax
+ 59a:	89 04 24             	mov    %eax,(%esp)
+ 59d:	e8 0a fe ff ff       	call   3ac <putc>
+          s++;
+ 5a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 5a6:	eb 01                	jmp    5a9 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 5a8:	90                   	nop
+ 5a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5ac:	0f b6 00             	movzbl (%eax),%eax
+ 5af:	84 c0                	test   %al,%al
+ 5b1:	75 d7                	jne    58a <printf+0x101>
+ 5b3:	eb 68                	jmp    61d <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5b5:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5b9:	75 1d                	jne    5d8 <printf+0x14f>
+        putc(fd, *ap);
+ 5bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5be:	8b 00                	mov    (%eax),%eax
+ 5c0:	0f be c0             	movsbl %al,%eax
+ 5c3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5c7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ca:	89 04 24             	mov    %eax,(%esp)
+ 5cd:	e8 da fd ff ff       	call   3ac <putc>
+        ap++;
+ 5d2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5d6:	eb 45                	jmp    61d <printf+0x194>
+      } else if(c == '%'){
+ 5d8:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5dc:	75 17                	jne    5f5 <printf+0x16c>
+        putc(fd, c);
+ 5de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5e1:	0f be c0             	movsbl %al,%eax
+ 5e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5e8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5eb:	89 04 24             	mov    %eax,(%esp)
+ 5ee:	e8 b9 fd ff ff       	call   3ac <putc>
+ 5f3:	eb 28                	jmp    61d <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5f5:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 5fc:	00 
+ 5fd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 600:	89 04 24             	mov    %eax,(%esp)
+ 603:	e8 a4 fd ff ff       	call   3ac <putc>
+        putc(fd, c);
+ 608:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 60b:	0f be c0             	movsbl %al,%eax
+ 60e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 612:	8b 45 08             	mov    0x8(%ebp),%eax
+ 615:	89 04 24             	mov    %eax,(%esp)
+ 618:	e8 8f fd ff ff       	call   3ac <putc>
+      }
+      state = 0;
+ 61d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 624:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 628:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 62b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 62e:	01 d0                	add    %edx,%eax
+ 630:	0f b6 00             	movzbl (%eax),%eax
+ 633:	84 c0                	test   %al,%al
+ 635:	0f 85 70 fe ff ff    	jne    4ab <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 63b:	c9                   	leave  
+ 63c:	c3                   	ret    
+ 63d:	90                   	nop
+ 63e:	90                   	nop
+ 63f:	90                   	nop
+
+00000640 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 640:	55                   	push   %ebp
+ 641:	89 e5                	mov    %esp,%ebp
+ 643:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 646:	8b 45 08             	mov    0x8(%ebp),%eax
+ 649:	83 e8 08             	sub    $0x8,%eax
+ 64c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 64f:	a1 e0 0a 00 00       	mov    0xae0,%eax
+ 654:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 657:	eb 24                	jmp    67d <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 659:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65c:	8b 00                	mov    (%eax),%eax
+ 65e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 661:	77 12                	ja     675 <free+0x35>
+ 663:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 666:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 669:	77 24                	ja     68f <free+0x4f>
+ 66b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 66e:	8b 00                	mov    (%eax),%eax
+ 670:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 673:	77 1a                	ja     68f <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 675:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 678:	8b 00                	mov    (%eax),%eax
+ 67a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 67d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 680:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 683:	76 d4                	jbe    659 <free+0x19>
+ 685:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 688:	8b 00                	mov    (%eax),%eax
+ 68a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 68d:	76 ca                	jbe    659 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 68f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 692:	8b 40 04             	mov    0x4(%eax),%eax
+ 695:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 69c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69f:	01 c2                	add    %eax,%edx
+ 6a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a4:	8b 00                	mov    (%eax),%eax
+ 6a6:	39 c2                	cmp    %eax,%edx
+ 6a8:	75 24                	jne    6ce <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 6aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ad:	8b 50 04             	mov    0x4(%eax),%edx
+ 6b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b3:	8b 00                	mov    (%eax),%eax
+ 6b5:	8b 40 04             	mov    0x4(%eax),%eax
+ 6b8:	01 c2                	add    %eax,%edx
+ 6ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6bd:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c3:	8b 00                	mov    (%eax),%eax
+ 6c5:	8b 10                	mov    (%eax),%edx
+ 6c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ca:	89 10                	mov    %edx,(%eax)
+ 6cc:	eb 0a                	jmp    6d8 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d1:	8b 10                	mov    (%eax),%edx
+ 6d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6d6:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6db:	8b 40 04             	mov    0x4(%eax),%eax
+ 6de:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e8:	01 d0                	add    %edx,%eax
+ 6ea:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 6ed:	75 20                	jne    70f <free+0xcf>
+    p->s.size += bp->s.size;
+ 6ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f2:	8b 50 04             	mov    0x4(%eax),%edx
+ 6f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f8:	8b 40 04             	mov    0x4(%eax),%eax
+ 6fb:	01 c2                	add    %eax,%edx
+ 6fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 700:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 703:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 706:	8b 10                	mov    (%eax),%edx
+ 708:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 70b:	89 10                	mov    %edx,(%eax)
+ 70d:	eb 08                	jmp    717 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 70f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 712:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 715:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 717:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71a:	a3 e0 0a 00 00       	mov    %eax,0xae0
+}
+ 71f:	c9                   	leave  
+ 720:	c3                   	ret    
+
+00000721 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 721:	55                   	push   %ebp
+ 722:	89 e5                	mov    %esp,%ebp
+ 724:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 727:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 72e:	77 07                	ja     737 <morecore+0x16>
+    nu = 4096;
+ 730:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 737:	8b 45 08             	mov    0x8(%ebp),%eax
+ 73a:	c1 e0 03             	shl    $0x3,%eax
+ 73d:	89 04 24             	mov    %eax,(%esp)
+ 740:	e8 27 fc ff ff       	call   36c <sbrk>
+ 745:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 748:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 74c:	75 07                	jne    755 <morecore+0x34>
+    return 0;
+ 74e:	b8 00 00 00 00       	mov    $0x0,%eax
+ 753:	eb 22                	jmp    777 <morecore+0x56>
+  hp = (Header*)p;
+ 755:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 758:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 75b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 75e:	8b 55 08             	mov    0x8(%ebp),%edx
+ 761:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 764:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 767:	83 c0 08             	add    $0x8,%eax
+ 76a:	89 04 24             	mov    %eax,(%esp)
+ 76d:	e8 ce fe ff ff       	call   640 <free>
+  return freep;
+ 772:	a1 e0 0a 00 00       	mov    0xae0,%eax
+}
+ 777:	c9                   	leave  
+ 778:	c3                   	ret    
+
+00000779 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 779:	55                   	push   %ebp
+ 77a:	89 e5                	mov    %esp,%ebp
+ 77c:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 77f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 782:	83 c0 07             	add    $0x7,%eax
+ 785:	c1 e8 03             	shr    $0x3,%eax
+ 788:	83 c0 01             	add    $0x1,%eax
+ 78b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 78e:	a1 e0 0a 00 00       	mov    0xae0,%eax
+ 793:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 796:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 79a:	75 23                	jne    7bf <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 79c:	c7 45 f0 d8 0a 00 00 	movl   $0xad8,-0x10(%ebp)
+ 7a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7a6:	a3 e0 0a 00 00       	mov    %eax,0xae0
+ 7ab:	a1 e0 0a 00 00       	mov    0xae0,%eax
+ 7b0:	a3 d8 0a 00 00       	mov    %eax,0xad8
+    base.s.size = 0;
+ 7b5:	c7 05 dc 0a 00 00 00 	movl   $0x0,0xadc
+ 7bc:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c2:	8b 00                	mov    (%eax),%eax
+ 7c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ca:	8b 40 04             	mov    0x4(%eax),%eax
+ 7cd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7d0:	72 4d                	jb     81f <malloc+0xa6>
+      if(p->s.size == nunits)
+ 7d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d5:	8b 40 04             	mov    0x4(%eax),%eax
+ 7d8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7db:	75 0c                	jne    7e9 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 7dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e0:	8b 10                	mov    (%eax),%edx
+ 7e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e5:	89 10                	mov    %edx,(%eax)
+ 7e7:	eb 26                	jmp    80f <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 7e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ec:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ef:	89 c2                	mov    %eax,%edx
+ 7f1:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 7f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f7:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fd:	8b 40 04             	mov    0x4(%eax),%eax
+ 800:	c1 e0 03             	shl    $0x3,%eax
+ 803:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 806:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 809:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 80c:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 80f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 812:	a3 e0 0a 00 00       	mov    %eax,0xae0
+      return (void*)(p + 1);
+ 817:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81a:	83 c0 08             	add    $0x8,%eax
+ 81d:	eb 38                	jmp    857 <malloc+0xde>
+    }
+    if(p == freep)
+ 81f:	a1 e0 0a 00 00       	mov    0xae0,%eax
+ 824:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 827:	75 1b                	jne    844 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 829:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 82c:	89 04 24             	mov    %eax,(%esp)
+ 82f:	e8 ed fe ff ff       	call   721 <morecore>
+ 834:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 837:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 83b:	75 07                	jne    844 <malloc+0xcb>
+        return 0;
+ 83d:	b8 00 00 00 00       	mov    $0x0,%eax
+ 842:	eb 13                	jmp    857 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 844:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 847:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 84a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 84d:	8b 00                	mov    (%eax),%eax
+ 84f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 852:	e9 70 ff ff ff       	jmp    7c7 <malloc+0x4e>
+}
+ 857:	c9                   	leave  
+ 858:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/ln.d cs550-16s-proj1-working/ln.d
--- cs550-16s-proj1-base/ln.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ln.d	2016-03-04 14:37:00.000000000 -0500
@@ -0,0 +1 @@
+ln.o: ln.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/ln.o and cs550-16s-proj1-working/ln.o differ
diff -uNr cs550-16s-proj1-base/ln.sym cs550-16s-proj1-working/ln.sym
--- cs550-16s-proj1-base/ln.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ln.sym	2016-03-04 14:37:01.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+00000859 .rodata
+00000888 .eh_frame
+00000ac4 .data
+00000ad8 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 ln.c
+00000000 ulib.c
+0000007c stosb
+00000000 printf.c
+000003ac putc
+000003d4 printint
+00000ac4 digits.1028
+00000000 umalloc.c
+00000ad8 base
+00000ae0 freep
+00000721 morecore
+000000a1 strcpy
+00000489 printf
+000002a0 memmove
+0000032c mknod
+00000194 gets
+00000364 getpid
+00000779 malloc
+00000374 sleep
+000003a4 set_priority
+000002f4 pipe
+00000304 write
+0000033c fstat
+00000314 kill
+00000354 chdir
+0000031c exec
+000002ec wait
+000002fc read
+00000334 unlink
+000002dc fork
+0000036c sbrk
+0000037c uptime
+00000ad8 __bss_start
+0000013d memset
+00000000 main
+00000384 enable_sched_trace
+000000d5 strcmp
+0000038c shutdown
+0000035c dup
+0000039c set_sched
+00000207 stat
+00000ad8 _edata
+00000ae4 _end
+00000344 link
+000002e4 exit
+00000255 atoi
+00000394 fork_winner
+00000116 strlen
+00000324 open
+00000161 strchr
+0000034c mkdir
+0000030c close
+00000640 free
diff -uNr cs550-16s-proj1-base/log.c cs550-16s-proj1-working/log.c
--- cs550-16s-proj1-base/log.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/log.c	2016-03-04 14:36:40.000000000 -0500
@@ -21,7 +21,7 @@
 //
 // The log is a physical re-do log containing disk blocks.
 // The on-disk log format:
-//   header block, containing block #s for block A, B, C, ...
+//   header block, containing sector #s for block A, B, C, ...
 //   block A
 //   block B
 //   block C
@@ -29,10 +29,10 @@
 // Log appends are synchronous.
 
 // Contents of the header block, used for both the on-disk header block
-// and to keep track in memory of logged block# before commit.
+// and to keep track in memory of logged sector #s before commit.
 struct logheader {
   int n;   
-  int block[LOGSIZE];
+  int sector[LOGSIZE];
 };
 
 struct log {
@@ -50,17 +50,17 @@
 static void commit();
 
 void
-initlog(int dev)
+initlog(void)
 {
   if (sizeof(struct logheader) >= BSIZE)
     panic("initlog: too big logheader");
 
   struct superblock sb;
   initlock(&log.lock, "log");
-  readsb(dev, &sb);
-  log.start = sb.logstart;
+  readsb(ROOTDEV, &sb);
+  log.start = sb.size - sb.nlog;
   log.size = sb.nlog;
-  log.dev = dev;
+  log.dev = ROOTDEV;
   recover_from_log();
 }
 
@@ -72,7 +72,7 @@
 
   for (tail = 0; tail < log.lh.n; tail++) {
     struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+    struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); // read dst
     memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
     bwrite(dbuf);  // write dst to disk
     brelse(lbuf); 
@@ -89,7 +89,7 @@
   int i;
   log.lh.n = lh->n;
   for (i = 0; i < log.lh.n; i++) {
-    log.lh.block[i] = lh->block[i];
+    log.lh.sector[i] = lh->sector[i];
   }
   brelse(buf);
 }
@@ -105,7 +105,7 @@
   int i;
   hb->n = log.lh.n;
   for (i = 0; i < log.lh.n; i++) {
-    hb->block[i] = log.lh.block[i];
+    hb->sector[i] = log.lh.sector[i];
   }
   bwrite(buf);
   brelse(buf);
@@ -178,7 +178,7 @@
 
   for (tail = 0; tail < log.lh.n; tail++) {
     struct buf *to = bread(log.dev, log.start+tail+1); // log block
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+    struct buf *from = bread(log.dev, log.lh.sector[tail]); // cache block
     memmove(to->data, from->data, BSIZE);
     bwrite(to);  // write the log
     brelse(from); 
@@ -217,15 +217,13 @@
   if (log.outstanding < 1)
     panic("log_write outside of trans");
 
-  acquire(&log.lock);
   for (i = 0; i < log.lh.n; i++) {
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
+    if (log.lh.sector[i] == b->sector)   // log absorbtion
       break;
   }
-  log.lh.block[i] = b->blockno;
+  log.lh.sector[i] = b->sector;
   if (i == log.lh.n)
     log.lh.n++;
   b->flags |= B_DIRTY; // prevent eviction
-  release(&log.lock);
 }
 
diff -uNr cs550-16s-proj1-base/log.d cs550-16s-proj1-working/log.d
--- cs550-16s-proj1-base/log.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/log.d	2016-03-04 14:37:20.000000000 -0500
@@ -0,0 +1 @@
+log.o: log.c types.h defs.h param.h spinlock.h fs.h buf.h
Binary files cs550-16s-proj1-base/log.o and cs550-16s-proj1-working/log.o differ
Binary files cs550-16s-proj1-base/_ls and cs550-16s-proj1-working/_ls differ
diff -uNr cs550-16s-proj1-base/ls.asm cs550-16s-proj1-working/ls.asm
--- cs550-16s-proj1-base/ls.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ls.asm	2016-03-04 14:37:02.000000000 -0500
@@ -0,0 +1,1502 @@
+
+_ls:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <fmtname>:
+#include "user.h"
+#include "fs.h"
+
+char*
+fmtname(char *path)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	53                   	push   %ebx
+   4:	83 ec 24             	sub    $0x24,%esp
+  static char buf[DIRSIZ+1];
+  char *p;
+  
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+   7:	8b 45 08             	mov    0x8(%ebp),%eax
+   a:	89 04 24             	mov    %eax,(%esp)
+   d:	e8 e4 03 00 00       	call   3f6 <strlen>
+  12:	8b 55 08             	mov    0x8(%ebp),%edx
+  15:	01 d0                	add    %edx,%eax
+  17:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  1a:	eb 04                	jmp    20 <fmtname+0x20>
+  1c:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  20:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  23:	3b 45 08             	cmp    0x8(%ebp),%eax
+  26:	72 0a                	jb     32 <fmtname+0x32>
+  28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  2b:	0f b6 00             	movzbl (%eax),%eax
+  2e:	3c 2f                	cmp    $0x2f,%al
+  30:	75 ea                	jne    1c <fmtname+0x1c>
+    ;
+  p++;
+  32:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  
+  // Return blank-padded name.
+  if(strlen(p) >= DIRSIZ)
+  36:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  39:	89 04 24             	mov    %eax,(%esp)
+  3c:	e8 b5 03 00 00       	call   3f6 <strlen>
+  41:	83 f8 0d             	cmp    $0xd,%eax
+  44:	76 05                	jbe    4b <fmtname+0x4b>
+    return p;
+  46:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  49:	eb 5f                	jmp    aa <fmtname+0xaa>
+  memmove(buf, p, strlen(p));
+  4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  4e:	89 04 24             	mov    %eax,(%esp)
+  51:	e8 a0 03 00 00       	call   3f6 <strlen>
+  56:	89 44 24 08          	mov    %eax,0x8(%esp)
+  5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  5d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  61:	c7 04 24 30 0e 00 00 	movl   $0xe30,(%esp)
+  68:	e8 13 05 00 00       	call   580 <memmove>
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  70:	89 04 24             	mov    %eax,(%esp)
+  73:	e8 7e 03 00 00       	call   3f6 <strlen>
+  78:	ba 0e 00 00 00       	mov    $0xe,%edx
+  7d:	89 d3                	mov    %edx,%ebx
+  7f:	29 c3                	sub    %eax,%ebx
+  81:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  84:	89 04 24             	mov    %eax,(%esp)
+  87:	e8 6a 03 00 00       	call   3f6 <strlen>
+  8c:	05 30 0e 00 00       	add    $0xe30,%eax
+  91:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  95:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
+  9c:	00 
+  9d:	89 04 24             	mov    %eax,(%esp)
+  a0:	e8 78 03 00 00       	call   41d <memset>
+  return buf;
+  a5:	b8 30 0e 00 00       	mov    $0xe30,%eax
+}
+  aa:	83 c4 24             	add    $0x24,%esp
+  ad:	5b                   	pop    %ebx
+  ae:	5d                   	pop    %ebp
+  af:	c3                   	ret    
+
+000000b0 <ls>:
+
+void
+ls(char *path)
+{
+  b0:	55                   	push   %ebp
+  b1:	89 e5                	mov    %esp,%ebp
+  b3:	57                   	push   %edi
+  b4:	56                   	push   %esi
+  b5:	53                   	push   %ebx
+  b6:	81 ec 5c 02 00 00    	sub    $0x25c,%esp
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+  
+  if((fd = open(path, 0)) < 0){
+  bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  c3:	00 
+  c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  c7:	89 04 24             	mov    %eax,(%esp)
+  ca:	e8 35 05 00 00       	call   604 <open>
+  cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  d2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  d6:	79 20                	jns    f8 <ls+0x48>
+    printf(2, "ls: cannot open %s\n", path);
+  d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  db:	89 44 24 08          	mov    %eax,0x8(%esp)
+  df:	c7 44 24 04 39 0b 00 	movl   $0xb39,0x4(%esp)
+  e6:	00 
+  e7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  ee:	e8 76 06 00 00       	call   769 <printf>
+  f3:	e9 01 02 00 00       	jmp    2f9 <ls+0x249>
+    return;
+  }
+  
+  if(fstat(fd, &st) < 0){
+  f8:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+  fe:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 102:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 105:	89 04 24             	mov    %eax,(%esp)
+ 108:	e8 0f 05 00 00       	call   61c <fstat>
+ 10d:	85 c0                	test   %eax,%eax
+ 10f:	79 2b                	jns    13c <ls+0x8c>
+    printf(2, "ls: cannot stat %s\n", path);
+ 111:	8b 45 08             	mov    0x8(%ebp),%eax
+ 114:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 118:	c7 44 24 04 4d 0b 00 	movl   $0xb4d,0x4(%esp)
+ 11f:	00 
+ 120:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+ 127:	e8 3d 06 00 00       	call   769 <printf>
+    close(fd);
+ 12c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 12f:	89 04 24             	mov    %eax,(%esp)
+ 132:	e8 b5 04 00 00       	call   5ec <close>
+ 137:	e9 bd 01 00 00       	jmp    2f9 <ls+0x249>
+    return;
+  }
+  
+  switch(st.type){
+ 13c:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
+ 143:	98                   	cwtl   
+ 144:	83 f8 01             	cmp    $0x1,%eax
+ 147:	74 53                	je     19c <ls+0xec>
+ 149:	83 f8 02             	cmp    $0x2,%eax
+ 14c:	0f 85 9c 01 00 00    	jne    2ee <ls+0x23e>
+  case T_FILE:
+    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+ 152:	8b bd cc fd ff ff    	mov    -0x234(%ebp),%edi
+ 158:	8b b5 c4 fd ff ff    	mov    -0x23c(%ebp),%esi
+ 15e:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
+ 165:	0f bf d8             	movswl %ax,%ebx
+ 168:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16b:	89 04 24             	mov    %eax,(%esp)
+ 16e:	e8 8d fe ff ff       	call   0 <fmtname>
+ 173:	89 7c 24 14          	mov    %edi,0x14(%esp)
+ 177:	89 74 24 10          	mov    %esi,0x10(%esp)
+ 17b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+ 17f:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 183:	c7 44 24 04 61 0b 00 	movl   $0xb61,0x4(%esp)
+ 18a:	00 
+ 18b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 192:	e8 d2 05 00 00       	call   769 <printf>
+    break;
+ 197:	e9 52 01 00 00       	jmp    2ee <ls+0x23e>
+  
+  case T_DIR:
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+ 19c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 19f:	89 04 24             	mov    %eax,(%esp)
+ 1a2:	e8 4f 02 00 00       	call   3f6 <strlen>
+ 1a7:	83 c0 10             	add    $0x10,%eax
+ 1aa:	3d 00 02 00 00       	cmp    $0x200,%eax
+ 1af:	76 19                	jbe    1ca <ls+0x11a>
+      printf(1, "ls: path too long\n");
+ 1b1:	c7 44 24 04 6e 0b 00 	movl   $0xb6e,0x4(%esp)
+ 1b8:	00 
+ 1b9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 1c0:	e8 a4 05 00 00       	call   769 <printf>
+      break;
+ 1c5:	e9 24 01 00 00       	jmp    2ee <ls+0x23e>
+    }
+    strcpy(buf, path);
+ 1ca:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1cd:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1d1:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 1d7:	89 04 24             	mov    %eax,(%esp)
+ 1da:	e8 a2 01 00 00       	call   381 <strcpy>
+    p = buf+strlen(buf);
+ 1df:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 1e5:	89 04 24             	mov    %eax,(%esp)
+ 1e8:	e8 09 02 00 00       	call   3f6 <strlen>
+ 1ed:	8d 95 e0 fd ff ff    	lea    -0x220(%ebp),%edx
+ 1f3:	01 d0                	add    %edx,%eax
+ 1f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    *p++ = '/';
+ 1f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+ 1fb:	c6 00 2f             	movb   $0x2f,(%eax)
+ 1fe:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 202:	e9 c0 00 00 00       	jmp    2c7 <ls+0x217>
+      if(de.inum == 0)
+ 207:	0f b7 85 d0 fd ff ff 	movzwl -0x230(%ebp),%eax
+ 20e:	66 85 c0             	test   %ax,%ax
+ 211:	0f 84 af 00 00 00    	je     2c6 <ls+0x216>
+        continue;
+      memmove(p, de.name, DIRSIZ);
+ 217:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+ 21e:	00 
+ 21f:	8d 85 d0 fd ff ff    	lea    -0x230(%ebp),%eax
+ 225:	83 c0 02             	add    $0x2,%eax
+ 228:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 22c:	8b 45 e0             	mov    -0x20(%ebp),%eax
+ 22f:	89 04 24             	mov    %eax,(%esp)
+ 232:	e8 49 03 00 00       	call   580 <memmove>
+      p[DIRSIZ] = 0;
+ 237:	8b 45 e0             	mov    -0x20(%ebp),%eax
+ 23a:	83 c0 0e             	add    $0xe,%eax
+ 23d:	c6 00 00             	movb   $0x0,(%eax)
+      if(stat(buf, &st) < 0){
+ 240:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+ 246:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 24a:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 250:	89 04 24             	mov    %eax,(%esp)
+ 253:	e8 8f 02 00 00       	call   4e7 <stat>
+ 258:	85 c0                	test   %eax,%eax
+ 25a:	79 20                	jns    27c <ls+0x1cc>
+        printf(1, "ls: cannot stat %s\n", buf);
+ 25c:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 262:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 266:	c7 44 24 04 4d 0b 00 	movl   $0xb4d,0x4(%esp)
+ 26d:	00 
+ 26e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 275:	e8 ef 04 00 00       	call   769 <printf>
+        continue;
+ 27a:	eb 4b                	jmp    2c7 <ls+0x217>
+      }
+      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+ 27c:	8b bd cc fd ff ff    	mov    -0x234(%ebp),%edi
+ 282:	8b b5 c4 fd ff ff    	mov    -0x23c(%ebp),%esi
+ 288:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
+ 28f:	0f bf d8             	movswl %ax,%ebx
+ 292:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 298:	89 04 24             	mov    %eax,(%esp)
+ 29b:	e8 60 fd ff ff       	call   0 <fmtname>
+ 2a0:	89 7c 24 14          	mov    %edi,0x14(%esp)
+ 2a4:	89 74 24 10          	mov    %esi,0x10(%esp)
+ 2a8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+ 2ac:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 2b0:	c7 44 24 04 61 0b 00 	movl   $0xb61,0x4(%esp)
+ 2b7:	00 
+ 2b8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 2bf:	e8 a5 04 00 00       	call   769 <printf>
+ 2c4:	eb 01                	jmp    2c7 <ls+0x217>
+    strcpy(buf, path);
+    p = buf+strlen(buf);
+    *p++ = '/';
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+      if(de.inum == 0)
+        continue;
+ 2c6:	90                   	nop
+      break;
+    }
+    strcpy(buf, path);
+    p = buf+strlen(buf);
+    *p++ = '/';
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 2c7:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 2ce:	00 
+ 2cf:	8d 85 d0 fd ff ff    	lea    -0x230(%ebp),%eax
+ 2d5:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 2dc:	89 04 24             	mov    %eax,(%esp)
+ 2df:	e8 f8 02 00 00       	call   5dc <read>
+ 2e4:	83 f8 10             	cmp    $0x10,%eax
+ 2e7:	0f 84 1a ff ff ff    	je     207 <ls+0x157>
+        printf(1, "ls: cannot stat %s\n", buf);
+        continue;
+      }
+      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+    }
+    break;
+ 2ed:	90                   	nop
+  }
+  close(fd);
+ 2ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 2f1:	89 04 24             	mov    %eax,(%esp)
+ 2f4:	e8 f3 02 00 00       	call   5ec <close>
+}
+ 2f9:	81 c4 5c 02 00 00    	add    $0x25c,%esp
+ 2ff:	5b                   	pop    %ebx
+ 300:	5e                   	pop    %esi
+ 301:	5f                   	pop    %edi
+ 302:	5d                   	pop    %ebp
+ 303:	c3                   	ret    
+
+00000304 <main>:
+
+int
+main(int argc, char *argv[])
+{
+ 304:	55                   	push   %ebp
+ 305:	89 e5                	mov    %esp,%ebp
+ 307:	83 e4 f0             	and    $0xfffffff0,%esp
+ 30a:	83 ec 20             	sub    $0x20,%esp
+  int i;
+
+  if(argc < 2){
+ 30d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+ 311:	7f 11                	jg     324 <main+0x20>
+    ls(".");
+ 313:	c7 04 24 81 0b 00 00 	movl   $0xb81,(%esp)
+ 31a:	e8 91 fd ff ff       	call   b0 <ls>
+    exit();
+ 31f:	e8 a0 02 00 00       	call   5c4 <exit>
+  }
+  for(i=1; i<argc; i++)
+ 324:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+ 32b:	00 
+ 32c:	eb 1f                	jmp    34d <main+0x49>
+    ls(argv[i]);
+ 32e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 332:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 339:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 33c:	01 d0                	add    %edx,%eax
+ 33e:	8b 00                	mov    (%eax),%eax
+ 340:	89 04 24             	mov    %eax,(%esp)
+ 343:	e8 68 fd ff ff       	call   b0 <ls>
+
+  if(argc < 2){
+    ls(".");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+ 348:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+ 34d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 351:	3b 45 08             	cmp    0x8(%ebp),%eax
+ 354:	7c d8                	jl     32e <main+0x2a>
+    ls(argv[i]);
+  exit();
+ 356:	e8 69 02 00 00       	call   5c4 <exit>
+ 35b:	90                   	nop
+
+0000035c <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 35c:	55                   	push   %ebp
+ 35d:	89 e5                	mov    %esp,%ebp
+ 35f:	57                   	push   %edi
+ 360:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 361:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 364:	8b 55 10             	mov    0x10(%ebp),%edx
+ 367:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 36a:	89 cb                	mov    %ecx,%ebx
+ 36c:	89 df                	mov    %ebx,%edi
+ 36e:	89 d1                	mov    %edx,%ecx
+ 370:	fc                   	cld    
+ 371:	f3 aa                	rep stos %al,%es:(%edi)
+ 373:	89 ca                	mov    %ecx,%edx
+ 375:	89 fb                	mov    %edi,%ebx
+ 377:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 37a:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 37d:	5b                   	pop    %ebx
+ 37e:	5f                   	pop    %edi
+ 37f:	5d                   	pop    %ebp
+ 380:	c3                   	ret    
+
+00000381 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 381:	55                   	push   %ebp
+ 382:	89 e5                	mov    %esp,%ebp
+ 384:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 387:	8b 45 08             	mov    0x8(%ebp),%eax
+ 38a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 38d:	90                   	nop
+ 38e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 391:	0f b6 10             	movzbl (%eax),%edx
+ 394:	8b 45 08             	mov    0x8(%ebp),%eax
+ 397:	88 10                	mov    %dl,(%eax)
+ 399:	8b 45 08             	mov    0x8(%ebp),%eax
+ 39c:	0f b6 00             	movzbl (%eax),%eax
+ 39f:	84 c0                	test   %al,%al
+ 3a1:	0f 95 c0             	setne  %al
+ 3a4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 3a8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 3ac:	84 c0                	test   %al,%al
+ 3ae:	75 de                	jne    38e <strcpy+0xd>
+    ;
+  return os;
+ 3b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3b3:	c9                   	leave  
+ 3b4:	c3                   	ret    
+
+000003b5 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 3b5:	55                   	push   %ebp
+ 3b6:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 3b8:	eb 08                	jmp    3c2 <strcmp+0xd>
+    p++, q++;
+ 3ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 3be:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 3c2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3c5:	0f b6 00             	movzbl (%eax),%eax
+ 3c8:	84 c0                	test   %al,%al
+ 3ca:	74 10                	je     3dc <strcmp+0x27>
+ 3cc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3cf:	0f b6 10             	movzbl (%eax),%edx
+ 3d2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3d5:	0f b6 00             	movzbl (%eax),%eax
+ 3d8:	38 c2                	cmp    %al,%dl
+ 3da:	74 de                	je     3ba <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 3dc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3df:	0f b6 00             	movzbl (%eax),%eax
+ 3e2:	0f b6 d0             	movzbl %al,%edx
+ 3e5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3e8:	0f b6 00             	movzbl (%eax),%eax
+ 3eb:	0f b6 c0             	movzbl %al,%eax
+ 3ee:	89 d1                	mov    %edx,%ecx
+ 3f0:	29 c1                	sub    %eax,%ecx
+ 3f2:	89 c8                	mov    %ecx,%eax
+}
+ 3f4:	5d                   	pop    %ebp
+ 3f5:	c3                   	ret    
+
+000003f6 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 3f6:	55                   	push   %ebp
+ 3f7:	89 e5                	mov    %esp,%ebp
+ 3f9:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 3fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 403:	eb 04                	jmp    409 <strlen+0x13>
+ 405:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 409:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 40c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 40f:	01 d0                	add    %edx,%eax
+ 411:	0f b6 00             	movzbl (%eax),%eax
+ 414:	84 c0                	test   %al,%al
+ 416:	75 ed                	jne    405 <strlen+0xf>
+    ;
+  return n;
+ 418:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 41b:	c9                   	leave  
+ 41c:	c3                   	ret    
+
+0000041d <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 41d:	55                   	push   %ebp
+ 41e:	89 e5                	mov    %esp,%ebp
+ 420:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 423:	8b 45 10             	mov    0x10(%ebp),%eax
+ 426:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 42a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 42d:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 431:	8b 45 08             	mov    0x8(%ebp),%eax
+ 434:	89 04 24             	mov    %eax,(%esp)
+ 437:	e8 20 ff ff ff       	call   35c <stosb>
+  return dst;
+ 43c:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 43f:	c9                   	leave  
+ 440:	c3                   	ret    
+
+00000441 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 441:	55                   	push   %ebp
+ 442:	89 e5                	mov    %esp,%ebp
+ 444:	83 ec 04             	sub    $0x4,%esp
+ 447:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 44a:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 44d:	eb 14                	jmp    463 <strchr+0x22>
+    if(*s == c)
+ 44f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 452:	0f b6 00             	movzbl (%eax),%eax
+ 455:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 458:	75 05                	jne    45f <strchr+0x1e>
+      return (char*)s;
+ 45a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 45d:	eb 13                	jmp    472 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 45f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 463:	8b 45 08             	mov    0x8(%ebp),%eax
+ 466:	0f b6 00             	movzbl (%eax),%eax
+ 469:	84 c0                	test   %al,%al
+ 46b:	75 e2                	jne    44f <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 46d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 472:	c9                   	leave  
+ 473:	c3                   	ret    
+
+00000474 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 474:	55                   	push   %ebp
+ 475:	89 e5                	mov    %esp,%ebp
+ 477:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 47a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 481:	eb 46                	jmp    4c9 <gets+0x55>
+    cc = read(0, &c, 1);
+ 483:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 48a:	00 
+ 48b:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 48e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 492:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 499:	e8 3e 01 00 00       	call   5dc <read>
+ 49e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 4a1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 4a5:	7e 2f                	jle    4d6 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 4a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4aa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4ad:	01 c2                	add    %eax,%edx
+ 4af:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4b3:	88 02                	mov    %al,(%edx)
+ 4b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 4b9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4bd:	3c 0a                	cmp    $0xa,%al
+ 4bf:	74 16                	je     4d7 <gets+0x63>
+ 4c1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4c5:	3c 0d                	cmp    $0xd,%al
+ 4c7:	74 0e                	je     4d7 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 4c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4cc:	83 c0 01             	add    $0x1,%eax
+ 4cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 4d2:	7c af                	jl     483 <gets+0xf>
+ 4d4:	eb 01                	jmp    4d7 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 4d6:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 4d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4da:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4dd:	01 d0                	add    %edx,%eax
+ 4df:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 4e2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 4e5:	c9                   	leave  
+ 4e6:	c3                   	ret    
+
+000004e7 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 4e7:	55                   	push   %ebp
+ 4e8:	89 e5                	mov    %esp,%ebp
+ 4ea:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 4ed:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 4f4:	00 
+ 4f5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4f8:	89 04 24             	mov    %eax,(%esp)
+ 4fb:	e8 04 01 00 00       	call   604 <open>
+ 500:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 503:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 507:	79 07                	jns    510 <stat+0x29>
+    return -1;
+ 509:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 50e:	eb 23                	jmp    533 <stat+0x4c>
+  r = fstat(fd, st);
+ 510:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 513:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 517:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 51a:	89 04 24             	mov    %eax,(%esp)
+ 51d:	e8 fa 00 00 00       	call   61c <fstat>
+ 522:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 525:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 528:	89 04 24             	mov    %eax,(%esp)
+ 52b:	e8 bc 00 00 00       	call   5ec <close>
+  return r;
+ 530:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 533:	c9                   	leave  
+ 534:	c3                   	ret    
+
+00000535 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 535:	55                   	push   %ebp
+ 536:	89 e5                	mov    %esp,%ebp
+ 538:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 53b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 542:	eb 23                	jmp    567 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 544:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 547:	89 d0                	mov    %edx,%eax
+ 549:	c1 e0 02             	shl    $0x2,%eax
+ 54c:	01 d0                	add    %edx,%eax
+ 54e:	01 c0                	add    %eax,%eax
+ 550:	89 c2                	mov    %eax,%edx
+ 552:	8b 45 08             	mov    0x8(%ebp),%eax
+ 555:	0f b6 00             	movzbl (%eax),%eax
+ 558:	0f be c0             	movsbl %al,%eax
+ 55b:	01 d0                	add    %edx,%eax
+ 55d:	83 e8 30             	sub    $0x30,%eax
+ 560:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 563:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 567:	8b 45 08             	mov    0x8(%ebp),%eax
+ 56a:	0f b6 00             	movzbl (%eax),%eax
+ 56d:	3c 2f                	cmp    $0x2f,%al
+ 56f:	7e 0a                	jle    57b <atoi+0x46>
+ 571:	8b 45 08             	mov    0x8(%ebp),%eax
+ 574:	0f b6 00             	movzbl (%eax),%eax
+ 577:	3c 39                	cmp    $0x39,%al
+ 579:	7e c9                	jle    544 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 57b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 57e:	c9                   	leave  
+ 57f:	c3                   	ret    
+
+00000580 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 580:	55                   	push   %ebp
+ 581:	89 e5                	mov    %esp,%ebp
+ 583:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 586:	8b 45 08             	mov    0x8(%ebp),%eax
+ 589:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 58c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 58f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 592:	eb 13                	jmp    5a7 <memmove+0x27>
+    *dst++ = *src++;
+ 594:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 597:	0f b6 10             	movzbl (%eax),%edx
+ 59a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 59d:	88 10                	mov    %dl,(%eax)
+ 59f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 5a3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 5a7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 5ab:	0f 9f c0             	setg   %al
+ 5ae:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 5b2:	84 c0                	test   %al,%al
+ 5b4:	75 de                	jne    594 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 5b6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5b9:	c9                   	leave  
+ 5ba:	c3                   	ret    
+ 5bb:	90                   	nop
+
+000005bc <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 5bc:	b8 01 00 00 00       	mov    $0x1,%eax
+ 5c1:	cd 40                	int    $0x40
+ 5c3:	c3                   	ret    
+
+000005c4 <exit>:
+SYSCALL(exit)
+ 5c4:	b8 02 00 00 00       	mov    $0x2,%eax
+ 5c9:	cd 40                	int    $0x40
+ 5cb:	c3                   	ret    
+
+000005cc <wait>:
+SYSCALL(wait)
+ 5cc:	b8 03 00 00 00       	mov    $0x3,%eax
+ 5d1:	cd 40                	int    $0x40
+ 5d3:	c3                   	ret    
+
+000005d4 <pipe>:
+SYSCALL(pipe)
+ 5d4:	b8 04 00 00 00       	mov    $0x4,%eax
+ 5d9:	cd 40                	int    $0x40
+ 5db:	c3                   	ret    
+
+000005dc <read>:
+SYSCALL(read)
+ 5dc:	b8 05 00 00 00       	mov    $0x5,%eax
+ 5e1:	cd 40                	int    $0x40
+ 5e3:	c3                   	ret    
+
+000005e4 <write>:
+SYSCALL(write)
+ 5e4:	b8 10 00 00 00       	mov    $0x10,%eax
+ 5e9:	cd 40                	int    $0x40
+ 5eb:	c3                   	ret    
+
+000005ec <close>:
+SYSCALL(close)
+ 5ec:	b8 15 00 00 00       	mov    $0x15,%eax
+ 5f1:	cd 40                	int    $0x40
+ 5f3:	c3                   	ret    
+
+000005f4 <kill>:
+SYSCALL(kill)
+ 5f4:	b8 06 00 00 00       	mov    $0x6,%eax
+ 5f9:	cd 40                	int    $0x40
+ 5fb:	c3                   	ret    
+
+000005fc <exec>:
+SYSCALL(exec)
+ 5fc:	b8 07 00 00 00       	mov    $0x7,%eax
+ 601:	cd 40                	int    $0x40
+ 603:	c3                   	ret    
+
+00000604 <open>:
+SYSCALL(open)
+ 604:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 609:	cd 40                	int    $0x40
+ 60b:	c3                   	ret    
+
+0000060c <mknod>:
+SYSCALL(mknod)
+ 60c:	b8 11 00 00 00       	mov    $0x11,%eax
+ 611:	cd 40                	int    $0x40
+ 613:	c3                   	ret    
+
+00000614 <unlink>:
+SYSCALL(unlink)
+ 614:	b8 12 00 00 00       	mov    $0x12,%eax
+ 619:	cd 40                	int    $0x40
+ 61b:	c3                   	ret    
+
+0000061c <fstat>:
+SYSCALL(fstat)
+ 61c:	b8 08 00 00 00       	mov    $0x8,%eax
+ 621:	cd 40                	int    $0x40
+ 623:	c3                   	ret    
+
+00000624 <link>:
+SYSCALL(link)
+ 624:	b8 13 00 00 00       	mov    $0x13,%eax
+ 629:	cd 40                	int    $0x40
+ 62b:	c3                   	ret    
+
+0000062c <mkdir>:
+SYSCALL(mkdir)
+ 62c:	b8 14 00 00 00       	mov    $0x14,%eax
+ 631:	cd 40                	int    $0x40
+ 633:	c3                   	ret    
+
+00000634 <chdir>:
+SYSCALL(chdir)
+ 634:	b8 09 00 00 00       	mov    $0x9,%eax
+ 639:	cd 40                	int    $0x40
+ 63b:	c3                   	ret    
+
+0000063c <dup>:
+SYSCALL(dup)
+ 63c:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 641:	cd 40                	int    $0x40
+ 643:	c3                   	ret    
+
+00000644 <getpid>:
+SYSCALL(getpid)
+ 644:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 649:	cd 40                	int    $0x40
+ 64b:	c3                   	ret    
+
+0000064c <sbrk>:
+SYSCALL(sbrk)
+ 64c:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 651:	cd 40                	int    $0x40
+ 653:	c3                   	ret    
+
+00000654 <sleep>:
+SYSCALL(sleep)
+ 654:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 659:	cd 40                	int    $0x40
+ 65b:	c3                   	ret    
+
+0000065c <uptime>:
+SYSCALL(uptime)
+ 65c:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 661:	cd 40                	int    $0x40
+ 663:	c3                   	ret    
+
+00000664 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 664:	b8 16 00 00 00       	mov    $0x16,%eax
+ 669:	cd 40                	int    $0x40
+ 66b:	c3                   	ret    
+
+0000066c <shutdown>:
+SYSCALL(shutdown)
+ 66c:	b8 17 00 00 00       	mov    $0x17,%eax
+ 671:	cd 40                	int    $0x40
+ 673:	c3                   	ret    
+
+00000674 <fork_winner>:
+SYSCALL(fork_winner)
+ 674:	b8 18 00 00 00       	mov    $0x18,%eax
+ 679:	cd 40                	int    $0x40
+ 67b:	c3                   	ret    
+
+0000067c <set_sched>:
+SYSCALL(set_sched)
+ 67c:	b8 19 00 00 00       	mov    $0x19,%eax
+ 681:	cd 40                	int    $0x40
+ 683:	c3                   	ret    
+
+00000684 <set_priority>:
+SYSCALL(set_priority)
+ 684:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 689:	cd 40                	int    $0x40
+ 68b:	c3                   	ret    
+
+0000068c <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 68c:	55                   	push   %ebp
+ 68d:	89 e5                	mov    %esp,%ebp
+ 68f:	83 ec 28             	sub    $0x28,%esp
+ 692:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 695:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 698:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 69f:	00 
+ 6a0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 6a3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6a7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6aa:	89 04 24             	mov    %eax,(%esp)
+ 6ad:	e8 32 ff ff ff       	call   5e4 <write>
+}
+ 6b2:	c9                   	leave  
+ 6b3:	c3                   	ret    
+
+000006b4 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 6b4:	55                   	push   %ebp
+ 6b5:	89 e5                	mov    %esp,%ebp
+ 6b7:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 6ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 6c1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 6c5:	74 17                	je     6de <printint+0x2a>
+ 6c7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 6cb:	79 11                	jns    6de <printint+0x2a>
+    neg = 1;
+ 6cd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 6d4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6d7:	f7 d8                	neg    %eax
+ 6d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 6dc:	eb 06                	jmp    6e4 <printint+0x30>
+  } else {
+    x = xx;
+ 6de:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 6e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 6eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 6ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 6f1:	ba 00 00 00 00       	mov    $0x0,%edx
+ 6f6:	f7 f1                	div    %ecx
+ 6f8:	89 d0                	mov    %edx,%eax
+ 6fa:	0f b6 80 1c 0e 00 00 	movzbl 0xe1c(%eax),%eax
+ 701:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 704:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 707:	01 ca                	add    %ecx,%edx
+ 709:	88 02                	mov    %al,(%edx)
+ 70b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 70f:	8b 55 10             	mov    0x10(%ebp),%edx
+ 712:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 715:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 718:	ba 00 00 00 00       	mov    $0x0,%edx
+ 71d:	f7 75 d4             	divl   -0x2c(%ebp)
+ 720:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 723:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 727:	75 c2                	jne    6eb <printint+0x37>
+  if(neg)
+ 729:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 72d:	74 2e                	je     75d <printint+0xa9>
+    buf[i++] = '-';
+ 72f:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 732:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 735:	01 d0                	add    %edx,%eax
+ 737:	c6 00 2d             	movb   $0x2d,(%eax)
+ 73a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 73e:	eb 1d                	jmp    75d <printint+0xa9>
+    putc(fd, buf[i]);
+ 740:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 743:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 746:	01 d0                	add    %edx,%eax
+ 748:	0f b6 00             	movzbl (%eax),%eax
+ 74b:	0f be c0             	movsbl %al,%eax
+ 74e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 752:	8b 45 08             	mov    0x8(%ebp),%eax
+ 755:	89 04 24             	mov    %eax,(%esp)
+ 758:	e8 2f ff ff ff       	call   68c <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 75d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 761:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 765:	79 d9                	jns    740 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 767:	c9                   	leave  
+ 768:	c3                   	ret    
+
+00000769 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 769:	55                   	push   %ebp
+ 76a:	89 e5                	mov    %esp,%ebp
+ 76c:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 76f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 776:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 779:	83 c0 04             	add    $0x4,%eax
+ 77c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 77f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 786:	e9 7d 01 00 00       	jmp    908 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 78b:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 78e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 791:	01 d0                	add    %edx,%eax
+ 793:	0f b6 00             	movzbl (%eax),%eax
+ 796:	0f be c0             	movsbl %al,%eax
+ 799:	25 ff 00 00 00       	and    $0xff,%eax
+ 79e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 7a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 7a5:	75 2c                	jne    7d3 <printf+0x6a>
+      if(c == '%'){
+ 7a7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 7ab:	75 0c                	jne    7b9 <printf+0x50>
+        state = '%';
+ 7ad:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 7b4:	e9 4b 01 00 00       	jmp    904 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 7b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 7bc:	0f be c0             	movsbl %al,%eax
+ 7bf:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 7c3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7c6:	89 04 24             	mov    %eax,(%esp)
+ 7c9:	e8 be fe ff ff       	call   68c <putc>
+ 7ce:	e9 31 01 00 00       	jmp    904 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 7d3:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 7d7:	0f 85 27 01 00 00    	jne    904 <printf+0x19b>
+      if(c == 'd'){
+ 7dd:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 7e1:	75 2d                	jne    810 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 7e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 7e6:	8b 00                	mov    (%eax),%eax
+ 7e8:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 7ef:	00 
+ 7f0:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 7f7:	00 
+ 7f8:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 7fc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7ff:	89 04 24             	mov    %eax,(%esp)
+ 802:	e8 ad fe ff ff       	call   6b4 <printint>
+        ap++;
+ 807:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 80b:	e9 ed 00 00 00       	jmp    8fd <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 810:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 814:	74 06                	je     81c <printf+0xb3>
+ 816:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 81a:	75 2d                	jne    849 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 81c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 81f:	8b 00                	mov    (%eax),%eax
+ 821:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 828:	00 
+ 829:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 830:	00 
+ 831:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 835:	8b 45 08             	mov    0x8(%ebp),%eax
+ 838:	89 04 24             	mov    %eax,(%esp)
+ 83b:	e8 74 fe ff ff       	call   6b4 <printint>
+        ap++;
+ 840:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 844:	e9 b4 00 00 00       	jmp    8fd <printf+0x194>
+      } else if(c == 's'){
+ 849:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 84d:	75 46                	jne    895 <printf+0x12c>
+        s = (char*)*ap;
+ 84f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 852:	8b 00                	mov    (%eax),%eax
+ 854:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 857:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 85b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 85f:	75 27                	jne    888 <printf+0x11f>
+          s = "(null)";
+ 861:	c7 45 f4 83 0b 00 00 	movl   $0xb83,-0xc(%ebp)
+        while(*s != 0){
+ 868:	eb 1e                	jmp    888 <printf+0x11f>
+          putc(fd, *s);
+ 86a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86d:	0f b6 00             	movzbl (%eax),%eax
+ 870:	0f be c0             	movsbl %al,%eax
+ 873:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 877:	8b 45 08             	mov    0x8(%ebp),%eax
+ 87a:	89 04 24             	mov    %eax,(%esp)
+ 87d:	e8 0a fe ff ff       	call   68c <putc>
+          s++;
+ 882:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 886:	eb 01                	jmp    889 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 888:	90                   	nop
+ 889:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 88c:	0f b6 00             	movzbl (%eax),%eax
+ 88f:	84 c0                	test   %al,%al
+ 891:	75 d7                	jne    86a <printf+0x101>
+ 893:	eb 68                	jmp    8fd <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 895:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 899:	75 1d                	jne    8b8 <printf+0x14f>
+        putc(fd, *ap);
+ 89b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 89e:	8b 00                	mov    (%eax),%eax
+ 8a0:	0f be c0             	movsbl %al,%eax
+ 8a3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8a7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8aa:	89 04 24             	mov    %eax,(%esp)
+ 8ad:	e8 da fd ff ff       	call   68c <putc>
+        ap++;
+ 8b2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 8b6:	eb 45                	jmp    8fd <printf+0x194>
+      } else if(c == '%'){
+ 8b8:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 8bc:	75 17                	jne    8d5 <printf+0x16c>
+        putc(fd, c);
+ 8be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8c1:	0f be c0             	movsbl %al,%eax
+ 8c4:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8c8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8cb:	89 04 24             	mov    %eax,(%esp)
+ 8ce:	e8 b9 fd ff ff       	call   68c <putc>
+ 8d3:	eb 28                	jmp    8fd <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 8d5:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 8dc:	00 
+ 8dd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8e0:	89 04 24             	mov    %eax,(%esp)
+ 8e3:	e8 a4 fd ff ff       	call   68c <putc>
+        putc(fd, c);
+ 8e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8eb:	0f be c0             	movsbl %al,%eax
+ 8ee:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8f2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8f5:	89 04 24             	mov    %eax,(%esp)
+ 8f8:	e8 8f fd ff ff       	call   68c <putc>
+      }
+      state = 0;
+ 8fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 904:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 908:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 90b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 90e:	01 d0                	add    %edx,%eax
+ 910:	0f b6 00             	movzbl (%eax),%eax
+ 913:	84 c0                	test   %al,%al
+ 915:	0f 85 70 fe ff ff    	jne    78b <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 91b:	c9                   	leave  
+ 91c:	c3                   	ret    
+ 91d:	90                   	nop
+ 91e:	90                   	nop
+ 91f:	90                   	nop
+
+00000920 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 920:	55                   	push   %ebp
+ 921:	89 e5                	mov    %esp,%ebp
+ 923:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 926:	8b 45 08             	mov    0x8(%ebp),%eax
+ 929:	83 e8 08             	sub    $0x8,%eax
+ 92c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 92f:	a1 48 0e 00 00       	mov    0xe48,%eax
+ 934:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 937:	eb 24                	jmp    95d <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 939:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 93c:	8b 00                	mov    (%eax),%eax
+ 93e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 941:	77 12                	ja     955 <free+0x35>
+ 943:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 946:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 949:	77 24                	ja     96f <free+0x4f>
+ 94b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 94e:	8b 00                	mov    (%eax),%eax
+ 950:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 953:	77 1a                	ja     96f <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 955:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 958:	8b 00                	mov    (%eax),%eax
+ 95a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 95d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 960:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 963:	76 d4                	jbe    939 <free+0x19>
+ 965:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 968:	8b 00                	mov    (%eax),%eax
+ 96a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 96d:	76 ca                	jbe    939 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 96f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 972:	8b 40 04             	mov    0x4(%eax),%eax
+ 975:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 97c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 97f:	01 c2                	add    %eax,%edx
+ 981:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 984:	8b 00                	mov    (%eax),%eax
+ 986:	39 c2                	cmp    %eax,%edx
+ 988:	75 24                	jne    9ae <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 98a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 98d:	8b 50 04             	mov    0x4(%eax),%edx
+ 990:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 993:	8b 00                	mov    (%eax),%eax
+ 995:	8b 40 04             	mov    0x4(%eax),%eax
+ 998:	01 c2                	add    %eax,%edx
+ 99a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 99d:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 9a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9a3:	8b 00                	mov    (%eax),%eax
+ 9a5:	8b 10                	mov    (%eax),%edx
+ 9a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9aa:	89 10                	mov    %edx,(%eax)
+ 9ac:	eb 0a                	jmp    9b8 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 9ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9b1:	8b 10                	mov    (%eax),%edx
+ 9b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9b6:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 9b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9bb:	8b 40 04             	mov    0x4(%eax),%eax
+ 9be:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 9c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9c8:	01 d0                	add    %edx,%eax
+ 9ca:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 9cd:	75 20                	jne    9ef <free+0xcf>
+    p->s.size += bp->s.size;
+ 9cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9d2:	8b 50 04             	mov    0x4(%eax),%edx
+ 9d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9d8:	8b 40 04             	mov    0x4(%eax),%eax
+ 9db:	01 c2                	add    %eax,%edx
+ 9dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9e0:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 9e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9e6:	8b 10                	mov    (%eax),%edx
+ 9e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9eb:	89 10                	mov    %edx,(%eax)
+ 9ed:	eb 08                	jmp    9f7 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 9ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9f2:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 9f5:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 9f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9fa:	a3 48 0e 00 00       	mov    %eax,0xe48
+}
+ 9ff:	c9                   	leave  
+ a00:	c3                   	ret    
+
+00000a01 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ a01:	55                   	push   %ebp
+ a02:	89 e5                	mov    %esp,%ebp
+ a04:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ a07:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ a0e:	77 07                	ja     a17 <morecore+0x16>
+    nu = 4096;
+ a10:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ a17:	8b 45 08             	mov    0x8(%ebp),%eax
+ a1a:	c1 e0 03             	shl    $0x3,%eax
+ a1d:	89 04 24             	mov    %eax,(%esp)
+ a20:	e8 27 fc ff ff       	call   64c <sbrk>
+ a25:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ a28:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ a2c:	75 07                	jne    a35 <morecore+0x34>
+    return 0;
+ a2e:	b8 00 00 00 00       	mov    $0x0,%eax
+ a33:	eb 22                	jmp    a57 <morecore+0x56>
+  hp = (Header*)p;
+ a35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a38:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ a3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a3e:	8b 55 08             	mov    0x8(%ebp),%edx
+ a41:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ a44:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a47:	83 c0 08             	add    $0x8,%eax
+ a4a:	89 04 24             	mov    %eax,(%esp)
+ a4d:	e8 ce fe ff ff       	call   920 <free>
+  return freep;
+ a52:	a1 48 0e 00 00       	mov    0xe48,%eax
+}
+ a57:	c9                   	leave  
+ a58:	c3                   	ret    
+
+00000a59 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ a59:	55                   	push   %ebp
+ a5a:	89 e5                	mov    %esp,%ebp
+ a5c:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ a5f:	8b 45 08             	mov    0x8(%ebp),%eax
+ a62:	83 c0 07             	add    $0x7,%eax
+ a65:	c1 e8 03             	shr    $0x3,%eax
+ a68:	83 c0 01             	add    $0x1,%eax
+ a6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ a6e:	a1 48 0e 00 00       	mov    0xe48,%eax
+ a73:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ a76:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ a7a:	75 23                	jne    a9f <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ a7c:	c7 45 f0 40 0e 00 00 	movl   $0xe40,-0x10(%ebp)
+ a83:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a86:	a3 48 0e 00 00       	mov    %eax,0xe48
+ a8b:	a1 48 0e 00 00       	mov    0xe48,%eax
+ a90:	a3 40 0e 00 00       	mov    %eax,0xe40
+    base.s.size = 0;
+ a95:	c7 05 44 0e 00 00 00 	movl   $0x0,0xe44
+ a9c:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ aa2:	8b 00                	mov    (%eax),%eax
+ aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aaa:	8b 40 04             	mov    0x4(%eax),%eax
+ aad:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ ab0:	72 4d                	jb     aff <malloc+0xa6>
+      if(p->s.size == nunits)
+ ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ab5:	8b 40 04             	mov    0x4(%eax),%eax
+ ab8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ abb:	75 0c                	jne    ac9 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ac0:	8b 10                	mov    (%eax),%edx
+ ac2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ ac5:	89 10                	mov    %edx,(%eax)
+ ac7:	eb 26                	jmp    aef <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ ac9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ acc:	8b 40 04             	mov    0x4(%eax),%eax
+ acf:	89 c2                	mov    %eax,%edx
+ ad1:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ ad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ad7:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ ada:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ add:	8b 40 04             	mov    0x4(%eax),%eax
+ ae0:	c1 e0 03             	shl    $0x3,%eax
+ ae3:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ ae6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ae9:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ aec:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ aef:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ af2:	a3 48 0e 00 00       	mov    %eax,0xe48
+      return (void*)(p + 1);
+ af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ afa:	83 c0 08             	add    $0x8,%eax
+ afd:	eb 38                	jmp    b37 <malloc+0xde>
+    }
+    if(p == freep)
+ aff:	a1 48 0e 00 00       	mov    0xe48,%eax
+ b04:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ b07:	75 1b                	jne    b24 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ b09:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ b0c:	89 04 24             	mov    %eax,(%esp)
+ b0f:	e8 ed fe ff ff       	call   a01 <morecore>
+ b14:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ b17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ b1b:	75 07                	jne    b24 <malloc+0xcb>
+        return 0;
+ b1d:	b8 00 00 00 00       	mov    $0x0,%eax
+ b22:	eb 13                	jmp    b37 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ b24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b27:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b2d:	8b 00                	mov    (%eax),%eax
+ b2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ b32:	e9 70 ff ff ff       	jmp    aa7 <malloc+0x4e>
+}
+ b37:	c9                   	leave  
+ b38:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/ls.d cs550-16s-proj1-working/ls.d
--- cs550-16s-proj1-base/ls.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ls.d	2016-03-04 14:37:01.000000000 -0500
@@ -0,0 +1 @@
+ls.o: ls.c types.h stat.h user.h fs.h
Binary files cs550-16s-proj1-base/ls.o and cs550-16s-proj1-working/ls.o differ
diff -uNr cs550-16s-proj1-base/ls.sym cs550-16s-proj1-working/ls.sym
--- cs550-16s-proj1-base/ls.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ls.sym	2016-03-04 14:37:02.000000000 -0500
@@ -0,0 +1,68 @@
+00000000 .text
+00000b39 .rodata
+00000b8c .eh_frame
+00000e1c .data
+00000e30 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 ls.c
+00000e30 buf.1036
+00000000 ulib.c
+0000035c stosb
+00000000 printf.c
+0000068c putc
+000006b4 printint
+00000e1c digits.1028
+00000000 umalloc.c
+00000e40 base
+00000e48 freep
+00000a01 morecore
+00000381 strcpy
+00000000 fmtname
+00000769 printf
+00000580 memmove
+0000060c mknod
+00000474 gets
+00000644 getpid
+00000a59 malloc
+00000654 sleep
+00000684 set_priority
+000005d4 pipe
+000005e4 write
+0000061c fstat
+000005f4 kill
+00000634 chdir
+000005fc exec
+000005cc wait
+000005dc read
+00000614 unlink
+000005bc fork
+0000064c sbrk
+0000065c uptime
+00000e30 __bss_start
+0000041d memset
+00000304 main
+00000664 enable_sched_trace
+000003b5 strcmp
+0000066c shutdown
+0000063c dup
+0000067c set_sched
+000004e7 stat
+00000e30 _edata
+00000e4c _end
+00000624 link
+000000b0 ls
+000005c4 exit
+00000535 atoi
+00000674 fork_winner
+000003f6 strlen
+00000604 open
+00000441 strchr
+0000062c mkdir
+000005ec close
+00000920 free
diff -uNr cs550-16s-proj1-base/main.c cs550-16s-proj1-working/main.c
--- cs550-16s-proj1-base/main.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/main.c	2016-03-04 14:36:40.000000000 -0500
@@ -31,6 +31,7 @@
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
+  iinit();         // inode cache
   ideinit();       // disk
   if(!ismp)
     timerinit();   // uniprocessor timer
diff -uNr cs550-16s-proj1-base/main.d cs550-16s-proj1-working/main.d
--- cs550-16s-proj1-base/main.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/main.d	2016-03-04 15:49:55.472983199 -0500
@@ -0,0 +1 @@
+main.o: main.c types.h defs.h param.h memlayout.h mmu.h proc.h x86.h
Binary files cs550-16s-proj1-base/main.o and cs550-16s-proj1-working/main.o differ
diff -uNr cs550-16s-proj1-base/Makefile cs550-16s-proj1-working/Makefile
--- cs550-16s-proj1-base/Makefile	2016-02-15 22:46:39.000000000 -0500
+++ cs550-16s-proj1-working/Makefile	2016-03-04 14:36:40.000000000 -0500
@@ -51,7 +51,7 @@
 endif
 
 # If the makefile can't find QEMU, specify its path here
-# QEMU = qemu-system-i386
+QEMU = ~zhangy/t_bin/qemu-system-i386
 
 # Try to infer the correct QEMU
 ifndef QEMU
@@ -172,6 +172,7 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_shutdown \
 	_proj1_forktest \
 	_proj1_schdtest \
 
@@ -275,6 +276,6 @@
 	rm -rf /tmp/xv6
 	mkdir -p /tmp/xv6
 	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev9.tar.gz  # the next one will be 9 (6/27/15)
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev9.tar.gz
 
 .PHONY: dist-test dist
diff -uNr cs550-16s-proj1-base/memide.c cs550-16s-proj1-working/memide.c
--- cs550-16s-proj1-base/memide.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/memide.c	2016-03-04 14:36:40.000000000 -0500
@@ -9,7 +9,6 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "fs.h"
 #include "buf.h"
 
 extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
@@ -21,7 +20,7 @@
 ideinit(void)
 {
   memdisk = _binary_fs_img_start;
-  disksize = (uint)_binary_fs_img_size/BSIZE;
+  disksize = (uint)_binary_fs_img_size/512;
 }
 
 // Interrupt handler.
@@ -45,15 +44,15 @@
     panic("iderw: nothing to do");
   if(b->dev != 1)
     panic("iderw: request not for disk 1");
-  if(b->blockno >= disksize)
-    panic("iderw: block out of range");
+  if(b->sector >= disksize)
+    panic("iderw: sector out of range");
 
-  p = memdisk + b->blockno*BSIZE;
+  p = memdisk + b->sector*512;
   
   if(b->flags & B_DIRTY){
     b->flags &= ~B_DIRTY;
-    memmove(p, b->data, BSIZE);
+    memmove(p, b->data, 512);
   } else
-    memmove(b->data, p, BSIZE);
+    memmove(b->data, p, 512);
   b->flags |= B_VALID;
 }
diff -uNr cs550-16s-proj1-base/memlayout.h cs550-16s-proj1-working/memlayout.h
--- cs550-16s-proj1-base/memlayout.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/memlayout.h	2016-03-04 14:36:40.000000000 -0500
@@ -19,4 +19,4 @@
 #define P2V(a) (((void *) (a)) + KERNBASE)
 
 #define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
+#define P2V_WO(x) ((x) + KERNBASE)    // same as V2P, but without casts
Binary files cs550-16s-proj1-base/_mkdir and cs550-16s-proj1-working/_mkdir differ
diff -uNr cs550-16s-proj1-base/mkdir.asm cs550-16s-proj1-working/mkdir.asm
--- cs550-16s-proj1-base/mkdir.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/mkdir.asm	2016-03-04 14:37:03.000000000 -0500
@@ -0,0 +1,1232 @@
+
+_mkdir:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 20             	sub    $0x20,%esp
+  int i;
+
+  if(argc < 2){
+   9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+   d:	7f 19                	jg     28 <main+0x28>
+    printf(2, "Usage: mkdir files...\n");
+   f:	c7 44 24 04 6d 08 00 	movl   $0x86d,0x4(%esp)
+  16:	00 
+  17:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  1e:	e8 7a 04 00 00       	call   49d <printf>
+    exit();
+  23:	e8 d0 02 00 00       	call   2f8 <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+  28:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+  2f:	00 
+  30:	eb 4f                	jmp    81 <main+0x81>
+    if(mkdir(argv[i]) < 0){
+  32:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  36:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  3d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  40:	01 d0                	add    %edx,%eax
+  42:	8b 00                	mov    (%eax),%eax
+  44:	89 04 24             	mov    %eax,(%esp)
+  47:	e8 14 03 00 00       	call   360 <mkdir>
+  4c:	85 c0                	test   %eax,%eax
+  4e:	79 2c                	jns    7c <main+0x7c>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+  50:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  5b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  5e:	01 d0                	add    %edx,%eax
+  60:	8b 00                	mov    (%eax),%eax
+  62:	89 44 24 08          	mov    %eax,0x8(%esp)
+  66:	c7 44 24 04 84 08 00 	movl   $0x884,0x4(%esp)
+  6d:	00 
+  6e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  75:	e8 23 04 00 00       	call   49d <printf>
+      break;
+  7a:	eb 0e                	jmp    8a <main+0x8a>
+  if(argc < 2){
+    printf(2, "Usage: mkdir files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+  7c:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+  81:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  85:	3b 45 08             	cmp    0x8(%ebp),%eax
+  88:	7c a8                	jl     32 <main+0x32>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+  8a:	e8 69 02 00 00       	call   2f8 <exit>
+  8f:	90                   	nop
+
+00000090 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  90:	55                   	push   %ebp
+  91:	89 e5                	mov    %esp,%ebp
+  93:	57                   	push   %edi
+  94:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  95:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  98:	8b 55 10             	mov    0x10(%ebp),%edx
+  9b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  9e:	89 cb                	mov    %ecx,%ebx
+  a0:	89 df                	mov    %ebx,%edi
+  a2:	89 d1                	mov    %edx,%ecx
+  a4:	fc                   	cld    
+  a5:	f3 aa                	rep stos %al,%es:(%edi)
+  a7:	89 ca                	mov    %ecx,%edx
+  a9:	89 fb                	mov    %edi,%ebx
+  ab:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  ae:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  b1:	5b                   	pop    %ebx
+  b2:	5f                   	pop    %edi
+  b3:	5d                   	pop    %ebp
+  b4:	c3                   	ret    
+
+000000b5 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  b5:	55                   	push   %ebp
+  b6:	89 e5                	mov    %esp,%ebp
+  b8:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  bb:	8b 45 08             	mov    0x8(%ebp),%eax
+  be:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  c1:	90                   	nop
+  c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  c5:	0f b6 10             	movzbl (%eax),%edx
+  c8:	8b 45 08             	mov    0x8(%ebp),%eax
+  cb:	88 10                	mov    %dl,(%eax)
+  cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  d0:	0f b6 00             	movzbl (%eax),%eax
+  d3:	84 c0                	test   %al,%al
+  d5:	0f 95 c0             	setne  %al
+  d8:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  dc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  e0:	84 c0                	test   %al,%al
+  e2:	75 de                	jne    c2 <strcpy+0xd>
+    ;
+  return os;
+  e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  e7:	c9                   	leave  
+  e8:	c3                   	ret    
+
+000000e9 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  e9:	55                   	push   %ebp
+  ea:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  ec:	eb 08                	jmp    f6 <strcmp+0xd>
+    p++, q++;
+  ee:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  f2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  f6:	8b 45 08             	mov    0x8(%ebp),%eax
+  f9:	0f b6 00             	movzbl (%eax),%eax
+  fc:	84 c0                	test   %al,%al
+  fe:	74 10                	je     110 <strcmp+0x27>
+ 100:	8b 45 08             	mov    0x8(%ebp),%eax
+ 103:	0f b6 10             	movzbl (%eax),%edx
+ 106:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 109:	0f b6 00             	movzbl (%eax),%eax
+ 10c:	38 c2                	cmp    %al,%dl
+ 10e:	74 de                	je     ee <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 110:	8b 45 08             	mov    0x8(%ebp),%eax
+ 113:	0f b6 00             	movzbl (%eax),%eax
+ 116:	0f b6 d0             	movzbl %al,%edx
+ 119:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 11c:	0f b6 00             	movzbl (%eax),%eax
+ 11f:	0f b6 c0             	movzbl %al,%eax
+ 122:	89 d1                	mov    %edx,%ecx
+ 124:	29 c1                	sub    %eax,%ecx
+ 126:	89 c8                	mov    %ecx,%eax
+}
+ 128:	5d                   	pop    %ebp
+ 129:	c3                   	ret    
+
+0000012a <strlen>:
+
+uint
+strlen(char *s)
+{
+ 12a:	55                   	push   %ebp
+ 12b:	89 e5                	mov    %esp,%ebp
+ 12d:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 130:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 137:	eb 04                	jmp    13d <strlen+0x13>
+ 139:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 13d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 140:	8b 45 08             	mov    0x8(%ebp),%eax
+ 143:	01 d0                	add    %edx,%eax
+ 145:	0f b6 00             	movzbl (%eax),%eax
+ 148:	84 c0                	test   %al,%al
+ 14a:	75 ed                	jne    139 <strlen+0xf>
+    ;
+  return n;
+ 14c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 14f:	c9                   	leave  
+ 150:	c3                   	ret    
+
+00000151 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 151:	55                   	push   %ebp
+ 152:	89 e5                	mov    %esp,%ebp
+ 154:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 157:	8b 45 10             	mov    0x10(%ebp),%eax
+ 15a:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 15e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 161:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 165:	8b 45 08             	mov    0x8(%ebp),%eax
+ 168:	89 04 24             	mov    %eax,(%esp)
+ 16b:	e8 20 ff ff ff       	call   90 <stosb>
+  return dst;
+ 170:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 173:	c9                   	leave  
+ 174:	c3                   	ret    
+
+00000175 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 175:	55                   	push   %ebp
+ 176:	89 e5                	mov    %esp,%ebp
+ 178:	83 ec 04             	sub    $0x4,%esp
+ 17b:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 17e:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 181:	eb 14                	jmp    197 <strchr+0x22>
+    if(*s == c)
+ 183:	8b 45 08             	mov    0x8(%ebp),%eax
+ 186:	0f b6 00             	movzbl (%eax),%eax
+ 189:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 18c:	75 05                	jne    193 <strchr+0x1e>
+      return (char*)s;
+ 18e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 191:	eb 13                	jmp    1a6 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 193:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 197:	8b 45 08             	mov    0x8(%ebp),%eax
+ 19a:	0f b6 00             	movzbl (%eax),%eax
+ 19d:	84 c0                	test   %al,%al
+ 19f:	75 e2                	jne    183 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 1a1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 1a6:	c9                   	leave  
+ 1a7:	c3                   	ret    
+
+000001a8 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1a8:	55                   	push   %ebp
+ 1a9:	89 e5                	mov    %esp,%ebp
+ 1ab:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1b5:	eb 46                	jmp    1fd <gets+0x55>
+    cc = read(0, &c, 1);
+ 1b7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 1be:	00 
+ 1bf:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1c2:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1c6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 1cd:	e8 3e 01 00 00       	call   310 <read>
+ 1d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1d9:	7e 2f                	jle    20a <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1db:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1e1:	01 c2                	add    %eax,%edx
+ 1e3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1e7:	88 02                	mov    %al,(%edx)
+ 1e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 1ed:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1f1:	3c 0a                	cmp    $0xa,%al
+ 1f3:	74 16                	je     20b <gets+0x63>
+ 1f5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1f9:	3c 0d                	cmp    $0xd,%al
+ 1fb:	74 0e                	je     20b <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 200:	83 c0 01             	add    $0x1,%eax
+ 203:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 206:	7c af                	jl     1b7 <gets+0xf>
+ 208:	eb 01                	jmp    20b <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 20a:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 20b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 20e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 211:	01 d0                	add    %edx,%eax
+ 213:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 216:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 219:	c9                   	leave  
+ 21a:	c3                   	ret    
+
+0000021b <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 21b:	55                   	push   %ebp
+ 21c:	89 e5                	mov    %esp,%ebp
+ 21e:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 221:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 228:	00 
+ 229:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22c:	89 04 24             	mov    %eax,(%esp)
+ 22f:	e8 04 01 00 00       	call   338 <open>
+ 234:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 237:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 23b:	79 07                	jns    244 <stat+0x29>
+    return -1;
+ 23d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 242:	eb 23                	jmp    267 <stat+0x4c>
+  r = fstat(fd, st);
+ 244:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 247:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 24b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 24e:	89 04 24             	mov    %eax,(%esp)
+ 251:	e8 fa 00 00 00       	call   350 <fstat>
+ 256:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 259:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 25c:	89 04 24             	mov    %eax,(%esp)
+ 25f:	e8 bc 00 00 00       	call   320 <close>
+  return r;
+ 264:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 267:	c9                   	leave  
+ 268:	c3                   	ret    
+
+00000269 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 269:	55                   	push   %ebp
+ 26a:	89 e5                	mov    %esp,%ebp
+ 26c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 26f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 276:	eb 23                	jmp    29b <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 278:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 27b:	89 d0                	mov    %edx,%eax
+ 27d:	c1 e0 02             	shl    $0x2,%eax
+ 280:	01 d0                	add    %edx,%eax
+ 282:	01 c0                	add    %eax,%eax
+ 284:	89 c2                	mov    %eax,%edx
+ 286:	8b 45 08             	mov    0x8(%ebp),%eax
+ 289:	0f b6 00             	movzbl (%eax),%eax
+ 28c:	0f be c0             	movsbl %al,%eax
+ 28f:	01 d0                	add    %edx,%eax
+ 291:	83 e8 30             	sub    $0x30,%eax
+ 294:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 297:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 29b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29e:	0f b6 00             	movzbl (%eax),%eax
+ 2a1:	3c 2f                	cmp    $0x2f,%al
+ 2a3:	7e 0a                	jle    2af <atoi+0x46>
+ 2a5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2a8:	0f b6 00             	movzbl (%eax),%eax
+ 2ab:	3c 39                	cmp    $0x39,%al
+ 2ad:	7e c9                	jle    278 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 2af:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2b2:	c9                   	leave  
+ 2b3:	c3                   	ret    
+
+000002b4 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 2ba:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2c3:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2c6:	eb 13                	jmp    2db <memmove+0x27>
+    *dst++ = *src++;
+ 2c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 2cb:	0f b6 10             	movzbl (%eax),%edx
+ 2ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2d1:	88 10                	mov    %dl,(%eax)
+ 2d3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 2d7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 2df:	0f 9f c0             	setg   %al
+ 2e2:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 2e6:	84 c0                	test   %al,%al
+ 2e8:	75 de                	jne    2c8 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 2ea:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2ed:	c9                   	leave  
+ 2ee:	c3                   	ret    
+ 2ef:	90                   	nop
+
+000002f0 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2f0:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2f5:	cd 40                	int    $0x40
+ 2f7:	c3                   	ret    
+
+000002f8 <exit>:
+SYSCALL(exit)
+ 2f8:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2fd:	cd 40                	int    $0x40
+ 2ff:	c3                   	ret    
+
+00000300 <wait>:
+SYSCALL(wait)
+ 300:	b8 03 00 00 00       	mov    $0x3,%eax
+ 305:	cd 40                	int    $0x40
+ 307:	c3                   	ret    
+
+00000308 <pipe>:
+SYSCALL(pipe)
+ 308:	b8 04 00 00 00       	mov    $0x4,%eax
+ 30d:	cd 40                	int    $0x40
+ 30f:	c3                   	ret    
+
+00000310 <read>:
+SYSCALL(read)
+ 310:	b8 05 00 00 00       	mov    $0x5,%eax
+ 315:	cd 40                	int    $0x40
+ 317:	c3                   	ret    
+
+00000318 <write>:
+SYSCALL(write)
+ 318:	b8 10 00 00 00       	mov    $0x10,%eax
+ 31d:	cd 40                	int    $0x40
+ 31f:	c3                   	ret    
+
+00000320 <close>:
+SYSCALL(close)
+ 320:	b8 15 00 00 00       	mov    $0x15,%eax
+ 325:	cd 40                	int    $0x40
+ 327:	c3                   	ret    
+
+00000328 <kill>:
+SYSCALL(kill)
+ 328:	b8 06 00 00 00       	mov    $0x6,%eax
+ 32d:	cd 40                	int    $0x40
+ 32f:	c3                   	ret    
+
+00000330 <exec>:
+SYSCALL(exec)
+ 330:	b8 07 00 00 00       	mov    $0x7,%eax
+ 335:	cd 40                	int    $0x40
+ 337:	c3                   	ret    
+
+00000338 <open>:
+SYSCALL(open)
+ 338:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 33d:	cd 40                	int    $0x40
+ 33f:	c3                   	ret    
+
+00000340 <mknod>:
+SYSCALL(mknod)
+ 340:	b8 11 00 00 00       	mov    $0x11,%eax
+ 345:	cd 40                	int    $0x40
+ 347:	c3                   	ret    
+
+00000348 <unlink>:
+SYSCALL(unlink)
+ 348:	b8 12 00 00 00       	mov    $0x12,%eax
+ 34d:	cd 40                	int    $0x40
+ 34f:	c3                   	ret    
+
+00000350 <fstat>:
+SYSCALL(fstat)
+ 350:	b8 08 00 00 00       	mov    $0x8,%eax
+ 355:	cd 40                	int    $0x40
+ 357:	c3                   	ret    
+
+00000358 <link>:
+SYSCALL(link)
+ 358:	b8 13 00 00 00       	mov    $0x13,%eax
+ 35d:	cd 40                	int    $0x40
+ 35f:	c3                   	ret    
+
+00000360 <mkdir>:
+SYSCALL(mkdir)
+ 360:	b8 14 00 00 00       	mov    $0x14,%eax
+ 365:	cd 40                	int    $0x40
+ 367:	c3                   	ret    
+
+00000368 <chdir>:
+SYSCALL(chdir)
+ 368:	b8 09 00 00 00       	mov    $0x9,%eax
+ 36d:	cd 40                	int    $0x40
+ 36f:	c3                   	ret    
+
+00000370 <dup>:
+SYSCALL(dup)
+ 370:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 375:	cd 40                	int    $0x40
+ 377:	c3                   	ret    
+
+00000378 <getpid>:
+SYSCALL(getpid)
+ 378:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 37d:	cd 40                	int    $0x40
+ 37f:	c3                   	ret    
+
+00000380 <sbrk>:
+SYSCALL(sbrk)
+ 380:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 385:	cd 40                	int    $0x40
+ 387:	c3                   	ret    
+
+00000388 <sleep>:
+SYSCALL(sleep)
+ 388:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 38d:	cd 40                	int    $0x40
+ 38f:	c3                   	ret    
+
+00000390 <uptime>:
+SYSCALL(uptime)
+ 390:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 395:	cd 40                	int    $0x40
+ 397:	c3                   	ret    
+
+00000398 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 398:	b8 16 00 00 00       	mov    $0x16,%eax
+ 39d:	cd 40                	int    $0x40
+ 39f:	c3                   	ret    
+
+000003a0 <shutdown>:
+SYSCALL(shutdown)
+ 3a0:	b8 17 00 00 00       	mov    $0x17,%eax
+ 3a5:	cd 40                	int    $0x40
+ 3a7:	c3                   	ret    
+
+000003a8 <fork_winner>:
+SYSCALL(fork_winner)
+ 3a8:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3ad:	cd 40                	int    $0x40
+ 3af:	c3                   	ret    
+
+000003b0 <set_sched>:
+SYSCALL(set_sched)
+ 3b0:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3b5:	cd 40                	int    $0x40
+ 3b7:	c3                   	ret    
+
+000003b8 <set_priority>:
+SYSCALL(set_priority)
+ 3b8:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3bd:	cd 40                	int    $0x40
+ 3bf:	c3                   	ret    
+
+000003c0 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3c0:	55                   	push   %ebp
+ 3c1:	89 e5                	mov    %esp,%ebp
+ 3c3:	83 ec 28             	sub    $0x28,%esp
+ 3c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c9:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3cc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 3d3:	00 
+ 3d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 3db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3de:	89 04 24             	mov    %eax,(%esp)
+ 3e1:	e8 32 ff ff ff       	call   318 <write>
+}
+ 3e6:	c9                   	leave  
+ 3e7:	c3                   	ret    
+
+000003e8 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3e8:	55                   	push   %ebp
+ 3e9:	89 e5                	mov    %esp,%ebp
+ 3eb:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3f5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3f9:	74 17                	je     412 <printint+0x2a>
+ 3fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3ff:	79 11                	jns    412 <printint+0x2a>
+    neg = 1;
+ 401:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 408:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 40b:	f7 d8                	neg    %eax
+ 40d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 410:	eb 06                	jmp    418 <printint+0x30>
+  } else {
+    x = xx;
+ 412:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 415:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 418:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 41f:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 422:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 425:	ba 00 00 00 00       	mov    $0x0,%edx
+ 42a:	f7 f1                	div    %ecx
+ 42c:	89 d0                	mov    %edx,%eax
+ 42e:	0f b6 80 e4 0a 00 00 	movzbl 0xae4(%eax),%eax
+ 435:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 438:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 43b:	01 ca                	add    %ecx,%edx
+ 43d:	88 02                	mov    %al,(%edx)
+ 43f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 443:	8b 55 10             	mov    0x10(%ebp),%edx
+ 446:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 449:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 44c:	ba 00 00 00 00       	mov    $0x0,%edx
+ 451:	f7 75 d4             	divl   -0x2c(%ebp)
+ 454:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 457:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 45b:	75 c2                	jne    41f <printint+0x37>
+  if(neg)
+ 45d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 461:	74 2e                	je     491 <printint+0xa9>
+    buf[i++] = '-';
+ 463:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 466:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 469:	01 d0                	add    %edx,%eax
+ 46b:	c6 00 2d             	movb   $0x2d,(%eax)
+ 46e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 472:	eb 1d                	jmp    491 <printint+0xa9>
+    putc(fd, buf[i]);
+ 474:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 477:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 47a:	01 d0                	add    %edx,%eax
+ 47c:	0f b6 00             	movzbl (%eax),%eax
+ 47f:	0f be c0             	movsbl %al,%eax
+ 482:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 486:	8b 45 08             	mov    0x8(%ebp),%eax
+ 489:	89 04 24             	mov    %eax,(%esp)
+ 48c:	e8 2f ff ff ff       	call   3c0 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 491:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 495:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 499:	79 d9                	jns    474 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 49b:	c9                   	leave  
+ 49c:	c3                   	ret    
+
+0000049d <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 49d:	55                   	push   %ebp
+ 49e:	89 e5                	mov    %esp,%ebp
+ 4a0:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 4a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4aa:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4ad:	83 c0 04             	add    $0x4,%eax
+ 4b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4ba:	e9 7d 01 00 00       	jmp    63c <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 4bf:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4c5:	01 d0                	add    %edx,%eax
+ 4c7:	0f b6 00             	movzbl (%eax),%eax
+ 4ca:	0f be c0             	movsbl %al,%eax
+ 4cd:	25 ff 00 00 00       	and    $0xff,%eax
+ 4d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4d5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4d9:	75 2c                	jne    507 <printf+0x6a>
+      if(c == '%'){
+ 4db:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4df:	75 0c                	jne    4ed <printf+0x50>
+        state = '%';
+ 4e1:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4e8:	e9 4b 01 00 00       	jmp    638 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 4ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4f0:	0f be c0             	movsbl %al,%eax
+ 4f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4f7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4fa:	89 04 24             	mov    %eax,(%esp)
+ 4fd:	e8 be fe ff ff       	call   3c0 <putc>
+ 502:	e9 31 01 00 00       	jmp    638 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 507:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 50b:	0f 85 27 01 00 00    	jne    638 <printf+0x19b>
+      if(c == 'd'){
+ 511:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 515:	75 2d                	jne    544 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 517:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 51a:	8b 00                	mov    (%eax),%eax
+ 51c:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 523:	00 
+ 524:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 52b:	00 
+ 52c:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 530:	8b 45 08             	mov    0x8(%ebp),%eax
+ 533:	89 04 24             	mov    %eax,(%esp)
+ 536:	e8 ad fe ff ff       	call   3e8 <printint>
+        ap++;
+ 53b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 53f:	e9 ed 00 00 00       	jmp    631 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 544:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 548:	74 06                	je     550 <printf+0xb3>
+ 54a:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 54e:	75 2d                	jne    57d <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 550:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 553:	8b 00                	mov    (%eax),%eax
+ 555:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 55c:	00 
+ 55d:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 564:	00 
+ 565:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 569:	8b 45 08             	mov    0x8(%ebp),%eax
+ 56c:	89 04 24             	mov    %eax,(%esp)
+ 56f:	e8 74 fe ff ff       	call   3e8 <printint>
+        ap++;
+ 574:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 578:	e9 b4 00 00 00       	jmp    631 <printf+0x194>
+      } else if(c == 's'){
+ 57d:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 581:	75 46                	jne    5c9 <printf+0x12c>
+        s = (char*)*ap;
+ 583:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 586:	8b 00                	mov    (%eax),%eax
+ 588:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 58b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 58f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 593:	75 27                	jne    5bc <printf+0x11f>
+          s = "(null)";
+ 595:	c7 45 f4 a0 08 00 00 	movl   $0x8a0,-0xc(%ebp)
+        while(*s != 0){
+ 59c:	eb 1e                	jmp    5bc <printf+0x11f>
+          putc(fd, *s);
+ 59e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5a1:	0f b6 00             	movzbl (%eax),%eax
+ 5a4:	0f be c0             	movsbl %al,%eax
+ 5a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5ab:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ae:	89 04 24             	mov    %eax,(%esp)
+ 5b1:	e8 0a fe ff ff       	call   3c0 <putc>
+          s++;
+ 5b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 5ba:	eb 01                	jmp    5bd <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 5bc:	90                   	nop
+ 5bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5c0:	0f b6 00             	movzbl (%eax),%eax
+ 5c3:	84 c0                	test   %al,%al
+ 5c5:	75 d7                	jne    59e <printf+0x101>
+ 5c7:	eb 68                	jmp    631 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5c9:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5cd:	75 1d                	jne    5ec <printf+0x14f>
+        putc(fd, *ap);
+ 5cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5d2:	8b 00                	mov    (%eax),%eax
+ 5d4:	0f be c0             	movsbl %al,%eax
+ 5d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5de:	89 04 24             	mov    %eax,(%esp)
+ 5e1:	e8 da fd ff ff       	call   3c0 <putc>
+        ap++;
+ 5e6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5ea:	eb 45                	jmp    631 <printf+0x194>
+      } else if(c == '%'){
+ 5ec:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5f0:	75 17                	jne    609 <printf+0x16c>
+        putc(fd, c);
+ 5f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5f5:	0f be c0             	movsbl %al,%eax
+ 5f8:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5fc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ff:	89 04 24             	mov    %eax,(%esp)
+ 602:	e8 b9 fd ff ff       	call   3c0 <putc>
+ 607:	eb 28                	jmp    631 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 609:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 610:	00 
+ 611:	8b 45 08             	mov    0x8(%ebp),%eax
+ 614:	89 04 24             	mov    %eax,(%esp)
+ 617:	e8 a4 fd ff ff       	call   3c0 <putc>
+        putc(fd, c);
+ 61c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 61f:	0f be c0             	movsbl %al,%eax
+ 622:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 626:	8b 45 08             	mov    0x8(%ebp),%eax
+ 629:	89 04 24             	mov    %eax,(%esp)
+ 62c:	e8 8f fd ff ff       	call   3c0 <putc>
+      }
+      state = 0;
+ 631:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 638:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 63c:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 63f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 642:	01 d0                	add    %edx,%eax
+ 644:	0f b6 00             	movzbl (%eax),%eax
+ 647:	84 c0                	test   %al,%al
+ 649:	0f 85 70 fe ff ff    	jne    4bf <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 64f:	c9                   	leave  
+ 650:	c3                   	ret    
+ 651:	90                   	nop
+ 652:	90                   	nop
+ 653:	90                   	nop
+
+00000654 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 654:	55                   	push   %ebp
+ 655:	89 e5                	mov    %esp,%ebp
+ 657:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 65a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 65d:	83 e8 08             	sub    $0x8,%eax
+ 660:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 663:	a1 00 0b 00 00       	mov    0xb00,%eax
+ 668:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 66b:	eb 24                	jmp    691 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 66d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 670:	8b 00                	mov    (%eax),%eax
+ 672:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 675:	77 12                	ja     689 <free+0x35>
+ 677:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 67a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 67d:	77 24                	ja     6a3 <free+0x4f>
+ 67f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 682:	8b 00                	mov    (%eax),%eax
+ 684:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 687:	77 1a                	ja     6a3 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 689:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 68c:	8b 00                	mov    (%eax),%eax
+ 68e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 691:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 694:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 697:	76 d4                	jbe    66d <free+0x19>
+ 699:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 69c:	8b 00                	mov    (%eax),%eax
+ 69e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 6a1:	76 ca                	jbe    66d <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 6a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6a6:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6b3:	01 c2                	add    %eax,%edx
+ 6b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b8:	8b 00                	mov    (%eax),%eax
+ 6ba:	39 c2                	cmp    %eax,%edx
+ 6bc:	75 24                	jne    6e2 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 6be:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c1:	8b 50 04             	mov    0x4(%eax),%edx
+ 6c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c7:	8b 00                	mov    (%eax),%eax
+ 6c9:	8b 40 04             	mov    0x4(%eax),%eax
+ 6cc:	01 c2                	add    %eax,%edx
+ 6ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6d1:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d7:	8b 00                	mov    (%eax),%eax
+ 6d9:	8b 10                	mov    (%eax),%edx
+ 6db:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6de:	89 10                	mov    %edx,(%eax)
+ 6e0:	eb 0a                	jmp    6ec <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e5:	8b 10                	mov    (%eax),%edx
+ 6e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ea:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ef:	8b 40 04             	mov    0x4(%eax),%eax
+ 6f2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fc:	01 d0                	add    %edx,%eax
+ 6fe:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 701:	75 20                	jne    723 <free+0xcf>
+    p->s.size += bp->s.size;
+ 703:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 706:	8b 50 04             	mov    0x4(%eax),%edx
+ 709:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 70c:	8b 40 04             	mov    0x4(%eax),%eax
+ 70f:	01 c2                	add    %eax,%edx
+ 711:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 714:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 717:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 71a:	8b 10                	mov    (%eax),%edx
+ 71c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71f:	89 10                	mov    %edx,(%eax)
+ 721:	eb 08                	jmp    72b <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 723:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 726:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 729:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 72b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 72e:	a3 00 0b 00 00       	mov    %eax,0xb00
+}
+ 733:	c9                   	leave  
+ 734:	c3                   	ret    
+
+00000735 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 735:	55                   	push   %ebp
+ 736:	89 e5                	mov    %esp,%ebp
+ 738:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 73b:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 742:	77 07                	ja     74b <morecore+0x16>
+    nu = 4096;
+ 744:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 74b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 74e:	c1 e0 03             	shl    $0x3,%eax
+ 751:	89 04 24             	mov    %eax,(%esp)
+ 754:	e8 27 fc ff ff       	call   380 <sbrk>
+ 759:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 75c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 760:	75 07                	jne    769 <morecore+0x34>
+    return 0;
+ 762:	b8 00 00 00 00       	mov    $0x0,%eax
+ 767:	eb 22                	jmp    78b <morecore+0x56>
+  hp = (Header*)p;
+ 769:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 76c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 76f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 772:	8b 55 08             	mov    0x8(%ebp),%edx
+ 775:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 778:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 77b:	83 c0 08             	add    $0x8,%eax
+ 77e:	89 04 24             	mov    %eax,(%esp)
+ 781:	e8 ce fe ff ff       	call   654 <free>
+  return freep;
+ 786:	a1 00 0b 00 00       	mov    0xb00,%eax
+}
+ 78b:	c9                   	leave  
+ 78c:	c3                   	ret    
+
+0000078d <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 78d:	55                   	push   %ebp
+ 78e:	89 e5                	mov    %esp,%ebp
+ 790:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 793:	8b 45 08             	mov    0x8(%ebp),%eax
+ 796:	83 c0 07             	add    $0x7,%eax
+ 799:	c1 e8 03             	shr    $0x3,%eax
+ 79c:	83 c0 01             	add    $0x1,%eax
+ 79f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 7a2:	a1 00 0b 00 00       	mov    0xb00,%eax
+ 7a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 7ae:	75 23                	jne    7d3 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 7b0:	c7 45 f0 f8 0a 00 00 	movl   $0xaf8,-0x10(%ebp)
+ 7b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7ba:	a3 00 0b 00 00       	mov    %eax,0xb00
+ 7bf:	a1 00 0b 00 00       	mov    0xb00,%eax
+ 7c4:	a3 f8 0a 00 00       	mov    %eax,0xaf8
+    base.s.size = 0;
+ 7c9:	c7 05 fc 0a 00 00 00 	movl   $0x0,0xafc
+ 7d0:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7d6:	8b 00                	mov    (%eax),%eax
+ 7d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7de:	8b 40 04             	mov    0x4(%eax),%eax
+ 7e1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7e4:	72 4d                	jb     833 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 7e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e9:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7ef:	75 0c                	jne    7fd <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 7f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f4:	8b 10                	mov    (%eax),%edx
+ 7f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7f9:	89 10                	mov    %edx,(%eax)
+ 7fb:	eb 26                	jmp    823 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 7fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 800:	8b 40 04             	mov    0x4(%eax),%eax
+ 803:	89 c2                	mov    %eax,%edx
+ 805:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 808:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80b:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 80e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 811:	8b 40 04             	mov    0x4(%eax),%eax
+ 814:	c1 e0 03             	shl    $0x3,%eax
+ 817:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 81a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81d:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 820:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 823:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 826:	a3 00 0b 00 00       	mov    %eax,0xb00
+      return (void*)(p + 1);
+ 82b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 82e:	83 c0 08             	add    $0x8,%eax
+ 831:	eb 38                	jmp    86b <malloc+0xde>
+    }
+    if(p == freep)
+ 833:	a1 00 0b 00 00       	mov    0xb00,%eax
+ 838:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 83b:	75 1b                	jne    858 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 83d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 840:	89 04 24             	mov    %eax,(%esp)
+ 843:	e8 ed fe ff ff       	call   735 <morecore>
+ 848:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 84b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 84f:	75 07                	jne    858 <malloc+0xcb>
+        return 0;
+ 851:	b8 00 00 00 00       	mov    $0x0,%eax
+ 856:	eb 13                	jmp    86b <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 858:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 85b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 85e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 861:	8b 00                	mov    (%eax),%eax
+ 863:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 866:	e9 70 ff ff ff       	jmp    7db <malloc+0x4e>
+}
+ 86b:	c9                   	leave  
+ 86c:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/mkdir.d cs550-16s-proj1-working/mkdir.d
--- cs550-16s-proj1-base/mkdir.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/mkdir.d	2016-03-04 14:37:02.000000000 -0500
@@ -0,0 +1 @@
+mkdir.o: mkdir.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/mkdir.o and cs550-16s-proj1-working/mkdir.o differ
diff -uNr cs550-16s-proj1-base/mkdir.sym cs550-16s-proj1-working/mkdir.sym
--- cs550-16s-proj1-base/mkdir.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/mkdir.sym	2016-03-04 14:37:03.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+0000086d .rodata
+000008a8 .eh_frame
+00000ae4 .data
+00000af8 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 mkdir.c
+00000000 ulib.c
+00000090 stosb
+00000000 printf.c
+000003c0 putc
+000003e8 printint
+00000ae4 digits.1028
+00000000 umalloc.c
+00000af8 base
+00000b00 freep
+00000735 morecore
+000000b5 strcpy
+0000049d printf
+000002b4 memmove
+00000340 mknod
+000001a8 gets
+00000378 getpid
+0000078d malloc
+00000388 sleep
+000003b8 set_priority
+00000308 pipe
+00000318 write
+00000350 fstat
+00000328 kill
+00000368 chdir
+00000330 exec
+00000300 wait
+00000310 read
+00000348 unlink
+000002f0 fork
+00000380 sbrk
+00000390 uptime
+00000af8 __bss_start
+00000151 memset
+00000000 main
+00000398 enable_sched_trace
+000000e9 strcmp
+000003a0 shutdown
+00000370 dup
+000003b0 set_sched
+0000021b stat
+00000af8 _edata
+00000b04 _end
+00000358 link
+000002f8 exit
+00000269 atoi
+000003a8 fork_winner
+0000012a strlen
+00000338 open
+00000175 strchr
+00000360 mkdir
+00000320 close
+00000654 free
Binary files cs550-16s-proj1-base/mkfs and cs550-16s-proj1-working/mkfs differ
diff -uNr cs550-16s-proj1-base/mkfs.c cs550-16s-proj1-working/mkfs.c
--- cs550-16s-proj1-base/mkfs.c	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/mkfs.c	2016-03-04 14:36:41.000000000 -0500
@@ -11,27 +11,20 @@
 #include "stat.h"
 #include "param.h"
 
-#ifndef static_assert
 #define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
-#endif
 
-#define NINODES 200
-
-// Disk layout:
-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
-
-int nbitmap = FSSIZE/(BSIZE*8) + 1;
-int ninodeblocks = NINODES / IPB + 1;
-int nlog = LOGSIZE;  
-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
-int nblocks;  // Number of data blocks
+int nblocks = (995-LOGSIZE);
+int nlog = LOGSIZE;
+int ninodes = 200;
+int size = 1024;
 
 int fsfd;
 struct superblock sb;
-char zeroes[BSIZE];
-uint freeinode = 1;
+char zeroes[512];
 uint freeblock;
-
+uint usedblocks;
+uint bitblocks;
+uint freeinode = 1;
 
 void balloc(int);
 void wsect(uint, void*);
@@ -70,7 +63,7 @@
   int i, cc, fd;
   uint rootino, inum, off;
   struct dirent de;
-  char buf[BSIZE];
+  char buf[512];
   struct dinode din;
 
 
@@ -81,8 +74,8 @@
     exit(1);
   }
 
-  assert((BSIZE % sizeof(struct dinode)) == 0);
-  assert((BSIZE % sizeof(struct dirent)) == 0);
+  assert((512 % sizeof(struct dinode)) == 0);
+  assert((512 % sizeof(struct dirent)) == 0);
 
   fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
   if(fsfd < 0){
@@ -90,24 +83,21 @@
     exit(1);
   }
 
-  // 1 fs block = 1 disk sector
-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
-  nblocks = FSSIZE - nmeta;
-
-  sb.size = xint(FSSIZE);
-  sb.nblocks = xint(nblocks);
-  sb.ninodes = xint(NINODES);
+  sb.size = xint(size);
+  sb.nblocks = xint(nblocks); // so whole disk is size sectors
+  sb.ninodes = xint(ninodes);
   sb.nlog = xint(nlog);
-  sb.logstart = xint(2);
-  sb.inodestart = xint(2+nlog);
-  sb.bmapstart = xint(2+nlog+ninodeblocks);
 
-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
+  bitblocks = size/(512*8) + 1;
+  usedblocks = ninodes / IPB + 3 + bitblocks;
+  freeblock = usedblocks;
+
+  printf("used %d (bit %d ninode %zu) free %u log %u total %d\n", usedblocks,
+         bitblocks, ninodes/IPB + 1, freeblock, nlog, nblocks+usedblocks+nlog);
 
-  freeblock = nmeta;     // the first free block that we can allocate
+  assert(nblocks + usedblocks + nlog == size);
 
-  for(i = 0; i < FSSIZE; i++)
+  for(i = 0; i < nblocks + usedblocks + nlog; i++)
     wsect(i, zeroes);
 
   memset(buf, 0, sizeof(buf));
@@ -162,7 +152,7 @@
   din.size = xint(off);
   winode(rootino, &din);
 
-  balloc(freeblock);
+  balloc(usedblocks);
 
   exit(0);
 }
@@ -170,24 +160,30 @@
 void
 wsect(uint sec, void *buf)
 {
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+  if(lseek(fsfd, sec * 512L, 0) != sec * 512L){
     perror("lseek");
     exit(1);
   }
-  if(write(fsfd, buf, BSIZE) != BSIZE){
+  if(write(fsfd, buf, 512) != 512){
     perror("write");
     exit(1);
   }
 }
 
+uint
+i2b(uint inum)
+{
+  return (inum / IPB) + 2;
+}
+
 void
 winode(uint inum, struct dinode *ip)
 {
-  char buf[BSIZE];
+  char buf[512];
   uint bn;
   struct dinode *dip;
 
-  bn = IBLOCK(inum, sb);
+  bn = i2b(inum);
   rsect(bn, buf);
   dip = ((struct dinode*)buf) + (inum % IPB);
   *dip = *ip;
@@ -197,11 +193,11 @@
 void
 rinode(uint inum, struct dinode *ip)
 {
-  char buf[BSIZE];
+  char buf[512];
   uint bn;
   struct dinode *dip;
 
-  bn = IBLOCK(inum, sb);
+  bn = i2b(inum);
   rsect(bn, buf);
   dip = ((struct dinode*)buf) + (inum % IPB);
   *ip = *dip;
@@ -210,11 +206,11 @@
 void
 rsect(uint sec, void *buf)
 {
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+  if(lseek(fsfd, sec * 512L, 0) != sec * 512L){
     perror("lseek");
     exit(1);
   }
-  if(read(fsfd, buf, BSIZE) != BSIZE){
+  if(read(fsfd, buf, 512) != 512){
     perror("read");
     exit(1);
   }
@@ -237,17 +233,17 @@
 void
 balloc(int used)
 {
-  uchar buf[BSIZE];
+  uchar buf[512];
   int i;
 
   printf("balloc: first %d blocks have been allocated\n", used);
-  assert(used < BSIZE*8);
-  bzero(buf, BSIZE);
+  assert(used < 512*8);
+  bzero(buf, 512);
   for(i = 0; i < used; i++){
     buf[i/8] = buf[i/8] | (0x1 << (i%8));
   }
-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
-  wsect(sb.bmapstart, buf);
+  printf("balloc: write bitmap block at sector %zu\n", ninodes/IPB + 3);
+  wsect(ninodes / IPB + 3, buf);
 }
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
@@ -258,35 +254,40 @@
   char *p = (char*)xp;
   uint fbn, off, n1;
   struct dinode din;
-  char buf[BSIZE];
+  char buf[512];
   uint indirect[NINDIRECT];
   uint x;
 
   rinode(inum, &din);
+
   off = xint(din.size);
-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
   while(n > 0){
-    fbn = off / BSIZE;
+    fbn = off / 512;
     assert(fbn < MAXFILE);
     if(fbn < NDIRECT){
       if(xint(din.addrs[fbn]) == 0){
         din.addrs[fbn] = xint(freeblock++);
+        usedblocks++;
       }
       x = xint(din.addrs[fbn]);
     } else {
       if(xint(din.addrs[NDIRECT]) == 0){
+        // printf("allocate indirect block\n");
         din.addrs[NDIRECT] = xint(freeblock++);
+        usedblocks++;
       }
+      // printf("read indirect block\n");
       rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
       if(indirect[fbn - NDIRECT] == 0){
         indirect[fbn - NDIRECT] = xint(freeblock++);
+        usedblocks++;
         wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
       }
       x = xint(indirect[fbn-NDIRECT]);
     }
-    n1 = min(n, (fbn + 1) * BSIZE - off);
+    n1 = min(n, (fbn + 1) * 512 - off);
     rsect(x, buf);
-    bcopy(p, buf + off - (fbn * BSIZE), n1);
+    bcopy(p, buf + off - (fbn * 512), n1);
     wsect(x, buf);
     n -= n1;
     off += n1;
diff -uNr cs550-16s-proj1-base/mp.d cs550-16s-proj1-working/mp.d
--- cs550-16s-proj1-base/mp.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/mp.d	2016-03-04 15:49:55.912976884 -0500
@@ -0,0 +1 @@
+mp.o: mp.c types.h defs.h param.h memlayout.h mp.h x86.h mmu.h proc.h
Binary files cs550-16s-proj1-base/mp.o and cs550-16s-proj1-working/mp.o differ
diff -uNr cs550-16s-proj1-base/param.h cs550-16s-proj1-working/param.h
--- cs550-16s-proj1-base/param.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/param.h	2016-03-04 14:36:41.000000000 -0500
@@ -8,7 +8,6 @@
 #define ROOTDEV       1  // device number of file system root disk
 #define MAXARG       32  // max exec arguments
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+#define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
 
diff -uNr cs550-16s-proj1-base/picirq.d cs550-16s-proj1-working/picirq.d
--- cs550-16s-proj1-base/picirq.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/picirq.d	2016-03-04 14:37:22.000000000 -0500
@@ -0,0 +1 @@
+picirq.o: picirq.c types.h x86.h traps.h
Binary files cs550-16s-proj1-base/picirq.o and cs550-16s-proj1-working/picirq.o differ
diff -uNr cs550-16s-proj1-base/pipe.d cs550-16s-proj1-working/pipe.d
--- cs550-16s-proj1-base/pipe.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/pipe.d	2016-03-04 15:49:56.392969994 -0500
@@ -0,0 +1 @@
+pipe.o: pipe.c types.h defs.h param.h mmu.h proc.h fs.h file.h spinlock.h
Binary files cs550-16s-proj1-base/pipe.o and cs550-16s-proj1-working/pipe.o differ
diff -uNr cs550-16s-proj1-base/printf.d cs550-16s-proj1-working/printf.d
--- cs550-16s-proj1-base/printf.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/printf.d	2016-03-04 14:36:52.000000000 -0500
@@ -0,0 +1 @@
+printf.o: printf.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/printf.o and cs550-16s-proj1-working/printf.o differ
diff -uNr cs550-16s-proj1-base/proc.c cs550-16s-proj1-working/proc.c
--- cs550-16s-proj1-base/proc.c	2016-02-15 22:30:50.000000000 -0500
+++ cs550-16s-proj1-working/proc.c	2016-03-04 15:52:24.000000000 -0500
@@ -14,15 +14,30 @@
 
 static struct proc *initproc;
 
+int maximum = 3;
 int nextpid = 1;
-
 int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
-
+int win;
+int schd_choice = 0;
+int process_id;
+int process_priority = 2;
 extern void forkret(void);
 extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+void set_priority(int pid,int priority) {
+   struct proc *p;
+   p = ptable.proc;
+   while(p < &ptable.proc[NPROC]) {
+      if(p->pid == pid) {
+        p->process_priority = priority;
+      }
+	 p++; 
+   }
+}
+
+
 void
 pinit(void)
 {
@@ -148,7 +163,7 @@
   np->sz = proc->sz;
   np->parent = proc;
   *np->tf = *proc->tf;
-
+  np->process_priority = 2;
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
@@ -158,14 +173,14 @@
   np->cwd = idup(proc->cwd);
 
   safestrcpy(np->name, proc->name, sizeof(proc->name));
- 
+
   pid = np->pid;
 
-  // lock to force the compiler to emit the np->state write last.
-  acquire(&ptable.lock);
   np->state = RUNNABLE;
-  release(&ptable.lock);
-  
+  if(win == 1) {
+	yield();
+  }
+
   return pid;
 }
 
@@ -269,40 +284,49 @@
 scheduler(void)
 {
   struct proc *p;
-  int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
-
   for(;;){
-    // Enable interrupts on this processor.
     sti();
-
-    // Loop over process table looking for process to run.
+  if(schd_choice == 0) {
     acquire(&ptable.lock);
-    ran = 0;
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
 
-      ran = 1;
-      
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
       proc = p;
       switchuvm(p);
       p->state = RUNNING;
       swtch(&cpu->scheduler, proc->context);
       switchkvm();
 
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
       proc = 0;
     }
     release(&ptable.lock);
 
-    if (ran == 0){
-        halt();
+  }
+  else {
+    acquire(&ptable.lock);
+    int flag = 0;
+
+    for(p = &ptable.proc[NPROC - 1]; p >= ptable.proc; p--){
+      if((p->state != RUNNABLE))
+        continue;
+      if(p->process_priority > maximum)
+           maximum = p->process_priority;
+      if((p->process_priority == maximum)) {
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+      proc = 0;
+      flag = 1;
+     }
     }
+    if((flag == 0))
+       maximum--;
+    release(&ptable.lock);
   }
+ }
 }
 
 // Enter scheduler.  Must hold only ptable.lock
@@ -354,8 +378,7 @@
     // of a regular process (e.g., they call sleep), and thus cannot 
     // be run from main().
     first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
+    initlog();
   }
   
   // Return to "caller", actually trapret (see allocproc).
diff -uNr cs550-16s-proj1-base/proc.c.save.1 cs550-16s-proj1-working/proc.c.save.1
--- cs550-16s-proj1-base/proc.c.save.1	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proc.c.save.1	2016-03-04 14:36:41.000000000 -0500
@@ -0,0 +1,476 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+
+struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+static struct proc *initproc;
+
+int nextpid = 1;
+
+int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
+int winner;
+extern void forkret(void);
+extern void trapret(void);
+
+static void wakeup1(void *chan);
+
+void
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
+}
+
+//PAGEBREAK: 32
+// Look in the process table for an UNUSED proc.
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+  release(&ptable.lock);
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+    p->state = UNUSED;
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+  
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+  p->tf = (struct trapframe*)sp;
+  
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+  p->context->eip = (uint)forkret;
+
+  return p;
+}
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+  p = allocproc();
+  initproc = p;
+  if((p->pgdir = setupkvm()) == 0)
+    panic("userinit: out of memory?");
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+  p->sz = PGSIZE;
+  memset(p->tf, 0, sizeof(*p->tf));
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  p->tf->es = p->tf->ds;
+  p->tf->ss = p->tf->ds;
+  p->tf->eflags = FL_IF;
+  p->tf->esp = PGSIZE;
+  p->tf->eip = 0;  // beginning of initcode.S
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  p->state = RUNNABLE;
+}
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint sz;
+  
+  sz = proc->sz;
+  if(n > 0){
+    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  } else if(n < 0){
+    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  }
+  proc->sz = sz;
+  switchuvm(proc);
+  return 0;
+}
+
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+
+  pid = np->pid;
+
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  np->state = RUNNABLE;
+  if(winner == 0) {
+
+  }
+  release(&ptable.lock);
+
+  return pid;
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+  struct proc *p;
+  int fd;
+
+  if(proc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(proc->ofile[fd]){
+      fileclose(proc->ofile[fd]);
+      proc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(proc->cwd);
+  end_op();
+  proc->cwd = 0;
+
+  acquire(&ptable.lock);
+
+  // Parent might be sleeping in wait().
+  wakeup1(proc->parent);
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == proc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  proc->state = ZOMBIE;
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+  struct proc *p;
+
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    }
+    release(&ptable.lock);
+
+  }
+}
+
+// Enter scheduler.  Must hold only ptable.lock
+// and have changed proc->state.
+void
+sched(void)
+{
+  int intena;
+
+  if(!holding(&ptable.lock))
+    panic("sched ptable.lock");
+  if(cpu->ncli != 1)
+    panic("sched locks");
+  if(proc->state == RUNNING)
+    panic("sched running");
+  if(readeflags()&FL_IF)
+    panic("sched interruptible");
+  intena = cpu->intena;
+  swtch(&proc->context, cpu->scheduler);
+  cpu->intena = intena;
+}
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  if (sched_trace_enabled)
+  {
+    cprintf("%d - ", proc->pid);
+  }
+
+  acquire(&ptable.lock);  //DOC: yieldlock
+  proc->state = RUNNABLE;
+  sched();
+  release(&ptable.lock);
+}
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+
+  if (first) {
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot 
+    // be run from main().
+    first = 0;
+    initlog();
+  }
+  
+  // Return to "caller", actually trapret (see allocproc).
+}
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  if(proc == 0)
+    panic("sleep");
+
+  if(lk == 0)
+    panic("sleep without lk");
+
+  // Must acquire ptable.lock in order to
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+    acquire(&ptable.lock);  //DOC: sleeplock1
+    release(lk);
+  }
+
+  // Go to sleep.
+  proc->chan = chan;
+  proc->state = SLEEPING;
+  sched();
+
+  // Tidy up.
+  proc->chan = 0;
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+    release(&ptable.lock);
+    acquire(lk);
+  }
+}
+
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+  acquire(&ptable.lock);
+  wakeup1(chan);
+  release(&ptable.lock);
+}
+
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid == pid){
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+//PAGEBREAK: 36
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+  }
+}
diff -uNr cs550-16s-proj1-base/proc.d cs550-16s-proj1-working/proc.d
--- cs550-16s-proj1-base/proc.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proc.d	2016-03-04 15:52:33.882706752 -0500
@@ -0,0 +1,2 @@
+proc.o: proc.c types.h defs.h param.h memlayout.h mmu.h x86.h proc.h \
+ spinlock.h
diff -uNr cs550-16s-proj1-base/proc.h cs550-16s-proj1-working/proc.h
--- cs550-16s-proj1-base/proc.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/proc.h	2016-03-04 15:45:04.000000000 -0500
@@ -66,6 +66,7 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int process_priority;
 };
 
 // Process memory is laid out contiguously, low addresses first:
Binary files cs550-16s-proj1-base/proc.o and cs550-16s-proj1-working/proc.o differ
Binary files cs550-16s-proj1-base/_proj1_forktest and cs550-16s-proj1-working/_proj1_forktest differ
diff -uNr cs550-16s-proj1-base/proj1_forktest.asm cs550-16s-proj1-working/proj1_forktest.asm
--- cs550-16s-proj1-base/proj1_forktest.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1_forktest.asm	2016-03-04 14:37:12.000000000 -0500
@@ -0,0 +1,1324 @@
+
+_proj1_forktest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+*/
+#define TOTAL_TEST_TRIALS 50
+
+int
+main(int argc, char *argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 20             	sub    $0x20,%esp
+    int i = 0;
+   9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
+  10:	00 
+    int w = 0;
+  11:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  18:	00 
+    int ret = 0;
+  19:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  20:	00 
+
+    if (argc < 2)
+  21:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+  25:	7f 19                	jg     40 <main+0x40>
+    {
+        printf(1, "Usage: proj1_forktest 0|1 \n"
+  27:	c7 44 24 04 6c 09 00 	movl   $0x96c,0x4(%esp)
+  2e:	00 
+  2f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  36:	e8 5e 05 00 00       	call   599 <printf>
+                  "\t0: Parent is scheduled to run most often\n"
+                  "\t1: Child is scheduled to run most often\n");
+        exit();
+  3b:	e8 b4 03 00 00       	call   3f4 <exit>
+    }
+
+    if (argv[1][0] == '0')
+  40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  43:	83 c0 04             	add    $0x4,%eax
+  46:	8b 00                	mov    (%eax),%eax
+  48:	0f b6 00             	movzbl (%eax),%eax
+  4b:	3c 30                	cmp    $0x30,%al
+  4d:	75 1e                	jne    6d <main+0x6d>
+    {
+        w = 0;
+  4f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  56:	00 
+        printf(1, "\nSetting parent as the fork winner ...\n");
+  57:	c7 44 24 04 dc 09 00 	movl   $0x9dc,0x4(%esp)
+  5e:	00 
+  5f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  66:	e8 2e 05 00 00       	call   599 <printf>
+  6b:	eb 1c                	jmp    89 <main+0x89>
+    }
+    else
+    {
+        w = 1;
+  6d:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
+  74:	00 
+        printf(1, "\nSetting child as the fork winner ...\n");
+  75:	c7 44 24 04 04 0a 00 	movl   $0xa04,0x4(%esp)
+  7c:	00 
+  7d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  84:	e8 10 05 00 00       	call   599 <printf>
+    }
+
+    fork_winner(w); // set according to user input
+  89:	8b 44 24 18          	mov    0x18(%esp),%eax
+  8d:	89 04 24             	mov    %eax,(%esp)
+  90:	e8 0f 04 00 00       	call   4a4 <fork_winner>
+
+    printf(1, "\nCS550 proj1 fork test ==> \n");
+  95:	c7 44 24 04 2b 0a 00 	movl   $0xa2b,0x4(%esp)
+  9c:	00 
+  9d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  a4:	e8 f0 04 00 00       	call   599 <printf>
+
+    for (i = 0; i < TOTAL_TEST_TRIALS; i++)
+  a9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
+  b0:	00 
+  b1:	e9 a5 00 00 00       	jmp    15b <main+0x15b>
+    {
+        printf(1, "\nTrial %d: ", i);
+  b6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  ba:	89 44 24 08          	mov    %eax,0x8(%esp)
+  be:	c7 44 24 04 48 0a 00 	movl   $0xa48,0x4(%esp)
+  c5:	00 
+  c6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  cd:	e8 c7 04 00 00       	call   599 <printf>
+        ret = fork();
+  d2:	e8 15 03 00 00       	call   3ec <fork>
+  d7:	89 44 24 14          	mov    %eax,0x14(%esp)
+        if (ret < 0)
+  db:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
+  e0:	79 21                	jns    103 <main+0x103>
+        {
+            printf(1, "fork() failed (%d)\n", ret);
+  e2:	8b 44 24 14          	mov    0x14(%esp),%eax
+  e6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  ea:	c7 44 24 04 54 0a 00 	movl   $0xa54,0x4(%esp)
+  f1:	00 
+  f2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  f9:	e8 9b 04 00 00       	call   599 <printf>
+            exit();
+  fe:	e8 f1 02 00 00       	call   3f4 <exit>
+        }
+        else if (ret == 0) // child
+ 103:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
+ 108:	75 19                	jne    123 <main+0x123>
+        {
+            printf(1, " child! ");
+ 10a:	c7 44 24 04 68 0a 00 	movl   $0xa68,0x4(%esp)
+ 111:	00 
+ 112:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 119:	e8 7b 04 00 00       	call   599 <printf>
+            exit();
+ 11e:	e8 d1 02 00 00       	call   3f4 <exit>
+        }
+
+        // parent
+        printf(1, " parent! ");
+ 123:	c7 44 24 04 71 0a 00 	movl   $0xa71,0x4(%esp)
+ 12a:	00 
+ 12b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 132:	e8 62 04 00 00       	call   599 <printf>
+        if (ret != wait())
+ 137:	e8 c0 02 00 00       	call   3fc <wait>
+ 13c:	3b 44 24 14          	cmp    0x14(%esp),%eax
+ 140:	74 14                	je     156 <main+0x156>
+        {
+            printf(1, "wait() failed!\n");
+ 142:	c7 44 24 04 7b 0a 00 	movl   $0xa7b,0x4(%esp)
+ 149:	00 
+ 14a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 151:	e8 43 04 00 00       	call   599 <printf>
+
+    fork_winner(w); // set according to user input
+
+    printf(1, "\nCS550 proj1 fork test ==> \n");
+
+    for (i = 0; i < TOTAL_TEST_TRIALS; i++)
+ 156:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+ 15b:	83 7c 24 1c 31       	cmpl   $0x31,0x1c(%esp)
+ 160:	0f 8e 50 ff ff ff    	jle    b6 <main+0xb6>
+        {
+            printf(1, "wait() failed!\n");
+        }
+    }
+
+    printf(1, "\n");
+ 166:	c7 44 24 04 8b 0a 00 	movl   $0xa8b,0x4(%esp)
+ 16d:	00 
+ 16e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 175:	e8 1f 04 00 00       	call   599 <printf>
+
+    fork_winner(0); // set back to default
+ 17a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 181:	e8 1e 03 00 00       	call   4a4 <fork_winner>
+
+    exit();
+ 186:	e8 69 02 00 00       	call   3f4 <exit>
+ 18b:	90                   	nop
+
+0000018c <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 18c:	55                   	push   %ebp
+ 18d:	89 e5                	mov    %esp,%ebp
+ 18f:	57                   	push   %edi
+ 190:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 191:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 194:	8b 55 10             	mov    0x10(%ebp),%edx
+ 197:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 19a:	89 cb                	mov    %ecx,%ebx
+ 19c:	89 df                	mov    %ebx,%edi
+ 19e:	89 d1                	mov    %edx,%ecx
+ 1a0:	fc                   	cld    
+ 1a1:	f3 aa                	rep stos %al,%es:(%edi)
+ 1a3:	89 ca                	mov    %ecx,%edx
+ 1a5:	89 fb                	mov    %edi,%ebx
+ 1a7:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 1aa:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 1ad:	5b                   	pop    %ebx
+ 1ae:	5f                   	pop    %edi
+ 1af:	5d                   	pop    %ebp
+ 1b0:	c3                   	ret    
+
+000001b1 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 1b1:	55                   	push   %ebp
+ 1b2:	89 e5                	mov    %esp,%ebp
+ 1b4:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 1b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ba:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 1bd:	90                   	nop
+ 1be:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1c1:	0f b6 10             	movzbl (%eax),%edx
+ 1c4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1c7:	88 10                	mov    %dl,(%eax)
+ 1c9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1cc:	0f b6 00             	movzbl (%eax),%eax
+ 1cf:	84 c0                	test   %al,%al
+ 1d1:	0f 95 c0             	setne  %al
+ 1d4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 1d8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 1dc:	84 c0                	test   %al,%al
+ 1de:	75 de                	jne    1be <strcpy+0xd>
+    ;
+  return os;
+ 1e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1e3:	c9                   	leave  
+ 1e4:	c3                   	ret    
+
+000001e5 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 1e5:	55                   	push   %ebp
+ 1e6:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 1e8:	eb 08                	jmp    1f2 <strcmp+0xd>
+    p++, q++;
+ 1ea:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 1ee:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 1f2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1f5:	0f b6 00             	movzbl (%eax),%eax
+ 1f8:	84 c0                	test   %al,%al
+ 1fa:	74 10                	je     20c <strcmp+0x27>
+ 1fc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ff:	0f b6 10             	movzbl (%eax),%edx
+ 202:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 205:	0f b6 00             	movzbl (%eax),%eax
+ 208:	38 c2                	cmp    %al,%dl
+ 20a:	74 de                	je     1ea <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 20c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20f:	0f b6 00             	movzbl (%eax),%eax
+ 212:	0f b6 d0             	movzbl %al,%edx
+ 215:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 218:	0f b6 00             	movzbl (%eax),%eax
+ 21b:	0f b6 c0             	movzbl %al,%eax
+ 21e:	89 d1                	mov    %edx,%ecx
+ 220:	29 c1                	sub    %eax,%ecx
+ 222:	89 c8                	mov    %ecx,%eax
+}
+ 224:	5d                   	pop    %ebp
+ 225:	c3                   	ret    
+
+00000226 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 226:	55                   	push   %ebp
+ 227:	89 e5                	mov    %esp,%ebp
+ 229:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 22c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 233:	eb 04                	jmp    239 <strlen+0x13>
+ 235:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 239:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 23c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 23f:	01 d0                	add    %edx,%eax
+ 241:	0f b6 00             	movzbl (%eax),%eax
+ 244:	84 c0                	test   %al,%al
+ 246:	75 ed                	jne    235 <strlen+0xf>
+    ;
+  return n;
+ 248:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 24b:	c9                   	leave  
+ 24c:	c3                   	ret    
+
+0000024d <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 24d:	55                   	push   %ebp
+ 24e:	89 e5                	mov    %esp,%ebp
+ 250:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 253:	8b 45 10             	mov    0x10(%ebp),%eax
+ 256:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 25a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 25d:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 261:	8b 45 08             	mov    0x8(%ebp),%eax
+ 264:	89 04 24             	mov    %eax,(%esp)
+ 267:	e8 20 ff ff ff       	call   18c <stosb>
+  return dst;
+ 26c:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 26f:	c9                   	leave  
+ 270:	c3                   	ret    
+
+00000271 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 271:	55                   	push   %ebp
+ 272:	89 e5                	mov    %esp,%ebp
+ 274:	83 ec 04             	sub    $0x4,%esp
+ 277:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 27a:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 27d:	eb 14                	jmp    293 <strchr+0x22>
+    if(*s == c)
+ 27f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 282:	0f b6 00             	movzbl (%eax),%eax
+ 285:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 288:	75 05                	jne    28f <strchr+0x1e>
+      return (char*)s;
+ 28a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28d:	eb 13                	jmp    2a2 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 28f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 293:	8b 45 08             	mov    0x8(%ebp),%eax
+ 296:	0f b6 00             	movzbl (%eax),%eax
+ 299:	84 c0                	test   %al,%al
+ 29b:	75 e2                	jne    27f <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 29d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 2a2:	c9                   	leave  
+ 2a3:	c3                   	ret    
+
+000002a4 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 2a4:	55                   	push   %ebp
+ 2a5:	89 e5                	mov    %esp,%ebp
+ 2a7:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 2b1:	eb 46                	jmp    2f9 <gets+0x55>
+    cc = read(0, &c, 1);
+ 2b3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 2ba:	00 
+ 2bb:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 2be:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 2c9:	e8 3e 01 00 00       	call   40c <read>
+ 2ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 2d1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 2d5:	7e 2f                	jle    306 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 2d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 2da:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2dd:	01 c2                	add    %eax,%edx
+ 2df:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2e3:	88 02                	mov    %al,(%edx)
+ 2e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 2e9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2ed:	3c 0a                	cmp    $0xa,%al
+ 2ef:	74 16                	je     307 <gets+0x63>
+ 2f1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2f5:	3c 0d                	cmp    $0xd,%al
+ 2f7:	74 0e                	je     307 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2fc:	83 c0 01             	add    $0x1,%eax
+ 2ff:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 302:	7c af                	jl     2b3 <gets+0xf>
+ 304:	eb 01                	jmp    307 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 306:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 307:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 30a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 30d:	01 d0                	add    %edx,%eax
+ 30f:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 312:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 315:	c9                   	leave  
+ 316:	c3                   	ret    
+
+00000317 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 317:	55                   	push   %ebp
+ 318:	89 e5                	mov    %esp,%ebp
+ 31a:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 31d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 324:	00 
+ 325:	8b 45 08             	mov    0x8(%ebp),%eax
+ 328:	89 04 24             	mov    %eax,(%esp)
+ 32b:	e8 04 01 00 00       	call   434 <open>
+ 330:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 333:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 337:	79 07                	jns    340 <stat+0x29>
+    return -1;
+ 339:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 33e:	eb 23                	jmp    363 <stat+0x4c>
+  r = fstat(fd, st);
+ 340:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 343:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 347:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 34a:	89 04 24             	mov    %eax,(%esp)
+ 34d:	e8 fa 00 00 00       	call   44c <fstat>
+ 352:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 355:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 358:	89 04 24             	mov    %eax,(%esp)
+ 35b:	e8 bc 00 00 00       	call   41c <close>
+  return r;
+ 360:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 363:	c9                   	leave  
+ 364:	c3                   	ret    
+
+00000365 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 365:	55                   	push   %ebp
+ 366:	89 e5                	mov    %esp,%ebp
+ 368:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 36b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 372:	eb 23                	jmp    397 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 374:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 377:	89 d0                	mov    %edx,%eax
+ 379:	c1 e0 02             	shl    $0x2,%eax
+ 37c:	01 d0                	add    %edx,%eax
+ 37e:	01 c0                	add    %eax,%eax
+ 380:	89 c2                	mov    %eax,%edx
+ 382:	8b 45 08             	mov    0x8(%ebp),%eax
+ 385:	0f b6 00             	movzbl (%eax),%eax
+ 388:	0f be c0             	movsbl %al,%eax
+ 38b:	01 d0                	add    %edx,%eax
+ 38d:	83 e8 30             	sub    $0x30,%eax
+ 390:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 393:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 397:	8b 45 08             	mov    0x8(%ebp),%eax
+ 39a:	0f b6 00             	movzbl (%eax),%eax
+ 39d:	3c 2f                	cmp    $0x2f,%al
+ 39f:	7e 0a                	jle    3ab <atoi+0x46>
+ 3a1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3a4:	0f b6 00             	movzbl (%eax),%eax
+ 3a7:	3c 39                	cmp    $0x39,%al
+ 3a9:	7e c9                	jle    374 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 3ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3ae:	c9                   	leave  
+ 3af:	c3                   	ret    
+
+000003b0 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 3b0:	55                   	push   %ebp
+ 3b1:	89 e5                	mov    %esp,%ebp
+ 3b3:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 3b6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 3bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 3c2:	eb 13                	jmp    3d7 <memmove+0x27>
+    *dst++ = *src++;
+ 3c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 3c7:	0f b6 10             	movzbl (%eax),%edx
+ 3ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 3cd:	88 10                	mov    %dl,(%eax)
+ 3cf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 3d3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 3d7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 3db:	0f 9f c0             	setg   %al
+ 3de:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 3e2:	84 c0                	test   %al,%al
+ 3e4:	75 de                	jne    3c4 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 3e6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 3e9:	c9                   	leave  
+ 3ea:	c3                   	ret    
+ 3eb:	90                   	nop
+
+000003ec <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 3ec:	b8 01 00 00 00       	mov    $0x1,%eax
+ 3f1:	cd 40                	int    $0x40
+ 3f3:	c3                   	ret    
+
+000003f4 <exit>:
+SYSCALL(exit)
+ 3f4:	b8 02 00 00 00       	mov    $0x2,%eax
+ 3f9:	cd 40                	int    $0x40
+ 3fb:	c3                   	ret    
+
+000003fc <wait>:
+SYSCALL(wait)
+ 3fc:	b8 03 00 00 00       	mov    $0x3,%eax
+ 401:	cd 40                	int    $0x40
+ 403:	c3                   	ret    
+
+00000404 <pipe>:
+SYSCALL(pipe)
+ 404:	b8 04 00 00 00       	mov    $0x4,%eax
+ 409:	cd 40                	int    $0x40
+ 40b:	c3                   	ret    
+
+0000040c <read>:
+SYSCALL(read)
+ 40c:	b8 05 00 00 00       	mov    $0x5,%eax
+ 411:	cd 40                	int    $0x40
+ 413:	c3                   	ret    
+
+00000414 <write>:
+SYSCALL(write)
+ 414:	b8 10 00 00 00       	mov    $0x10,%eax
+ 419:	cd 40                	int    $0x40
+ 41b:	c3                   	ret    
+
+0000041c <close>:
+SYSCALL(close)
+ 41c:	b8 15 00 00 00       	mov    $0x15,%eax
+ 421:	cd 40                	int    $0x40
+ 423:	c3                   	ret    
+
+00000424 <kill>:
+SYSCALL(kill)
+ 424:	b8 06 00 00 00       	mov    $0x6,%eax
+ 429:	cd 40                	int    $0x40
+ 42b:	c3                   	ret    
+
+0000042c <exec>:
+SYSCALL(exec)
+ 42c:	b8 07 00 00 00       	mov    $0x7,%eax
+ 431:	cd 40                	int    $0x40
+ 433:	c3                   	ret    
+
+00000434 <open>:
+SYSCALL(open)
+ 434:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 439:	cd 40                	int    $0x40
+ 43b:	c3                   	ret    
+
+0000043c <mknod>:
+SYSCALL(mknod)
+ 43c:	b8 11 00 00 00       	mov    $0x11,%eax
+ 441:	cd 40                	int    $0x40
+ 443:	c3                   	ret    
+
+00000444 <unlink>:
+SYSCALL(unlink)
+ 444:	b8 12 00 00 00       	mov    $0x12,%eax
+ 449:	cd 40                	int    $0x40
+ 44b:	c3                   	ret    
+
+0000044c <fstat>:
+SYSCALL(fstat)
+ 44c:	b8 08 00 00 00       	mov    $0x8,%eax
+ 451:	cd 40                	int    $0x40
+ 453:	c3                   	ret    
+
+00000454 <link>:
+SYSCALL(link)
+ 454:	b8 13 00 00 00       	mov    $0x13,%eax
+ 459:	cd 40                	int    $0x40
+ 45b:	c3                   	ret    
+
+0000045c <mkdir>:
+SYSCALL(mkdir)
+ 45c:	b8 14 00 00 00       	mov    $0x14,%eax
+ 461:	cd 40                	int    $0x40
+ 463:	c3                   	ret    
+
+00000464 <chdir>:
+SYSCALL(chdir)
+ 464:	b8 09 00 00 00       	mov    $0x9,%eax
+ 469:	cd 40                	int    $0x40
+ 46b:	c3                   	ret    
+
+0000046c <dup>:
+SYSCALL(dup)
+ 46c:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 471:	cd 40                	int    $0x40
+ 473:	c3                   	ret    
+
+00000474 <getpid>:
+SYSCALL(getpid)
+ 474:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 479:	cd 40                	int    $0x40
+ 47b:	c3                   	ret    
+
+0000047c <sbrk>:
+SYSCALL(sbrk)
+ 47c:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 481:	cd 40                	int    $0x40
+ 483:	c3                   	ret    
+
+00000484 <sleep>:
+SYSCALL(sleep)
+ 484:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 489:	cd 40                	int    $0x40
+ 48b:	c3                   	ret    
+
+0000048c <uptime>:
+SYSCALL(uptime)
+ 48c:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 491:	cd 40                	int    $0x40
+ 493:	c3                   	ret    
+
+00000494 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 494:	b8 16 00 00 00       	mov    $0x16,%eax
+ 499:	cd 40                	int    $0x40
+ 49b:	c3                   	ret    
+
+0000049c <shutdown>:
+SYSCALL(shutdown)
+ 49c:	b8 17 00 00 00       	mov    $0x17,%eax
+ 4a1:	cd 40                	int    $0x40
+ 4a3:	c3                   	ret    
+
+000004a4 <fork_winner>:
+SYSCALL(fork_winner)
+ 4a4:	b8 18 00 00 00       	mov    $0x18,%eax
+ 4a9:	cd 40                	int    $0x40
+ 4ab:	c3                   	ret    
+
+000004ac <set_sched>:
+SYSCALL(set_sched)
+ 4ac:	b8 19 00 00 00       	mov    $0x19,%eax
+ 4b1:	cd 40                	int    $0x40
+ 4b3:	c3                   	ret    
+
+000004b4 <set_priority>:
+SYSCALL(set_priority)
+ 4b4:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 4b9:	cd 40                	int    $0x40
+ 4bb:	c3                   	ret    
+
+000004bc <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 4bc:	55                   	push   %ebp
+ 4bd:	89 e5                	mov    %esp,%ebp
+ 4bf:	83 ec 28             	sub    $0x28,%esp
+ 4c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4c5:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 4c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 4cf:	00 
+ 4d0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 4d3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4d7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4da:	89 04 24             	mov    %eax,(%esp)
+ 4dd:	e8 32 ff ff ff       	call   414 <write>
+}
+ 4e2:	c9                   	leave  
+ 4e3:	c3                   	ret    
+
+000004e4 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 4e4:	55                   	push   %ebp
+ 4e5:	89 e5                	mov    %esp,%ebp
+ 4e7:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 4ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 4f1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 4f5:	74 17                	je     50e <printint+0x2a>
+ 4f7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 4fb:	79 11                	jns    50e <printint+0x2a>
+    neg = 1;
+ 4fd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 504:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 507:	f7 d8                	neg    %eax
+ 509:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 50c:	eb 06                	jmp    514 <printint+0x30>
+  } else {
+    x = xx;
+ 50e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 511:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 514:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 51b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 51e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 521:	ba 00 00 00 00       	mov    $0x0,%edx
+ 526:	f7 f1                	div    %ecx
+ 528:	89 d0                	mov    %edx,%eax
+ 52a:	0f b6 80 d0 0c 00 00 	movzbl 0xcd0(%eax),%eax
+ 531:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 534:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 537:	01 ca                	add    %ecx,%edx
+ 539:	88 02                	mov    %al,(%edx)
+ 53b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 53f:	8b 55 10             	mov    0x10(%ebp),%edx
+ 542:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 545:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 548:	ba 00 00 00 00       	mov    $0x0,%edx
+ 54d:	f7 75 d4             	divl   -0x2c(%ebp)
+ 550:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 553:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 557:	75 c2                	jne    51b <printint+0x37>
+  if(neg)
+ 559:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 55d:	74 2e                	je     58d <printint+0xa9>
+    buf[i++] = '-';
+ 55f:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 562:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 565:	01 d0                	add    %edx,%eax
+ 567:	c6 00 2d             	movb   $0x2d,(%eax)
+ 56a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 56e:	eb 1d                	jmp    58d <printint+0xa9>
+    putc(fd, buf[i]);
+ 570:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 573:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 576:	01 d0                	add    %edx,%eax
+ 578:	0f b6 00             	movzbl (%eax),%eax
+ 57b:	0f be c0             	movsbl %al,%eax
+ 57e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 582:	8b 45 08             	mov    0x8(%ebp),%eax
+ 585:	89 04 24             	mov    %eax,(%esp)
+ 588:	e8 2f ff ff ff       	call   4bc <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 58d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 591:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 595:	79 d9                	jns    570 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 597:	c9                   	leave  
+ 598:	c3                   	ret    
+
+00000599 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 599:	55                   	push   %ebp
+ 59a:	89 e5                	mov    %esp,%ebp
+ 59c:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 59f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 5a6:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 5a9:	83 c0 04             	add    $0x4,%eax
+ 5ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 5af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 5b6:	e9 7d 01 00 00       	jmp    738 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 5bb:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 5be:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 5c1:	01 d0                	add    %edx,%eax
+ 5c3:	0f b6 00             	movzbl (%eax),%eax
+ 5c6:	0f be c0             	movsbl %al,%eax
+ 5c9:	25 ff 00 00 00       	and    $0xff,%eax
+ 5ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 5d1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 5d5:	75 2c                	jne    603 <printf+0x6a>
+      if(c == '%'){
+ 5d7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5db:	75 0c                	jne    5e9 <printf+0x50>
+        state = '%';
+ 5dd:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 5e4:	e9 4b 01 00 00       	jmp    734 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 5e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5ec:	0f be c0             	movsbl %al,%eax
+ 5ef:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5f3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5f6:	89 04 24             	mov    %eax,(%esp)
+ 5f9:	e8 be fe ff ff       	call   4bc <putc>
+ 5fe:	e9 31 01 00 00       	jmp    734 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 603:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 607:	0f 85 27 01 00 00    	jne    734 <printf+0x19b>
+      if(c == 'd'){
+ 60d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 611:	75 2d                	jne    640 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 613:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 616:	8b 00                	mov    (%eax),%eax
+ 618:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 61f:	00 
+ 620:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 627:	00 
+ 628:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 62c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 62f:	89 04 24             	mov    %eax,(%esp)
+ 632:	e8 ad fe ff ff       	call   4e4 <printint>
+        ap++;
+ 637:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 63b:	e9 ed 00 00 00       	jmp    72d <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 640:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 644:	74 06                	je     64c <printf+0xb3>
+ 646:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 64a:	75 2d                	jne    679 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 64c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 64f:	8b 00                	mov    (%eax),%eax
+ 651:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 658:	00 
+ 659:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 660:	00 
+ 661:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 665:	8b 45 08             	mov    0x8(%ebp),%eax
+ 668:	89 04 24             	mov    %eax,(%esp)
+ 66b:	e8 74 fe ff ff       	call   4e4 <printint>
+        ap++;
+ 670:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 674:	e9 b4 00 00 00       	jmp    72d <printf+0x194>
+      } else if(c == 's'){
+ 679:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 67d:	75 46                	jne    6c5 <printf+0x12c>
+        s = (char*)*ap;
+ 67f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 682:	8b 00                	mov    (%eax),%eax
+ 684:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 687:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 68b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 68f:	75 27                	jne    6b8 <printf+0x11f>
+          s = "(null)";
+ 691:	c7 45 f4 8d 0a 00 00 	movl   $0xa8d,-0xc(%ebp)
+        while(*s != 0){
+ 698:	eb 1e                	jmp    6b8 <printf+0x11f>
+          putc(fd, *s);
+ 69a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 69d:	0f b6 00             	movzbl (%eax),%eax
+ 6a0:	0f be c0             	movsbl %al,%eax
+ 6a3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6a7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6aa:	89 04 24             	mov    %eax,(%esp)
+ 6ad:	e8 0a fe ff ff       	call   4bc <putc>
+          s++;
+ 6b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 6b6:	eb 01                	jmp    6b9 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 6b8:	90                   	nop
+ 6b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6bc:	0f b6 00             	movzbl (%eax),%eax
+ 6bf:	84 c0                	test   %al,%al
+ 6c1:	75 d7                	jne    69a <printf+0x101>
+ 6c3:	eb 68                	jmp    72d <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 6c5:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 6c9:	75 1d                	jne    6e8 <printf+0x14f>
+        putc(fd, *ap);
+ 6cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 6ce:	8b 00                	mov    (%eax),%eax
+ 6d0:	0f be c0             	movsbl %al,%eax
+ 6d3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6d7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6da:	89 04 24             	mov    %eax,(%esp)
+ 6dd:	e8 da fd ff ff       	call   4bc <putc>
+        ap++;
+ 6e2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 6e6:	eb 45                	jmp    72d <printf+0x194>
+      } else if(c == '%'){
+ 6e8:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 6ec:	75 17                	jne    705 <printf+0x16c>
+        putc(fd, c);
+ 6ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 6f1:	0f be c0             	movsbl %al,%eax
+ 6f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6f8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6fb:	89 04 24             	mov    %eax,(%esp)
+ 6fe:	e8 b9 fd ff ff       	call   4bc <putc>
+ 703:	eb 28                	jmp    72d <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 705:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 70c:	00 
+ 70d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 710:	89 04 24             	mov    %eax,(%esp)
+ 713:	e8 a4 fd ff ff       	call   4bc <putc>
+        putc(fd, c);
+ 718:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 71b:	0f be c0             	movsbl %al,%eax
+ 71e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 722:	8b 45 08             	mov    0x8(%ebp),%eax
+ 725:	89 04 24             	mov    %eax,(%esp)
+ 728:	e8 8f fd ff ff       	call   4bc <putc>
+      }
+      state = 0;
+ 72d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 734:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 738:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 73b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 73e:	01 d0                	add    %edx,%eax
+ 740:	0f b6 00             	movzbl (%eax),%eax
+ 743:	84 c0                	test   %al,%al
+ 745:	0f 85 70 fe ff ff    	jne    5bb <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 74b:	c9                   	leave  
+ 74c:	c3                   	ret    
+ 74d:	90                   	nop
+ 74e:	90                   	nop
+ 74f:	90                   	nop
+
+00000750 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 750:	55                   	push   %ebp
+ 751:	89 e5                	mov    %esp,%ebp
+ 753:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 756:	8b 45 08             	mov    0x8(%ebp),%eax
+ 759:	83 e8 08             	sub    $0x8,%eax
+ 75c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 75f:	a1 ec 0c 00 00       	mov    0xcec,%eax
+ 764:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 767:	eb 24                	jmp    78d <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 769:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 76c:	8b 00                	mov    (%eax),%eax
+ 76e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 771:	77 12                	ja     785 <free+0x35>
+ 773:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 776:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 779:	77 24                	ja     79f <free+0x4f>
+ 77b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 77e:	8b 00                	mov    (%eax),%eax
+ 780:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 783:	77 1a                	ja     79f <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 785:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 788:	8b 00                	mov    (%eax),%eax
+ 78a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 78d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 790:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 793:	76 d4                	jbe    769 <free+0x19>
+ 795:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 798:	8b 00                	mov    (%eax),%eax
+ 79a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 79d:	76 ca                	jbe    769 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 79f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7a2:	8b 40 04             	mov    0x4(%eax),%eax
+ 7a5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 7ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7af:	01 c2                	add    %eax,%edx
+ 7b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b4:	8b 00                	mov    (%eax),%eax
+ 7b6:	39 c2                	cmp    %eax,%edx
+ 7b8:	75 24                	jne    7de <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 7ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7bd:	8b 50 04             	mov    0x4(%eax),%edx
+ 7c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7c3:	8b 00                	mov    (%eax),%eax
+ 7c5:	8b 40 04             	mov    0x4(%eax),%eax
+ 7c8:	01 c2                	add    %eax,%edx
+ 7ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7cd:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7d3:	8b 00                	mov    (%eax),%eax
+ 7d5:	8b 10                	mov    (%eax),%edx
+ 7d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7da:	89 10                	mov    %edx,(%eax)
+ 7dc:	eb 0a                	jmp    7e8 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 7de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7e1:	8b 10                	mov    (%eax),%edx
+ 7e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7e6:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 7e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7eb:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ee:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 7f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7f8:	01 d0                	add    %edx,%eax
+ 7fa:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 7fd:	75 20                	jne    81f <free+0xcf>
+    p->s.size += bp->s.size;
+ 7ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 802:	8b 50 04             	mov    0x4(%eax),%edx
+ 805:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 808:	8b 40 04             	mov    0x4(%eax),%eax
+ 80b:	01 c2                	add    %eax,%edx
+ 80d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 810:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 813:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 816:	8b 10                	mov    (%eax),%edx
+ 818:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 81b:	89 10                	mov    %edx,(%eax)
+ 81d:	eb 08                	jmp    827 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 81f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 822:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 825:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 827:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 82a:	a3 ec 0c 00 00       	mov    %eax,0xcec
+}
+ 82f:	c9                   	leave  
+ 830:	c3                   	ret    
+
+00000831 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 831:	55                   	push   %ebp
+ 832:	89 e5                	mov    %esp,%ebp
+ 834:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 837:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 83e:	77 07                	ja     847 <morecore+0x16>
+    nu = 4096;
+ 840:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 847:	8b 45 08             	mov    0x8(%ebp),%eax
+ 84a:	c1 e0 03             	shl    $0x3,%eax
+ 84d:	89 04 24             	mov    %eax,(%esp)
+ 850:	e8 27 fc ff ff       	call   47c <sbrk>
+ 855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 858:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 85c:	75 07                	jne    865 <morecore+0x34>
+    return 0;
+ 85e:	b8 00 00 00 00       	mov    $0x0,%eax
+ 863:	eb 22                	jmp    887 <morecore+0x56>
+  hp = (Header*)p;
+ 865:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 868:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 86b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 86e:	8b 55 08             	mov    0x8(%ebp),%edx
+ 871:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 874:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 877:	83 c0 08             	add    $0x8,%eax
+ 87a:	89 04 24             	mov    %eax,(%esp)
+ 87d:	e8 ce fe ff ff       	call   750 <free>
+  return freep;
+ 882:	a1 ec 0c 00 00       	mov    0xcec,%eax
+}
+ 887:	c9                   	leave  
+ 888:	c3                   	ret    
+
+00000889 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 889:	55                   	push   %ebp
+ 88a:	89 e5                	mov    %esp,%ebp
+ 88c:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 88f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 892:	83 c0 07             	add    $0x7,%eax
+ 895:	c1 e8 03             	shr    $0x3,%eax
+ 898:	83 c0 01             	add    $0x1,%eax
+ 89b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 89e:	a1 ec 0c 00 00       	mov    0xcec,%eax
+ 8a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 8aa:	75 23                	jne    8cf <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 8ac:	c7 45 f0 e4 0c 00 00 	movl   $0xce4,-0x10(%ebp)
+ 8b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8b6:	a3 ec 0c 00 00       	mov    %eax,0xcec
+ 8bb:	a1 ec 0c 00 00       	mov    0xcec,%eax
+ 8c0:	a3 e4 0c 00 00       	mov    %eax,0xce4
+    base.s.size = 0;
+ 8c5:	c7 05 e8 0c 00 00 00 	movl   $0x0,0xce8
+ 8cc:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8d2:	8b 00                	mov    (%eax),%eax
+ 8d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 8d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8da:	8b 40 04             	mov    0x4(%eax),%eax
+ 8dd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 8e0:	72 4d                	jb     92f <malloc+0xa6>
+      if(p->s.size == nunits)
+ 8e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8e5:	8b 40 04             	mov    0x4(%eax),%eax
+ 8e8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 8eb:	75 0c                	jne    8f9 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 8ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8f0:	8b 10                	mov    (%eax),%edx
+ 8f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8f5:	89 10                	mov    %edx,(%eax)
+ 8f7:	eb 26                	jmp    91f <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 8f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8fc:	8b 40 04             	mov    0x4(%eax),%eax
+ 8ff:	89 c2                	mov    %eax,%edx
+ 901:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 904:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 907:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 90d:	8b 40 04             	mov    0x4(%eax),%eax
+ 910:	c1 e0 03             	shl    $0x3,%eax
+ 913:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 916:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 919:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 91c:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 91f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 922:	a3 ec 0c 00 00       	mov    %eax,0xcec
+      return (void*)(p + 1);
+ 927:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 92a:	83 c0 08             	add    $0x8,%eax
+ 92d:	eb 38                	jmp    967 <malloc+0xde>
+    }
+    if(p == freep)
+ 92f:	a1 ec 0c 00 00       	mov    0xcec,%eax
+ 934:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 937:	75 1b                	jne    954 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 939:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 93c:	89 04 24             	mov    %eax,(%esp)
+ 93f:	e8 ed fe ff ff       	call   831 <morecore>
+ 944:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 947:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 94b:	75 07                	jne    954 <malloc+0xcb>
+        return 0;
+ 94d:	b8 00 00 00 00       	mov    $0x0,%eax
+ 952:	eb 13                	jmp    967 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 954:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 957:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 95a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 95d:	8b 00                	mov    (%eax),%eax
+ 95f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 962:	e9 70 ff ff ff       	jmp    8d7 <malloc+0x4e>
+}
+ 967:	c9                   	leave  
+ 968:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/proj1_forktest.c cs550-16s-proj1-working/proj1_forktest.c
--- cs550-16s-proj1-base/proj1_forktest.c	2016-02-15 19:39:42.000000000 -0500
+++ cs550-16s-proj1-working/proj1_forktest.c	2016-03-04 14:36:42.000000000 -0500
@@ -5,12 +5,11 @@
    stub functions for the system call user space wrapper functions are provided. 
    REMEMBER to disable the stub functions (by commenting the following macro) to 
    allow your implementation to work properly. */
-#define STUB_FUNCS
+/*#define STUB_FUNCS
 #ifdef STUB_FUNCS
 void fork_winner(int winner) {}
 #endif
-
-
+*/
 #define TOTAL_TEST_TRIALS 50
 
 int
@@ -42,7 +41,7 @@
     fork_winner(w); // set according to user input
 
     printf(1, "\nCS550 proj1 fork test ==> \n");
-    
+
     for (i = 0; i < TOTAL_TEST_TRIALS; i++)
     {
         printf(1, "\nTrial %d: ", i);
diff -uNr cs550-16s-proj1-base/proj1_forktest.d cs550-16s-proj1-working/proj1_forktest.d
--- cs550-16s-proj1-base/proj1_forktest.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1_forktest.d	2016-03-04 14:37:11.000000000 -0500
@@ -0,0 +1 @@
+proj1_forktest.o: proj1_forktest.c types.h user.h
Binary files cs550-16s-proj1-base/proj1_forktest.o and cs550-16s-proj1-working/proj1_forktest.o differ
diff -uNr cs550-16s-proj1-base/proj1_forktest.sym cs550-16s-proj1-working/proj1_forktest.sym
--- cs550-16s-proj1-base/proj1_forktest.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1_forktest.sym	2016-03-04 14:37:12.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+0000096c .rodata
+00000a94 .eh_frame
+00000cd0 .data
+00000ce4 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 proj1_forktest.c
+00000000 ulib.c
+0000018c stosb
+00000000 printf.c
+000004bc putc
+000004e4 printint
+00000cd0 digits.1028
+00000000 umalloc.c
+00000ce4 base
+00000cec freep
+00000831 morecore
+000001b1 strcpy
+00000599 printf
+000003b0 memmove
+0000043c mknod
+000002a4 gets
+00000474 getpid
+00000889 malloc
+00000484 sleep
+000004b4 set_priority
+00000404 pipe
+00000414 write
+0000044c fstat
+00000424 kill
+00000464 chdir
+0000042c exec
+000003fc wait
+0000040c read
+00000444 unlink
+000003ec fork
+0000047c sbrk
+0000048c uptime
+00000ce4 __bss_start
+0000024d memset
+00000000 main
+00000494 enable_sched_trace
+000001e5 strcmp
+0000049c shutdown
+0000046c dup
+000004ac set_sched
+00000317 stat
+00000ce4 _edata
+00000cf0 _end
+00000454 link
+000003f4 exit
+00000365 atoi
+000004a4 fork_winner
+00000226 strlen
+00000434 open
+00000271 strchr
+0000045c mkdir
+0000041c close
+00000750 free
diff -uNr cs550-16s-proj1-base/proj1.jsivaku1.patch cs550-16s-proj1-working/proj1.jsivaku1.patch
--- cs550-16s-proj1-base/proj1.jsivaku1.patch	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1.jsivaku1.patch	2016-03-02 08:13:30.000000000 -0500
@@ -0,0 +1,1958 @@
+diff -uNr cs550-16s-proj1-base/bio.c cs550-16s-proj1-working/bio.c
+--- cs550-16s-proj1-base/bio.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/bio.c	2015-09-19 19:26:32.000000000 -0400
+@@ -24,7 +24,6 @@
+ #include "defs.h"
+ #include "param.h"
+ #include "spinlock.h"
+-#include "fs.h"
+ #include "buf.h"
+ 
+ struct {
+@@ -56,20 +55,20 @@
+   }
+ }
+ 
+-// Look through buffer cache for block on device dev.
++// Look through buffer cache for sector on device dev.
+ // If not found, allocate a buffer.
+ // In either case, return B_BUSY buffer.
+ static struct buf*
+-bget(uint dev, uint blockno)
++bget(uint dev, uint sector)
+ {
+   struct buf *b;
+ 
+   acquire(&bcache.lock);
+ 
+  loop:
+-  // Is the block already cached?
++  // Is the sector already cached?
+   for(b = bcache.head.next; b != &bcache.head; b = b->next){
+-    if(b->dev == dev && b->blockno == blockno){
++    if(b->dev == dev && b->sector == sector){
+       if(!(b->flags & B_BUSY)){
+         b->flags |= B_BUSY;
+         release(&bcache.lock);
+@@ -86,7 +85,7 @@
+   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
+       b->dev = dev;
+-      b->blockno = blockno;
++      b->sector = sector;
+       b->flags = B_BUSY;
+       release(&bcache.lock);
+       return b;
+@@ -95,16 +94,15 @@
+   panic("bget: no buffers");
+ }
+ 
+-// Return a B_BUSY buf with the contents of the indicated block.
++// Return a B_BUSY buf with the contents of the indicated disk sector.
+ struct buf*
+-bread(uint dev, uint blockno)
++bread(uint dev, uint sector)
+ {
+   struct buf *b;
+ 
+-  b = bget(dev, blockno);
+-  if(!(b->flags & B_VALID)) {
++  b = bget(dev, sector);
++  if(!(b->flags & B_VALID))
+     iderw(b);
+-  }
+   return b;
+ }
+ 
+diff -uNr cs550-16s-proj1-base/bootmain.c cs550-16s-proj1-working/bootmain.c
+--- cs550-16s-proj1-base/bootmain.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/bootmain.c	2015-09-19 19:26:32.000000000 -0400
+@@ -1,6 +1,6 @@
+ // Boot loader.
+ // 
+-// Part of the boot block, along with bootasm.S, which calls bootmain().
++// Part of the boot sector, along with bootasm.S, which calls bootmain().
+ // bootasm.S has put the processor into protected 32-bit mode.
+ // bootmain() loads an ELF kernel image from the disk starting at
+ // sector 1 and then jumps to the kernel entry routine.
+diff -uNr cs550-16s-proj1-base/buf.h cs550-16s-proj1-working/buf.h
+--- cs550-16s-proj1-base/buf.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/buf.h	2015-09-19 19:26:32.000000000 -0400
+@@ -1,11 +1,11 @@
+ struct buf {
+   int flags;
+   uint dev;
+-  uint blockno;
++  uint sector;
+   struct buf *prev; // LRU cache list
+   struct buf *next;
+   struct buf *qnext; // disk queue
+-  uchar data[BSIZE];
++  uchar data[512];
+ };
+ #define B_BUSY  0x1  // buffer is locked by some process
+ #define B_VALID 0x2  // buffer has been read from disk
+diff -uNr cs550-16s-proj1-base/console.c cs550-16s-proj1-working/console.c
+--- cs550-16s-proj1-base/console.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/console.c	2015-09-19 19:26:32.000000000 -0400
+@@ -143,9 +143,6 @@
+     if(pos > 0) --pos;
+   } else
+     crt[pos++] = (c&0xff) | 0x0700;  // black on white
+-
+-  if(pos < 0 || pos > 25*80)
+-    panic("pos under/overflow");
+   
+   if((pos/80) >= 24){  // Scroll up.
+     memmove(crt, crt+80, sizeof(crt[0])*23*80);
+@@ -178,6 +175,7 @@
+ 
+ #define INPUT_BUF 128
+ struct {
++  struct spinlock lock;
+   char buf[INPUT_BUF];
+   uint r;  // Read index
+   uint w;  // Write index
+@@ -189,13 +187,13 @@
+ void
+ consoleintr(int (*getc)(void))
+ {
+-  int c, doprocdump = 0;
++  int c;
+ 
+-  acquire(&cons.lock);
++  acquire(&input.lock);
+   while((c = getc()) >= 0){
+     switch(c){
+     case C('P'):  // Process listing.
+-      doprocdump = 1;   // procdump() locks cons.lock indirectly; invoke later
++      procdump();
+       break;
+     case C('U'):  // Kill line.
+       while(input.e != input.w &&
+@@ -223,10 +221,7 @@
+       break;
+     }
+   }
+-  release(&cons.lock);
+-  if(doprocdump) {
+-    procdump();  // now call procdump() wo. cons.lock held
+-  }
++  release(&input.lock);
+ }
+ 
+ int
+@@ -237,15 +232,15 @@
+ 
+   iunlock(ip);
+   target = n;
+-  acquire(&cons.lock);
++  acquire(&input.lock);
+   while(n > 0){
+     while(input.r == input.w){
+       if(proc->killed){
+-        release(&cons.lock);
++        release(&input.lock);
+         ilock(ip);
+         return -1;
+       }
+-      sleep(&input.r, &cons.lock);
++      sleep(&input.r, &input.lock);
+     }
+     c = input.buf[input.r++ % INPUT_BUF];
+     if(c == C('D')){  // EOF
+@@ -261,7 +256,7 @@
+     if(c == '\n')
+       break;
+   }
+-  release(&cons.lock);
++  release(&input.lock);
+   ilock(ip);
+ 
+   return target - n;
+@@ -286,6 +281,7 @@
+ consoleinit(void)
+ {
+   initlock(&cons.lock, "console");
++  initlock(&input.lock, "input");
+ 
+   devsw[CONSOLE].write = consolewrite;
+   devsw[CONSOLE].read = consoleread;
+diff -uNr cs550-16s-proj1-base/date.h cs550-16s-proj1-working/date.h
+--- cs550-16s-proj1-base/date.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/date.h	2015-09-19 19:26:32.000000000 -0400
+@@ -1,8 +1,8 @@
+ struct rtcdate {
+-  uint second;
+-  uint minute;
+-  uint hour;
+-  uint day;
+-  uint month;
+-  uint year;
++	uint second;
++	uint minute;
++	uint hour;
++	uint day;
++	uint month;
++	uint year;
+ };
+diff -uNr cs550-16s-proj1-base/defs.h cs550-16s-proj1-working/defs.h
+--- cs550-16s-proj1-base/defs.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/defs.h	2015-09-19 19:26:32.000000000 -0400
+@@ -39,7 +39,7 @@
+ struct inode*   dirlookup(struct inode*, char*, uint*);
+ struct inode*   ialloc(uint, short);
+ struct inode*   idup(struct inode*);
+-void            iinit(int dev);
++void            iinit(void);
+ void            ilock(struct inode*);
+ void            iput(struct inode*);
+ void            iunlock(struct inode*);
+@@ -81,7 +81,7 @@
+ void            microdelay(int);
+ 
+ // log.c
+-void            initlog(int dev);
++void            initlog(void);
+ void            log_write(struct buf*);
+ void            begin_op();
+ void            end_op();
+diff -uNr cs550-16s-proj1-base/fs.c cs550-16s-proj1-working/fs.c
+--- cs550-16s-proj1-base/fs.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/fs.c	2015-09-19 19:26:32.000000000 -0400
+@@ -16,13 +16,12 @@
+ #include "mmu.h"
+ #include "proc.h"
+ #include "spinlock.h"
+-#include "fs.h"
+ #include "buf.h"
++#include "fs.h"
+ #include "file.h"
+ 
+ #define min(a, b) ((a) < (b) ? (a) : (b))
+ static void itrunc(struct inode*);
+-struct superblock sb;   // there should be one per dev, but we run with one dev
+ 
+ // Read the super block.
+ void
+@@ -55,10 +54,12 @@
+ {
+   int b, bi, m;
+   struct buf *bp;
++  struct superblock sb;
+ 
+   bp = 0;
++  readsb(dev, &sb);
+   for(b = 0; b < sb.size; b += BPB){
+-    bp = bread(dev, BBLOCK(b, sb));
++    bp = bread(dev, BBLOCK(b, sb.ninodes));
+     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+       m = 1 << (bi % 8);
+       if((bp->data[bi/8] & m) == 0){  // Is block free?
+@@ -79,10 +80,11 @@
+ bfree(int dev, uint b)
+ {
+   struct buf *bp;
++  struct superblock sb;
+   int bi, m;
+ 
+   readsb(dev, &sb);
+-  bp = bread(dev, BBLOCK(b, sb));
++  bp = bread(dev, BBLOCK(b, sb.ninodes));
+   bi = b % BPB;
+   m = 1 << (bi % 8);
+   if((bp->data[bi/8] & m) == 0)
+@@ -99,8 +101,8 @@
+ // its size, the number of links referring to it, and the
+ // list of blocks holding the file's content.
+ //
+-// The inodes are laid out sequentially on disk at
+-// sb.startinode. Each inode has a number, indicating its
++// The inodes are laid out sequentially on disk immediately after
++// the superblock. Each inode has a number, indicating its
+ // position on the disk.
+ //
+ // The kernel keeps a cache of in-use inodes in memory
+@@ -160,12 +162,9 @@
+ } icache;
+ 
+ void
+-iinit(int dev)
++iinit(void)
+ {
+   initlock(&icache.lock, "icache");
+-  readsb(dev, &sb);
+-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
+-          sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
+ }
+ 
+ static struct inode* iget(uint dev, uint inum);
+@@ -179,9 +178,12 @@
+   int inum;
+   struct buf *bp;
+   struct dinode *dip;
++  struct superblock sb;
++
++  readsb(dev, &sb);
+ 
+   for(inum = 1; inum < sb.ninodes; inum++){
+-    bp = bread(dev, IBLOCK(inum, sb));
++    bp = bread(dev, IBLOCK(inum));
+     dip = (struct dinode*)bp->data + inum%IPB;
+     if(dip->type == 0){  // a free inode
+       memset(dip, 0, sizeof(*dip));
+@@ -202,7 +204,7 @@
+   struct buf *bp;
+   struct dinode *dip;
+ 
+-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++  bp = bread(ip->dev, IBLOCK(ip->inum));
+   dip = (struct dinode*)bp->data + ip->inum%IPB;
+   dip->type = ip->type;
+   dip->major = ip->major;
+@@ -279,7 +281,7 @@
+   release(&icache.lock);
+ 
+   if(!(ip->flags & I_VALID)){
+-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++    bp = bread(ip->dev, IBLOCK(ip->inum));
+     dip = (struct dinode*)bp->data + ip->inum%IPB;
+     ip->type = dip->type;
+     ip->major = dip->major;
+diff -uNr cs550-16s-proj1-base/fs.h cs550-16s-proj1-working/fs.h
+--- cs550-16s-proj1-base/fs.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/fs.h	2015-09-19 19:26:32.000000000 -0400
+@@ -1,23 +1,22 @@
+ // On-disk file system format. 
+ // Both the kernel and user programs use this header file.
+ 
++// Block 0 is unused.
++// Block 1 is super block.
++// Blocks 2 through sb.ninodes/IPB hold inodes.
++// Then free bitmap blocks holding sb.size bits.
++// Then sb.nblocks data blocks.
++// Then sb.nlog log blocks.
+ 
+ #define ROOTINO 1  // root i-number
+ #define BSIZE 512  // block size
+ 
+-// Disk layout:
+-// [ boot block | super block | log | inode blocks | free bit map | data blocks ]
+-//
+-// mkfs computes the super block and builds an initial file system. The super describes
+-// the disk layout:
++// File system super block
+ struct superblock {
+   uint size;         // Size of file system image (blocks)
+   uint nblocks;      // Number of data blocks
+   uint ninodes;      // Number of inodes.
+   uint nlog;         // Number of log blocks
+-  uint logstart;     // Block number of first log block
+-  uint inodestart;   // Block number of first inode block
+-  uint bmapstart;    // Block number of first free map block
+ };
+ 
+ #define NDIRECT 12
+@@ -38,13 +37,13 @@
+ #define IPB           (BSIZE / sizeof(struct dinode))
+ 
+ // Block containing inode i
+-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
++#define IBLOCK(i)     ((i) / IPB + 2)
+ 
+ // Bitmap bits per block
+ #define BPB           (BSIZE*8)
+ 
+-// Block of free map containing bit for block b
+-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
++// Block containing bit for block b
++#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
+ 
+ // Directory is a file containing a sequence of dirent structures.
+ #define DIRSIZ 14
+diff -uNr cs550-16s-proj1-base/grep.c cs550-16s-proj1-working/grep.c
+--- cs550-16s-proj1-base/grep.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/grep.c	2015-09-19 19:26:32.000000000 -0400
+@@ -14,9 +14,8 @@
+   char *p, *q;
+   
+   m = 0;
+-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
++  while((n = read(fd, buf+m, sizeof(buf)-m)) > 0){
+     m += n;
+-    buf[m] = '\0';
+     p = buf;
+     while((q = strchr(p, '\n')) != 0){
+       *q = 0;
+diff -uNr cs550-16s-proj1-base/ide.c cs550-16s-proj1-working/ide.c
+--- cs550-16s-proj1-base/ide.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/ide.c	2015-09-19 19:26:32.000000000 -0400
+@@ -9,10 +9,8 @@
+ #include "x86.h"
+ #include "traps.h"
+ #include "spinlock.h"
+-#include "fs.h"
+ #include "buf.h"
+ 
+-#define SECTOR_SIZE   512
+ #define IDE_BSY       0x80
+ #define IDE_DRDY      0x40
+ #define IDE_DF        0x20
+@@ -48,7 +46,7 @@
+ ideinit(void)
+ {
+   int i;
+-  
++
+   initlock(&idelock, "ide");
+   picenable(IRQ_IDE);
+   ioapicenable(IRQ_IDE, ncpu - 1);
+@@ -73,23 +71,17 @@
+ {
+   if(b == 0)
+     panic("idestart");
+-  if(b->blockno >= FSSIZE)
+-    panic("incorrect blockno");
+-  int sector_per_block =  BSIZE/SECTOR_SIZE;
+-  int sector = b->blockno * sector_per_block;
+ 
+-  if (sector_per_block > 7) panic("idestart");
+-  
+   idewait(0);
+   outb(0x3f6, 0);  // generate interrupt
+-  outb(0x1f2, sector_per_block);  // number of sectors
+-  outb(0x1f3, sector & 0xff);
+-  outb(0x1f4, (sector >> 8) & 0xff);
+-  outb(0x1f5, (sector >> 16) & 0xff);
+-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
++  outb(0x1f2, 1);  // number of sectors
++  outb(0x1f3, b->sector & 0xff);
++  outb(0x1f4, (b->sector >> 8) & 0xff);
++  outb(0x1f5, (b->sector >> 16) & 0xff);
++  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
+   if(b->flags & B_DIRTY){
+     outb(0x1f7, IDE_CMD_WRITE);
+-    outsl(0x1f0, b->data, BSIZE/4);
++    outsl(0x1f0, b->data, 512/4);
+   } else {
+     outb(0x1f7, IDE_CMD_READ);
+   }
+@@ -112,7 +104,7 @@
+ 
+   // Read data if needed.
+   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+-    insl(0x1f0, b->data, BSIZE/4);
++    insl(0x1f0, b->data, 512/4);
+   
+   // Wake process waiting for this buf.
+   b->flags |= B_VALID;
+diff -uNr cs550-16s-proj1-base/kill.c cs550-16s-proj1-working/kill.c
+--- cs550-16s-proj1-base/kill.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/kill.c	2015-09-19 19:26:32.000000000 -0400
+@@ -7,7 +7,7 @@
+ {
+   int i;
+ 
+-  if(argc < 2){
++  if(argc < 1){
+     printf(2, "usage: kill pid...\n");
+     exit();
+   }
+diff -uNr cs550-16s-proj1-base/log.c cs550-16s-proj1-working/log.c
+--- cs550-16s-proj1-base/log.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/log.c	2015-09-19 19:26:32.000000000 -0400
+@@ -21,7 +21,7 @@
+ //
+ // The log is a physical re-do log containing disk blocks.
+ // The on-disk log format:
+-//   header block, containing block #s for block A, B, C, ...
++//   header block, containing sector #s for block A, B, C, ...
+ //   block A
+ //   block B
+ //   block C
+@@ -29,10 +29,10 @@
+ // Log appends are synchronous.
+ 
+ // Contents of the header block, used for both the on-disk header block
+-// and to keep track in memory of logged block# before commit.
++// and to keep track in memory of logged sector #s before commit.
+ struct logheader {
+   int n;   
+-  int block[LOGSIZE];
++  int sector[LOGSIZE];
+ };
+ 
+ struct log {
+@@ -50,17 +50,17 @@
+ static void commit();
+ 
+ void
+-initlog(int dev)
++initlog(void)
+ {
+   if (sizeof(struct logheader) >= BSIZE)
+     panic("initlog: too big logheader");
+ 
+   struct superblock sb;
+   initlock(&log.lock, "log");
+-  readsb(dev, &sb);
+-  log.start = sb.logstart;
++  readsb(ROOTDEV, &sb);
++  log.start = sb.size - sb.nlog;
+   log.size = sb.nlog;
+-  log.dev = dev;
++  log.dev = ROOTDEV;
+   recover_from_log();
+ }
+ 
+@@ -72,7 +72,7 @@
+ 
+   for (tail = 0; tail < log.lh.n; tail++) {
+     struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
++    struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); // read dst
+     memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+     bwrite(dbuf);  // write dst to disk
+     brelse(lbuf); 
+@@ -89,7 +89,7 @@
+   int i;
+   log.lh.n = lh->n;
+   for (i = 0; i < log.lh.n; i++) {
+-    log.lh.block[i] = lh->block[i];
++    log.lh.sector[i] = lh->sector[i];
+   }
+   brelse(buf);
+ }
+@@ -105,7 +105,7 @@
+   int i;
+   hb->n = log.lh.n;
+   for (i = 0; i < log.lh.n; i++) {
+-    hb->block[i] = log.lh.block[i];
++    hb->sector[i] = log.lh.sector[i];
+   }
+   bwrite(buf);
+   brelse(buf);
+@@ -178,7 +178,7 @@
+ 
+   for (tail = 0; tail < log.lh.n; tail++) {
+     struct buf *to = bread(log.dev, log.start+tail+1); // log block
+-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
++    struct buf *from = bread(log.dev, log.lh.sector[tail]); // cache block
+     memmove(to->data, from->data, BSIZE);
+     bwrite(to);  // write the log
+     brelse(from); 
+@@ -217,15 +217,13 @@
+   if (log.outstanding < 1)
+     panic("log_write outside of trans");
+ 
+-  acquire(&log.lock);
+   for (i = 0; i < log.lh.n; i++) {
+-    if (log.lh.block[i] == b->blockno)   // log absorbtion
++    if (log.lh.sector[i] == b->sector)   // log absorbtion
+       break;
+   }
+-  log.lh.block[i] = b->blockno;
++  log.lh.sector[i] = b->sector;
+   if (i == log.lh.n)
+     log.lh.n++;
+   b->flags |= B_DIRTY; // prevent eviction
+-  release(&log.lock);
+ }
+ 
+diff -uNr cs550-16s-proj1-base/main.c cs550-16s-proj1-working/main.c
+--- cs550-16s-proj1-base/main.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/main.c	2015-09-19 19:26:32.000000000 -0400
+@@ -31,6 +31,7 @@
+   tvinit();        // trap vectors
+   binit();         // buffer cache
+   fileinit();      // file table
++  iinit();         // inode cache
+   ideinit();       // disk
+   if(!ismp)
+     timerinit();   // uniprocessor timer
+diff -uNr cs550-16s-proj1-base/Makefile cs550-16s-proj1-working/Makefile
+--- cs550-16s-proj1-base/Makefile	2016-03-01 12:25:31.488321398 -0500
++++ cs550-16s-proj1-working/Makefile	2016-03-01 12:18:19.591298509 -0500
+@@ -172,6 +172,7 @@
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_shutdown \
+ 	_proj1_forktest \
+ 	_proj1_schdtest \
+ 
+@@ -275,6 +276,6 @@
+ 	rm -rf /tmp/xv6
+ 	mkdir -p /tmp/xv6
+ 	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev9.tar.gz  # the next one will be 9 (6/27/15)
++	(cd /tmp; tar cf - xv6) | gzip >xv6-rev9.tar.gz
+ 
+ .PHONY: dist-test dist
+diff -uNr cs550-16s-proj1-base/memide.c cs550-16s-proj1-working/memide.c
+--- cs550-16s-proj1-base/memide.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/memide.c	2015-09-19 19:26:32.000000000 -0400
+@@ -9,7 +9,6 @@
+ #include "x86.h"
+ #include "traps.h"
+ #include "spinlock.h"
+-#include "fs.h"
+ #include "buf.h"
+ 
+ extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
+@@ -21,7 +20,7 @@
+ ideinit(void)
+ {
+   memdisk = _binary_fs_img_start;
+-  disksize = (uint)_binary_fs_img_size/BSIZE;
++  disksize = (uint)_binary_fs_img_size/512;
+ }
+ 
+ // Interrupt handler.
+@@ -45,15 +44,15 @@
+     panic("iderw: nothing to do");
+   if(b->dev != 1)
+     panic("iderw: request not for disk 1");
+-  if(b->blockno >= disksize)
+-    panic("iderw: block out of range");
++  if(b->sector >= disksize)
++    panic("iderw: sector out of range");
+ 
+-  p = memdisk + b->blockno*BSIZE;
++  p = memdisk + b->sector*512;
+   
+   if(b->flags & B_DIRTY){
+     b->flags &= ~B_DIRTY;
+-    memmove(p, b->data, BSIZE);
++    memmove(p, b->data, 512);
+   } else
+-    memmove(b->data, p, BSIZE);
++    memmove(b->data, p, 512);
+   b->flags |= B_VALID;
+ }
+diff -uNr cs550-16s-proj1-base/memlayout.h cs550-16s-proj1-working/memlayout.h
+--- cs550-16s-proj1-base/memlayout.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/memlayout.h	2015-09-19 19:26:32.000000000 -0400
+@@ -19,4 +19,4 @@
+ #define P2V(a) (((void *) (a)) + KERNBASE)
+ 
+ #define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
+-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
++#define P2V_WO(x) ((x) + KERNBASE)    // same as V2P, but without casts
+diff -uNr cs550-16s-proj1-base/mkfs.c cs550-16s-proj1-working/mkfs.c
+--- cs550-16s-proj1-base/mkfs.c	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/mkfs.c	2015-09-19 19:26:32.000000000 -0400
+@@ -11,27 +11,20 @@
+ #include "stat.h"
+ #include "param.h"
+ 
+-#ifndef static_assert
+ #define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+-#endif
+ 
+-#define NINODES 200
+-
+-// Disk layout:
+-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
+-
+-int nbitmap = FSSIZE/(BSIZE*8) + 1;
+-int ninodeblocks = NINODES / IPB + 1;
+-int nlog = LOGSIZE;  
+-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+-int nblocks;  // Number of data blocks
++int nblocks = (995-LOGSIZE);
++int nlog = LOGSIZE;
++int ninodes = 200;
++int size = 1024;
+ 
+ int fsfd;
+ struct superblock sb;
+-char zeroes[BSIZE];
+-uint freeinode = 1;
++char zeroes[512];
+ uint freeblock;
+-
++uint usedblocks;
++uint bitblocks;
++uint freeinode = 1;
+ 
+ void balloc(int);
+ void wsect(uint, void*);
+@@ -70,7 +63,7 @@
+   int i, cc, fd;
+   uint rootino, inum, off;
+   struct dirent de;
+-  char buf[BSIZE];
++  char buf[512];
+   struct dinode din;
+ 
+ 
+@@ -81,8 +74,8 @@
+     exit(1);
+   }
+ 
+-  assert((BSIZE % sizeof(struct dinode)) == 0);
+-  assert((BSIZE % sizeof(struct dirent)) == 0);
++  assert((512 % sizeof(struct dinode)) == 0);
++  assert((512 % sizeof(struct dirent)) == 0);
+ 
+   fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
+   if(fsfd < 0){
+@@ -90,24 +83,21 @@
+     exit(1);
+   }
+ 
+-  // 1 fs block = 1 disk sector
+-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
+-  nblocks = FSSIZE - nmeta;
+-
+-  sb.size = xint(FSSIZE);
+-  sb.nblocks = xint(nblocks);
+-  sb.ninodes = xint(NINODES);
++  sb.size = xint(size);
++  sb.nblocks = xint(nblocks); // so whole disk is size sectors
++  sb.ninodes = xint(ninodes);
+   sb.nlog = xint(nlog);
+-  sb.logstart = xint(2);
+-  sb.inodestart = xint(2+nlog);
+-  sb.bmapstart = xint(2+nlog+ninodeblocks);
+ 
+-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
+-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
++  bitblocks = size/(512*8) + 1;
++  usedblocks = ninodes / IPB + 3 + bitblocks;
++  freeblock = usedblocks;
++
++  printf("used %d (bit %d ninode %zu) free %u log %u total %d\n", usedblocks,
++         bitblocks, ninodes/IPB + 1, freeblock, nlog, nblocks+usedblocks+nlog);
+ 
+-  freeblock = nmeta;     // the first free block that we can allocate
++  assert(nblocks + usedblocks + nlog == size);
+ 
+-  for(i = 0; i < FSSIZE; i++)
++  for(i = 0; i < nblocks + usedblocks + nlog; i++)
+     wsect(i, zeroes);
+ 
+   memset(buf, 0, sizeof(buf));
+@@ -162,7 +152,7 @@
+   din.size = xint(off);
+   winode(rootino, &din);
+ 
+-  balloc(freeblock);
++  balloc(usedblocks);
+ 
+   exit(0);
+ }
+@@ -170,24 +160,30 @@
+ void
+ wsect(uint sec, void *buf)
+ {
+-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
++  if(lseek(fsfd, sec * 512L, 0) != sec * 512L){
+     perror("lseek");
+     exit(1);
+   }
+-  if(write(fsfd, buf, BSIZE) != BSIZE){
++  if(write(fsfd, buf, 512) != 512){
+     perror("write");
+     exit(1);
+   }
+ }
+ 
++uint
++i2b(uint inum)
++{
++  return (inum / IPB) + 2;
++}
++
+ void
+ winode(uint inum, struct dinode *ip)
+ {
+-  char buf[BSIZE];
++  char buf[512];
+   uint bn;
+   struct dinode *dip;
+ 
+-  bn = IBLOCK(inum, sb);
++  bn = i2b(inum);
+   rsect(bn, buf);
+   dip = ((struct dinode*)buf) + (inum % IPB);
+   *dip = *ip;
+@@ -197,11 +193,11 @@
+ void
+ rinode(uint inum, struct dinode *ip)
+ {
+-  char buf[BSIZE];
++  char buf[512];
+   uint bn;
+   struct dinode *dip;
+ 
+-  bn = IBLOCK(inum, sb);
++  bn = i2b(inum);
+   rsect(bn, buf);
+   dip = ((struct dinode*)buf) + (inum % IPB);
+   *ip = *dip;
+@@ -210,11 +206,11 @@
+ void
+ rsect(uint sec, void *buf)
+ {
+-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
++  if(lseek(fsfd, sec * 512L, 0) != sec * 512L){
+     perror("lseek");
+     exit(1);
+   }
+-  if(read(fsfd, buf, BSIZE) != BSIZE){
++  if(read(fsfd, buf, 512) != 512){
+     perror("read");
+     exit(1);
+   }
+@@ -237,17 +233,17 @@
+ void
+ balloc(int used)
+ {
+-  uchar buf[BSIZE];
++  uchar buf[512];
+   int i;
+ 
+   printf("balloc: first %d blocks have been allocated\n", used);
+-  assert(used < BSIZE*8);
+-  bzero(buf, BSIZE);
++  assert(used < 512*8);
++  bzero(buf, 512);
+   for(i = 0; i < used; i++){
+     buf[i/8] = buf[i/8] | (0x1 << (i%8));
+   }
+-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
+-  wsect(sb.bmapstart, buf);
++  printf("balloc: write bitmap block at sector %zu\n", ninodes/IPB + 3);
++  wsect(ninodes / IPB + 3, buf);
+ }
+ 
+ #define min(a, b) ((a) < (b) ? (a) : (b))
+@@ -258,35 +254,40 @@
+   char *p = (char*)xp;
+   uint fbn, off, n1;
+   struct dinode din;
+-  char buf[BSIZE];
++  char buf[512];
+   uint indirect[NINDIRECT];
+   uint x;
+ 
+   rinode(inum, &din);
++
+   off = xint(din.size);
+-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
+   while(n > 0){
+-    fbn = off / BSIZE;
++    fbn = off / 512;
+     assert(fbn < MAXFILE);
+     if(fbn < NDIRECT){
+       if(xint(din.addrs[fbn]) == 0){
+         din.addrs[fbn] = xint(freeblock++);
++        usedblocks++;
+       }
+       x = xint(din.addrs[fbn]);
+     } else {
+       if(xint(din.addrs[NDIRECT]) == 0){
++        // printf("allocate indirect block\n");
+         din.addrs[NDIRECT] = xint(freeblock++);
++        usedblocks++;
+       }
++      // printf("read indirect block\n");
+       rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+       if(indirect[fbn - NDIRECT] == 0){
+         indirect[fbn - NDIRECT] = xint(freeblock++);
++        usedblocks++;
+         wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+       }
+       x = xint(indirect[fbn-NDIRECT]);
+     }
+-    n1 = min(n, (fbn + 1) * BSIZE - off);
++    n1 = min(n, (fbn + 1) * 512 - off);
+     rsect(x, buf);
+-    bcopy(p, buf + off - (fbn * BSIZE), n1);
++    bcopy(p, buf + off - (fbn * 512), n1);
+     wsect(x, buf);
+     n -= n1;
+     off += n1;
+Binary files cs550-16s-proj1-base/.nfs000000092f41708b0000008e and cs550-16s-proj1-working/.nfs000000092f41708b0000008e differ
+Binary files cs550-16s-proj1-base/.nfs00000009678519110000008d and cs550-16s-proj1-working/.nfs00000009678519110000008d differ
+diff -uNr cs550-16s-proj1-base/param.h cs550-16s-proj1-working/param.h
+--- cs550-16s-proj1-base/param.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/param.h	2015-09-19 19:26:32.000000000 -0400
+@@ -8,7 +8,6 @@
+ #define ROOTDEV       1  // device number of file system root disk
+ #define MAXARG       32  // max exec arguments
+ #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
+-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
++#define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
+ #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+-#define FSSIZE       1000  // size of file system in blocks
+ 
+diff -uNr cs550-16s-proj1-base/proc.c cs550-16s-proj1-working/proc.c
+--- cs550-16s-proj1-base/proc.c	2016-02-15 22:30:50.000000000 -0500
++++ cs550-16s-proj1-working/proc.c	2015-09-19 19:26:32.000000000 -0400
+@@ -14,15 +14,28 @@
+ 
+ static struct proc *initproc;
+ 
++int max = 3;
+ int nextpid = 1;
+-
+ int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
+-
++int winner;
++int scheduler_choice = 0;
++int process_id;
++int process_priority = 2;
+ extern void forkret(void);
+ extern void trapret(void);
+ 
+ static void wakeup1(void *chan);
+ 
++void set_priority(int pid,int priority) {
++   struct proc *p;
++   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++      if(p->pid == pid) {
++        p->priority = priority;
++      }
++   }
++}
++
++
+ void
+ pinit(void)
+ {
+@@ -148,7 +161,7 @@
+   np->sz = proc->sz;
+   np->parent = proc;
+   *np->tf = *proc->tf;
+-
++  np->priority = 2;
+   // Clear %eax so that fork returns 0 in the child.
+   np->tf->eax = 0;
+ 
+@@ -158,14 +171,14 @@
+   np->cwd = idup(proc->cwd);
+ 
+   safestrcpy(np->name, proc->name, sizeof(proc->name));
+- 
++
+   pid = np->pid;
+ 
+-  // lock to force the compiler to emit the np->state write last.
+-  acquire(&ptable.lock);
+   np->state = RUNNABLE;
+-  release(&ptable.lock);
+-  
++  if(winner == 1) {
++	yield();
++  }
++
+   return pid;
+ }
+ 
+@@ -269,40 +282,49 @@
+ scheduler(void)
+ {
+   struct proc *p;
+-  int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
+-
+   for(;;){
+-    // Enable interrupts on this processor.
+     sti();
+-
+-    // Loop over process table looking for process to run.
++  if(scheduler_choice == 0) {
+     acquire(&ptable.lock);
+-    ran = 0;
+     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+       if(p->state != RUNNABLE)
+         continue;
+ 
+-      ran = 1;
+-      
+-      // Switch to chosen process.  It is the process's job
+-      // to release ptable.lock and then reacquire it
+-      // before jumping back to us.
+       proc = p;
+       switchuvm(p);
+       p->state = RUNNING;
+       swtch(&cpu->scheduler, proc->context);
+       switchkvm();
+ 
+-      // Process is done running for now.
+-      // It should have changed its p->state before coming back.
+       proc = 0;
+     }
+     release(&ptable.lock);
+ 
+-    if (ran == 0){
+-        halt();
++  }
++  else {
++    acquire(&ptable.lock);
++    int flag = 0;
++
++    for(p = &ptable.proc[NPROC - 1]; p >= ptable.proc; p--){
++      if((p->state != RUNNABLE))
++        continue;
++      if(p->priority > max)
++           max = p->priority;
++      if((p->priority == max)) {
++      proc = p;
++      switchuvm(p);
++      p->state = RUNNING;
++      swtch(&cpu->scheduler, proc->context);
++      switchkvm();
++      proc = 0;
++      flag = 1;
++     }
+     }
++    if((flag == 0))
++       max--;
++    release(&ptable.lock);
+   }
++ }
+ }
+ 
+ // Enter scheduler.  Must hold only ptable.lock
+@@ -331,7 +353,7 @@
+ {
+   if (sched_trace_enabled)
+   {
+-    cprintf("[%d]", proc->pid);
++    cprintf("%d - ", proc->pid);
+   }
+ 
+   acquire(&ptable.lock);  //DOC: yieldlock
+@@ -354,8 +376,7 @@
+     // of a regular process (e.g., they call sleep), and thus cannot 
+     // be run from main().
+     first = 0;
+-    iinit(ROOTDEV);
+-    initlog(ROOTDEV);
++    initlog();
+   }
+   
+   // Return to "caller", actually trapret (see allocproc).
+diff -uNr cs550-16s-proj1-base/proc.c.save.1 cs550-16s-proj1-working/proc.c.save.1
+--- cs550-16s-proj1-base/proc.c.save.1	1969-12-31 19:00:00.000000000 -0500
++++ cs550-16s-proj1-working/proc.c.save.1	2015-09-19 19:26:32.000000000 -0400
+@@ -0,0 +1,476 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++#include "spinlock.h"
++
++struct {
++  struct spinlock lock;
++  struct proc proc[NPROC];
++} ptable;
++
++static struct proc *initproc;
++
++int nextpid = 1;
++
++int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
++int winner;
++extern void forkret(void);
++extern void trapret(void);
++
++static void wakeup1(void *chan);
++
++void
++pinit(void)
++{
++  initlock(&ptable.lock, "ptable");
++}
++
++//PAGEBREAK: 32
++// Look in the process table for an UNUSED proc.
++// If found, change state to EMBRYO and initialize
++// state required to run in the kernel.
++// Otherwise return 0.
++static struct proc*
++allocproc(void)
++{
++  struct proc *p;
++  char *sp;
++
++  acquire(&ptable.lock);
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++    if(p->state == UNUSED)
++      goto found;
++  release(&ptable.lock);
++  return 0;
++
++found:
++  p->state = EMBRYO;
++  p->pid = nextpid++;
++  release(&ptable.lock);
++
++  // Allocate kernel stack.
++  if((p->kstack = kalloc()) == 0){
++    p->state = UNUSED;
++    return 0;
++  }
++  sp = p->kstack + KSTACKSIZE;
++  
++  // Leave room for trap frame.
++  sp -= sizeof *p->tf;
++  p->tf = (struct trapframe*)sp;
++  
++  // Set up new context to start executing at forkret,
++  // which returns to trapret.
++  sp -= 4;
++  *(uint*)sp = (uint)trapret;
++
++  sp -= sizeof *p->context;
++  p->context = (struct context*)sp;
++  memset(p->context, 0, sizeof *p->context);
++  p->context->eip = (uint)forkret;
++
++  return p;
++}
++
++//PAGEBREAK: 32
++// Set up first user process.
++void
++userinit(void)
++{
++  struct proc *p;
++  extern char _binary_initcode_start[], _binary_initcode_size[];
++  
++  p = allocproc();
++  initproc = p;
++  if((p->pgdir = setupkvm()) == 0)
++    panic("userinit: out of memory?");
++  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
++  p->sz = PGSIZE;
++  memset(p->tf, 0, sizeof(*p->tf));
++  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++  p->tf->es = p->tf->ds;
++  p->tf->ss = p->tf->ds;
++  p->tf->eflags = FL_IF;
++  p->tf->esp = PGSIZE;
++  p->tf->eip = 0;  // beginning of initcode.S
++
++  safestrcpy(p->name, "initcode", sizeof(p->name));
++  p->cwd = namei("/");
++
++  p->state = RUNNABLE;
++}
++
++// Grow current process's memory by n bytes.
++// Return 0 on success, -1 on failure.
++int
++growproc(int n)
++{
++  uint sz;
++  
++  sz = proc->sz;
++  if(n > 0){
++    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
++      return -1;
++  } else if(n < 0){
++    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
++      return -1;
++  }
++  proc->sz = sz;
++  switchuvm(proc);
++  return 0;
++}
++
++// Create a new process copying p as the parent.
++// Sets up stack to return as if from system call.
++// Caller must set state of returned proc to RUNNABLE.
++int
++fork(void)
++{
++  int i, pid;
++  struct proc *np;
++
++  // Allocate process.
++  if((np = allocproc()) == 0)
++    return -1;
++
++  // Copy process state from p.
++  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
++    kfree(np->kstack);
++    np->kstack = 0;
++    np->state = UNUSED;
++    return -1;
++  }
++  np->sz = proc->sz;
++  np->parent = proc;
++  *np->tf = *proc->tf;
++
++  // Clear %eax so that fork returns 0 in the child.
++  np->tf->eax = 0;
++
++  for(i = 0; i < NOFILE; i++)
++    if(proc->ofile[i])
++      np->ofile[i] = filedup(proc->ofile[i]);
++  np->cwd = idup(proc->cwd);
++
++  safestrcpy(np->name, proc->name, sizeof(proc->name));
++
++  pid = np->pid;
++
++  // lock to force the compiler to emit the np->state write last.
++  acquire(&ptable.lock);
++  np->state = RUNNABLE;
++  if(winner == 0) {
++
++  }
++  release(&ptable.lock);
++
++  return pid;
++}
++
++// Exit the current process.  Does not return.
++// An exited process remains in the zombie state
++// until its parent calls wait() to find out it exited.
++void
++exit(void)
++{
++  struct proc *p;
++  int fd;
++
++  if(proc == initproc)
++    panic("init exiting");
++
++  // Close all open files.
++  for(fd = 0; fd < NOFILE; fd++){
++    if(proc->ofile[fd]){
++      fileclose(proc->ofile[fd]);
++      proc->ofile[fd] = 0;
++    }
++  }
++
++  begin_op();
++  iput(proc->cwd);
++  end_op();
++  proc->cwd = 0;
++
++  acquire(&ptable.lock);
++
++  // Parent might be sleeping in wait().
++  wakeup1(proc->parent);
++
++  // Pass abandoned children to init.
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    if(p->parent == proc){
++      p->parent = initproc;
++      if(p->state == ZOMBIE)
++        wakeup1(initproc);
++    }
++  }
++
++  // Jump into the scheduler, never to return.
++  proc->state = ZOMBIE;
++  sched();
++  panic("zombie exit");
++}
++
++// Wait for a child process to exit and return its pid.
++// Return -1 if this process has no children.
++int
++wait(void)
++{
++  struct proc *p;
++  int havekids, pid;
++
++  acquire(&ptable.lock);
++  for(;;){
++    // Scan through table looking for zombie children.
++    havekids = 0;
++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      if(p->parent != proc)
++        continue;
++      havekids = 1;
++      if(p->state == ZOMBIE){
++        // Found one.
++        pid = p->pid;
++        kfree(p->kstack);
++        p->kstack = 0;
++        freevm(p->pgdir);
++        p->state = UNUSED;
++        p->pid = 0;
++        p->parent = 0;
++        p->name[0] = 0;
++        p->killed = 0;
++        release(&ptable.lock);
++        return pid;
++      }
++    }
++
++    // No point waiting if we don't have any children.
++    if(!havekids || proc->killed){
++      release(&ptable.lock);
++      return -1;
++    }
++
++    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++    sleep(proc, &ptable.lock);  //DOC: wait-sleep
++  }
++}
++
++//PAGEBREAK: 42
++// Per-CPU process scheduler.
++// Each CPU calls scheduler() after setting itself up.
++// Scheduler never returns.  It loops, doing:
++//  - choose a process to run
++//  - swtch to start running that process
++//  - eventually that process transfers control
++//      via swtch back to the scheduler.
++void
++scheduler(void)
++{
++  struct proc *p;
++
++  for(;;){
++    // Enable interrupts on this processor.
++    sti();
++
++    // Loop over process table looking for process to run.
++    acquire(&ptable.lock);
++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      if(p->state != RUNNABLE)
++        continue;
++
++      // Switch to chosen process.  It is the process's job
++      // to release ptable.lock and then reacquire it
++      // before jumping back to us.
++      proc = p;
++      switchuvm(p);
++      p->state = RUNNING;
++      swtch(&cpu->scheduler, proc->context);
++      switchkvm();
++
++      // Process is done running for now.
++      // It should have changed its p->state before coming back.
++      proc = 0;
++    }
++    release(&ptable.lock);
++
++  }
++}
++
++// Enter scheduler.  Must hold only ptable.lock
++// and have changed proc->state.
++void
++sched(void)
++{
++  int intena;
++
++  if(!holding(&ptable.lock))
++    panic("sched ptable.lock");
++  if(cpu->ncli != 1)
++    panic("sched locks");
++  if(proc->state == RUNNING)
++    panic("sched running");
++  if(readeflags()&FL_IF)
++    panic("sched interruptible");
++  intena = cpu->intena;
++  swtch(&proc->context, cpu->scheduler);
++  cpu->intena = intena;
++}
++
++// Give up the CPU for one scheduling round.
++void
++yield(void)
++{
++  if (sched_trace_enabled)
++  {
++    cprintf("%d - ", proc->pid);
++  }
++
++  acquire(&ptable.lock);  //DOC: yieldlock
++  proc->state = RUNNABLE;
++  sched();
++  release(&ptable.lock);
++}
++
++// A fork child's very first scheduling by scheduler()
++// will swtch here.  "Return" to user space.
++void
++forkret(void)
++{
++  static int first = 1;
++  // Still holding ptable.lock from scheduler.
++  release(&ptable.lock);
++
++  if (first) {
++    // Some initialization functions must be run in the context
++    // of a regular process (e.g., they call sleep), and thus cannot 
++    // be run from main().
++    first = 0;
++    initlog();
++  }
++  
++  // Return to "caller", actually trapret (see allocproc).
++}
++
++// Atomically release lock and sleep on chan.
++// Reacquires lock when awakened.
++void
++sleep(void *chan, struct spinlock *lk)
++{
++  if(proc == 0)
++    panic("sleep");
++
++  if(lk == 0)
++    panic("sleep without lk");
++
++  // Must acquire ptable.lock in order to
++  // change p->state and then call sched.
++  // Once we hold ptable.lock, we can be
++  // guaranteed that we won't miss any wakeup
++  // (wakeup runs with ptable.lock locked),
++  // so it's okay to release lk.
++  if(lk != &ptable.lock){  //DOC: sleeplock0
++    acquire(&ptable.lock);  //DOC: sleeplock1
++    release(lk);
++  }
++
++  // Go to sleep.
++  proc->chan = chan;
++  proc->state = SLEEPING;
++  sched();
++
++  // Tidy up.
++  proc->chan = 0;
++
++  // Reacquire original lock.
++  if(lk != &ptable.lock){  //DOC: sleeplock2
++    release(&ptable.lock);
++    acquire(lk);
++  }
++}
++
++//PAGEBREAK!
++// Wake up all processes sleeping on chan.
++// The ptable lock must be held.
++static void
++wakeup1(void *chan)
++{
++  struct proc *p;
++
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++    if(p->state == SLEEPING && p->chan == chan)
++      p->state = RUNNABLE;
++}
++
++// Wake up all processes sleeping on chan.
++void
++wakeup(void *chan)
++{
++  acquire(&ptable.lock);
++  wakeup1(chan);
++  release(&ptable.lock);
++}
++
++// Kill the process with the given pid.
++// Process won't exit until it returns
++// to user space (see trap in trap.c).
++int
++kill(int pid)
++{
++  struct proc *p;
++
++  acquire(&ptable.lock);
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    if(p->pid == pid){
++      p->killed = 1;
++      // Wake process from sleep if necessary.
++      if(p->state == SLEEPING)
++        p->state = RUNNABLE;
++      release(&ptable.lock);
++      return 0;
++    }
++  }
++  release(&ptable.lock);
++  return -1;
++}
++
++//PAGEBREAK: 36
++// Print a process listing to console.  For debugging.
++// Runs when user types ^P on console.
++// No lock to avoid wedging a stuck machine further.
++void
++procdump(void)
++{
++  static char *states[] = {
++  [UNUSED]    "unused",
++  [EMBRYO]    "embryo",
++  [SLEEPING]  "sleep ",
++  [RUNNABLE]  "runble",
++  [RUNNING]   "run   ",
++  [ZOMBIE]    "zombie"
++  };
++  int i;
++  struct proc *p;
++  char *state;
++  uint pc[10];
++  
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    if(p->state == UNUSED)
++      continue;
++    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
++      state = states[p->state];
++    else
++      state = "???";
++    cprintf("%d %s %s", p->pid, state, p->name);
++    if(p->state == SLEEPING){
++      getcallerpcs((uint*)p->context->ebp+2, pc);
++      for(i=0; i<10 && pc[i] != 0; i++)
++        cprintf(" %p", pc[i]);
++    }
++    cprintf("\n");
++  }
++}
+diff -uNr cs550-16s-proj1-base/proc.h cs550-16s-proj1-working/proc.h
+--- cs550-16s-proj1-base/proc.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/proc.h	2015-09-19 19:26:32.000000000 -0400
+@@ -66,6 +66,7 @@
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
++  int priority;
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+diff -uNr cs550-16s-proj1-base/proj1_forktest.c cs550-16s-proj1-working/proj1_forktest.c
+--- cs550-16s-proj1-base/proj1_forktest.c	2016-02-15 19:39:42.000000000 -0500
++++ cs550-16s-proj1-working/proj1_forktest.c	2015-09-19 19:26:32.000000000 -0400
+@@ -5,12 +5,11 @@
+    stub functions for the system call user space wrapper functions are provided. 
+    REMEMBER to disable the stub functions (by commenting the following macro) to 
+    allow your implementation to work properly. */
+-#define STUB_FUNCS
++/*#define STUB_FUNCS
+ #ifdef STUB_FUNCS
+ void fork_winner(int winner) {}
+ #endif
+-
+-
++*/
+ #define TOTAL_TEST_TRIALS 50
+ 
+ int
+@@ -42,7 +41,7 @@
+     fork_winner(w); // set according to user input
+ 
+     printf(1, "\nCS550 proj1 fork test ==> \n");
+-    
++
+     for (i = 0; i < TOTAL_TEST_TRIALS; i++)
+     {
+         printf(1, "\nTrial %d: ", i);
+diff -uNr cs550-16s-proj1-base/proj1_schdtest.c cs550-16s-proj1-working/proj1_schdtest.c
+--- cs550-16s-proj1-base/proj1_schdtest.c	2016-02-15 22:48:35.000000000 -0500
++++ cs550-16s-proj1-working/proj1_schdtest.c	2015-09-19 19:26:32.000000000 -0400
+@@ -1,60 +1,194 @@
+ #include "types.h"
+ #include "user.h"
+ 
++/* CS550 ATTENTION: to ensure correct compilation of the base code, 
++   stub functions for the system call user space wrapper functions are provided. 
++   REMEMBER to disable the stub functions (by commenting the following macro) to 
++   allow your implementation to work properly. */
++
++#define CHILD_COUNT  6
++#define SLEEP_TICKS  30
++
+ #define LOOP_CNT 0x01000000
+ 
+-void do_child(void)
++void usage(void)
++{
++    printf(1, "Usage: proj1_schdtest scheduler_type [with_rg_proc] \n"
++              "\tscheduler_type:\n"
++              "\t\t0: Use the default xv6 scheduler\n"
++              "\t\t1: Use the priority-based scheduler\n"
++              "\twith_rg_proc (used with priority-based scheduler):\n"
++              "\t\t0: Without runtime-generated process\n"
++              "\t\t1: With runtime-generated process\n");
++}
++
++int
++main(int argc, char *argv[])
+ {
+-    int cnt = 0;
++    int scheduler = 0, with_rg_proc = 0;
++    int i = 0, j = 0;
+     int tmp = 0;
++    struct {
++        int pid;
++        int priority;
++    } pa[CHILD_COUNT];
++    int rg_pid = 0;
++    int pipe_fd[CHILD_COUNT][2];
++    int c = 0;
+ 
+-    while(cnt < LOOP_CNT)
++    if (argc < 2)
+     {
+-        tmp += cnt;
+-        cnt ++;
++        usage();
++        exit();
+     }
+ 
+-    exit();
+-}
+-
+-void example_test_code()
+-{
+-    int pid = 0;
++    printf(1, "==============\n");
+ 
+-    pid = fork();
+-    if (pid < 0)
++    if (argv[1][0] == '0')
+     {
+-        printf(1, "fork() failed!\n");
+-        exit();
++        scheduler = 0;
++        printf(1, "Using the default xv6 scheduler \n");
+     }
+-    else if (pid == 0) // child
++    else
+     {
+-        do_child();
++        scheduler = 1;
++        printf(1, "Using the priority based scheduler, ");
++
++        if (argc < 3)
++        {
++            usage();
++            exit();
++        }
++
++        if (argv[2][0] == '0')
++        {
++            with_rg_proc = 0;
++            printf(1, "without runtime-generated process\n");
++        }
++        else
++        {
++            with_rg_proc = 1;
++            printf(1, "with runtime-generated process\n");
++        }
+     }
+-    else // parent
++
++    printf(1, "--------------\n");
++
++    set_sched(scheduler);
++
++    for (i = 0; i < CHILD_COUNT; i++)
+     {
+-       if (wait() < 0)
+-       {
+-            printf(1, "wait() failed!\n");
+-       }
++        if (pipe(pipe_fd[i]) < 0)
++        {
++            printf(1, "pipe() failed!\n");
++            exit();
++        }
++
++        pa[i].pid = fork();
++        if (pa[i].pid < 0)
++        {
++            printf(1, "fork() failed!\n");
++            exit();
++        }
++        else if (pa[i].pid == 0) // child
++        {
++            #if 1
++            close(pipe_fd[i][1]); // close the write end
++            read(pipe_fd[i][0], &c, 1);
++            #endif
++
++            while(j < LOOP_CNT)
++            {
++                tmp += j;
++                j++;
++            }
++
++            exit();
++        }
++        else // parent
++        {
++            close(pipe_fd[i][0]); // close the read end
++
++            if (scheduler == 0) // RR
++            {
++                printf(1, "Parent: child (pid=%d) created!\n",
++                       pa[i].pid, pa[i].priority);
++            }
++            else // priority-based
++            {
++                if (i == 0 || i == 1)
++                {
++                    pa[i].priority = 1;
++                    set_priority(pa[i].pid, pa[i].priority);
++                }
++                else if (i == 4 || i == 5)
++                {
++                    pa[i].priority = 3;
++                    set_priority(pa[i].pid, pa[i].priority);
++                }
++                else
++                {
++                    pa[i].priority = 2;
++                    //Note: no need to set priority, because it should be set to 2 by the kernel by default
++                }
++
++                printf(1, "Parent: child (pid=%d priority=%d) created!\n",
++                       pa[i].pid, pa[i].priority);
++            }
++        }
+     }
+-	
+-	printf(1, "\n");
+-}
+ 
+-int
+-main(int argc, char *argv[])
+-{
+-    enable_sched_trace(1);
++    printf(1, "==============\n");
+ 
+-    /* ---------------- start: add your test code ------------------- */
++    enable_sched_trace(1);
+ 
+-    example_test_code();
++    #if 1
++    for (i = 0; i < CHILD_COUNT; i++)
++    {
++       write(pipe_fd[i][1], "A", 1); // start child-i
++    }
++    #endif
+ 
+-    /* ---------------- end: add your test code ------------------- */
++    for (i = 0; i < CHILD_COUNT; i++)
++    {
++        if (with_rg_proc)
++        {
++            if (i == 4)
++            {
++                rg_pid = fork();
++                if (pa[i].pid < 0)
++                {
++                    printf(1, "fork() failed!\n");
++                    exit();
++                }
++                else if (rg_pid == 0) // child
++                {
++                    while(j < LOOP_CNT)
++                    {
++                        tmp += j;
++                        j++;
++                    }
++                    exit();
++                }
++                else // parent
++                {
++                    if (wait() < 0)
++                    {
++                        printf(1, "wait() on child-%d failed!\n", i);
++                    }
++                }
++            }
++        }
++
++        if (wait() < 0)
++        {
++            printf(1, "wait() on child-%d failed!\n", i);
++        }
++    }
+ 
+     enable_sched_trace(0);
+-    
++
++    printf(1, "\n");
++
+     exit();
+ }
+-
+diff -uNr cs550-16s-proj1-base/README cs550-16s-proj1-working/README
+--- cs550-16s-proj1-base/README	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/README	2015-09-19 19:26:32.000000000 -0400
+@@ -6,7 +6,7 @@
+ 
+ xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+ to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+-2000)). See also http://pdos.csail.mit.edu/6.828/2014/xv6.html, which
++2000)). See also http://pdos.csail.mit.edu/6.828/2012/v6.html, which
+ provides pointers to on-line resources for v6.
+ 
+ xv6 borrows code from the following sources:
+diff -uNr cs550-16s-proj1-base/shutdown.c cs550-16s-proj1-working/shutdown.c
+--- cs550-16s-proj1-base/shutdown.c	1969-12-31 19:00:00.000000000 -0500
++++ cs550-16s-proj1-working/shutdown.c	2015-09-19 19:26:32.000000000 -0400
+@@ -0,0 +1,15 @@
++#include "types.h"
++#include "stat.h"
++#include "user.h"
++#include "x86.h"
++/* CS550 ATTENTION: to ensure correct compilation of the base code, 
++   stub functions for the system call user space wrapper functions are provided. 
++   REMEMBER to disable the stub functions (by commenting the following macro) to 
++   allow your implementation to work properly. */
++
++int 
++main(int argc, char * argv[])
++{
++    shutdown();
++    return 0;
++}
+diff -uNr cs550-16s-proj1-base/syscall.c cs550-16s-proj1-working/syscall.c
+--- cs550-16s-proj1-base/syscall.c	2016-02-15 19:34:32.000000000 -0500
++++ cs550-16s-proj1-working/syscall.c	2015-09-19 19:26:32.000000000 -0400
+@@ -99,7 +99,10 @@
+ extern int sys_write(void);
+ extern int sys_uptime(void);
+ extern int sys_enable_sched_trace(void);
+-
++extern int sys_shutdown(void);
++extern int sys_fork_winner(void);
++extern int sys_set_sched(void);
++extern int sys_set_priority(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -124,7 +127,10 @@
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
+ [SYS_enable_sched_trace]   sys_enable_sched_trace,
+-
++[SYS_shutdown]   sys_shutdown,
++[SYS_fork_winner]   sys_fork_winner,
++[SYS_set_sched]  sys_set_sched,
++[SYS_set_priority]  sys_set_priority,
+ };
+ 
+ void
+diff -uNr cs550-16s-proj1-base/syscall.h cs550-16s-proj1-working/syscall.h
+--- cs550-16s-proj1-base/syscall.h	2016-02-15 19:35:00.000000000 -0500
++++ cs550-16s-proj1-working/syscall.h	2015-09-19 19:26:32.000000000 -0400
+@@ -21,4 +21,7 @@
+ #define SYS_mkdir  20
+ #define SYS_close  21
+ #define SYS_enable_sched_trace  22
+-
++#define SYS_shutdown  23
++#define SYS_fork_winner  24
++#define SYS_set_sched  25
++#define SYS_set_priority  26
+diff -uNr cs550-16s-proj1-base/sysproc.c cs550-16s-proj1-working/sysproc.c
+--- cs550-16s-proj1-base/sysproc.c	2016-02-15 19:35:25.000000000 -0500
++++ cs550-16s-proj1-working/sysproc.c	2015-09-19 19:26:32.000000000 -0400
+@@ -7,6 +7,44 @@
+ #include "mmu.h"
+ #include "proc.h"
+ 
++extern int scheduler_choice;
++int
++sys_set_sched(void)
++{
++   if (argint(0, &scheduler_choice) < 0) {
++       cprintf("set_sched() failed!\n");
++    }
++   return 0;
++}
++
++extern int process_id;
++extern int process_priority;
++extern void set_priority(int pid,int priority);
++int
++sys_set_priority(void)
++{
++   if ((argint(0, &process_id) < 0)||(argint(1, &process_priority) < 0)) {
++       cprintf("set_priority() failed!\n");
++        return -1;
++    }
++   set_priority(process_id,process_priority);
++   return 0;
++}
++extern int winner;
++int
++sys_fork_winner(void)
++{
++   if (argint(0, &winner) < 0) {
++       cprintf("fork_winner() failed!\n");
++    }
++    return 0;
++}
++int
++sys_shutdown(void)
++{
++   outw(0xB004, 0x0|0x2000);
++   return 0;
++}
+ int
+ sys_fork(void)
+ {
+@@ -89,8 +127,8 @@
+   release(&tickslock);
+   return xticks;
+ }
+-
+ extern int sched_trace_enabled;
++//extern int sched_trace_enabled;
+ int sys_enable_sched_trace(void)
+ {
+   if (argint(0, &sched_trace_enabled) < 0)
+diff -uNr cs550-16s-proj1-base/user.h cs550-16s-proj1-working/user.h
+--- cs550-16s-proj1-base/user.h	2016-02-15 19:35:38.000000000 -0500
++++ cs550-16s-proj1-working/user.h	2015-09-19 19:26:32.000000000 -0400
+@@ -23,6 +23,10 @@
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++void shutdown(void);
++void fork_winner(int);
++void set_sched(int);
++void set_priority(int,int);
+ 
+ // ulib.c
+ int stat(char*, struct stat*);
+diff -uNr cs550-16s-proj1-base/usys.S cs550-16s-proj1-working/usys.S
+--- cs550-16s-proj1-base/usys.S	2016-02-15 19:35:48.000000000 -0500
++++ cs550-16s-proj1-working/usys.S	2015-09-19 19:26:32.000000000 -0400
+@@ -30,3 +30,7 @@
+ SYSCALL(sleep)
+ SYSCALL(uptime)
+ SYSCALL(enable_sched_trace)
++SYSCALL(shutdown)
++SYSCALL(fork_winner)
++SYSCALL(set_sched)
++SYSCALL(set_priority)
+diff -uNr cs550-16s-proj1-base/x86.h cs550-16s-proj1-working/x86.h
+--- cs550-16s-proj1-base/x86.h	2016-02-15 15:37:10.000000000 -0500
++++ cs550-16s-proj1-working/x86.h	2015-09-19 19:26:32.000000000 -0400
+@@ -144,13 +144,6 @@
+   asm volatile("movl %0,%%cr3" : : "r" (val));
+ }
+ 
+-// CS550: to solve the 100%-CPU-utilization-when-idling problem - "hlt" instruction puts CPU to sleep
+-static inline void
+-halt()
+-{
+-    asm volatile("hlt" : : :"memory");
+-}
+-
+ //PAGEBREAK: 36
+ // Layout of the trap frame built on the stack by the
+ // hardware and by trapasm.S, and passed to trap().
Binary files cs550-16s-proj1-base/_proj1_schdtest and cs550-16s-proj1-working/_proj1_schdtest differ
diff -uNr cs550-16s-proj1-base/proj1_schdtest.asm cs550-16s-proj1-working/proj1_schdtest.asm
--- cs550-16s-proj1-base/proj1_schdtest.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1_schdtest.asm	2016-03-04 14:54:57.000000000 -0500
@@ -0,0 +1,1689 @@
+
+_proj1_schdtest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <usage>:
+#define SLEEP_TICKS  30
+
+#define LOOP_CNT 0x01000000
+
+void usage(void)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 ec 18             	sub    $0x18,%esp
+    printf(1, "Usage: proj1_schdtest scheduler_type [with_rg_proc] \n"
+   6:	c7 44 24 04 e8 0c 00 	movl   $0xce8,0x4(%esp)
+   d:	00 
+   e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  15:	e8 fb 08 00 00       	call   915 <printf>
+              "\t\t0: Use the default xv6 scheduler\n"
+              "\t\t1: Use the priority-based scheduler\n"
+              "\twith_rg_proc (used with priority-based scheduler):\n"
+              "\t\t0: Without runtime-generated process\n"
+              "\t\t1: With runtime-generated process\n");
+}
+  1a:	c9                   	leave  
+  1b:	c3                   	ret    
+
+0000001c <main>:
+
+int
+main(int argc, char *argv[])
+{
+  1c:	55                   	push   %ebp
+  1d:	89 e5                	mov    %esp,%ebp
+  1f:	83 e4 f0             	and    $0xfffffff0,%esp
+  22:	81 ec 90 00 00 00    	sub    $0x90,%esp
+    int scheduler = 0, with_rg_proc = 0;
+  28:	c7 84 24 8c 00 00 00 	movl   $0x0,0x8c(%esp)
+  2f:	00 00 00 00 
+  33:	c7 84 24 88 00 00 00 	movl   $0x0,0x88(%esp)
+  3a:	00 00 00 00 
+    int i = 0, j = 0;
+  3e:	c7 84 24 84 00 00 00 	movl   $0x0,0x84(%esp)
+  45:	00 00 00 00 
+  49:	c7 84 24 80 00 00 00 	movl   $0x0,0x80(%esp)
+  50:	00 00 00 00 
+    int tmp = 0;
+  54:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%esp)
+  5b:	00 
+    struct {
+        int pid;
+        int priority;
+    } pa[CHILD_COUNT];
+    int rg_pid = 0;
+  5c:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%esp)
+  63:	00 
+    int pipe_fd[CHILD_COUNT][2];
+    int c = 0;
+  64:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  6b:	00 
+
+    if (argc < 2)
+  6c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+  70:	7f 0a                	jg     7c <main+0x60>
+    {
+        usage();
+  72:	e8 89 ff ff ff       	call   0 <usage>
+        exit();
+  77:	e8 f4 06 00 00       	call   770 <exit>
+    }
+
+    printf(1, "==============\n");
+  7c:	c7 44 24 04 f7 0d 00 	movl   $0xdf7,0x4(%esp)
+  83:	00 
+  84:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  8b:	e8 85 08 00 00       	call   915 <printf>
+
+    if (argv[1][0] == '0')
+  90:	8b 45 0c             	mov    0xc(%ebp),%eax
+  93:	83 c0 04             	add    $0x4,%eax
+  96:	8b 00                	mov    (%eax),%eax
+  98:	0f b6 00             	movzbl (%eax),%eax
+  9b:	3c 30                	cmp    $0x30,%al
+  9d:	75 21                	jne    c0 <main+0xa4>
+    {
+        scheduler = 0;
+  9f:	c7 84 24 8c 00 00 00 	movl   $0x0,0x8c(%esp)
+  a6:	00 00 00 00 
+        printf(1, "Using the default xv6 scheduler \n");
+  aa:	c7 44 24 04 08 0e 00 	movl   $0xe08,0x4(%esp)
+  b1:	00 
+  b2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  b9:	e8 57 08 00 00       	call   915 <printf>
+  be:	eb 7e                	jmp    13e <main+0x122>
+    }
+    else
+    {
+        scheduler = 1;
+  c0:	c7 84 24 8c 00 00 00 	movl   $0x1,0x8c(%esp)
+  c7:	01 00 00 00 
+        printf(1, "Using the priority based scheduler, ");
+  cb:	c7 44 24 04 2c 0e 00 	movl   $0xe2c,0x4(%esp)
+  d2:	00 
+  d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  da:	e8 36 08 00 00       	call   915 <printf>
+
+        if (argc < 3)
+  df:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
+  e3:	7f 0a                	jg     ef <main+0xd3>
+        {
+            usage();
+  e5:	e8 16 ff ff ff       	call   0 <usage>
+            exit();
+  ea:	e8 81 06 00 00       	call   770 <exit>
+        }
+
+        if (argv[2][0] == '0')
+  ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f2:	83 c0 08             	add    $0x8,%eax
+  f5:	8b 00                	mov    (%eax),%eax
+  f7:	0f b6 00             	movzbl (%eax),%eax
+  fa:	3c 30                	cmp    $0x30,%al
+  fc:	75 21                	jne    11f <main+0x103>
+        {
+            with_rg_proc = 0;
+  fe:	c7 84 24 88 00 00 00 	movl   $0x0,0x88(%esp)
+ 105:	00 00 00 00 
+            printf(1, "without runtime-generated process\n");
+ 109:	c7 44 24 04 54 0e 00 	movl   $0xe54,0x4(%esp)
+ 110:	00 
+ 111:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 118:	e8 f8 07 00 00       	call   915 <printf>
+ 11d:	eb 1f                	jmp    13e <main+0x122>
+        }
+        else
+        {
+            with_rg_proc = 1;
+ 11f:	c7 84 24 88 00 00 00 	movl   $0x1,0x88(%esp)
+ 126:	01 00 00 00 
+            printf(1, "with runtime-generated process\n");
+ 12a:	c7 44 24 04 78 0e 00 	movl   $0xe78,0x4(%esp)
+ 131:	00 
+ 132:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 139:	e8 d7 07 00 00       	call   915 <printf>
+        }
+    }
+
+    printf(1, "--------------\n");
+ 13e:	c7 44 24 04 98 0e 00 	movl   $0xe98,0x4(%esp)
+ 145:	00 
+ 146:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 14d:	e8 c3 07 00 00       	call   915 <printf>
+
+    set_sched(scheduler);
+ 152:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
+ 159:	89 04 24             	mov    %eax,(%esp)
+ 15c:	e8 c7 06 00 00       	call   828 <set_sched>
+    i = 0;	
+ 161:	c7 84 24 84 00 00 00 	movl   $0x0,0x84(%esp)
+ 168:	00 00 00 00 
+    while(i < CHILD_COUNT)
+ 16c:	e9 04 02 00 00       	jmp    375 <main+0x359>
+    {
+        if (pipe(pipe_fd[i]) < 0)
+ 171:	8d 44 24 18          	lea    0x18(%esp),%eax
+ 175:	8b 94 24 84 00 00 00 	mov    0x84(%esp),%edx
+ 17c:	c1 e2 03             	shl    $0x3,%edx
+ 17f:	01 d0                	add    %edx,%eax
+ 181:	89 04 24             	mov    %eax,(%esp)
+ 184:	e8 f7 05 00 00       	call   780 <pipe>
+ 189:	85 c0                	test   %eax,%eax
+ 18b:	79 19                	jns    1a6 <main+0x18a>
+        {
+            printf(1, "pipe() failed!\n");
+ 18d:	c7 44 24 04 a8 0e 00 	movl   $0xea8,0x4(%esp)
+ 194:	00 
+ 195:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 19c:	e8 74 07 00 00       	call   915 <printf>
+            exit();
+ 1a1:	e8 ca 05 00 00       	call   770 <exit>
+        }
+
+        pa[i].pid = fork();
+ 1a6:	e8 bd 05 00 00       	call   768 <fork>
+ 1ab:	8b 94 24 84 00 00 00 	mov    0x84(%esp),%edx
+ 1b2:	89 44 d4 48          	mov    %eax,0x48(%esp,%edx,8)
+        if (pa[i].pid < 0)
+ 1b6:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 1bd:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 1c1:	85 c0                	test   %eax,%eax
+ 1c3:	79 19                	jns    1de <main+0x1c2>
+        {
+            printf(1, "fork() failed!\n");
+ 1c5:	c7 44 24 04 b8 0e 00 	movl   $0xeb8,0x4(%esp)
+ 1cc:	00 
+ 1cd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 1d4:	e8 3c 07 00 00       	call   915 <printf>
+            exit();
+ 1d9:	e8 92 05 00 00       	call   770 <exit>
+        }
+        else if (pa[i].pid == 0) // child
+ 1de:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 1e5:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 1e9:	85 c0                	test   %eax,%eax
+ 1eb:	75 5d                	jne    24a <main+0x22e>
+        {
+            #if 1
+            close(pipe_fd[i][1]); // close the write end
+ 1ed:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 1f4:	8b 44 c4 1c          	mov    0x1c(%esp,%eax,8),%eax
+ 1f8:	89 04 24             	mov    %eax,(%esp)
+ 1fb:	e8 98 05 00 00       	call   798 <close>
+            read(pipe_fd[i][0], &c, 1);
+ 200:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 207:	8b 44 c4 18          	mov    0x18(%esp,%eax,8),%eax
+ 20b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 212:	00 
+ 213:	8d 54 24 14          	lea    0x14(%esp),%edx
+ 217:	89 54 24 04          	mov    %edx,0x4(%esp)
+ 21b:	89 04 24             	mov    %eax,(%esp)
+ 21e:	e8 65 05 00 00       	call   788 <read>
+            #endif
+
+            while(j < LOOP_CNT)
+ 223:	eb 13                	jmp    238 <main+0x21c>
+            {
+                tmp += j;
+ 225:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
+ 22c:	01 44 24 7c          	add    %eax,0x7c(%esp)
+                j++;
+ 230:	83 84 24 80 00 00 00 	addl   $0x1,0x80(%esp)
+ 237:	01 
+            #if 1
+            close(pipe_fd[i][1]); // close the write end
+            read(pipe_fd[i][0], &c, 1);
+            #endif
+
+            while(j < LOOP_CNT)
+ 238:	81 bc 24 80 00 00 00 	cmpl   $0xffffff,0x80(%esp)
+ 23f:	ff ff ff 00 
+ 243:	7e e0                	jle    225 <main+0x209>
+            {
+                tmp += j;
+                j++;
+            }
+
+            exit();
+ 245:	e8 26 05 00 00       	call   770 <exit>
+        }
+        else // parent
+        {
+            close(pipe_fd[i][0]); // close the read end
+ 24a:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 251:	8b 44 c4 18          	mov    0x18(%esp,%eax,8),%eax
+ 255:	89 04 24             	mov    %eax,(%esp)
+ 258:	e8 3b 05 00 00       	call   798 <close>
+
+            if (scheduler == 0) // RR
+ 25d:	83 bc 24 8c 00 00 00 	cmpl   $0x0,0x8c(%esp)
+ 264:	00 
+ 265:	75 37                	jne    29e <main+0x282>
+            {
+                printf(1, "Parent: child (pid=%d) created!\n",
+ 267:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 26e:	8b 54 c4 4c          	mov    0x4c(%esp,%eax,8),%edx
+ 272:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 279:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 27d:	89 54 24 0c          	mov    %edx,0xc(%esp)
+ 281:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 285:	c7 44 24 04 c8 0e 00 	movl   $0xec8,0x4(%esp)
+ 28c:	00 
+ 28d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 294:	e8 7c 06 00 00       	call   915 <printf>
+ 299:	e9 cf 00 00 00       	jmp    36d <main+0x351>
+                       pa[i].pid, pa[i].priority);
+            }
+            else // priority-based
+            {
+                if (i == 0 || i == 1)
+ 29e:	83 bc 24 84 00 00 00 	cmpl   $0x0,0x84(%esp)
+ 2a5:	00 
+ 2a6:	74 0a                	je     2b2 <main+0x296>
+ 2a8:	83 bc 24 84 00 00 00 	cmpl   $0x1,0x84(%esp)
+ 2af:	01 
+ 2b0:	75 33                	jne    2e5 <main+0x2c9>
+                {
+                    pa[i].priority = 1;
+ 2b2:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 2b9:	c7 44 c4 4c 01 00 00 	movl   $0x1,0x4c(%esp,%eax,8)
+ 2c0:	00 
+                    set_priority(pa[i].pid, pa[i].priority);
+ 2c1:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 2c8:	8b 54 c4 4c          	mov    0x4c(%esp,%eax,8),%edx
+ 2cc:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 2d3:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 2d7:	89 54 24 04          	mov    %edx,0x4(%esp)
+ 2db:	89 04 24             	mov    %eax,(%esp)
+ 2de:	e8 4d 05 00 00       	call   830 <set_priority>
+ 2e3:	eb 56                	jmp    33b <main+0x31f>
+                }
+                else if (i == 4 || i == 5)
+ 2e5:	83 bc 24 84 00 00 00 	cmpl   $0x4,0x84(%esp)
+ 2ec:	04 
+ 2ed:	74 0a                	je     2f9 <main+0x2dd>
+ 2ef:	83 bc 24 84 00 00 00 	cmpl   $0x5,0x84(%esp)
+ 2f6:	05 
+ 2f7:	75 33                	jne    32c <main+0x310>
+                {
+                    pa[i].priority = 3;
+ 2f9:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 300:	c7 44 c4 4c 03 00 00 	movl   $0x3,0x4c(%esp,%eax,8)
+ 307:	00 
+                    set_priority(pa[i].pid, pa[i].priority);
+ 308:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 30f:	8b 54 c4 4c          	mov    0x4c(%esp,%eax,8),%edx
+ 313:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 31a:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 31e:	89 54 24 04          	mov    %edx,0x4(%esp)
+ 322:	89 04 24             	mov    %eax,(%esp)
+ 325:	e8 06 05 00 00       	call   830 <set_priority>
+ 32a:	eb 0f                	jmp    33b <main+0x31f>
+                }
+                else
+                {
+                    pa[i].priority = 2;
+ 32c:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 333:	c7 44 c4 4c 02 00 00 	movl   $0x2,0x4c(%esp,%eax,8)
+ 33a:	00 
+                    //Note: no need to set priority, because it should be set to 2 by the kernel by default
+                }
+
+                printf(1, "Parent: child (pid=%d priority=%d) created!\n",
+ 33b:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 342:	8b 54 c4 4c          	mov    0x4c(%esp,%eax,8),%edx
+ 346:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 34d:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 351:	89 54 24 0c          	mov    %edx,0xc(%esp)
+ 355:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 359:	c7 44 24 04 ec 0e 00 	movl   $0xeec,0x4(%esp)
+ 360:	00 
+ 361:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 368:	e8 a8 05 00 00       	call   915 <printf>
+                       pa[i].pid, pa[i].priority);
+            }
+        }
+	i++;
+ 36d:	83 84 24 84 00 00 00 	addl   $0x1,0x84(%esp)
+ 374:	01 
+
+    printf(1, "--------------\n");
+
+    set_sched(scheduler);
+    i = 0;	
+    while(i < CHILD_COUNT)
+ 375:	83 bc 24 84 00 00 00 	cmpl   $0x5,0x84(%esp)
+ 37c:	05 
+ 37d:	0f 8e ee fd ff ff    	jle    171 <main+0x155>
+            }
+        }
+	i++;
+    }
+
+    printf(1, "==============\n");
+ 383:	c7 44 24 04 f7 0d 00 	movl   $0xdf7,0x4(%esp)
+ 38a:	00 
+ 38b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 392:	e8 7e 05 00 00       	call   915 <printf>
+
+    enable_sched_trace(1);
+ 397:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 39e:	e8 6d 04 00 00       	call   810 <enable_sched_trace>
+	i = 0;
+ 3a3:	c7 84 24 84 00 00 00 	movl   $0x0,0x84(%esp)
+ 3aa:	00 00 00 00 
+    #if 1
+    while(i < CHILD_COUNT)
+ 3ae:	eb 2b                	jmp    3db <main+0x3bf>
+    {
+       write(pipe_fd[i][1], "A", 1); // start child-i
+ 3b0:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 3b7:	8b 44 c4 1c          	mov    0x1c(%esp,%eax,8),%eax
+ 3bb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 3c2:	00 
+ 3c3:	c7 44 24 04 19 0f 00 	movl   $0xf19,0x4(%esp)
+ 3ca:	00 
+ 3cb:	89 04 24             	mov    %eax,(%esp)
+ 3ce:	e8 bd 03 00 00       	call   790 <write>
+	i++;
+ 3d3:	83 84 24 84 00 00 00 	addl   $0x1,0x84(%esp)
+ 3da:	01 
+    printf(1, "==============\n");
+
+    enable_sched_trace(1);
+	i = 0;
+    #if 1
+    while(i < CHILD_COUNT)
+ 3db:	83 bc 24 84 00 00 00 	cmpl   $0x5,0x84(%esp)
+ 3e2:	05 
+ 3e3:	7e cb                	jle    3b0 <main+0x394>
+    {
+       write(pipe_fd[i][1], "A", 1); // start child-i
+	i++;
+    }
+    #endif
+	i=0;
+ 3e5:	c7 84 24 84 00 00 00 	movl   $0x0,0x84(%esp)
+ 3ec:	00 00 00 00 
+    while(i < CHILD_COUNT)
+ 3f0:	e9 de 00 00 00       	jmp    4d3 <main+0x4b7>
+    {
+        if (with_rg_proc)
+ 3f5:	83 bc 24 88 00 00 00 	cmpl   $0x0,0x88(%esp)
+ 3fc:	00 
+ 3fd:	0f 84 a0 00 00 00    	je     4a3 <main+0x487>
+        {
+            if (i == 4)
+ 403:	83 bc 24 84 00 00 00 	cmpl   $0x4,0x84(%esp)
+ 40a:	04 
+ 40b:	0f 85 92 00 00 00    	jne    4a3 <main+0x487>
+            {
+                rg_pid = fork();
+ 411:	e8 52 03 00 00       	call   768 <fork>
+ 416:	89 44 24 78          	mov    %eax,0x78(%esp)
+                if (pa[i].pid < 0)
+ 41a:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 421:	8b 44 c4 48          	mov    0x48(%esp,%eax,8),%eax
+ 425:	85 c0                	test   %eax,%eax
+ 427:	79 19                	jns    442 <main+0x426>
+                {
+                    printf(1, "fork() failed!\n");
+ 429:	c7 44 24 04 b8 0e 00 	movl   $0xeb8,0x4(%esp)
+ 430:	00 
+ 431:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 438:	e8 d8 04 00 00       	call   915 <printf>
+                    exit();
+ 43d:	e8 2e 03 00 00       	call   770 <exit>
+                }
+                else if (rg_pid == 0) // child
+ 442:	83 7c 24 78 00       	cmpl   $0x0,0x78(%esp)
+ 447:	75 32                	jne    47b <main+0x45f>
+                {
+                    for(j=0;j < LOOP_CNT;j++)
+ 449:	c7 84 24 80 00 00 00 	movl   $0x0,0x80(%esp)
+ 450:	00 00 00 00 
+ 454:	eb 13                	jmp    469 <main+0x44d>
+                    {
+                        tmp += j;
+ 456:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
+ 45d:	01 44 24 7c          	add    %eax,0x7c(%esp)
+                    printf(1, "fork() failed!\n");
+                    exit();
+                }
+                else if (rg_pid == 0) // child
+                {
+                    for(j=0;j < LOOP_CNT;j++)
+ 461:	83 84 24 80 00 00 00 	addl   $0x1,0x80(%esp)
+ 468:	01 
+ 469:	81 bc 24 80 00 00 00 	cmpl   $0xffffff,0x80(%esp)
+ 470:	ff ff ff 00 
+ 474:	7e e0                	jle    456 <main+0x43a>
+                    {
+                        tmp += j;
+                
+                    }
+                    exit();
+ 476:	e8 f5 02 00 00       	call   770 <exit>
+                }
+                else // parent
+                {
+                    if (wait() < 0)
+ 47b:	e8 f8 02 00 00       	call   778 <wait>
+ 480:	85 c0                	test   %eax,%eax
+ 482:	79 1f                	jns    4a3 <main+0x487>
+                    {
+                        printf(1, "wait() on child-%d failed!\n", i);
+ 484:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 48b:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 48f:	c7 44 24 04 1b 0f 00 	movl   $0xf1b,0x4(%esp)
+ 496:	00 
+ 497:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 49e:	e8 72 04 00 00       	call   915 <printf>
+                    }
+                }
+            }
+        }
+
+        if (wait() < 0)
+ 4a3:	e8 d0 02 00 00       	call   778 <wait>
+ 4a8:	85 c0                	test   %eax,%eax
+ 4aa:	79 1f                	jns    4cb <main+0x4af>
+        {
+            printf(1, "wait() on child-%d failed!\n", i);
+ 4ac:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
+ 4b3:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 4b7:	c7 44 24 04 1b 0f 00 	movl   $0xf1b,0x4(%esp)
+ 4be:	00 
+ 4bf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 4c6:	e8 4a 04 00 00       	call   915 <printf>
+        }
+i++;
+ 4cb:	83 84 24 84 00 00 00 	addl   $0x1,0x84(%esp)
+ 4d2:	01 
+       write(pipe_fd[i][1], "A", 1); // start child-i
+	i++;
+    }
+    #endif
+	i=0;
+    while(i < CHILD_COUNT)
+ 4d3:	83 bc 24 84 00 00 00 	cmpl   $0x5,0x84(%esp)
+ 4da:	05 
+ 4db:	0f 8e 14 ff ff ff    	jle    3f5 <main+0x3d9>
+            printf(1, "wait() on child-%d failed!\n", i);
+        }
+i++;
+    }
+
+    enable_sched_trace(0);
+ 4e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 4e8:	e8 23 03 00 00       	call   810 <enable_sched_trace>
+
+    printf(1, "\n");
+ 4ed:	c7 44 24 04 37 0f 00 	movl   $0xf37,0x4(%esp)
+ 4f4:	00 
+ 4f5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 4fc:	e8 14 04 00 00       	call   915 <printf>
+
+    exit();
+ 501:	e8 6a 02 00 00       	call   770 <exit>
+ 506:	90                   	nop
+ 507:	90                   	nop
+
+00000508 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 508:	55                   	push   %ebp
+ 509:	89 e5                	mov    %esp,%ebp
+ 50b:	57                   	push   %edi
+ 50c:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 50d:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 510:	8b 55 10             	mov    0x10(%ebp),%edx
+ 513:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 516:	89 cb                	mov    %ecx,%ebx
+ 518:	89 df                	mov    %ebx,%edi
+ 51a:	89 d1                	mov    %edx,%ecx
+ 51c:	fc                   	cld    
+ 51d:	f3 aa                	rep stos %al,%es:(%edi)
+ 51f:	89 ca                	mov    %ecx,%edx
+ 521:	89 fb                	mov    %edi,%ebx
+ 523:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 526:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 529:	5b                   	pop    %ebx
+ 52a:	5f                   	pop    %edi
+ 52b:	5d                   	pop    %ebp
+ 52c:	c3                   	ret    
+
+0000052d <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 52d:	55                   	push   %ebp
+ 52e:	89 e5                	mov    %esp,%ebp
+ 530:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 533:	8b 45 08             	mov    0x8(%ebp),%eax
+ 536:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 539:	90                   	nop
+ 53a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 53d:	0f b6 10             	movzbl (%eax),%edx
+ 540:	8b 45 08             	mov    0x8(%ebp),%eax
+ 543:	88 10                	mov    %dl,(%eax)
+ 545:	8b 45 08             	mov    0x8(%ebp),%eax
+ 548:	0f b6 00             	movzbl (%eax),%eax
+ 54b:	84 c0                	test   %al,%al
+ 54d:	0f 95 c0             	setne  %al
+ 550:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 554:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 558:	84 c0                	test   %al,%al
+ 55a:	75 de                	jne    53a <strcpy+0xd>
+    ;
+  return os;
+ 55c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 55f:	c9                   	leave  
+ 560:	c3                   	ret    
+
+00000561 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 561:	55                   	push   %ebp
+ 562:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 564:	eb 08                	jmp    56e <strcmp+0xd>
+    p++, q++;
+ 566:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 56a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 56e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 571:	0f b6 00             	movzbl (%eax),%eax
+ 574:	84 c0                	test   %al,%al
+ 576:	74 10                	je     588 <strcmp+0x27>
+ 578:	8b 45 08             	mov    0x8(%ebp),%eax
+ 57b:	0f b6 10             	movzbl (%eax),%edx
+ 57e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 581:	0f b6 00             	movzbl (%eax),%eax
+ 584:	38 c2                	cmp    %al,%dl
+ 586:	74 de                	je     566 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 588:	8b 45 08             	mov    0x8(%ebp),%eax
+ 58b:	0f b6 00             	movzbl (%eax),%eax
+ 58e:	0f b6 d0             	movzbl %al,%edx
+ 591:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 594:	0f b6 00             	movzbl (%eax),%eax
+ 597:	0f b6 c0             	movzbl %al,%eax
+ 59a:	89 d1                	mov    %edx,%ecx
+ 59c:	29 c1                	sub    %eax,%ecx
+ 59e:	89 c8                	mov    %ecx,%eax
+}
+ 5a0:	5d                   	pop    %ebp
+ 5a1:	c3                   	ret    
+
+000005a2 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 5a2:	55                   	push   %ebp
+ 5a3:	89 e5                	mov    %esp,%ebp
+ 5a5:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 5a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 5af:	eb 04                	jmp    5b5 <strlen+0x13>
+ 5b1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 5b5:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 5b8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5bb:	01 d0                	add    %edx,%eax
+ 5bd:	0f b6 00             	movzbl (%eax),%eax
+ 5c0:	84 c0                	test   %al,%al
+ 5c2:	75 ed                	jne    5b1 <strlen+0xf>
+    ;
+  return n;
+ 5c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 5c7:	c9                   	leave  
+ 5c8:	c3                   	ret    
+
+000005c9 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 5c9:	55                   	push   %ebp
+ 5ca:	89 e5                	mov    %esp,%ebp
+ 5cc:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 5cf:	8b 45 10             	mov    0x10(%ebp),%eax
+ 5d2:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 5d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 5d9:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5dd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5e0:	89 04 24             	mov    %eax,(%esp)
+ 5e3:	e8 20 ff ff ff       	call   508 <stosb>
+  return dst;
+ 5e8:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5eb:	c9                   	leave  
+ 5ec:	c3                   	ret    
+
+000005ed <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 5ed:	55                   	push   %ebp
+ 5ee:	89 e5                	mov    %esp,%ebp
+ 5f0:	83 ec 04             	sub    $0x4,%esp
+ 5f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 5f6:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 5f9:	eb 14                	jmp    60f <strchr+0x22>
+    if(*s == c)
+ 5fb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5fe:	0f b6 00             	movzbl (%eax),%eax
+ 601:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 604:	75 05                	jne    60b <strchr+0x1e>
+      return (char*)s;
+ 606:	8b 45 08             	mov    0x8(%ebp),%eax
+ 609:	eb 13                	jmp    61e <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 60b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 60f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 612:	0f b6 00             	movzbl (%eax),%eax
+ 615:	84 c0                	test   %al,%al
+ 617:	75 e2                	jne    5fb <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 619:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 61e:	c9                   	leave  
+ 61f:	c3                   	ret    
+
+00000620 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 620:	55                   	push   %ebp
+ 621:	89 e5                	mov    %esp,%ebp
+ 623:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 626:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 62d:	eb 46                	jmp    675 <gets+0x55>
+    cc = read(0, &c, 1);
+ 62f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 636:	00 
+ 637:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 63a:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 63e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 645:	e8 3e 01 00 00       	call   788 <read>
+ 64a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 64d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 651:	7e 2f                	jle    682 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 653:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 656:	8b 45 08             	mov    0x8(%ebp),%eax
+ 659:	01 c2                	add    %eax,%edx
+ 65b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 65f:	88 02                	mov    %al,(%edx)
+ 661:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 665:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 669:	3c 0a                	cmp    $0xa,%al
+ 66b:	74 16                	je     683 <gets+0x63>
+ 66d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 671:	3c 0d                	cmp    $0xd,%al
+ 673:	74 0e                	je     683 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 675:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 678:	83 c0 01             	add    $0x1,%eax
+ 67b:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 67e:	7c af                	jl     62f <gets+0xf>
+ 680:	eb 01                	jmp    683 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 682:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 683:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 686:	8b 45 08             	mov    0x8(%ebp),%eax
+ 689:	01 d0                	add    %edx,%eax
+ 68b:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 68e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 691:	c9                   	leave  
+ 692:	c3                   	ret    
+
+00000693 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 693:	55                   	push   %ebp
+ 694:	89 e5                	mov    %esp,%ebp
+ 696:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 699:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 6a0:	00 
+ 6a1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6a4:	89 04 24             	mov    %eax,(%esp)
+ 6a7:	e8 04 01 00 00       	call   7b0 <open>
+ 6ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 6af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 6b3:	79 07                	jns    6bc <stat+0x29>
+    return -1;
+ 6b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 6ba:	eb 23                	jmp    6df <stat+0x4c>
+  r = fstat(fd, st);
+ 6bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6bf:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6c6:	89 04 24             	mov    %eax,(%esp)
+ 6c9:	e8 fa 00 00 00       	call   7c8 <fstat>
+ 6ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 6d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6d4:	89 04 24             	mov    %eax,(%esp)
+ 6d7:	e8 bc 00 00 00       	call   798 <close>
+  return r;
+ 6dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 6df:	c9                   	leave  
+ 6e0:	c3                   	ret    
+
+000006e1 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 6e1:	55                   	push   %ebp
+ 6e2:	89 e5                	mov    %esp,%ebp
+ 6e4:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 6e7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 6ee:	eb 23                	jmp    713 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 6f0:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 6f3:	89 d0                	mov    %edx,%eax
+ 6f5:	c1 e0 02             	shl    $0x2,%eax
+ 6f8:	01 d0                	add    %edx,%eax
+ 6fa:	01 c0                	add    %eax,%eax
+ 6fc:	89 c2                	mov    %eax,%edx
+ 6fe:	8b 45 08             	mov    0x8(%ebp),%eax
+ 701:	0f b6 00             	movzbl (%eax),%eax
+ 704:	0f be c0             	movsbl %al,%eax
+ 707:	01 d0                	add    %edx,%eax
+ 709:	83 e8 30             	sub    $0x30,%eax
+ 70c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 70f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 713:	8b 45 08             	mov    0x8(%ebp),%eax
+ 716:	0f b6 00             	movzbl (%eax),%eax
+ 719:	3c 2f                	cmp    $0x2f,%al
+ 71b:	7e 0a                	jle    727 <atoi+0x46>
+ 71d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 720:	0f b6 00             	movzbl (%eax),%eax
+ 723:	3c 39                	cmp    $0x39,%al
+ 725:	7e c9                	jle    6f0 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 727:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 72a:	c9                   	leave  
+ 72b:	c3                   	ret    
+
+0000072c <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 72c:	55                   	push   %ebp
+ 72d:	89 e5                	mov    %esp,%ebp
+ 72f:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 732:	8b 45 08             	mov    0x8(%ebp),%eax
+ 735:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 738:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 73b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 73e:	eb 13                	jmp    753 <memmove+0x27>
+    *dst++ = *src++;
+ 740:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 743:	0f b6 10             	movzbl (%eax),%edx
+ 746:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 749:	88 10                	mov    %dl,(%eax)
+ 74b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 74f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 753:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 757:	0f 9f c0             	setg   %al
+ 75a:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 75e:	84 c0                	test   %al,%al
+ 760:	75 de                	jne    740 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 762:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 765:	c9                   	leave  
+ 766:	c3                   	ret    
+ 767:	90                   	nop
+
+00000768 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 768:	b8 01 00 00 00       	mov    $0x1,%eax
+ 76d:	cd 40                	int    $0x40
+ 76f:	c3                   	ret    
+
+00000770 <exit>:
+SYSCALL(exit)
+ 770:	b8 02 00 00 00       	mov    $0x2,%eax
+ 775:	cd 40                	int    $0x40
+ 777:	c3                   	ret    
+
+00000778 <wait>:
+SYSCALL(wait)
+ 778:	b8 03 00 00 00       	mov    $0x3,%eax
+ 77d:	cd 40                	int    $0x40
+ 77f:	c3                   	ret    
+
+00000780 <pipe>:
+SYSCALL(pipe)
+ 780:	b8 04 00 00 00       	mov    $0x4,%eax
+ 785:	cd 40                	int    $0x40
+ 787:	c3                   	ret    
+
+00000788 <read>:
+SYSCALL(read)
+ 788:	b8 05 00 00 00       	mov    $0x5,%eax
+ 78d:	cd 40                	int    $0x40
+ 78f:	c3                   	ret    
+
+00000790 <write>:
+SYSCALL(write)
+ 790:	b8 10 00 00 00       	mov    $0x10,%eax
+ 795:	cd 40                	int    $0x40
+ 797:	c3                   	ret    
+
+00000798 <close>:
+SYSCALL(close)
+ 798:	b8 15 00 00 00       	mov    $0x15,%eax
+ 79d:	cd 40                	int    $0x40
+ 79f:	c3                   	ret    
+
+000007a0 <kill>:
+SYSCALL(kill)
+ 7a0:	b8 06 00 00 00       	mov    $0x6,%eax
+ 7a5:	cd 40                	int    $0x40
+ 7a7:	c3                   	ret    
+
+000007a8 <exec>:
+SYSCALL(exec)
+ 7a8:	b8 07 00 00 00       	mov    $0x7,%eax
+ 7ad:	cd 40                	int    $0x40
+ 7af:	c3                   	ret    
+
+000007b0 <open>:
+SYSCALL(open)
+ 7b0:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 7b5:	cd 40                	int    $0x40
+ 7b7:	c3                   	ret    
+
+000007b8 <mknod>:
+SYSCALL(mknod)
+ 7b8:	b8 11 00 00 00       	mov    $0x11,%eax
+ 7bd:	cd 40                	int    $0x40
+ 7bf:	c3                   	ret    
+
+000007c0 <unlink>:
+SYSCALL(unlink)
+ 7c0:	b8 12 00 00 00       	mov    $0x12,%eax
+ 7c5:	cd 40                	int    $0x40
+ 7c7:	c3                   	ret    
+
+000007c8 <fstat>:
+SYSCALL(fstat)
+ 7c8:	b8 08 00 00 00       	mov    $0x8,%eax
+ 7cd:	cd 40                	int    $0x40
+ 7cf:	c3                   	ret    
+
+000007d0 <link>:
+SYSCALL(link)
+ 7d0:	b8 13 00 00 00       	mov    $0x13,%eax
+ 7d5:	cd 40                	int    $0x40
+ 7d7:	c3                   	ret    
+
+000007d8 <mkdir>:
+SYSCALL(mkdir)
+ 7d8:	b8 14 00 00 00       	mov    $0x14,%eax
+ 7dd:	cd 40                	int    $0x40
+ 7df:	c3                   	ret    
+
+000007e0 <chdir>:
+SYSCALL(chdir)
+ 7e0:	b8 09 00 00 00       	mov    $0x9,%eax
+ 7e5:	cd 40                	int    $0x40
+ 7e7:	c3                   	ret    
+
+000007e8 <dup>:
+SYSCALL(dup)
+ 7e8:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 7ed:	cd 40                	int    $0x40
+ 7ef:	c3                   	ret    
+
+000007f0 <getpid>:
+SYSCALL(getpid)
+ 7f0:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 7f5:	cd 40                	int    $0x40
+ 7f7:	c3                   	ret    
+
+000007f8 <sbrk>:
+SYSCALL(sbrk)
+ 7f8:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 7fd:	cd 40                	int    $0x40
+ 7ff:	c3                   	ret    
+
+00000800 <sleep>:
+SYSCALL(sleep)
+ 800:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 805:	cd 40                	int    $0x40
+ 807:	c3                   	ret    
+
+00000808 <uptime>:
+SYSCALL(uptime)
+ 808:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 80d:	cd 40                	int    $0x40
+ 80f:	c3                   	ret    
+
+00000810 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 810:	b8 16 00 00 00       	mov    $0x16,%eax
+ 815:	cd 40                	int    $0x40
+ 817:	c3                   	ret    
+
+00000818 <shutdown>:
+SYSCALL(shutdown)
+ 818:	b8 17 00 00 00       	mov    $0x17,%eax
+ 81d:	cd 40                	int    $0x40
+ 81f:	c3                   	ret    
+
+00000820 <fork_winner>:
+SYSCALL(fork_winner)
+ 820:	b8 18 00 00 00       	mov    $0x18,%eax
+ 825:	cd 40                	int    $0x40
+ 827:	c3                   	ret    
+
+00000828 <set_sched>:
+SYSCALL(set_sched)
+ 828:	b8 19 00 00 00       	mov    $0x19,%eax
+ 82d:	cd 40                	int    $0x40
+ 82f:	c3                   	ret    
+
+00000830 <set_priority>:
+SYSCALL(set_priority)
+ 830:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 835:	cd 40                	int    $0x40
+ 837:	c3                   	ret    
+
+00000838 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 838:	55                   	push   %ebp
+ 839:	89 e5                	mov    %esp,%ebp
+ 83b:	83 ec 28             	sub    $0x28,%esp
+ 83e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 841:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 844:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 84b:	00 
+ 84c:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 84f:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 853:	8b 45 08             	mov    0x8(%ebp),%eax
+ 856:	89 04 24             	mov    %eax,(%esp)
+ 859:	e8 32 ff ff ff       	call   790 <write>
+}
+ 85e:	c9                   	leave  
+ 85f:	c3                   	ret    
+
+00000860 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 860:	55                   	push   %ebp
+ 861:	89 e5                	mov    %esp,%ebp
+ 863:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 866:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 86d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 871:	74 17                	je     88a <printint+0x2a>
+ 873:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 877:	79 11                	jns    88a <printint+0x2a>
+    neg = 1;
+ 879:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 880:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 883:	f7 d8                	neg    %eax
+ 885:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 888:	eb 06                	jmp    890 <printint+0x30>
+  } else {
+    x = xx;
+ 88a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 88d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 890:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 897:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 89a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 89d:	ba 00 00 00 00       	mov    $0x0,%edx
+ 8a2:	f7 f1                	div    %ecx
+ 8a4:	89 d0                	mov    %edx,%eax
+ 8a6:	0f b6 80 9c 11 00 00 	movzbl 0x119c(%eax),%eax
+ 8ad:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 8b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 8b3:	01 ca                	add    %ecx,%edx
+ 8b5:	88 02                	mov    %al,(%edx)
+ 8b7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 8bb:	8b 55 10             	mov    0x10(%ebp),%edx
+ 8be:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 8c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 8c4:	ba 00 00 00 00       	mov    $0x0,%edx
+ 8c9:	f7 75 d4             	divl   -0x2c(%ebp)
+ 8cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 8cf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 8d3:	75 c2                	jne    897 <printint+0x37>
+  if(neg)
+ 8d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 8d9:	74 2e                	je     909 <printint+0xa9>
+    buf[i++] = '-';
+ 8db:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 8de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8e1:	01 d0                	add    %edx,%eax
+ 8e3:	c6 00 2d             	movb   $0x2d,(%eax)
+ 8e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 8ea:	eb 1d                	jmp    909 <printint+0xa9>
+    putc(fd, buf[i]);
+ 8ec:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 8ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8f2:	01 d0                	add    %edx,%eax
+ 8f4:	0f b6 00             	movzbl (%eax),%eax
+ 8f7:	0f be c0             	movsbl %al,%eax
+ 8fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 8fe:	8b 45 08             	mov    0x8(%ebp),%eax
+ 901:	89 04 24             	mov    %eax,(%esp)
+ 904:	e8 2f ff ff ff       	call   838 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 909:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 90d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 911:	79 d9                	jns    8ec <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 913:	c9                   	leave  
+ 914:	c3                   	ret    
+
+00000915 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 915:	55                   	push   %ebp
+ 916:	89 e5                	mov    %esp,%ebp
+ 918:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 91b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 922:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 925:	83 c0 04             	add    $0x4,%eax
+ 928:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 92b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 932:	e9 7d 01 00 00       	jmp    ab4 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 937:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 93a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 93d:	01 d0                	add    %edx,%eax
+ 93f:	0f b6 00             	movzbl (%eax),%eax
+ 942:	0f be c0             	movsbl %al,%eax
+ 945:	25 ff 00 00 00       	and    $0xff,%eax
+ 94a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 94d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 951:	75 2c                	jne    97f <printf+0x6a>
+      if(c == '%'){
+ 953:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 957:	75 0c                	jne    965 <printf+0x50>
+        state = '%';
+ 959:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 960:	e9 4b 01 00 00       	jmp    ab0 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 965:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 968:	0f be c0             	movsbl %al,%eax
+ 96b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 96f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 972:	89 04 24             	mov    %eax,(%esp)
+ 975:	e8 be fe ff ff       	call   838 <putc>
+ 97a:	e9 31 01 00 00       	jmp    ab0 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 97f:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 983:	0f 85 27 01 00 00    	jne    ab0 <printf+0x19b>
+      if(c == 'd'){
+ 989:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 98d:	75 2d                	jne    9bc <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 98f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 992:	8b 00                	mov    (%eax),%eax
+ 994:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 99b:	00 
+ 99c:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 9a3:	00 
+ 9a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 9a8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 9ab:	89 04 24             	mov    %eax,(%esp)
+ 9ae:	e8 ad fe ff ff       	call   860 <printint>
+        ap++;
+ 9b3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 9b7:	e9 ed 00 00 00       	jmp    aa9 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 9bc:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 9c0:	74 06                	je     9c8 <printf+0xb3>
+ 9c2:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 9c6:	75 2d                	jne    9f5 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 9c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 9cb:	8b 00                	mov    (%eax),%eax
+ 9cd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 9d4:	00 
+ 9d5:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 9dc:	00 
+ 9dd:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 9e1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 9e4:	89 04 24             	mov    %eax,(%esp)
+ 9e7:	e8 74 fe ff ff       	call   860 <printint>
+        ap++;
+ 9ec:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 9f0:	e9 b4 00 00 00       	jmp    aa9 <printf+0x194>
+      } else if(c == 's'){
+ 9f5:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 9f9:	75 46                	jne    a41 <printf+0x12c>
+        s = (char*)*ap;
+ 9fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 9fe:	8b 00                	mov    (%eax),%eax
+ a00:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ a03:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ a07:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ a0b:	75 27                	jne    a34 <printf+0x11f>
+          s = "(null)";
+ a0d:	c7 45 f4 39 0f 00 00 	movl   $0xf39,-0xc(%ebp)
+        while(*s != 0){
+ a14:	eb 1e                	jmp    a34 <printf+0x11f>
+          putc(fd, *s);
+ a16:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a19:	0f b6 00             	movzbl (%eax),%eax
+ a1c:	0f be c0             	movsbl %al,%eax
+ a1f:	89 44 24 04          	mov    %eax,0x4(%esp)
+ a23:	8b 45 08             	mov    0x8(%ebp),%eax
+ a26:	89 04 24             	mov    %eax,(%esp)
+ a29:	e8 0a fe ff ff       	call   838 <putc>
+          s++;
+ a2e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ a32:	eb 01                	jmp    a35 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ a34:	90                   	nop
+ a35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a38:	0f b6 00             	movzbl (%eax),%eax
+ a3b:	84 c0                	test   %al,%al
+ a3d:	75 d7                	jne    a16 <printf+0x101>
+ a3f:	eb 68                	jmp    aa9 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ a41:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ a45:	75 1d                	jne    a64 <printf+0x14f>
+        putc(fd, *ap);
+ a47:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ a4a:	8b 00                	mov    (%eax),%eax
+ a4c:	0f be c0             	movsbl %al,%eax
+ a4f:	89 44 24 04          	mov    %eax,0x4(%esp)
+ a53:	8b 45 08             	mov    0x8(%ebp),%eax
+ a56:	89 04 24             	mov    %eax,(%esp)
+ a59:	e8 da fd ff ff       	call   838 <putc>
+        ap++;
+ a5e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ a62:	eb 45                	jmp    aa9 <printf+0x194>
+      } else if(c == '%'){
+ a64:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ a68:	75 17                	jne    a81 <printf+0x16c>
+        putc(fd, c);
+ a6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ a6d:	0f be c0             	movsbl %al,%eax
+ a70:	89 44 24 04          	mov    %eax,0x4(%esp)
+ a74:	8b 45 08             	mov    0x8(%ebp),%eax
+ a77:	89 04 24             	mov    %eax,(%esp)
+ a7a:	e8 b9 fd ff ff       	call   838 <putc>
+ a7f:	eb 28                	jmp    aa9 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ a81:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ a88:	00 
+ a89:	8b 45 08             	mov    0x8(%ebp),%eax
+ a8c:	89 04 24             	mov    %eax,(%esp)
+ a8f:	e8 a4 fd ff ff       	call   838 <putc>
+        putc(fd, c);
+ a94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ a97:	0f be c0             	movsbl %al,%eax
+ a9a:	89 44 24 04          	mov    %eax,0x4(%esp)
+ a9e:	8b 45 08             	mov    0x8(%ebp),%eax
+ aa1:	89 04 24             	mov    %eax,(%esp)
+ aa4:	e8 8f fd ff ff       	call   838 <putc>
+      }
+      state = 0;
+ aa9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ ab0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ ab4:	8b 55 0c             	mov    0xc(%ebp),%edx
+ ab7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ aba:	01 d0                	add    %edx,%eax
+ abc:	0f b6 00             	movzbl (%eax),%eax
+ abf:	84 c0                	test   %al,%al
+ ac1:	0f 85 70 fe ff ff    	jne    937 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ ac7:	c9                   	leave  
+ ac8:	c3                   	ret    
+ ac9:	90                   	nop
+ aca:	90                   	nop
+ acb:	90                   	nop
+
+00000acc <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ acc:	55                   	push   %ebp
+ acd:	89 e5                	mov    %esp,%ebp
+ acf:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ ad2:	8b 45 08             	mov    0x8(%ebp),%eax
+ ad5:	83 e8 08             	sub    $0x8,%eax
+ ad8:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ adb:	a1 b8 11 00 00       	mov    0x11b8,%eax
+ ae0:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ ae3:	eb 24                	jmp    b09 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ ae5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ ae8:	8b 00                	mov    (%eax),%eax
+ aea:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ aed:	77 12                	ja     b01 <free+0x35>
+ aef:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ af2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ af5:	77 24                	ja     b1b <free+0x4f>
+ af7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ afa:	8b 00                	mov    (%eax),%eax
+ afc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ aff:	77 1a                	ja     b1b <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ b01:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b04:	8b 00                	mov    (%eax),%eax
+ b06:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ b09:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b0c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ b0f:	76 d4                	jbe    ae5 <free+0x19>
+ b11:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b14:	8b 00                	mov    (%eax),%eax
+ b16:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ b19:	76 ca                	jbe    ae5 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ b1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b1e:	8b 40 04             	mov    0x4(%eax),%eax
+ b21:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ b28:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b2b:	01 c2                	add    %eax,%edx
+ b2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b30:	8b 00                	mov    (%eax),%eax
+ b32:	39 c2                	cmp    %eax,%edx
+ b34:	75 24                	jne    b5a <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ b36:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b39:	8b 50 04             	mov    0x4(%eax),%edx
+ b3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b3f:	8b 00                	mov    (%eax),%eax
+ b41:	8b 40 04             	mov    0x4(%eax),%eax
+ b44:	01 c2                	add    %eax,%edx
+ b46:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b49:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ b4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b4f:	8b 00                	mov    (%eax),%eax
+ b51:	8b 10                	mov    (%eax),%edx
+ b53:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b56:	89 10                	mov    %edx,(%eax)
+ b58:	eb 0a                	jmp    b64 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ b5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b5d:	8b 10                	mov    (%eax),%edx
+ b5f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b62:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ b64:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b67:	8b 40 04             	mov    0x4(%eax),%eax
+ b6a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ b71:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b74:	01 d0                	add    %edx,%eax
+ b76:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ b79:	75 20                	jne    b9b <free+0xcf>
+    p->s.size += bp->s.size;
+ b7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b7e:	8b 50 04             	mov    0x4(%eax),%edx
+ b81:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b84:	8b 40 04             	mov    0x4(%eax),%eax
+ b87:	01 c2                	add    %eax,%edx
+ b89:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b8c:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ b8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ b92:	8b 10                	mov    (%eax),%edx
+ b94:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b97:	89 10                	mov    %edx,(%eax)
+ b99:	eb 08                	jmp    ba3 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ b9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ b9e:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ ba1:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ ba3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ ba6:	a3 b8 11 00 00       	mov    %eax,0x11b8
+}
+ bab:	c9                   	leave  
+ bac:	c3                   	ret    
+
+00000bad <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ bad:	55                   	push   %ebp
+ bae:	89 e5                	mov    %esp,%ebp
+ bb0:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ bb3:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ bba:	77 07                	ja     bc3 <morecore+0x16>
+    nu = 4096;
+ bbc:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ bc3:	8b 45 08             	mov    0x8(%ebp),%eax
+ bc6:	c1 e0 03             	shl    $0x3,%eax
+ bc9:	89 04 24             	mov    %eax,(%esp)
+ bcc:	e8 27 fc ff ff       	call   7f8 <sbrk>
+ bd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ bd4:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ bd8:	75 07                	jne    be1 <morecore+0x34>
+    return 0;
+ bda:	b8 00 00 00 00       	mov    $0x0,%eax
+ bdf:	eb 22                	jmp    c03 <morecore+0x56>
+  hp = (Header*)p;
+ be1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ be4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ be7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ bea:	8b 55 08             	mov    0x8(%ebp),%edx
+ bed:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ bf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ bf3:	83 c0 08             	add    $0x8,%eax
+ bf6:	89 04 24             	mov    %eax,(%esp)
+ bf9:	e8 ce fe ff ff       	call   acc <free>
+  return freep;
+ bfe:	a1 b8 11 00 00       	mov    0x11b8,%eax
+}
+ c03:	c9                   	leave  
+ c04:	c3                   	ret    
+
+00000c05 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ c05:	55                   	push   %ebp
+ c06:	89 e5                	mov    %esp,%ebp
+ c08:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ c0b:	8b 45 08             	mov    0x8(%ebp),%eax
+ c0e:	83 c0 07             	add    $0x7,%eax
+ c11:	c1 e8 03             	shr    $0x3,%eax
+ c14:	83 c0 01             	add    $0x1,%eax
+ c17:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ c1a:	a1 b8 11 00 00       	mov    0x11b8,%eax
+ c1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ c22:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ c26:	75 23                	jne    c4b <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ c28:	c7 45 f0 b0 11 00 00 	movl   $0x11b0,-0x10(%ebp)
+ c2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ c32:	a3 b8 11 00 00       	mov    %eax,0x11b8
+ c37:	a1 b8 11 00 00       	mov    0x11b8,%eax
+ c3c:	a3 b0 11 00 00       	mov    %eax,0x11b0
+    base.s.size = 0;
+ c41:	c7 05 b4 11 00 00 00 	movl   $0x0,0x11b4
+ c48:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ c4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ c4e:	8b 00                	mov    (%eax),%eax
+ c50:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c56:	8b 40 04             	mov    0x4(%eax),%eax
+ c59:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ c5c:	72 4d                	jb     cab <malloc+0xa6>
+      if(p->s.size == nunits)
+ c5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c61:	8b 40 04             	mov    0x4(%eax),%eax
+ c64:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ c67:	75 0c                	jne    c75 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c6c:	8b 10                	mov    (%eax),%edx
+ c6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ c71:	89 10                	mov    %edx,(%eax)
+ c73:	eb 26                	jmp    c9b <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c78:	8b 40 04             	mov    0x4(%eax),%eax
+ c7b:	89 c2                	mov    %eax,%edx
+ c7d:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ c80:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c83:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ c86:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c89:	8b 40 04             	mov    0x4(%eax),%eax
+ c8c:	c1 e0 03             	shl    $0x3,%eax
+ c8f:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ c95:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ c98:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ c9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ c9e:	a3 b8 11 00 00       	mov    %eax,0x11b8
+      return (void*)(p + 1);
+ ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ca6:	83 c0 08             	add    $0x8,%eax
+ ca9:	eb 38                	jmp    ce3 <malloc+0xde>
+    }
+    if(p == freep)
+ cab:	a1 b8 11 00 00       	mov    0x11b8,%eax
+ cb0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ cb3:	75 1b                	jne    cd0 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ cb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ cb8:	89 04 24             	mov    %eax,(%esp)
+ cbb:	e8 ed fe ff ff       	call   bad <morecore>
+ cc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ cc7:	75 07                	jne    cd0 <malloc+0xcb>
+        return 0;
+ cc9:	b8 00 00 00 00       	mov    $0x0,%eax
+ cce:	eb 13                	jmp    ce3 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ cd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ cd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ cd9:	8b 00                	mov    (%eax),%eax
+ cdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ cde:	e9 70 ff ff ff       	jmp    c53 <malloc+0x4e>
+}
+ ce3:	c9                   	leave  
+ ce4:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/proj1_schdtest.c cs550-16s-proj1-working/proj1_schdtest.c
--- cs550-16s-proj1-base/proj1_schdtest.c	2016-02-15 22:48:35.000000000 -0500
+++ cs550-16s-proj1-working/proj1_schdtest.c	2016-03-04 14:54:51.000000000 -0500
@@ -1,60 +1,197 @@
 #include "types.h"
 #include "user.h"
 
-#define LOOP_CNT 0x01000000
+/* CS550 ATTENTION: to ensure correct compilation of the base code, 
+   stub functions for the system call user space wrapper functions are provided. 
+   REMEMBER to disable the stub functions (by commenting the following macro) to 
+   allow your implementation to work properly. */
 
-void do_child(void)
-{
-    int cnt = 0;
-    int tmp = 0;
+#define CHILD_COUNT  6
+#define SLEEP_TICKS  30
 
-    while(cnt < LOOP_CNT)
-    {
-        tmp += cnt;
-        cnt ++;
-    }
+#define LOOP_CNT 0x01000000
 
-    exit();
+void usage(void)
+{
+    printf(1, "Usage: proj1_schdtest scheduler_type [with_rg_proc] \n"
+              "\tscheduler_type:\n"
+              "\t\t0: Use the default xv6 scheduler\n"
+              "\t\t1: Use the priority-based scheduler\n"
+              "\twith_rg_proc (used with priority-based scheduler):\n"
+              "\t\t0: Without runtime-generated process\n"
+              "\t\t1: With runtime-generated process\n");
 }
 
-void example_test_code()
+int
+main(int argc, char *argv[])
 {
-    int pid = 0;
+    int scheduler = 0, with_rg_proc = 0;
+    int i = 0, j = 0;
+    int tmp = 0;
+    struct {
+        int pid;
+        int priority;
+    } pa[CHILD_COUNT];
+    int rg_pid = 0;
+    int pipe_fd[CHILD_COUNT][2];
+    int c = 0;
 
-    pid = fork();
-    if (pid < 0)
+    if (argc < 2)
     {
-        printf(1, "fork() failed!\n");
+        usage();
         exit();
     }
-    else if (pid == 0) // child
+
+    printf(1, "==============\n");
+
+    if (argv[1][0] == '0')
     {
-        do_child();
+        scheduler = 0;
+        printf(1, "Using the default xv6 scheduler \n");
     }
-    else // parent
+    else
     {
-       if (wait() < 0)
-       {
-            printf(1, "wait() failed!\n");
-       }
+        scheduler = 1;
+        printf(1, "Using the priority based scheduler, ");
+
+        if (argc < 3)
+        {
+            usage();
+            exit();
+        }
+
+        if (argv[2][0] == '0')
+        {
+            with_rg_proc = 0;
+            printf(1, "without runtime-generated process\n");
+        }
+        else
+        {
+            with_rg_proc = 1;
+            printf(1, "with runtime-generated process\n");
+        }
     }
-	
-	printf(1, "\n");
-}
 
-int
-main(int argc, char *argv[])
-{
-    enable_sched_trace(1);
+    printf(1, "--------------\n");
 
-    /* ---------------- start: add your test code ------------------- */
+    set_sched(scheduler);
+    i = 0;	
+    while(i < CHILD_COUNT)
+    {
+        if (pipe(pipe_fd[i]) < 0)
+        {
+            printf(1, "pipe() failed!\n");
+            exit();
+        }
+
+        pa[i].pid = fork();
+        if (pa[i].pid < 0)
+        {
+            printf(1, "fork() failed!\n");
+            exit();
+        }
+        else if (pa[i].pid == 0) // child
+        {
+            #if 1
+            close(pipe_fd[i][1]); // close the write end
+            read(pipe_fd[i][0], &c, 1);
+            #endif
+
+            while(j < LOOP_CNT)
+            {
+                tmp += j;
+                j++;
+            }
+
+            exit();
+        }
+        else // parent
+        {
+            close(pipe_fd[i][0]); // close the read end
+
+            if (scheduler == 0) // RR
+            {
+                printf(1, "Parent: child (pid=%d) created!\n",
+                       pa[i].pid, pa[i].priority);
+            }
+            else // priority-based
+            {
+                if (i == 0 || i == 1)
+                {
+                    pa[i].priority = 1;
+                    set_priority(pa[i].pid, pa[i].priority);
+                }
+                else if (i == 4 || i == 5)
+                {
+                    pa[i].priority = 3;
+                    set_priority(pa[i].pid, pa[i].priority);
+                }
+                else
+                {
+                    pa[i].priority = 2;
+                    //Note: no need to set priority, because it should be set to 2 by the kernel by default
+                }
+
+                printf(1, "Parent: child (pid=%d priority=%d) created!\n",
+                       pa[i].pid, pa[i].priority);
+            }
+        }
+	i++;
+    }
 
-    example_test_code();
+    printf(1, "==============\n");
 
-    /* ---------------- end: add your test code ------------------- */
+    enable_sched_trace(1);
+	i = 0;
+    #if 1
+    while(i < CHILD_COUNT)
+    {
+       write(pipe_fd[i][1], "A", 1); // start child-i
+	i++;
+    }
+    #endif
+	i=0;
+    while(i < CHILD_COUNT)
+    {
+        if (with_rg_proc)
+        {
+            if (i == 4)
+            {
+                rg_pid = fork();
+                if (pa[i].pid < 0)
+                {
+                    printf(1, "fork() failed!\n");
+                    exit();
+                }
+                else if (rg_pid == 0) // child
+                {
+                    for(j=0;j < LOOP_CNT;j++)
+                    {
+                        tmp += j;
+                
+                    }
+                    exit();
+                }
+                else // parent
+                {
+                    if (wait() < 0)
+                    {
+                        printf(1, "wait() on child-%d failed!\n", i);
+                    }
+                }
+            }
+        }
+
+        if (wait() < 0)
+        {
+            printf(1, "wait() on child-%d failed!\n", i);
+        }
+i++;
+    }
 
     enable_sched_trace(0);
-    
+
+    printf(1, "\n");
+
     exit();
 }
-
diff -uNr cs550-16s-proj1-base/proj1_schdtest.d cs550-16s-proj1-working/proj1_schdtest.d
--- cs550-16s-proj1-base/proj1_schdtest.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1_schdtest.d	2016-03-04 14:54:56.000000000 -0500
@@ -0,0 +1 @@
+proj1_schdtest.o: proj1_schdtest.c types.h user.h
Binary files cs550-16s-proj1-base/proj1_schdtest.o and cs550-16s-proj1-working/proj1_schdtest.o differ
diff -uNr cs550-16s-proj1-base/proj1_schdtest.sym cs550-16s-proj1-working/proj1_schdtest.sym
--- cs550-16s-proj1-base/proj1_schdtest.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/proj1_schdtest.sym	2016-03-04 14:54:57.000000000 -0500
@@ -0,0 +1,66 @@
+00000000 .text
+00000ce8 .rodata
+00000f40 .eh_frame
+0000119c .data
+000011b0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 proj1_schdtest.c
+00000000 ulib.c
+00000508 stosb
+00000000 printf.c
+00000838 putc
+00000860 printint
+0000119c digits.1028
+00000000 umalloc.c
+000011b0 base
+000011b8 freep
+00000bad morecore
+0000052d strcpy
+00000915 printf
+0000072c memmove
+000007b8 mknod
+00000620 gets
+000007f0 getpid
+00000000 usage
+00000c05 malloc
+00000800 sleep
+00000830 set_priority
+00000780 pipe
+00000790 write
+000007c8 fstat
+000007a0 kill
+000007e0 chdir
+000007a8 exec
+00000778 wait
+00000788 read
+000007c0 unlink
+00000768 fork
+000007f8 sbrk
+00000808 uptime
+000011b0 __bss_start
+000005c9 memset
+0000001c main
+00000810 enable_sched_trace
+00000561 strcmp
+00000818 shutdown
+000007e8 dup
+00000828 set_sched
+00000693 stat
+000011b0 _edata
+000011bc _end
+000007d0 link
+00000770 exit
+000006e1 atoi
+00000820 fork_winner
+000005a2 strlen
+000007b0 open
+000005ed strchr
+000007d8 mkdir
+00000798 close
+00000acc free
diff -uNr cs550-16s-proj1-base/README cs550-16s-proj1-working/README
--- cs550-16s-proj1-base/README	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/README	2016-03-04 14:36:42.000000000 -0500
@@ -6,7 +6,7 @@
 
 xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
 to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also http://pdos.csail.mit.edu/6.828/2014/xv6.html, which
+2000)). See also http://pdos.csail.mit.edu/6.828/2012/v6.html, which
 provides pointers to on-line resources for v6.
 
 xv6 borrows code from the following sources:
Binary files cs550-16s-proj1-base/_rm and cs550-16s-proj1-working/_rm differ
diff -uNr cs550-16s-proj1-base/rm.asm cs550-16s-proj1-working/rm.asm
--- cs550-16s-proj1-base/rm.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/rm.asm	2016-03-04 14:37:04.000000000 -0500
@@ -0,0 +1,1232 @@
+
+_rm:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 20             	sub    $0x20,%esp
+  int i;
+
+  if(argc < 2){
+   9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+   d:	7f 19                	jg     28 <main+0x28>
+    printf(2, "Usage: rm files...\n");
+   f:	c7 44 24 04 6d 08 00 	movl   $0x86d,0x4(%esp)
+  16:	00 
+  17:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  1e:	e8 7a 04 00 00       	call   49d <printf>
+    exit();
+  23:	e8 d0 02 00 00       	call   2f8 <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+  28:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+  2f:	00 
+  30:	eb 4f                	jmp    81 <main+0x81>
+    if(unlink(argv[i]) < 0){
+  32:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  36:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  3d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  40:	01 d0                	add    %edx,%eax
+  42:	8b 00                	mov    (%eax),%eax
+  44:	89 04 24             	mov    %eax,(%esp)
+  47:	e8 fc 02 00 00       	call   348 <unlink>
+  4c:	85 c0                	test   %eax,%eax
+  4e:	79 2c                	jns    7c <main+0x7c>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+  50:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  5b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  5e:	01 d0                	add    %edx,%eax
+  60:	8b 00                	mov    (%eax),%eax
+  62:	89 44 24 08          	mov    %eax,0x8(%esp)
+  66:	c7 44 24 04 81 08 00 	movl   $0x881,0x4(%esp)
+  6d:	00 
+  6e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  75:	e8 23 04 00 00       	call   49d <printf>
+      break;
+  7a:	eb 0e                	jmp    8a <main+0x8a>
+  if(argc < 2){
+    printf(2, "Usage: rm files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+  7c:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+  81:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+  85:	3b 45 08             	cmp    0x8(%ebp),%eax
+  88:	7c a8                	jl     32 <main+0x32>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+  8a:	e8 69 02 00 00       	call   2f8 <exit>
+  8f:	90                   	nop
+
+00000090 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  90:	55                   	push   %ebp
+  91:	89 e5                	mov    %esp,%ebp
+  93:	57                   	push   %edi
+  94:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  95:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  98:	8b 55 10             	mov    0x10(%ebp),%edx
+  9b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  9e:	89 cb                	mov    %ecx,%ebx
+  a0:	89 df                	mov    %ebx,%edi
+  a2:	89 d1                	mov    %edx,%ecx
+  a4:	fc                   	cld    
+  a5:	f3 aa                	rep stos %al,%es:(%edi)
+  a7:	89 ca                	mov    %ecx,%edx
+  a9:	89 fb                	mov    %edi,%ebx
+  ab:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  ae:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  b1:	5b                   	pop    %ebx
+  b2:	5f                   	pop    %edi
+  b3:	5d                   	pop    %ebp
+  b4:	c3                   	ret    
+
+000000b5 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  b5:	55                   	push   %ebp
+  b6:	89 e5                	mov    %esp,%ebp
+  b8:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  bb:	8b 45 08             	mov    0x8(%ebp),%eax
+  be:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  c1:	90                   	nop
+  c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  c5:	0f b6 10             	movzbl (%eax),%edx
+  c8:	8b 45 08             	mov    0x8(%ebp),%eax
+  cb:	88 10                	mov    %dl,(%eax)
+  cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  d0:	0f b6 00             	movzbl (%eax),%eax
+  d3:	84 c0                	test   %al,%al
+  d5:	0f 95 c0             	setne  %al
+  d8:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  dc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  e0:	84 c0                	test   %al,%al
+  e2:	75 de                	jne    c2 <strcpy+0xd>
+    ;
+  return os;
+  e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  e7:	c9                   	leave  
+  e8:	c3                   	ret    
+
+000000e9 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  e9:	55                   	push   %ebp
+  ea:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  ec:	eb 08                	jmp    f6 <strcmp+0xd>
+    p++, q++;
+  ee:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  f2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  f6:	8b 45 08             	mov    0x8(%ebp),%eax
+  f9:	0f b6 00             	movzbl (%eax),%eax
+  fc:	84 c0                	test   %al,%al
+  fe:	74 10                	je     110 <strcmp+0x27>
+ 100:	8b 45 08             	mov    0x8(%ebp),%eax
+ 103:	0f b6 10             	movzbl (%eax),%edx
+ 106:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 109:	0f b6 00             	movzbl (%eax),%eax
+ 10c:	38 c2                	cmp    %al,%dl
+ 10e:	74 de                	je     ee <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 110:	8b 45 08             	mov    0x8(%ebp),%eax
+ 113:	0f b6 00             	movzbl (%eax),%eax
+ 116:	0f b6 d0             	movzbl %al,%edx
+ 119:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 11c:	0f b6 00             	movzbl (%eax),%eax
+ 11f:	0f b6 c0             	movzbl %al,%eax
+ 122:	89 d1                	mov    %edx,%ecx
+ 124:	29 c1                	sub    %eax,%ecx
+ 126:	89 c8                	mov    %ecx,%eax
+}
+ 128:	5d                   	pop    %ebp
+ 129:	c3                   	ret    
+
+0000012a <strlen>:
+
+uint
+strlen(char *s)
+{
+ 12a:	55                   	push   %ebp
+ 12b:	89 e5                	mov    %esp,%ebp
+ 12d:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 130:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 137:	eb 04                	jmp    13d <strlen+0x13>
+ 139:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 13d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 140:	8b 45 08             	mov    0x8(%ebp),%eax
+ 143:	01 d0                	add    %edx,%eax
+ 145:	0f b6 00             	movzbl (%eax),%eax
+ 148:	84 c0                	test   %al,%al
+ 14a:	75 ed                	jne    139 <strlen+0xf>
+    ;
+  return n;
+ 14c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 14f:	c9                   	leave  
+ 150:	c3                   	ret    
+
+00000151 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 151:	55                   	push   %ebp
+ 152:	89 e5                	mov    %esp,%ebp
+ 154:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 157:	8b 45 10             	mov    0x10(%ebp),%eax
+ 15a:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 15e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 161:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 165:	8b 45 08             	mov    0x8(%ebp),%eax
+ 168:	89 04 24             	mov    %eax,(%esp)
+ 16b:	e8 20 ff ff ff       	call   90 <stosb>
+  return dst;
+ 170:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 173:	c9                   	leave  
+ 174:	c3                   	ret    
+
+00000175 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 175:	55                   	push   %ebp
+ 176:	89 e5                	mov    %esp,%ebp
+ 178:	83 ec 04             	sub    $0x4,%esp
+ 17b:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 17e:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 181:	eb 14                	jmp    197 <strchr+0x22>
+    if(*s == c)
+ 183:	8b 45 08             	mov    0x8(%ebp),%eax
+ 186:	0f b6 00             	movzbl (%eax),%eax
+ 189:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 18c:	75 05                	jne    193 <strchr+0x1e>
+      return (char*)s;
+ 18e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 191:	eb 13                	jmp    1a6 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 193:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 197:	8b 45 08             	mov    0x8(%ebp),%eax
+ 19a:	0f b6 00             	movzbl (%eax),%eax
+ 19d:	84 c0                	test   %al,%al
+ 19f:	75 e2                	jne    183 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 1a1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 1a6:	c9                   	leave  
+ 1a7:	c3                   	ret    
+
+000001a8 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1a8:	55                   	push   %ebp
+ 1a9:	89 e5                	mov    %esp,%ebp
+ 1ab:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1b5:	eb 46                	jmp    1fd <gets+0x55>
+    cc = read(0, &c, 1);
+ 1b7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 1be:	00 
+ 1bf:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1c2:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1c6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 1cd:	e8 3e 01 00 00       	call   310 <read>
+ 1d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1d9:	7e 2f                	jle    20a <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1db:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1e1:	01 c2                	add    %eax,%edx
+ 1e3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1e7:	88 02                	mov    %al,(%edx)
+ 1e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 1ed:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1f1:	3c 0a                	cmp    $0xa,%al
+ 1f3:	74 16                	je     20b <gets+0x63>
+ 1f5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1f9:	3c 0d                	cmp    $0xd,%al
+ 1fb:	74 0e                	je     20b <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 200:	83 c0 01             	add    $0x1,%eax
+ 203:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 206:	7c af                	jl     1b7 <gets+0xf>
+ 208:	eb 01                	jmp    20b <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 20a:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 20b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 20e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 211:	01 d0                	add    %edx,%eax
+ 213:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 216:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 219:	c9                   	leave  
+ 21a:	c3                   	ret    
+
+0000021b <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 21b:	55                   	push   %ebp
+ 21c:	89 e5                	mov    %esp,%ebp
+ 21e:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 221:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 228:	00 
+ 229:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22c:	89 04 24             	mov    %eax,(%esp)
+ 22f:	e8 04 01 00 00       	call   338 <open>
+ 234:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 237:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 23b:	79 07                	jns    244 <stat+0x29>
+    return -1;
+ 23d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 242:	eb 23                	jmp    267 <stat+0x4c>
+  r = fstat(fd, st);
+ 244:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 247:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 24b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 24e:	89 04 24             	mov    %eax,(%esp)
+ 251:	e8 fa 00 00 00       	call   350 <fstat>
+ 256:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 259:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 25c:	89 04 24             	mov    %eax,(%esp)
+ 25f:	e8 bc 00 00 00       	call   320 <close>
+  return r;
+ 264:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 267:	c9                   	leave  
+ 268:	c3                   	ret    
+
+00000269 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 269:	55                   	push   %ebp
+ 26a:	89 e5                	mov    %esp,%ebp
+ 26c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 26f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 276:	eb 23                	jmp    29b <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 278:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 27b:	89 d0                	mov    %edx,%eax
+ 27d:	c1 e0 02             	shl    $0x2,%eax
+ 280:	01 d0                	add    %edx,%eax
+ 282:	01 c0                	add    %eax,%eax
+ 284:	89 c2                	mov    %eax,%edx
+ 286:	8b 45 08             	mov    0x8(%ebp),%eax
+ 289:	0f b6 00             	movzbl (%eax),%eax
+ 28c:	0f be c0             	movsbl %al,%eax
+ 28f:	01 d0                	add    %edx,%eax
+ 291:	83 e8 30             	sub    $0x30,%eax
+ 294:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 297:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 29b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29e:	0f b6 00             	movzbl (%eax),%eax
+ 2a1:	3c 2f                	cmp    $0x2f,%al
+ 2a3:	7e 0a                	jle    2af <atoi+0x46>
+ 2a5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2a8:	0f b6 00             	movzbl (%eax),%eax
+ 2ab:	3c 39                	cmp    $0x39,%al
+ 2ad:	7e c9                	jle    278 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 2af:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2b2:	c9                   	leave  
+ 2b3:	c3                   	ret    
+
+000002b4 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 2ba:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2c3:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2c6:	eb 13                	jmp    2db <memmove+0x27>
+    *dst++ = *src++;
+ 2c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 2cb:	0f b6 10             	movzbl (%eax),%edx
+ 2ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2d1:	88 10                	mov    %dl,(%eax)
+ 2d3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 2d7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 2df:	0f 9f c0             	setg   %al
+ 2e2:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 2e6:	84 c0                	test   %al,%al
+ 2e8:	75 de                	jne    2c8 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 2ea:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2ed:	c9                   	leave  
+ 2ee:	c3                   	ret    
+ 2ef:	90                   	nop
+
+000002f0 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2f0:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2f5:	cd 40                	int    $0x40
+ 2f7:	c3                   	ret    
+
+000002f8 <exit>:
+SYSCALL(exit)
+ 2f8:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2fd:	cd 40                	int    $0x40
+ 2ff:	c3                   	ret    
+
+00000300 <wait>:
+SYSCALL(wait)
+ 300:	b8 03 00 00 00       	mov    $0x3,%eax
+ 305:	cd 40                	int    $0x40
+ 307:	c3                   	ret    
+
+00000308 <pipe>:
+SYSCALL(pipe)
+ 308:	b8 04 00 00 00       	mov    $0x4,%eax
+ 30d:	cd 40                	int    $0x40
+ 30f:	c3                   	ret    
+
+00000310 <read>:
+SYSCALL(read)
+ 310:	b8 05 00 00 00       	mov    $0x5,%eax
+ 315:	cd 40                	int    $0x40
+ 317:	c3                   	ret    
+
+00000318 <write>:
+SYSCALL(write)
+ 318:	b8 10 00 00 00       	mov    $0x10,%eax
+ 31d:	cd 40                	int    $0x40
+ 31f:	c3                   	ret    
+
+00000320 <close>:
+SYSCALL(close)
+ 320:	b8 15 00 00 00       	mov    $0x15,%eax
+ 325:	cd 40                	int    $0x40
+ 327:	c3                   	ret    
+
+00000328 <kill>:
+SYSCALL(kill)
+ 328:	b8 06 00 00 00       	mov    $0x6,%eax
+ 32d:	cd 40                	int    $0x40
+ 32f:	c3                   	ret    
+
+00000330 <exec>:
+SYSCALL(exec)
+ 330:	b8 07 00 00 00       	mov    $0x7,%eax
+ 335:	cd 40                	int    $0x40
+ 337:	c3                   	ret    
+
+00000338 <open>:
+SYSCALL(open)
+ 338:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 33d:	cd 40                	int    $0x40
+ 33f:	c3                   	ret    
+
+00000340 <mknod>:
+SYSCALL(mknod)
+ 340:	b8 11 00 00 00       	mov    $0x11,%eax
+ 345:	cd 40                	int    $0x40
+ 347:	c3                   	ret    
+
+00000348 <unlink>:
+SYSCALL(unlink)
+ 348:	b8 12 00 00 00       	mov    $0x12,%eax
+ 34d:	cd 40                	int    $0x40
+ 34f:	c3                   	ret    
+
+00000350 <fstat>:
+SYSCALL(fstat)
+ 350:	b8 08 00 00 00       	mov    $0x8,%eax
+ 355:	cd 40                	int    $0x40
+ 357:	c3                   	ret    
+
+00000358 <link>:
+SYSCALL(link)
+ 358:	b8 13 00 00 00       	mov    $0x13,%eax
+ 35d:	cd 40                	int    $0x40
+ 35f:	c3                   	ret    
+
+00000360 <mkdir>:
+SYSCALL(mkdir)
+ 360:	b8 14 00 00 00       	mov    $0x14,%eax
+ 365:	cd 40                	int    $0x40
+ 367:	c3                   	ret    
+
+00000368 <chdir>:
+SYSCALL(chdir)
+ 368:	b8 09 00 00 00       	mov    $0x9,%eax
+ 36d:	cd 40                	int    $0x40
+ 36f:	c3                   	ret    
+
+00000370 <dup>:
+SYSCALL(dup)
+ 370:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 375:	cd 40                	int    $0x40
+ 377:	c3                   	ret    
+
+00000378 <getpid>:
+SYSCALL(getpid)
+ 378:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 37d:	cd 40                	int    $0x40
+ 37f:	c3                   	ret    
+
+00000380 <sbrk>:
+SYSCALL(sbrk)
+ 380:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 385:	cd 40                	int    $0x40
+ 387:	c3                   	ret    
+
+00000388 <sleep>:
+SYSCALL(sleep)
+ 388:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 38d:	cd 40                	int    $0x40
+ 38f:	c3                   	ret    
+
+00000390 <uptime>:
+SYSCALL(uptime)
+ 390:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 395:	cd 40                	int    $0x40
+ 397:	c3                   	ret    
+
+00000398 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 398:	b8 16 00 00 00       	mov    $0x16,%eax
+ 39d:	cd 40                	int    $0x40
+ 39f:	c3                   	ret    
+
+000003a0 <shutdown>:
+SYSCALL(shutdown)
+ 3a0:	b8 17 00 00 00       	mov    $0x17,%eax
+ 3a5:	cd 40                	int    $0x40
+ 3a7:	c3                   	ret    
+
+000003a8 <fork_winner>:
+SYSCALL(fork_winner)
+ 3a8:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3ad:	cd 40                	int    $0x40
+ 3af:	c3                   	ret    
+
+000003b0 <set_sched>:
+SYSCALL(set_sched)
+ 3b0:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3b5:	cd 40                	int    $0x40
+ 3b7:	c3                   	ret    
+
+000003b8 <set_priority>:
+SYSCALL(set_priority)
+ 3b8:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3bd:	cd 40                	int    $0x40
+ 3bf:	c3                   	ret    
+
+000003c0 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3c0:	55                   	push   %ebp
+ 3c1:	89 e5                	mov    %esp,%ebp
+ 3c3:	83 ec 28             	sub    $0x28,%esp
+ 3c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c9:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3cc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 3d3:	00 
+ 3d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 3db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3de:	89 04 24             	mov    %eax,(%esp)
+ 3e1:	e8 32 ff ff ff       	call   318 <write>
+}
+ 3e6:	c9                   	leave  
+ 3e7:	c3                   	ret    
+
+000003e8 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3e8:	55                   	push   %ebp
+ 3e9:	89 e5                	mov    %esp,%ebp
+ 3eb:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3f5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3f9:	74 17                	je     412 <printint+0x2a>
+ 3fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3ff:	79 11                	jns    412 <printint+0x2a>
+    neg = 1;
+ 401:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 408:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 40b:	f7 d8                	neg    %eax
+ 40d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 410:	eb 06                	jmp    418 <printint+0x30>
+  } else {
+    x = xx;
+ 412:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 415:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 418:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 41f:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 422:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 425:	ba 00 00 00 00       	mov    $0x0,%edx
+ 42a:	f7 f1                	div    %ecx
+ 42c:	89 d0                	mov    %edx,%eax
+ 42e:	0f b6 80 e0 0a 00 00 	movzbl 0xae0(%eax),%eax
+ 435:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 438:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 43b:	01 ca                	add    %ecx,%edx
+ 43d:	88 02                	mov    %al,(%edx)
+ 43f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 443:	8b 55 10             	mov    0x10(%ebp),%edx
+ 446:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 449:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 44c:	ba 00 00 00 00       	mov    $0x0,%edx
+ 451:	f7 75 d4             	divl   -0x2c(%ebp)
+ 454:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 457:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 45b:	75 c2                	jne    41f <printint+0x37>
+  if(neg)
+ 45d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 461:	74 2e                	je     491 <printint+0xa9>
+    buf[i++] = '-';
+ 463:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 466:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 469:	01 d0                	add    %edx,%eax
+ 46b:	c6 00 2d             	movb   $0x2d,(%eax)
+ 46e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 472:	eb 1d                	jmp    491 <printint+0xa9>
+    putc(fd, buf[i]);
+ 474:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 477:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 47a:	01 d0                	add    %edx,%eax
+ 47c:	0f b6 00             	movzbl (%eax),%eax
+ 47f:	0f be c0             	movsbl %al,%eax
+ 482:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 486:	8b 45 08             	mov    0x8(%ebp),%eax
+ 489:	89 04 24             	mov    %eax,(%esp)
+ 48c:	e8 2f ff ff ff       	call   3c0 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 491:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 495:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 499:	79 d9                	jns    474 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 49b:	c9                   	leave  
+ 49c:	c3                   	ret    
+
+0000049d <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 49d:	55                   	push   %ebp
+ 49e:	89 e5                	mov    %esp,%ebp
+ 4a0:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 4a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4aa:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4ad:	83 c0 04             	add    $0x4,%eax
+ 4b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4ba:	e9 7d 01 00 00       	jmp    63c <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 4bf:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4c5:	01 d0                	add    %edx,%eax
+ 4c7:	0f b6 00             	movzbl (%eax),%eax
+ 4ca:	0f be c0             	movsbl %al,%eax
+ 4cd:	25 ff 00 00 00       	and    $0xff,%eax
+ 4d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4d5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4d9:	75 2c                	jne    507 <printf+0x6a>
+      if(c == '%'){
+ 4db:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4df:	75 0c                	jne    4ed <printf+0x50>
+        state = '%';
+ 4e1:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4e8:	e9 4b 01 00 00       	jmp    638 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 4ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4f0:	0f be c0             	movsbl %al,%eax
+ 4f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4f7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4fa:	89 04 24             	mov    %eax,(%esp)
+ 4fd:	e8 be fe ff ff       	call   3c0 <putc>
+ 502:	e9 31 01 00 00       	jmp    638 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 507:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 50b:	0f 85 27 01 00 00    	jne    638 <printf+0x19b>
+      if(c == 'd'){
+ 511:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 515:	75 2d                	jne    544 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 517:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 51a:	8b 00                	mov    (%eax),%eax
+ 51c:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 523:	00 
+ 524:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 52b:	00 
+ 52c:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 530:	8b 45 08             	mov    0x8(%ebp),%eax
+ 533:	89 04 24             	mov    %eax,(%esp)
+ 536:	e8 ad fe ff ff       	call   3e8 <printint>
+        ap++;
+ 53b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 53f:	e9 ed 00 00 00       	jmp    631 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 544:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 548:	74 06                	je     550 <printf+0xb3>
+ 54a:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 54e:	75 2d                	jne    57d <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 550:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 553:	8b 00                	mov    (%eax),%eax
+ 555:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 55c:	00 
+ 55d:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 564:	00 
+ 565:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 569:	8b 45 08             	mov    0x8(%ebp),%eax
+ 56c:	89 04 24             	mov    %eax,(%esp)
+ 56f:	e8 74 fe ff ff       	call   3e8 <printint>
+        ap++;
+ 574:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 578:	e9 b4 00 00 00       	jmp    631 <printf+0x194>
+      } else if(c == 's'){
+ 57d:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 581:	75 46                	jne    5c9 <printf+0x12c>
+        s = (char*)*ap;
+ 583:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 586:	8b 00                	mov    (%eax),%eax
+ 588:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 58b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 58f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 593:	75 27                	jne    5bc <printf+0x11f>
+          s = "(null)";
+ 595:	c7 45 f4 9a 08 00 00 	movl   $0x89a,-0xc(%ebp)
+        while(*s != 0){
+ 59c:	eb 1e                	jmp    5bc <printf+0x11f>
+          putc(fd, *s);
+ 59e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5a1:	0f b6 00             	movzbl (%eax),%eax
+ 5a4:	0f be c0             	movsbl %al,%eax
+ 5a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5ab:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ae:	89 04 24             	mov    %eax,(%esp)
+ 5b1:	e8 0a fe ff ff       	call   3c0 <putc>
+          s++;
+ 5b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 5ba:	eb 01                	jmp    5bd <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 5bc:	90                   	nop
+ 5bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5c0:	0f b6 00             	movzbl (%eax),%eax
+ 5c3:	84 c0                	test   %al,%al
+ 5c5:	75 d7                	jne    59e <printf+0x101>
+ 5c7:	eb 68                	jmp    631 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5c9:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5cd:	75 1d                	jne    5ec <printf+0x14f>
+        putc(fd, *ap);
+ 5cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5d2:	8b 00                	mov    (%eax),%eax
+ 5d4:	0f be c0             	movsbl %al,%eax
+ 5d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5de:	89 04 24             	mov    %eax,(%esp)
+ 5e1:	e8 da fd ff ff       	call   3c0 <putc>
+        ap++;
+ 5e6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5ea:	eb 45                	jmp    631 <printf+0x194>
+      } else if(c == '%'){
+ 5ec:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5f0:	75 17                	jne    609 <printf+0x16c>
+        putc(fd, c);
+ 5f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5f5:	0f be c0             	movsbl %al,%eax
+ 5f8:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5fc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ff:	89 04 24             	mov    %eax,(%esp)
+ 602:	e8 b9 fd ff ff       	call   3c0 <putc>
+ 607:	eb 28                	jmp    631 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 609:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 610:	00 
+ 611:	8b 45 08             	mov    0x8(%ebp),%eax
+ 614:	89 04 24             	mov    %eax,(%esp)
+ 617:	e8 a4 fd ff ff       	call   3c0 <putc>
+        putc(fd, c);
+ 61c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 61f:	0f be c0             	movsbl %al,%eax
+ 622:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 626:	8b 45 08             	mov    0x8(%ebp),%eax
+ 629:	89 04 24             	mov    %eax,(%esp)
+ 62c:	e8 8f fd ff ff       	call   3c0 <putc>
+      }
+      state = 0;
+ 631:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 638:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 63c:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 63f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 642:	01 d0                	add    %edx,%eax
+ 644:	0f b6 00             	movzbl (%eax),%eax
+ 647:	84 c0                	test   %al,%al
+ 649:	0f 85 70 fe ff ff    	jne    4bf <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 64f:	c9                   	leave  
+ 650:	c3                   	ret    
+ 651:	90                   	nop
+ 652:	90                   	nop
+ 653:	90                   	nop
+
+00000654 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 654:	55                   	push   %ebp
+ 655:	89 e5                	mov    %esp,%ebp
+ 657:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 65a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 65d:	83 e8 08             	sub    $0x8,%eax
+ 660:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 663:	a1 fc 0a 00 00       	mov    0xafc,%eax
+ 668:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 66b:	eb 24                	jmp    691 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 66d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 670:	8b 00                	mov    (%eax),%eax
+ 672:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 675:	77 12                	ja     689 <free+0x35>
+ 677:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 67a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 67d:	77 24                	ja     6a3 <free+0x4f>
+ 67f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 682:	8b 00                	mov    (%eax),%eax
+ 684:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 687:	77 1a                	ja     6a3 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 689:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 68c:	8b 00                	mov    (%eax),%eax
+ 68e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 691:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 694:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 697:	76 d4                	jbe    66d <free+0x19>
+ 699:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 69c:	8b 00                	mov    (%eax),%eax
+ 69e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 6a1:	76 ca                	jbe    66d <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 6a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6a6:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6b3:	01 c2                	add    %eax,%edx
+ 6b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b8:	8b 00                	mov    (%eax),%eax
+ 6ba:	39 c2                	cmp    %eax,%edx
+ 6bc:	75 24                	jne    6e2 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 6be:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c1:	8b 50 04             	mov    0x4(%eax),%edx
+ 6c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c7:	8b 00                	mov    (%eax),%eax
+ 6c9:	8b 40 04             	mov    0x4(%eax),%eax
+ 6cc:	01 c2                	add    %eax,%edx
+ 6ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6d1:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d7:	8b 00                	mov    (%eax),%eax
+ 6d9:	8b 10                	mov    (%eax),%edx
+ 6db:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6de:	89 10                	mov    %edx,(%eax)
+ 6e0:	eb 0a                	jmp    6ec <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e5:	8b 10                	mov    (%eax),%edx
+ 6e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ea:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ef:	8b 40 04             	mov    0x4(%eax),%eax
+ 6f2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fc:	01 d0                	add    %edx,%eax
+ 6fe:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 701:	75 20                	jne    723 <free+0xcf>
+    p->s.size += bp->s.size;
+ 703:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 706:	8b 50 04             	mov    0x4(%eax),%edx
+ 709:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 70c:	8b 40 04             	mov    0x4(%eax),%eax
+ 70f:	01 c2                	add    %eax,%edx
+ 711:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 714:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 717:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 71a:	8b 10                	mov    (%eax),%edx
+ 71c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71f:	89 10                	mov    %edx,(%eax)
+ 721:	eb 08                	jmp    72b <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 723:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 726:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 729:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 72b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 72e:	a3 fc 0a 00 00       	mov    %eax,0xafc
+}
+ 733:	c9                   	leave  
+ 734:	c3                   	ret    
+
+00000735 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 735:	55                   	push   %ebp
+ 736:	89 e5                	mov    %esp,%ebp
+ 738:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 73b:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 742:	77 07                	ja     74b <morecore+0x16>
+    nu = 4096;
+ 744:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 74b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 74e:	c1 e0 03             	shl    $0x3,%eax
+ 751:	89 04 24             	mov    %eax,(%esp)
+ 754:	e8 27 fc ff ff       	call   380 <sbrk>
+ 759:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 75c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 760:	75 07                	jne    769 <morecore+0x34>
+    return 0;
+ 762:	b8 00 00 00 00       	mov    $0x0,%eax
+ 767:	eb 22                	jmp    78b <morecore+0x56>
+  hp = (Header*)p;
+ 769:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 76c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 76f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 772:	8b 55 08             	mov    0x8(%ebp),%edx
+ 775:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 778:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 77b:	83 c0 08             	add    $0x8,%eax
+ 77e:	89 04 24             	mov    %eax,(%esp)
+ 781:	e8 ce fe ff ff       	call   654 <free>
+  return freep;
+ 786:	a1 fc 0a 00 00       	mov    0xafc,%eax
+}
+ 78b:	c9                   	leave  
+ 78c:	c3                   	ret    
+
+0000078d <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 78d:	55                   	push   %ebp
+ 78e:	89 e5                	mov    %esp,%ebp
+ 790:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 793:	8b 45 08             	mov    0x8(%ebp),%eax
+ 796:	83 c0 07             	add    $0x7,%eax
+ 799:	c1 e8 03             	shr    $0x3,%eax
+ 79c:	83 c0 01             	add    $0x1,%eax
+ 79f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 7a2:	a1 fc 0a 00 00       	mov    0xafc,%eax
+ 7a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 7ae:	75 23                	jne    7d3 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 7b0:	c7 45 f0 f4 0a 00 00 	movl   $0xaf4,-0x10(%ebp)
+ 7b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7ba:	a3 fc 0a 00 00       	mov    %eax,0xafc
+ 7bf:	a1 fc 0a 00 00       	mov    0xafc,%eax
+ 7c4:	a3 f4 0a 00 00       	mov    %eax,0xaf4
+    base.s.size = 0;
+ 7c9:	c7 05 f8 0a 00 00 00 	movl   $0x0,0xaf8
+ 7d0:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7d6:	8b 00                	mov    (%eax),%eax
+ 7d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7de:	8b 40 04             	mov    0x4(%eax),%eax
+ 7e1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7e4:	72 4d                	jb     833 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 7e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e9:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 7ef:	75 0c                	jne    7fd <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 7f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f4:	8b 10                	mov    (%eax),%edx
+ 7f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7f9:	89 10                	mov    %edx,(%eax)
+ 7fb:	eb 26                	jmp    823 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 7fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 800:	8b 40 04             	mov    0x4(%eax),%eax
+ 803:	89 c2                	mov    %eax,%edx
+ 805:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 808:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80b:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 80e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 811:	8b 40 04             	mov    0x4(%eax),%eax
+ 814:	c1 e0 03             	shl    $0x3,%eax
+ 817:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 81a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81d:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 820:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 823:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 826:	a3 fc 0a 00 00       	mov    %eax,0xafc
+      return (void*)(p + 1);
+ 82b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 82e:	83 c0 08             	add    $0x8,%eax
+ 831:	eb 38                	jmp    86b <malloc+0xde>
+    }
+    if(p == freep)
+ 833:	a1 fc 0a 00 00       	mov    0xafc,%eax
+ 838:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 83b:	75 1b                	jne    858 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 83d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 840:	89 04 24             	mov    %eax,(%esp)
+ 843:	e8 ed fe ff ff       	call   735 <morecore>
+ 848:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 84b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 84f:	75 07                	jne    858 <malloc+0xcb>
+        return 0;
+ 851:	b8 00 00 00 00       	mov    $0x0,%eax
+ 856:	eb 13                	jmp    86b <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 858:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 85b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 85e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 861:	8b 00                	mov    (%eax),%eax
+ 863:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 866:	e9 70 ff ff ff       	jmp    7db <malloc+0x4e>
+}
+ 86b:	c9                   	leave  
+ 86c:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/rm.d cs550-16s-proj1-working/rm.d
--- cs550-16s-proj1-base/rm.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/rm.d	2016-03-04 14:37:04.000000000 -0500
@@ -0,0 +1 @@
+rm.o: rm.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/rm.o and cs550-16s-proj1-working/rm.o differ
diff -uNr cs550-16s-proj1-base/rm.sym cs550-16s-proj1-working/rm.sym
--- cs550-16s-proj1-base/rm.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/rm.sym	2016-03-04 14:37:04.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+0000086d .rodata
+000008a4 .eh_frame
+00000ae0 .data
+00000af4 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 rm.c
+00000000 ulib.c
+00000090 stosb
+00000000 printf.c
+000003c0 putc
+000003e8 printint
+00000ae0 digits.1028
+00000000 umalloc.c
+00000af4 base
+00000afc freep
+00000735 morecore
+000000b5 strcpy
+0000049d printf
+000002b4 memmove
+00000340 mknod
+000001a8 gets
+00000378 getpid
+0000078d malloc
+00000388 sleep
+000003b8 set_priority
+00000308 pipe
+00000318 write
+00000350 fstat
+00000328 kill
+00000368 chdir
+00000330 exec
+00000300 wait
+00000310 read
+00000348 unlink
+000002f0 fork
+00000380 sbrk
+00000390 uptime
+00000af4 __bss_start
+00000151 memset
+00000000 main
+00000398 enable_sched_trace
+000000e9 strcmp
+000003a0 shutdown
+00000370 dup
+000003b0 set_sched
+0000021b stat
+00000af4 _edata
+00000b00 _end
+00000358 link
+000002f8 exit
+00000269 atoi
+000003a8 fork_winner
+0000012a strlen
+00000338 open
+00000175 strchr
+00000360 mkdir
+00000320 close
+00000654 free
Binary files cs550-16s-proj1-base/_sh and cs550-16s-proj1-working/_sh differ
diff -uNr cs550-16s-proj1-base/sh.asm cs550-16s-proj1-working/sh.asm
--- cs550-16s-proj1-base/sh.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/sh.asm	2016-03-04 14:37:05.000000000 -0500
@@ -0,0 +1,2716 @@
+
+_sh:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <runcmd>:
+struct cmd *parsecmd(char*);
+
+// Execute cmd.  Never returns.
+void
+runcmd(struct cmd *cmd)
+{
+       0:	55                   	push   %ebp
+       1:	89 e5                	mov    %esp,%ebp
+       3:	83 ec 38             	sub    $0x38,%esp
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+       6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+       a:	75 05                	jne    11 <runcmd+0x11>
+    exit();
+       c:	e8 53 0f 00 00       	call   f64 <exit>
+  
+  switch(cmd->type){
+      11:	8b 45 08             	mov    0x8(%ebp),%eax
+      14:	8b 00                	mov    (%eax),%eax
+      16:	83 f8 05             	cmp    $0x5,%eax
+      19:	77 09                	ja     24 <runcmd+0x24>
+      1b:	8b 04 85 08 15 00 00 	mov    0x1508(,%eax,4),%eax
+      22:	ff e0                	jmp    *%eax
+  default:
+    panic("runcmd");
+      24:	c7 04 24 dc 14 00 00 	movl   $0x14dc,(%esp)
+      2b:	e8 2a 03 00 00       	call   35a <panic>
+
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+      30:	8b 45 08             	mov    0x8(%ebp),%eax
+      33:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(ecmd->argv[0] == 0)
+      36:	8b 45 f4             	mov    -0xc(%ebp),%eax
+      39:	8b 40 04             	mov    0x4(%eax),%eax
+      3c:	85 c0                	test   %eax,%eax
+      3e:	75 05                	jne    45 <runcmd+0x45>
+      exit();
+      40:	e8 1f 0f 00 00       	call   f64 <exit>
+    exec(ecmd->argv[0], ecmd->argv);
+      45:	8b 45 f4             	mov    -0xc(%ebp),%eax
+      48:	8d 50 04             	lea    0x4(%eax),%edx
+      4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+      4e:	8b 40 04             	mov    0x4(%eax),%eax
+      51:	89 54 24 04          	mov    %edx,0x4(%esp)
+      55:	89 04 24             	mov    %eax,(%esp)
+      58:	e8 3f 0f 00 00       	call   f9c <exec>
+    printf(2, "exec %s failed\n", ecmd->argv[0]);
+      5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+      60:	8b 40 04             	mov    0x4(%eax),%eax
+      63:	89 44 24 08          	mov    %eax,0x8(%esp)
+      67:	c7 44 24 04 e3 14 00 	movl   $0x14e3,0x4(%esp)
+      6e:	00 
+      6f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+      76:	e8 8e 10 00 00       	call   1109 <printf>
+    break;
+      7b:	e9 84 01 00 00       	jmp    204 <runcmd+0x204>
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+      80:	8b 45 08             	mov    0x8(%ebp),%eax
+      83:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    close(rcmd->fd);
+      86:	8b 45 f0             	mov    -0x10(%ebp),%eax
+      89:	8b 40 14             	mov    0x14(%eax),%eax
+      8c:	89 04 24             	mov    %eax,(%esp)
+      8f:	e8 f8 0e 00 00       	call   f8c <close>
+    if(open(rcmd->file, rcmd->mode) < 0){
+      94:	8b 45 f0             	mov    -0x10(%ebp),%eax
+      97:	8b 50 10             	mov    0x10(%eax),%edx
+      9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+      9d:	8b 40 08             	mov    0x8(%eax),%eax
+      a0:	89 54 24 04          	mov    %edx,0x4(%esp)
+      a4:	89 04 24             	mov    %eax,(%esp)
+      a7:	e8 f8 0e 00 00       	call   fa4 <open>
+      ac:	85 c0                	test   %eax,%eax
+      ae:	79 23                	jns    d3 <runcmd+0xd3>
+      printf(2, "open %s failed\n", rcmd->file);
+      b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+      b3:	8b 40 08             	mov    0x8(%eax),%eax
+      b6:	89 44 24 08          	mov    %eax,0x8(%esp)
+      ba:	c7 44 24 04 f3 14 00 	movl   $0x14f3,0x4(%esp)
+      c1:	00 
+      c2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+      c9:	e8 3b 10 00 00       	call   1109 <printf>
+      exit();
+      ce:	e8 91 0e 00 00       	call   f64 <exit>
+    }
+    runcmd(rcmd->cmd);
+      d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+      d6:	8b 40 04             	mov    0x4(%eax),%eax
+      d9:	89 04 24             	mov    %eax,(%esp)
+      dc:	e8 1f ff ff ff       	call   0 <runcmd>
+    break;
+      e1:	e9 1e 01 00 00       	jmp    204 <runcmd+0x204>
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+      e6:	8b 45 08             	mov    0x8(%ebp),%eax
+      e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(fork1() == 0)
+      ec:	e8 8f 02 00 00       	call   380 <fork1>
+      f1:	85 c0                	test   %eax,%eax
+      f3:	75 0e                	jne    103 <runcmd+0x103>
+      runcmd(lcmd->left);
+      f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+      f8:	8b 40 04             	mov    0x4(%eax),%eax
+      fb:	89 04 24             	mov    %eax,(%esp)
+      fe:	e8 fd fe ff ff       	call   0 <runcmd>
+    wait();
+     103:	e8 64 0e 00 00       	call   f6c <wait>
+    runcmd(lcmd->right);
+     108:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     10b:	8b 40 08             	mov    0x8(%eax),%eax
+     10e:	89 04 24             	mov    %eax,(%esp)
+     111:	e8 ea fe ff ff       	call   0 <runcmd>
+    break;
+     116:	e9 e9 00 00 00       	jmp    204 <runcmd+0x204>
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+     11b:	8b 45 08             	mov    0x8(%ebp),%eax
+     11e:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pipe(p) < 0)
+     121:	8d 45 dc             	lea    -0x24(%ebp),%eax
+     124:	89 04 24             	mov    %eax,(%esp)
+     127:	e8 48 0e 00 00       	call   f74 <pipe>
+     12c:	85 c0                	test   %eax,%eax
+     12e:	79 0c                	jns    13c <runcmd+0x13c>
+      panic("pipe");
+     130:	c7 04 24 03 15 00 00 	movl   $0x1503,(%esp)
+     137:	e8 1e 02 00 00       	call   35a <panic>
+    if(fork1() == 0){
+     13c:	e8 3f 02 00 00       	call   380 <fork1>
+     141:	85 c0                	test   %eax,%eax
+     143:	75 3b                	jne    180 <runcmd+0x180>
+      close(1);
+     145:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     14c:	e8 3b 0e 00 00       	call   f8c <close>
+      dup(p[1]);
+     151:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     154:	89 04 24             	mov    %eax,(%esp)
+     157:	e8 80 0e 00 00       	call   fdc <dup>
+      close(p[0]);
+     15c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     15f:	89 04 24             	mov    %eax,(%esp)
+     162:	e8 25 0e 00 00       	call   f8c <close>
+      close(p[1]);
+     167:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     16a:	89 04 24             	mov    %eax,(%esp)
+     16d:	e8 1a 0e 00 00       	call   f8c <close>
+      runcmd(pcmd->left);
+     172:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     175:	8b 40 04             	mov    0x4(%eax),%eax
+     178:	89 04 24             	mov    %eax,(%esp)
+     17b:	e8 80 fe ff ff       	call   0 <runcmd>
+    }
+    if(fork1() == 0){
+     180:	e8 fb 01 00 00       	call   380 <fork1>
+     185:	85 c0                	test   %eax,%eax
+     187:	75 3b                	jne    1c4 <runcmd+0x1c4>
+      close(0);
+     189:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+     190:	e8 f7 0d 00 00       	call   f8c <close>
+      dup(p[0]);
+     195:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     198:	89 04 24             	mov    %eax,(%esp)
+     19b:	e8 3c 0e 00 00       	call   fdc <dup>
+      close(p[0]);
+     1a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     1a3:	89 04 24             	mov    %eax,(%esp)
+     1a6:	e8 e1 0d 00 00       	call   f8c <close>
+      close(p[1]);
+     1ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     1ae:	89 04 24             	mov    %eax,(%esp)
+     1b1:	e8 d6 0d 00 00       	call   f8c <close>
+      runcmd(pcmd->right);
+     1b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     1b9:	8b 40 08             	mov    0x8(%eax),%eax
+     1bc:	89 04 24             	mov    %eax,(%esp)
+     1bf:	e8 3c fe ff ff       	call   0 <runcmd>
+    }
+    close(p[0]);
+     1c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     1c7:	89 04 24             	mov    %eax,(%esp)
+     1ca:	e8 bd 0d 00 00       	call   f8c <close>
+    close(p[1]);
+     1cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     1d2:	89 04 24             	mov    %eax,(%esp)
+     1d5:	e8 b2 0d 00 00       	call   f8c <close>
+    wait();
+     1da:	e8 8d 0d 00 00       	call   f6c <wait>
+    wait();
+     1df:	e8 88 0d 00 00       	call   f6c <wait>
+    break;
+     1e4:	eb 1e                	jmp    204 <runcmd+0x204>
+    
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+     1e6:	8b 45 08             	mov    0x8(%ebp),%eax
+     1e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(fork1() == 0)
+     1ec:	e8 8f 01 00 00       	call   380 <fork1>
+     1f1:	85 c0                	test   %eax,%eax
+     1f3:	75 0e                	jne    203 <runcmd+0x203>
+      runcmd(bcmd->cmd);
+     1f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     1f8:	8b 40 04             	mov    0x4(%eax),%eax
+     1fb:	89 04 24             	mov    %eax,(%esp)
+     1fe:	e8 fd fd ff ff       	call   0 <runcmd>
+    break;
+     203:	90                   	nop
+  }
+  exit();
+     204:	e8 5b 0d 00 00       	call   f64 <exit>
+
+00000209 <getcmd>:
+}
+
+int
+getcmd(char *buf, int nbuf)
+{
+     209:	55                   	push   %ebp
+     20a:	89 e5                	mov    %esp,%ebp
+     20c:	83 ec 18             	sub    $0x18,%esp
+  printf(2, "$ ");
+     20f:	c7 44 24 04 20 15 00 	movl   $0x1520,0x4(%esp)
+     216:	00 
+     217:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+     21e:	e8 e6 0e 00 00       	call   1109 <printf>
+  memset(buf, 0, nbuf);
+     223:	8b 45 0c             	mov    0xc(%ebp),%eax
+     226:	89 44 24 08          	mov    %eax,0x8(%esp)
+     22a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     231:	00 
+     232:	8b 45 08             	mov    0x8(%ebp),%eax
+     235:	89 04 24             	mov    %eax,(%esp)
+     238:	e8 80 0b 00 00       	call   dbd <memset>
+  gets(buf, nbuf);
+     23d:	8b 45 0c             	mov    0xc(%ebp),%eax
+     240:	89 44 24 04          	mov    %eax,0x4(%esp)
+     244:	8b 45 08             	mov    0x8(%ebp),%eax
+     247:	89 04 24             	mov    %eax,(%esp)
+     24a:	e8 c5 0b 00 00       	call   e14 <gets>
+  if(buf[0] == 0) // EOF
+     24f:	8b 45 08             	mov    0x8(%ebp),%eax
+     252:	0f b6 00             	movzbl (%eax),%eax
+     255:	84 c0                	test   %al,%al
+     257:	75 07                	jne    260 <getcmd+0x57>
+    return -1;
+     259:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+     25e:	eb 05                	jmp    265 <getcmd+0x5c>
+  return 0;
+     260:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+     265:	c9                   	leave  
+     266:	c3                   	ret    
+
+00000267 <main>:
+
+int
+main(void)
+{
+     267:	55                   	push   %ebp
+     268:	89 e5                	mov    %esp,%ebp
+     26a:	83 e4 f0             	and    $0xfffffff0,%esp
+     26d:	83 ec 20             	sub    $0x20,%esp
+  static char buf[100];
+  int fd;
+  
+  // Assumes three file descriptors open.
+  while((fd = open("console", O_RDWR)) >= 0){
+     270:	eb 19                	jmp    28b <main+0x24>
+    if(fd >= 3){
+     272:	83 7c 24 1c 02       	cmpl   $0x2,0x1c(%esp)
+     277:	7e 12                	jle    28b <main+0x24>
+      close(fd);
+     279:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+     27d:	89 04 24             	mov    %eax,(%esp)
+     280:	e8 07 0d 00 00       	call   f8c <close>
+      break;
+     285:	90                   	nop
+    }
+  }
+  
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     286:	e9 ae 00 00 00       	jmp    339 <main+0xd2>
+{
+  static char buf[100];
+  int fd;
+  
+  // Assumes three file descriptors open.
+  while((fd = open("console", O_RDWR)) >= 0){
+     28b:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+     292:	00 
+     293:	c7 04 24 23 15 00 00 	movl   $0x1523,(%esp)
+     29a:	e8 05 0d 00 00       	call   fa4 <open>
+     29f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
+     2a3:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
+     2a8:	79 c8                	jns    272 <main+0xb>
+      break;
+    }
+  }
+  
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     2aa:	e9 8a 00 00 00       	jmp    339 <main+0xd2>
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+     2af:	0f b6 05 80 1a 00 00 	movzbl 0x1a80,%eax
+     2b6:	3c 63                	cmp    $0x63,%al
+     2b8:	75 5a                	jne    314 <main+0xad>
+     2ba:	0f b6 05 81 1a 00 00 	movzbl 0x1a81,%eax
+     2c1:	3c 64                	cmp    $0x64,%al
+     2c3:	75 4f                	jne    314 <main+0xad>
+     2c5:	0f b6 05 82 1a 00 00 	movzbl 0x1a82,%eax
+     2cc:	3c 20                	cmp    $0x20,%al
+     2ce:	75 44                	jne    314 <main+0xad>
+      // Clumsy but will have to do for now.
+      // Chdir has no effect on the parent if run in the child.
+      buf[strlen(buf)-1] = 0;  // chop \n
+     2d0:	c7 04 24 80 1a 00 00 	movl   $0x1a80,(%esp)
+     2d7:	e8 ba 0a 00 00       	call   d96 <strlen>
+     2dc:	83 e8 01             	sub    $0x1,%eax
+     2df:	c6 80 80 1a 00 00 00 	movb   $0x0,0x1a80(%eax)
+      if(chdir(buf+3) < 0)
+     2e6:	c7 04 24 83 1a 00 00 	movl   $0x1a83,(%esp)
+     2ed:	e8 e2 0c 00 00       	call   fd4 <chdir>
+     2f2:	85 c0                	test   %eax,%eax
+     2f4:	79 42                	jns    338 <main+0xd1>
+        printf(2, "cannot cd %s\n", buf+3);
+     2f6:	c7 44 24 08 83 1a 00 	movl   $0x1a83,0x8(%esp)
+     2fd:	00 
+     2fe:	c7 44 24 04 2b 15 00 	movl   $0x152b,0x4(%esp)
+     305:	00 
+     306:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+     30d:	e8 f7 0d 00 00       	call   1109 <printf>
+      continue;
+     312:	eb 24                	jmp    338 <main+0xd1>
+    }
+    if(fork1() == 0)
+     314:	e8 67 00 00 00       	call   380 <fork1>
+     319:	85 c0                	test   %eax,%eax
+     31b:	75 14                	jne    331 <main+0xca>
+      runcmd(parsecmd(buf));
+     31d:	c7 04 24 80 1a 00 00 	movl   $0x1a80,(%esp)
+     324:	e8 c9 03 00 00       	call   6f2 <parsecmd>
+     329:	89 04 24             	mov    %eax,(%esp)
+     32c:	e8 cf fc ff ff       	call   0 <runcmd>
+    wait();
+     331:	e8 36 0c 00 00       	call   f6c <wait>
+     336:	eb 01                	jmp    339 <main+0xd2>
+      // Clumsy but will have to do for now.
+      // Chdir has no effect on the parent if run in the child.
+      buf[strlen(buf)-1] = 0;  // chop \n
+      if(chdir(buf+3) < 0)
+        printf(2, "cannot cd %s\n", buf+3);
+      continue;
+     338:	90                   	nop
+      break;
+    }
+  }
+  
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     339:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+     340:	00 
+     341:	c7 04 24 80 1a 00 00 	movl   $0x1a80,(%esp)
+     348:	e8 bc fe ff ff       	call   209 <getcmd>
+     34d:	85 c0                	test   %eax,%eax
+     34f:	0f 89 5a ff ff ff    	jns    2af <main+0x48>
+    }
+    if(fork1() == 0)
+      runcmd(parsecmd(buf));
+    wait();
+  }
+  exit();
+     355:	e8 0a 0c 00 00       	call   f64 <exit>
+
+0000035a <panic>:
+}
+
+void
+panic(char *s)
+{
+     35a:	55                   	push   %ebp
+     35b:	89 e5                	mov    %esp,%ebp
+     35d:	83 ec 18             	sub    $0x18,%esp
+  printf(2, "%s\n", s);
+     360:	8b 45 08             	mov    0x8(%ebp),%eax
+     363:	89 44 24 08          	mov    %eax,0x8(%esp)
+     367:	c7 44 24 04 39 15 00 	movl   $0x1539,0x4(%esp)
+     36e:	00 
+     36f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+     376:	e8 8e 0d 00 00       	call   1109 <printf>
+  exit();
+     37b:	e8 e4 0b 00 00       	call   f64 <exit>
+
+00000380 <fork1>:
+}
+
+int
+fork1(void)
+{
+     380:	55                   	push   %ebp
+     381:	89 e5                	mov    %esp,%ebp
+     383:	83 ec 28             	sub    $0x28,%esp
+  int pid;
+  
+  pid = fork();
+     386:	e8 d1 0b 00 00       	call   f5c <fork>
+     38b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid == -1)
+     38e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+     392:	75 0c                	jne    3a0 <fork1+0x20>
+    panic("fork");
+     394:	c7 04 24 3d 15 00 00 	movl   $0x153d,(%esp)
+     39b:	e8 ba ff ff ff       	call   35a <panic>
+  return pid;
+     3a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     3a3:	c9                   	leave  
+     3a4:	c3                   	ret    
+
+000003a5 <execcmd>:
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+     3a5:	55                   	push   %ebp
+     3a6:	89 e5                	mov    %esp,%ebp
+     3a8:	83 ec 28             	sub    $0x28,%esp
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     3ab:	c7 04 24 54 00 00 00 	movl   $0x54,(%esp)
+     3b2:	e8 42 10 00 00       	call   13f9 <malloc>
+     3b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     3ba:	c7 44 24 08 54 00 00 	movl   $0x54,0x8(%esp)
+     3c1:	00 
+     3c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     3c9:	00 
+     3ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     3cd:	89 04 24             	mov    %eax,(%esp)
+     3d0:	e8 e8 09 00 00       	call   dbd <memset>
+  cmd->type = EXEC;
+     3d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     3d8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  return (struct cmd*)cmd;
+     3de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     3e1:	c9                   	leave  
+     3e2:	c3                   	ret    
+
+000003e3 <redircmd>:
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+     3e3:	55                   	push   %ebp
+     3e4:	89 e5                	mov    %esp,%ebp
+     3e6:	83 ec 28             	sub    $0x28,%esp
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     3e9:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
+     3f0:	e8 04 10 00 00       	call   13f9 <malloc>
+     3f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     3f8:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
+     3ff:	00 
+     400:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     407:	00 
+     408:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     40b:	89 04 24             	mov    %eax,(%esp)
+     40e:	e8 aa 09 00 00       	call   dbd <memset>
+  cmd->type = REDIR;
+     413:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     416:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
+  cmd->cmd = subcmd;
+     41c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     41f:	8b 55 08             	mov    0x8(%ebp),%edx
+     422:	89 50 04             	mov    %edx,0x4(%eax)
+  cmd->file = file;
+     425:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     428:	8b 55 0c             	mov    0xc(%ebp),%edx
+     42b:	89 50 08             	mov    %edx,0x8(%eax)
+  cmd->efile = efile;
+     42e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     431:	8b 55 10             	mov    0x10(%ebp),%edx
+     434:	89 50 0c             	mov    %edx,0xc(%eax)
+  cmd->mode = mode;
+     437:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     43a:	8b 55 14             	mov    0x14(%ebp),%edx
+     43d:	89 50 10             	mov    %edx,0x10(%eax)
+  cmd->fd = fd;
+     440:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     443:	8b 55 18             	mov    0x18(%ebp),%edx
+     446:	89 50 14             	mov    %edx,0x14(%eax)
+  return (struct cmd*)cmd;
+     449:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     44c:	c9                   	leave  
+     44d:	c3                   	ret    
+
+0000044e <pipecmd>:
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+     44e:	55                   	push   %ebp
+     44f:	89 e5                	mov    %esp,%ebp
+     451:	83 ec 28             	sub    $0x28,%esp
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     454:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
+     45b:	e8 99 0f 00 00       	call   13f9 <malloc>
+     460:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     463:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
+     46a:	00 
+     46b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     472:	00 
+     473:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     476:	89 04 24             	mov    %eax,(%esp)
+     479:	e8 3f 09 00 00       	call   dbd <memset>
+  cmd->type = PIPE;
+     47e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     481:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
+  cmd->left = left;
+     487:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     48a:	8b 55 08             	mov    0x8(%ebp),%edx
+     48d:	89 50 04             	mov    %edx,0x4(%eax)
+  cmd->right = right;
+     490:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     493:	8b 55 0c             	mov    0xc(%ebp),%edx
+     496:	89 50 08             	mov    %edx,0x8(%eax)
+  return (struct cmd*)cmd;
+     499:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     49c:	c9                   	leave  
+     49d:	c3                   	ret    
+
+0000049e <listcmd>:
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+     49e:	55                   	push   %ebp
+     49f:	89 e5                	mov    %esp,%ebp
+     4a1:	83 ec 28             	sub    $0x28,%esp
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     4a4:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
+     4ab:	e8 49 0f 00 00       	call   13f9 <malloc>
+     4b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     4b3:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
+     4ba:	00 
+     4bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     4c2:	00 
+     4c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4c6:	89 04 24             	mov    %eax,(%esp)
+     4c9:	e8 ef 08 00 00       	call   dbd <memset>
+  cmd->type = LIST;
+     4ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4d1:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
+  cmd->left = left;
+     4d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4da:	8b 55 08             	mov    0x8(%ebp),%edx
+     4dd:	89 50 04             	mov    %edx,0x4(%eax)
+  cmd->right = right;
+     4e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4e3:	8b 55 0c             	mov    0xc(%ebp),%edx
+     4e6:	89 50 08             	mov    %edx,0x8(%eax)
+  return (struct cmd*)cmd;
+     4e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     4ec:	c9                   	leave  
+     4ed:	c3                   	ret    
+
+000004ee <backcmd>:
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+     4ee:	55                   	push   %ebp
+     4ef:	89 e5                	mov    %esp,%ebp
+     4f1:	83 ec 28             	sub    $0x28,%esp
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     4f4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+     4fb:	e8 f9 0e 00 00       	call   13f9 <malloc>
+     500:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     503:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
+     50a:	00 
+     50b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     512:	00 
+     513:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     516:	89 04 24             	mov    %eax,(%esp)
+     519:	e8 9f 08 00 00       	call   dbd <memset>
+  cmd->type = BACK;
+     51e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     521:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
+  cmd->cmd = subcmd;
+     527:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     52a:	8b 55 08             	mov    0x8(%ebp),%edx
+     52d:	89 50 04             	mov    %edx,0x4(%eax)
+  return (struct cmd*)cmd;
+     530:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     533:	c9                   	leave  
+     534:	c3                   	ret    
+
+00000535 <gettoken>:
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+     535:	55                   	push   %ebp
+     536:	89 e5                	mov    %esp,%ebp
+     538:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int ret;
+  
+  s = *ps;
+     53b:	8b 45 08             	mov    0x8(%ebp),%eax
+     53e:	8b 00                	mov    (%eax),%eax
+     540:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     543:	eb 04                	jmp    549 <gettoken+0x14>
+    s++;
+     545:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+{
+  char *s;
+  int ret;
+  
+  s = *ps;
+  while(s < es && strchr(whitespace, *s))
+     549:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     54c:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     54f:	73 1d                	jae    56e <gettoken+0x39>
+     551:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     554:	0f b6 00             	movzbl (%eax),%eax
+     557:	0f be c0             	movsbl %al,%eax
+     55a:	89 44 24 04          	mov    %eax,0x4(%esp)
+     55e:	c7 04 24 4c 1a 00 00 	movl   $0x1a4c,(%esp)
+     565:	e8 77 08 00 00       	call   de1 <strchr>
+     56a:	85 c0                	test   %eax,%eax
+     56c:	75 d7                	jne    545 <gettoken+0x10>
+    s++;
+  if(q)
+     56e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+     572:	74 08                	je     57c <gettoken+0x47>
+    *q = s;
+     574:	8b 45 10             	mov    0x10(%ebp),%eax
+     577:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     57a:	89 10                	mov    %edx,(%eax)
+  ret = *s;
+     57c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     57f:	0f b6 00             	movzbl (%eax),%eax
+     582:	0f be c0             	movsbl %al,%eax
+     585:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  switch(*s){
+     588:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     58b:	0f b6 00             	movzbl (%eax),%eax
+     58e:	0f be c0             	movsbl %al,%eax
+     591:	83 f8 3c             	cmp    $0x3c,%eax
+     594:	7f 1e                	jg     5b4 <gettoken+0x7f>
+     596:	83 f8 3b             	cmp    $0x3b,%eax
+     599:	7d 23                	jge    5be <gettoken+0x89>
+     59b:	83 f8 29             	cmp    $0x29,%eax
+     59e:	7f 3f                	jg     5df <gettoken+0xaa>
+     5a0:	83 f8 28             	cmp    $0x28,%eax
+     5a3:	7d 19                	jge    5be <gettoken+0x89>
+     5a5:	85 c0                	test   %eax,%eax
+     5a7:	0f 84 83 00 00 00    	je     630 <gettoken+0xfb>
+     5ad:	83 f8 26             	cmp    $0x26,%eax
+     5b0:	74 0c                	je     5be <gettoken+0x89>
+     5b2:	eb 2b                	jmp    5df <gettoken+0xaa>
+     5b4:	83 f8 3e             	cmp    $0x3e,%eax
+     5b7:	74 0b                	je     5c4 <gettoken+0x8f>
+     5b9:	83 f8 7c             	cmp    $0x7c,%eax
+     5bc:	75 21                	jne    5df <gettoken+0xaa>
+  case '(':
+  case ')':
+  case ';':
+  case '&':
+  case '<':
+    s++;
+     5be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    break;
+     5c2:	eb 73                	jmp    637 <gettoken+0x102>
+  case '>':
+    s++;
+     5c4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(*s == '>'){
+     5c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     5cb:	0f b6 00             	movzbl (%eax),%eax
+     5ce:	3c 3e                	cmp    $0x3e,%al
+     5d0:	75 61                	jne    633 <gettoken+0xfe>
+      ret = '+';
+     5d2:	c7 45 f0 2b 00 00 00 	movl   $0x2b,-0x10(%ebp)
+      s++;
+     5d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    }
+    break;
+     5dd:	eb 54                	jmp    633 <gettoken+0xfe>
+  default:
+    ret = 'a';
+     5df:	c7 45 f0 61 00 00 00 	movl   $0x61,-0x10(%ebp)
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     5e6:	eb 04                	jmp    5ec <gettoken+0xb7>
+      s++;
+     5e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+      s++;
+    }
+    break;
+  default:
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     5ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     5ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     5f2:	73 42                	jae    636 <gettoken+0x101>
+     5f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     5f7:	0f b6 00             	movzbl (%eax),%eax
+     5fa:	0f be c0             	movsbl %al,%eax
+     5fd:	89 44 24 04          	mov    %eax,0x4(%esp)
+     601:	c7 04 24 4c 1a 00 00 	movl   $0x1a4c,(%esp)
+     608:	e8 d4 07 00 00       	call   de1 <strchr>
+     60d:	85 c0                	test   %eax,%eax
+     60f:	75 25                	jne    636 <gettoken+0x101>
+     611:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     614:	0f b6 00             	movzbl (%eax),%eax
+     617:	0f be c0             	movsbl %al,%eax
+     61a:	89 44 24 04          	mov    %eax,0x4(%esp)
+     61e:	c7 04 24 52 1a 00 00 	movl   $0x1a52,(%esp)
+     625:	e8 b7 07 00 00       	call   de1 <strchr>
+     62a:	85 c0                	test   %eax,%eax
+     62c:	74 ba                	je     5e8 <gettoken+0xb3>
+      s++;
+    break;
+     62e:	eb 06                	jmp    636 <gettoken+0x101>
+  if(q)
+    *q = s;
+  ret = *s;
+  switch(*s){
+  case 0:
+    break;
+     630:	90                   	nop
+     631:	eb 04                	jmp    637 <gettoken+0x102>
+    s++;
+    if(*s == '>'){
+      ret = '+';
+      s++;
+    }
+    break;
+     633:	90                   	nop
+     634:	eb 01                	jmp    637 <gettoken+0x102>
+  default:
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+      s++;
+    break;
+     636:	90                   	nop
+  }
+  if(eq)
+     637:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+     63b:	74 0e                	je     64b <gettoken+0x116>
+    *eq = s;
+     63d:	8b 45 14             	mov    0x14(%ebp),%eax
+     640:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     643:	89 10                	mov    %edx,(%eax)
+  
+  while(s < es && strchr(whitespace, *s))
+     645:	eb 04                	jmp    64b <gettoken+0x116>
+    s++;
+     647:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    break;
+  }
+  if(eq)
+    *eq = s;
+  
+  while(s < es && strchr(whitespace, *s))
+     64b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     64e:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     651:	73 1d                	jae    670 <gettoken+0x13b>
+     653:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     656:	0f b6 00             	movzbl (%eax),%eax
+     659:	0f be c0             	movsbl %al,%eax
+     65c:	89 44 24 04          	mov    %eax,0x4(%esp)
+     660:	c7 04 24 4c 1a 00 00 	movl   $0x1a4c,(%esp)
+     667:	e8 75 07 00 00       	call   de1 <strchr>
+     66c:	85 c0                	test   %eax,%eax
+     66e:	75 d7                	jne    647 <gettoken+0x112>
+    s++;
+  *ps = s;
+     670:	8b 45 08             	mov    0x8(%ebp),%eax
+     673:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     676:	89 10                	mov    %edx,(%eax)
+  return ret;
+     678:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     67b:	c9                   	leave  
+     67c:	c3                   	ret    
+
+0000067d <peek>:
+
+int
+peek(char **ps, char *es, char *toks)
+{
+     67d:	55                   	push   %ebp
+     67e:	89 e5                	mov    %esp,%ebp
+     680:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  
+  s = *ps;
+     683:	8b 45 08             	mov    0x8(%ebp),%eax
+     686:	8b 00                	mov    (%eax),%eax
+     688:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     68b:	eb 04                	jmp    691 <peek+0x14>
+    s++;
+     68d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+peek(char **ps, char *es, char *toks)
+{
+  char *s;
+  
+  s = *ps;
+  while(s < es && strchr(whitespace, *s))
+     691:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     694:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     697:	73 1d                	jae    6b6 <peek+0x39>
+     699:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     69c:	0f b6 00             	movzbl (%eax),%eax
+     69f:	0f be c0             	movsbl %al,%eax
+     6a2:	89 44 24 04          	mov    %eax,0x4(%esp)
+     6a6:	c7 04 24 4c 1a 00 00 	movl   $0x1a4c,(%esp)
+     6ad:	e8 2f 07 00 00       	call   de1 <strchr>
+     6b2:	85 c0                	test   %eax,%eax
+     6b4:	75 d7                	jne    68d <peek+0x10>
+    s++;
+  *ps = s;
+     6b6:	8b 45 08             	mov    0x8(%ebp),%eax
+     6b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     6bc:	89 10                	mov    %edx,(%eax)
+  return *s && strchr(toks, *s);
+     6be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     6c1:	0f b6 00             	movzbl (%eax),%eax
+     6c4:	84 c0                	test   %al,%al
+     6c6:	74 23                	je     6eb <peek+0x6e>
+     6c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     6cb:	0f b6 00             	movzbl (%eax),%eax
+     6ce:	0f be c0             	movsbl %al,%eax
+     6d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+     6d5:	8b 45 10             	mov    0x10(%ebp),%eax
+     6d8:	89 04 24             	mov    %eax,(%esp)
+     6db:	e8 01 07 00 00       	call   de1 <strchr>
+     6e0:	85 c0                	test   %eax,%eax
+     6e2:	74 07                	je     6eb <peek+0x6e>
+     6e4:	b8 01 00 00 00       	mov    $0x1,%eax
+     6e9:	eb 05                	jmp    6f0 <peek+0x73>
+     6eb:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+     6f0:	c9                   	leave  
+     6f1:	c3                   	ret    
+
+000006f2 <parsecmd>:
+struct cmd *parseexec(char**, char*);
+struct cmd *nulterminate(struct cmd*);
+
+struct cmd*
+parsecmd(char *s)
+{
+     6f2:	55                   	push   %ebp
+     6f3:	89 e5                	mov    %esp,%ebp
+     6f5:	53                   	push   %ebx
+     6f6:	83 ec 24             	sub    $0x24,%esp
+  char *es;
+  struct cmd *cmd;
+
+  es = s + strlen(s);
+     6f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+     6fc:	8b 45 08             	mov    0x8(%ebp),%eax
+     6ff:	89 04 24             	mov    %eax,(%esp)
+     702:	e8 8f 06 00 00       	call   d96 <strlen>
+     707:	01 d8                	add    %ebx,%eax
+     709:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  cmd = parseline(&s, es);
+     70c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     70f:	89 44 24 04          	mov    %eax,0x4(%esp)
+     713:	8d 45 08             	lea    0x8(%ebp),%eax
+     716:	89 04 24             	mov    %eax,(%esp)
+     719:	e8 60 00 00 00       	call   77e <parseline>
+     71e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  peek(&s, es, "");
+     721:	c7 44 24 08 42 15 00 	movl   $0x1542,0x8(%esp)
+     728:	00 
+     729:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     72c:	89 44 24 04          	mov    %eax,0x4(%esp)
+     730:	8d 45 08             	lea    0x8(%ebp),%eax
+     733:	89 04 24             	mov    %eax,(%esp)
+     736:	e8 42 ff ff ff       	call   67d <peek>
+  if(s != es){
+     73b:	8b 45 08             	mov    0x8(%ebp),%eax
+     73e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+     741:	74 27                	je     76a <parsecmd+0x78>
+    printf(2, "leftovers: %s\n", s);
+     743:	8b 45 08             	mov    0x8(%ebp),%eax
+     746:	89 44 24 08          	mov    %eax,0x8(%esp)
+     74a:	c7 44 24 04 43 15 00 	movl   $0x1543,0x4(%esp)
+     751:	00 
+     752:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+     759:	e8 ab 09 00 00       	call   1109 <printf>
+    panic("syntax");
+     75e:	c7 04 24 52 15 00 00 	movl   $0x1552,(%esp)
+     765:	e8 f0 fb ff ff       	call   35a <panic>
+  }
+  nulterminate(cmd);
+     76a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     76d:	89 04 24             	mov    %eax,(%esp)
+     770:	e8 a5 04 00 00       	call   c1a <nulterminate>
+  return cmd;
+     775:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     778:	83 c4 24             	add    $0x24,%esp
+     77b:	5b                   	pop    %ebx
+     77c:	5d                   	pop    %ebp
+     77d:	c3                   	ret    
+
+0000077e <parseline>:
+
+struct cmd*
+parseline(char **ps, char *es)
+{
+     77e:	55                   	push   %ebp
+     77f:	89 e5                	mov    %esp,%ebp
+     781:	83 ec 28             	sub    $0x28,%esp
+  struct cmd *cmd;
+
+  cmd = parsepipe(ps, es);
+     784:	8b 45 0c             	mov    0xc(%ebp),%eax
+     787:	89 44 24 04          	mov    %eax,0x4(%esp)
+     78b:	8b 45 08             	mov    0x8(%ebp),%eax
+     78e:	89 04 24             	mov    %eax,(%esp)
+     791:	e8 bc 00 00 00       	call   852 <parsepipe>
+     796:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(peek(ps, es, "&")){
+     799:	eb 30                	jmp    7cb <parseline+0x4d>
+    gettoken(ps, es, 0, 0);
+     79b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     7a2:	00 
+     7a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+     7aa:	00 
+     7ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+     7ae:	89 44 24 04          	mov    %eax,0x4(%esp)
+     7b2:	8b 45 08             	mov    0x8(%ebp),%eax
+     7b5:	89 04 24             	mov    %eax,(%esp)
+     7b8:	e8 78 fd ff ff       	call   535 <gettoken>
+    cmd = backcmd(cmd);
+     7bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     7c0:	89 04 24             	mov    %eax,(%esp)
+     7c3:	e8 26 fd ff ff       	call   4ee <backcmd>
+     7c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+parseline(char **ps, char *es)
+{
+  struct cmd *cmd;
+
+  cmd = parsepipe(ps, es);
+  while(peek(ps, es, "&")){
+     7cb:	c7 44 24 08 59 15 00 	movl   $0x1559,0x8(%esp)
+     7d2:	00 
+     7d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+     7d6:	89 44 24 04          	mov    %eax,0x4(%esp)
+     7da:	8b 45 08             	mov    0x8(%ebp),%eax
+     7dd:	89 04 24             	mov    %eax,(%esp)
+     7e0:	e8 98 fe ff ff       	call   67d <peek>
+     7e5:	85 c0                	test   %eax,%eax
+     7e7:	75 b2                	jne    79b <parseline+0x1d>
+    gettoken(ps, es, 0, 0);
+    cmd = backcmd(cmd);
+  }
+  if(peek(ps, es, ";")){
+     7e9:	c7 44 24 08 5b 15 00 	movl   $0x155b,0x8(%esp)
+     7f0:	00 
+     7f1:	8b 45 0c             	mov    0xc(%ebp),%eax
+     7f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+     7f8:	8b 45 08             	mov    0x8(%ebp),%eax
+     7fb:	89 04 24             	mov    %eax,(%esp)
+     7fe:	e8 7a fe ff ff       	call   67d <peek>
+     803:	85 c0                	test   %eax,%eax
+     805:	74 46                	je     84d <parseline+0xcf>
+    gettoken(ps, es, 0, 0);
+     807:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     80e:	00 
+     80f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+     816:	00 
+     817:	8b 45 0c             	mov    0xc(%ebp),%eax
+     81a:	89 44 24 04          	mov    %eax,0x4(%esp)
+     81e:	8b 45 08             	mov    0x8(%ebp),%eax
+     821:	89 04 24             	mov    %eax,(%esp)
+     824:	e8 0c fd ff ff       	call   535 <gettoken>
+    cmd = listcmd(cmd, parseline(ps, es));
+     829:	8b 45 0c             	mov    0xc(%ebp),%eax
+     82c:	89 44 24 04          	mov    %eax,0x4(%esp)
+     830:	8b 45 08             	mov    0x8(%ebp),%eax
+     833:	89 04 24             	mov    %eax,(%esp)
+     836:	e8 43 ff ff ff       	call   77e <parseline>
+     83b:	89 44 24 04          	mov    %eax,0x4(%esp)
+     83f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     842:	89 04 24             	mov    %eax,(%esp)
+     845:	e8 54 fc ff ff       	call   49e <listcmd>
+     84a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  }
+  return cmd;
+     84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     850:	c9                   	leave  
+     851:	c3                   	ret    
+
+00000852 <parsepipe>:
+
+struct cmd*
+parsepipe(char **ps, char *es)
+{
+     852:	55                   	push   %ebp
+     853:	89 e5                	mov    %esp,%ebp
+     855:	83 ec 28             	sub    $0x28,%esp
+  struct cmd *cmd;
+
+  cmd = parseexec(ps, es);
+     858:	8b 45 0c             	mov    0xc(%ebp),%eax
+     85b:	89 44 24 04          	mov    %eax,0x4(%esp)
+     85f:	8b 45 08             	mov    0x8(%ebp),%eax
+     862:	89 04 24             	mov    %eax,(%esp)
+     865:	e8 68 02 00 00       	call   ad2 <parseexec>
+     86a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(peek(ps, es, "|")){
+     86d:	c7 44 24 08 5d 15 00 	movl   $0x155d,0x8(%esp)
+     874:	00 
+     875:	8b 45 0c             	mov    0xc(%ebp),%eax
+     878:	89 44 24 04          	mov    %eax,0x4(%esp)
+     87c:	8b 45 08             	mov    0x8(%ebp),%eax
+     87f:	89 04 24             	mov    %eax,(%esp)
+     882:	e8 f6 fd ff ff       	call   67d <peek>
+     887:	85 c0                	test   %eax,%eax
+     889:	74 46                	je     8d1 <parsepipe+0x7f>
+    gettoken(ps, es, 0, 0);
+     88b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     892:	00 
+     893:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+     89a:	00 
+     89b:	8b 45 0c             	mov    0xc(%ebp),%eax
+     89e:	89 44 24 04          	mov    %eax,0x4(%esp)
+     8a2:	8b 45 08             	mov    0x8(%ebp),%eax
+     8a5:	89 04 24             	mov    %eax,(%esp)
+     8a8:	e8 88 fc ff ff       	call   535 <gettoken>
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+     8ad:	8b 45 0c             	mov    0xc(%ebp),%eax
+     8b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+     8b4:	8b 45 08             	mov    0x8(%ebp),%eax
+     8b7:	89 04 24             	mov    %eax,(%esp)
+     8ba:	e8 93 ff ff ff       	call   852 <parsepipe>
+     8bf:	89 44 24 04          	mov    %eax,0x4(%esp)
+     8c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     8c6:	89 04 24             	mov    %eax,(%esp)
+     8c9:	e8 80 fb ff ff       	call   44e <pipecmd>
+     8ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  }
+  return cmd;
+     8d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     8d4:	c9                   	leave  
+     8d5:	c3                   	ret    
+
+000008d6 <parseredirs>:
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+     8d6:	55                   	push   %ebp
+     8d7:	89 e5                	mov    %esp,%ebp
+     8d9:	83 ec 38             	sub    $0x38,%esp
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+     8dc:	e9 f6 00 00 00       	jmp    9d7 <parseredirs+0x101>
+    tok = gettoken(ps, es, 0, 0);
+     8e1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     8e8:	00 
+     8e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+     8f0:	00 
+     8f1:	8b 45 10             	mov    0x10(%ebp),%eax
+     8f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+     8f8:	8b 45 0c             	mov    0xc(%ebp),%eax
+     8fb:	89 04 24             	mov    %eax,(%esp)
+     8fe:	e8 32 fc ff ff       	call   535 <gettoken>
+     903:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(gettoken(ps, es, &q, &eq) != 'a')
+     906:	8d 45 ec             	lea    -0x14(%ebp),%eax
+     909:	89 44 24 0c          	mov    %eax,0xc(%esp)
+     90d:	8d 45 f0             	lea    -0x10(%ebp),%eax
+     910:	89 44 24 08          	mov    %eax,0x8(%esp)
+     914:	8b 45 10             	mov    0x10(%ebp),%eax
+     917:	89 44 24 04          	mov    %eax,0x4(%esp)
+     91b:	8b 45 0c             	mov    0xc(%ebp),%eax
+     91e:	89 04 24             	mov    %eax,(%esp)
+     921:	e8 0f fc ff ff       	call   535 <gettoken>
+     926:	83 f8 61             	cmp    $0x61,%eax
+     929:	74 0c                	je     937 <parseredirs+0x61>
+      panic("missing file for redirection");
+     92b:	c7 04 24 5f 15 00 00 	movl   $0x155f,(%esp)
+     932:	e8 23 fa ff ff       	call   35a <panic>
+    switch(tok){
+     937:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     93a:	83 f8 3c             	cmp    $0x3c,%eax
+     93d:	74 0f                	je     94e <parseredirs+0x78>
+     93f:	83 f8 3e             	cmp    $0x3e,%eax
+     942:	74 38                	je     97c <parseredirs+0xa6>
+     944:	83 f8 2b             	cmp    $0x2b,%eax
+     947:	74 61                	je     9aa <parseredirs+0xd4>
+     949:	e9 89 00 00 00       	jmp    9d7 <parseredirs+0x101>
+    case '<':
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+     94e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+     951:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     954:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+     95b:	00 
+     95c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     963:	00 
+     964:	89 54 24 08          	mov    %edx,0x8(%esp)
+     968:	89 44 24 04          	mov    %eax,0x4(%esp)
+     96c:	8b 45 08             	mov    0x8(%ebp),%eax
+     96f:	89 04 24             	mov    %eax,(%esp)
+     972:	e8 6c fa ff ff       	call   3e3 <redircmd>
+     977:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     97a:	eb 5b                	jmp    9d7 <parseredirs+0x101>
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     97c:	8b 55 ec             	mov    -0x14(%ebp),%edx
+     97f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     982:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
+     989:	00 
+     98a:	c7 44 24 0c 01 02 00 	movl   $0x201,0xc(%esp)
+     991:	00 
+     992:	89 54 24 08          	mov    %edx,0x8(%esp)
+     996:	89 44 24 04          	mov    %eax,0x4(%esp)
+     99a:	8b 45 08             	mov    0x8(%ebp),%eax
+     99d:	89 04 24             	mov    %eax,(%esp)
+     9a0:	e8 3e fa ff ff       	call   3e3 <redircmd>
+     9a5:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     9a8:	eb 2d                	jmp    9d7 <parseredirs+0x101>
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     9aa:	8b 55 ec             	mov    -0x14(%ebp),%edx
+     9ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     9b0:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
+     9b7:	00 
+     9b8:	c7 44 24 0c 01 02 00 	movl   $0x201,0xc(%esp)
+     9bf:	00 
+     9c0:	89 54 24 08          	mov    %edx,0x8(%esp)
+     9c4:	89 44 24 04          	mov    %eax,0x4(%esp)
+     9c8:	8b 45 08             	mov    0x8(%ebp),%eax
+     9cb:	89 04 24             	mov    %eax,(%esp)
+     9ce:	e8 10 fa ff ff       	call   3e3 <redircmd>
+     9d3:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     9d6:	90                   	nop
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+     9d7:	c7 44 24 08 7c 15 00 	movl   $0x157c,0x8(%esp)
+     9de:	00 
+     9df:	8b 45 10             	mov    0x10(%ebp),%eax
+     9e2:	89 44 24 04          	mov    %eax,0x4(%esp)
+     9e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+     9e9:	89 04 24             	mov    %eax,(%esp)
+     9ec:	e8 8c fc ff ff       	call   67d <peek>
+     9f1:	85 c0                	test   %eax,%eax
+     9f3:	0f 85 e8 fe ff ff    	jne    8e1 <parseredirs+0xb>
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    }
+  }
+  return cmd;
+     9f9:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     9fc:	c9                   	leave  
+     9fd:	c3                   	ret    
+
+000009fe <parseblock>:
+
+struct cmd*
+parseblock(char **ps, char *es)
+{
+     9fe:	55                   	push   %ebp
+     9ff:	89 e5                	mov    %esp,%ebp
+     a01:	83 ec 28             	sub    $0x28,%esp
+  struct cmd *cmd;
+
+  if(!peek(ps, es, "("))
+     a04:	c7 44 24 08 7f 15 00 	movl   $0x157f,0x8(%esp)
+     a0b:	00 
+     a0c:	8b 45 0c             	mov    0xc(%ebp),%eax
+     a0f:	89 44 24 04          	mov    %eax,0x4(%esp)
+     a13:	8b 45 08             	mov    0x8(%ebp),%eax
+     a16:	89 04 24             	mov    %eax,(%esp)
+     a19:	e8 5f fc ff ff       	call   67d <peek>
+     a1e:	85 c0                	test   %eax,%eax
+     a20:	75 0c                	jne    a2e <parseblock+0x30>
+    panic("parseblock");
+     a22:	c7 04 24 81 15 00 00 	movl   $0x1581,(%esp)
+     a29:	e8 2c f9 ff ff       	call   35a <panic>
+  gettoken(ps, es, 0, 0);
+     a2e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     a35:	00 
+     a36:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+     a3d:	00 
+     a3e:	8b 45 0c             	mov    0xc(%ebp),%eax
+     a41:	89 44 24 04          	mov    %eax,0x4(%esp)
+     a45:	8b 45 08             	mov    0x8(%ebp),%eax
+     a48:	89 04 24             	mov    %eax,(%esp)
+     a4b:	e8 e5 fa ff ff       	call   535 <gettoken>
+  cmd = parseline(ps, es);
+     a50:	8b 45 0c             	mov    0xc(%ebp),%eax
+     a53:	89 44 24 04          	mov    %eax,0x4(%esp)
+     a57:	8b 45 08             	mov    0x8(%ebp),%eax
+     a5a:	89 04 24             	mov    %eax,(%esp)
+     a5d:	e8 1c fd ff ff       	call   77e <parseline>
+     a62:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(!peek(ps, es, ")"))
+     a65:	c7 44 24 08 8c 15 00 	movl   $0x158c,0x8(%esp)
+     a6c:	00 
+     a6d:	8b 45 0c             	mov    0xc(%ebp),%eax
+     a70:	89 44 24 04          	mov    %eax,0x4(%esp)
+     a74:	8b 45 08             	mov    0x8(%ebp),%eax
+     a77:	89 04 24             	mov    %eax,(%esp)
+     a7a:	e8 fe fb ff ff       	call   67d <peek>
+     a7f:	85 c0                	test   %eax,%eax
+     a81:	75 0c                	jne    a8f <parseblock+0x91>
+    panic("syntax - missing )");
+     a83:	c7 04 24 8e 15 00 00 	movl   $0x158e,(%esp)
+     a8a:	e8 cb f8 ff ff       	call   35a <panic>
+  gettoken(ps, es, 0, 0);
+     a8f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+     a96:	00 
+     a97:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+     a9e:	00 
+     a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+     aa2:	89 44 24 04          	mov    %eax,0x4(%esp)
+     aa6:	8b 45 08             	mov    0x8(%ebp),%eax
+     aa9:	89 04 24             	mov    %eax,(%esp)
+     aac:	e8 84 fa ff ff       	call   535 <gettoken>
+  cmd = parseredirs(cmd, ps, es);
+     ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
+     ab4:	89 44 24 08          	mov    %eax,0x8(%esp)
+     ab8:	8b 45 08             	mov    0x8(%ebp),%eax
+     abb:	89 44 24 04          	mov    %eax,0x4(%esp)
+     abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     ac2:	89 04 24             	mov    %eax,(%esp)
+     ac5:	e8 0c fe ff ff       	call   8d6 <parseredirs>
+     aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  return cmd;
+     acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     ad0:	c9                   	leave  
+     ad1:	c3                   	ret    
+
+00000ad2 <parseexec>:
+
+struct cmd*
+parseexec(char **ps, char *es)
+{
+     ad2:	55                   	push   %ebp
+     ad3:	89 e5                	mov    %esp,%ebp
+     ad5:	83 ec 38             	sub    $0x38,%esp
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+  
+  if(peek(ps, es, "("))
+     ad8:	c7 44 24 08 7f 15 00 	movl   $0x157f,0x8(%esp)
+     adf:	00 
+     ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
+     ae3:	89 44 24 04          	mov    %eax,0x4(%esp)
+     ae7:	8b 45 08             	mov    0x8(%ebp),%eax
+     aea:	89 04 24             	mov    %eax,(%esp)
+     aed:	e8 8b fb ff ff       	call   67d <peek>
+     af2:	85 c0                	test   %eax,%eax
+     af4:	74 17                	je     b0d <parseexec+0x3b>
+    return parseblock(ps, es);
+     af6:	8b 45 0c             	mov    0xc(%ebp),%eax
+     af9:	89 44 24 04          	mov    %eax,0x4(%esp)
+     afd:	8b 45 08             	mov    0x8(%ebp),%eax
+     b00:	89 04 24             	mov    %eax,(%esp)
+     b03:	e8 f6 fe ff ff       	call   9fe <parseblock>
+     b08:	e9 0b 01 00 00       	jmp    c18 <parseexec+0x146>
+
+  ret = execcmd();
+     b0d:	e8 93 f8 ff ff       	call   3a5 <execcmd>
+     b12:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  cmd = (struct execcmd*)ret;
+     b15:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+  argc = 0;
+     b1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  ret = parseredirs(ret, ps, es);
+     b22:	8b 45 0c             	mov    0xc(%ebp),%eax
+     b25:	89 44 24 08          	mov    %eax,0x8(%esp)
+     b29:	8b 45 08             	mov    0x8(%ebp),%eax
+     b2c:	89 44 24 04          	mov    %eax,0x4(%esp)
+     b30:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     b33:	89 04 24             	mov    %eax,(%esp)
+     b36:	e8 9b fd ff ff       	call   8d6 <parseredirs>
+     b3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  while(!peek(ps, es, "|)&;")){
+     b3e:	e9 8e 00 00 00       	jmp    bd1 <parseexec+0xff>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+     b43:	8d 45 e0             	lea    -0x20(%ebp),%eax
+     b46:	89 44 24 0c          	mov    %eax,0xc(%esp)
+     b4a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+     b4d:	89 44 24 08          	mov    %eax,0x8(%esp)
+     b51:	8b 45 0c             	mov    0xc(%ebp),%eax
+     b54:	89 44 24 04          	mov    %eax,0x4(%esp)
+     b58:	8b 45 08             	mov    0x8(%ebp),%eax
+     b5b:	89 04 24             	mov    %eax,(%esp)
+     b5e:	e8 d2 f9 ff ff       	call   535 <gettoken>
+     b63:	89 45 e8             	mov    %eax,-0x18(%ebp)
+     b66:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     b6a:	0f 84 85 00 00 00    	je     bf5 <parseexec+0x123>
+      break;
+    if(tok != 'a')
+     b70:	83 7d e8 61          	cmpl   $0x61,-0x18(%ebp)
+     b74:	74 0c                	je     b82 <parseexec+0xb0>
+      panic("syntax");
+     b76:	c7 04 24 52 15 00 00 	movl   $0x1552,(%esp)
+     b7d:	e8 d8 f7 ff ff       	call   35a <panic>
+    cmd->argv[argc] = q;
+     b82:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+     b85:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     b88:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     b8b:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
+    cmd->eargv[argc] = eq;
+     b8f:	8b 55 e0             	mov    -0x20(%ebp),%edx
+     b92:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     b95:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+     b98:	83 c1 08             	add    $0x8,%ecx
+     b9b:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)
+    argc++;
+     b9f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(argc >= MAXARGS)
+     ba3:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+     ba7:	7e 0c                	jle    bb5 <parseexec+0xe3>
+      panic("too many args");
+     ba9:	c7 04 24 a1 15 00 00 	movl   $0x15a1,(%esp)
+     bb0:	e8 a5 f7 ff ff       	call   35a <panic>
+    ret = parseredirs(ret, ps, es);
+     bb5:	8b 45 0c             	mov    0xc(%ebp),%eax
+     bb8:	89 44 24 08          	mov    %eax,0x8(%esp)
+     bbc:	8b 45 08             	mov    0x8(%ebp),%eax
+     bbf:	89 44 24 04          	mov    %eax,0x4(%esp)
+     bc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     bc6:	89 04 24             	mov    %eax,(%esp)
+     bc9:	e8 08 fd ff ff       	call   8d6 <parseredirs>
+     bce:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  ret = execcmd();
+  cmd = (struct execcmd*)ret;
+
+  argc = 0;
+  ret = parseredirs(ret, ps, es);
+  while(!peek(ps, es, "|)&;")){
+     bd1:	c7 44 24 08 af 15 00 	movl   $0x15af,0x8(%esp)
+     bd8:	00 
+     bd9:	8b 45 0c             	mov    0xc(%ebp),%eax
+     bdc:	89 44 24 04          	mov    %eax,0x4(%esp)
+     be0:	8b 45 08             	mov    0x8(%ebp),%eax
+     be3:	89 04 24             	mov    %eax,(%esp)
+     be6:	e8 92 fa ff ff       	call   67d <peek>
+     beb:	85 c0                	test   %eax,%eax
+     bed:	0f 84 50 ff ff ff    	je     b43 <parseexec+0x71>
+     bf3:	eb 01                	jmp    bf6 <parseexec+0x124>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+      break;
+     bf5:	90                   	nop
+    argc++;
+    if(argc >= MAXARGS)
+      panic("too many args");
+    ret = parseredirs(ret, ps, es);
+  }
+  cmd->argv[argc] = 0;
+     bf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     bf9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     bfc:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
+     c03:	00 
+  cmd->eargv[argc] = 0;
+     c04:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     c07:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     c0a:	83 c2 08             	add    $0x8,%edx
+     c0d:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
+     c14:	00 
+  return ret;
+     c15:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     c18:	c9                   	leave  
+     c19:	c3                   	ret    
+
+00000c1a <nulterminate>:
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+     c1a:	55                   	push   %ebp
+     c1b:	89 e5                	mov    %esp,%ebp
+     c1d:	83 ec 38             	sub    $0x38,%esp
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+     c20:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+     c24:	75 0a                	jne    c30 <nulterminate+0x16>
+    return 0;
+     c26:	b8 00 00 00 00       	mov    $0x0,%eax
+     c2b:	e9 c9 00 00 00       	jmp    cf9 <nulterminate+0xdf>
+  
+  switch(cmd->type){
+     c30:	8b 45 08             	mov    0x8(%ebp),%eax
+     c33:	8b 00                	mov    (%eax),%eax
+     c35:	83 f8 05             	cmp    $0x5,%eax
+     c38:	0f 87 b8 00 00 00    	ja     cf6 <nulterminate+0xdc>
+     c3e:	8b 04 85 b4 15 00 00 	mov    0x15b4(,%eax,4),%eax
+     c45:	ff e0                	jmp    *%eax
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+     c47:	8b 45 08             	mov    0x8(%ebp),%eax
+     c4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    for(i=0; ecmd->argv[i]; i++)
+     c4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     c54:	eb 14                	jmp    c6a <nulterminate+0x50>
+      *ecmd->eargv[i] = 0;
+     c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     c59:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     c5c:	83 c2 08             	add    $0x8,%edx
+     c5f:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+     c63:	c6 00 00             	movb   $0x0,(%eax)
+    return 0;
+  
+  switch(cmd->type){
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+    for(i=0; ecmd->argv[i]; i++)
+     c66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     c6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     c6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     c70:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
+     c74:	85 c0                	test   %eax,%eax
+     c76:	75 de                	jne    c56 <nulterminate+0x3c>
+      *ecmd->eargv[i] = 0;
+    break;
+     c78:	eb 7c                	jmp    cf6 <nulterminate+0xdc>
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+     c7a:	8b 45 08             	mov    0x8(%ebp),%eax
+     c7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    nulterminate(rcmd->cmd);
+     c80:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     c83:	8b 40 04             	mov    0x4(%eax),%eax
+     c86:	89 04 24             	mov    %eax,(%esp)
+     c89:	e8 8c ff ff ff       	call   c1a <nulterminate>
+    *rcmd->efile = 0;
+     c8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     c91:	8b 40 0c             	mov    0xc(%eax),%eax
+     c94:	c6 00 00             	movb   $0x0,(%eax)
+    break;
+     c97:	eb 5d                	jmp    cf6 <nulterminate+0xdc>
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+     c99:	8b 45 08             	mov    0x8(%ebp),%eax
+     c9c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    nulterminate(pcmd->left);
+     c9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     ca2:	8b 40 04             	mov    0x4(%eax),%eax
+     ca5:	89 04 24             	mov    %eax,(%esp)
+     ca8:	e8 6d ff ff ff       	call   c1a <nulterminate>
+    nulterminate(pcmd->right);
+     cad:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     cb0:	8b 40 08             	mov    0x8(%eax),%eax
+     cb3:	89 04 24             	mov    %eax,(%esp)
+     cb6:	e8 5f ff ff ff       	call   c1a <nulterminate>
+    break;
+     cbb:	eb 39                	jmp    cf6 <nulterminate+0xdc>
+    
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+     cbd:	8b 45 08             	mov    0x8(%ebp),%eax
+     cc0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    nulterminate(lcmd->left);
+     cc3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     cc6:	8b 40 04             	mov    0x4(%eax),%eax
+     cc9:	89 04 24             	mov    %eax,(%esp)
+     ccc:	e8 49 ff ff ff       	call   c1a <nulterminate>
+    nulterminate(lcmd->right);
+     cd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     cd4:	8b 40 08             	mov    0x8(%eax),%eax
+     cd7:	89 04 24             	mov    %eax,(%esp)
+     cda:	e8 3b ff ff ff       	call   c1a <nulterminate>
+    break;
+     cdf:	eb 15                	jmp    cf6 <nulterminate+0xdc>
+
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+     ce1:	8b 45 08             	mov    0x8(%ebp),%eax
+     ce4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    nulterminate(bcmd->cmd);
+     ce7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     cea:	8b 40 04             	mov    0x4(%eax),%eax
+     ced:	89 04 24             	mov    %eax,(%esp)
+     cf0:	e8 25 ff ff ff       	call   c1a <nulterminate>
+    break;
+     cf5:	90                   	nop
+  }
+  return cmd;
+     cf6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     cf9:	c9                   	leave  
+     cfa:	c3                   	ret    
+     cfb:	90                   	nop
+
+00000cfc <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+     cfc:	55                   	push   %ebp
+     cfd:	89 e5                	mov    %esp,%ebp
+     cff:	57                   	push   %edi
+     d00:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+     d01:	8b 4d 08             	mov    0x8(%ebp),%ecx
+     d04:	8b 55 10             	mov    0x10(%ebp),%edx
+     d07:	8b 45 0c             	mov    0xc(%ebp),%eax
+     d0a:	89 cb                	mov    %ecx,%ebx
+     d0c:	89 df                	mov    %ebx,%edi
+     d0e:	89 d1                	mov    %edx,%ecx
+     d10:	fc                   	cld    
+     d11:	f3 aa                	rep stos %al,%es:(%edi)
+     d13:	89 ca                	mov    %ecx,%edx
+     d15:	89 fb                	mov    %edi,%ebx
+     d17:	89 5d 08             	mov    %ebx,0x8(%ebp)
+     d1a:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+     d1d:	5b                   	pop    %ebx
+     d1e:	5f                   	pop    %edi
+     d1f:	5d                   	pop    %ebp
+     d20:	c3                   	ret    
+
+00000d21 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+     d21:	55                   	push   %ebp
+     d22:	89 e5                	mov    %esp,%ebp
+     d24:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+     d27:	8b 45 08             	mov    0x8(%ebp),%eax
+     d2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+     d2d:	90                   	nop
+     d2e:	8b 45 0c             	mov    0xc(%ebp),%eax
+     d31:	0f b6 10             	movzbl (%eax),%edx
+     d34:	8b 45 08             	mov    0x8(%ebp),%eax
+     d37:	88 10                	mov    %dl,(%eax)
+     d39:	8b 45 08             	mov    0x8(%ebp),%eax
+     d3c:	0f b6 00             	movzbl (%eax),%eax
+     d3f:	84 c0                	test   %al,%al
+     d41:	0f 95 c0             	setne  %al
+     d44:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+     d48:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+     d4c:	84 c0                	test   %al,%al
+     d4e:	75 de                	jne    d2e <strcpy+0xd>
+    ;
+  return os;
+     d50:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+     d53:	c9                   	leave  
+     d54:	c3                   	ret    
+
+00000d55 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+     d55:	55                   	push   %ebp
+     d56:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+     d58:	eb 08                	jmp    d62 <strcmp+0xd>
+    p++, q++;
+     d5a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+     d5e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+     d62:	8b 45 08             	mov    0x8(%ebp),%eax
+     d65:	0f b6 00             	movzbl (%eax),%eax
+     d68:	84 c0                	test   %al,%al
+     d6a:	74 10                	je     d7c <strcmp+0x27>
+     d6c:	8b 45 08             	mov    0x8(%ebp),%eax
+     d6f:	0f b6 10             	movzbl (%eax),%edx
+     d72:	8b 45 0c             	mov    0xc(%ebp),%eax
+     d75:	0f b6 00             	movzbl (%eax),%eax
+     d78:	38 c2                	cmp    %al,%dl
+     d7a:	74 de                	je     d5a <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+     d7c:	8b 45 08             	mov    0x8(%ebp),%eax
+     d7f:	0f b6 00             	movzbl (%eax),%eax
+     d82:	0f b6 d0             	movzbl %al,%edx
+     d85:	8b 45 0c             	mov    0xc(%ebp),%eax
+     d88:	0f b6 00             	movzbl (%eax),%eax
+     d8b:	0f b6 c0             	movzbl %al,%eax
+     d8e:	89 d1                	mov    %edx,%ecx
+     d90:	29 c1                	sub    %eax,%ecx
+     d92:	89 c8                	mov    %ecx,%eax
+}
+     d94:	5d                   	pop    %ebp
+     d95:	c3                   	ret    
+
+00000d96 <strlen>:
+
+uint
+strlen(char *s)
+{
+     d96:	55                   	push   %ebp
+     d97:	89 e5                	mov    %esp,%ebp
+     d99:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+     d9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+     da3:	eb 04                	jmp    da9 <strlen+0x13>
+     da5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+     da9:	8b 55 fc             	mov    -0x4(%ebp),%edx
+     dac:	8b 45 08             	mov    0x8(%ebp),%eax
+     daf:	01 d0                	add    %edx,%eax
+     db1:	0f b6 00             	movzbl (%eax),%eax
+     db4:	84 c0                	test   %al,%al
+     db6:	75 ed                	jne    da5 <strlen+0xf>
+    ;
+  return n;
+     db8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+     dbb:	c9                   	leave  
+     dbc:	c3                   	ret    
+
+00000dbd <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+     dbd:	55                   	push   %ebp
+     dbe:	89 e5                	mov    %esp,%ebp
+     dc0:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+     dc3:	8b 45 10             	mov    0x10(%ebp),%eax
+     dc6:	89 44 24 08          	mov    %eax,0x8(%esp)
+     dca:	8b 45 0c             	mov    0xc(%ebp),%eax
+     dcd:	89 44 24 04          	mov    %eax,0x4(%esp)
+     dd1:	8b 45 08             	mov    0x8(%ebp),%eax
+     dd4:	89 04 24             	mov    %eax,(%esp)
+     dd7:	e8 20 ff ff ff       	call   cfc <stosb>
+  return dst;
+     ddc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     ddf:	c9                   	leave  
+     de0:	c3                   	ret    
+
+00000de1 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+     de1:	55                   	push   %ebp
+     de2:	89 e5                	mov    %esp,%ebp
+     de4:	83 ec 04             	sub    $0x4,%esp
+     de7:	8b 45 0c             	mov    0xc(%ebp),%eax
+     dea:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+     ded:	eb 14                	jmp    e03 <strchr+0x22>
+    if(*s == c)
+     def:	8b 45 08             	mov    0x8(%ebp),%eax
+     df2:	0f b6 00             	movzbl (%eax),%eax
+     df5:	3a 45 fc             	cmp    -0x4(%ebp),%al
+     df8:	75 05                	jne    dff <strchr+0x1e>
+      return (char*)s;
+     dfa:	8b 45 08             	mov    0x8(%ebp),%eax
+     dfd:	eb 13                	jmp    e12 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+     dff:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+     e03:	8b 45 08             	mov    0x8(%ebp),%eax
+     e06:	0f b6 00             	movzbl (%eax),%eax
+     e09:	84 c0                	test   %al,%al
+     e0b:	75 e2                	jne    def <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+     e0d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+     e12:	c9                   	leave  
+     e13:	c3                   	ret    
+
+00000e14 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+     e14:	55                   	push   %ebp
+     e15:	89 e5                	mov    %esp,%ebp
+     e17:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+     e1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     e21:	eb 46                	jmp    e69 <gets+0x55>
+    cc = read(0, &c, 1);
+     e23:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+     e2a:	00 
+     e2b:	8d 45 ef             	lea    -0x11(%ebp),%eax
+     e2e:	89 44 24 04          	mov    %eax,0x4(%esp)
+     e32:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+     e39:	e8 3e 01 00 00       	call   f7c <read>
+     e3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+     e41:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     e45:	7e 2f                	jle    e76 <gets+0x62>
+      break;
+    buf[i++] = c;
+     e47:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     e4a:	8b 45 08             	mov    0x8(%ebp),%eax
+     e4d:	01 c2                	add    %eax,%edx
+     e4f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+     e53:	88 02                	mov    %al,(%edx)
+     e55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+     e59:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+     e5d:	3c 0a                	cmp    $0xa,%al
+     e5f:	74 16                	je     e77 <gets+0x63>
+     e61:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+     e65:	3c 0d                	cmp    $0xd,%al
+     e67:	74 0e                	je     e77 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+     e69:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     e6c:	83 c0 01             	add    $0x1,%eax
+     e6f:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     e72:	7c af                	jl     e23 <gets+0xf>
+     e74:	eb 01                	jmp    e77 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+     e76:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+     e77:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     e7a:	8b 45 08             	mov    0x8(%ebp),%eax
+     e7d:	01 d0                	add    %edx,%eax
+     e7f:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+     e82:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     e85:	c9                   	leave  
+     e86:	c3                   	ret    
+
+00000e87 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+     e87:	55                   	push   %ebp
+     e88:	89 e5                	mov    %esp,%ebp
+     e8a:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+     e8d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     e94:	00 
+     e95:	8b 45 08             	mov    0x8(%ebp),%eax
+     e98:	89 04 24             	mov    %eax,(%esp)
+     e9b:	e8 04 01 00 00       	call   fa4 <open>
+     ea0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+     ea3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     ea7:	79 07                	jns    eb0 <stat+0x29>
+    return -1;
+     ea9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+     eae:	eb 23                	jmp    ed3 <stat+0x4c>
+  r = fstat(fd, st);
+     eb0:	8b 45 0c             	mov    0xc(%ebp),%eax
+     eb3:	89 44 24 04          	mov    %eax,0x4(%esp)
+     eb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     eba:	89 04 24             	mov    %eax,(%esp)
+     ebd:	e8 fa 00 00 00       	call   fbc <fstat>
+     ec2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+     ec5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     ec8:	89 04 24             	mov    %eax,(%esp)
+     ecb:	e8 bc 00 00 00       	call   f8c <close>
+  return r;
+     ed0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     ed3:	c9                   	leave  
+     ed4:	c3                   	ret    
+
+00000ed5 <atoi>:
+
+int
+atoi(const char *s)
+{
+     ed5:	55                   	push   %ebp
+     ed6:	89 e5                	mov    %esp,%ebp
+     ed8:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+     edb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+     ee2:	eb 23                	jmp    f07 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+     ee4:	8b 55 fc             	mov    -0x4(%ebp),%edx
+     ee7:	89 d0                	mov    %edx,%eax
+     ee9:	c1 e0 02             	shl    $0x2,%eax
+     eec:	01 d0                	add    %edx,%eax
+     eee:	01 c0                	add    %eax,%eax
+     ef0:	89 c2                	mov    %eax,%edx
+     ef2:	8b 45 08             	mov    0x8(%ebp),%eax
+     ef5:	0f b6 00             	movzbl (%eax),%eax
+     ef8:	0f be c0             	movsbl %al,%eax
+     efb:	01 d0                	add    %edx,%eax
+     efd:	83 e8 30             	sub    $0x30,%eax
+     f00:	89 45 fc             	mov    %eax,-0x4(%ebp)
+     f03:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+     f07:	8b 45 08             	mov    0x8(%ebp),%eax
+     f0a:	0f b6 00             	movzbl (%eax),%eax
+     f0d:	3c 2f                	cmp    $0x2f,%al
+     f0f:	7e 0a                	jle    f1b <atoi+0x46>
+     f11:	8b 45 08             	mov    0x8(%ebp),%eax
+     f14:	0f b6 00             	movzbl (%eax),%eax
+     f17:	3c 39                	cmp    $0x39,%al
+     f19:	7e c9                	jle    ee4 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+     f1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+     f1e:	c9                   	leave  
+     f1f:	c3                   	ret    
+
+00000f20 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+     f20:	55                   	push   %ebp
+     f21:	89 e5                	mov    %esp,%ebp
+     f23:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+     f26:	8b 45 08             	mov    0x8(%ebp),%eax
+     f29:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+     f2c:	8b 45 0c             	mov    0xc(%ebp),%eax
+     f2f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+     f32:	eb 13                	jmp    f47 <memmove+0x27>
+    *dst++ = *src++;
+     f34:	8b 45 f8             	mov    -0x8(%ebp),%eax
+     f37:	0f b6 10             	movzbl (%eax),%edx
+     f3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+     f3d:	88 10                	mov    %dl,(%eax)
+     f3f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+     f43:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+     f47:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+     f4b:	0f 9f c0             	setg   %al
+     f4e:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+     f52:	84 c0                	test   %al,%al
+     f54:	75 de                	jne    f34 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+     f56:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     f59:	c9                   	leave  
+     f5a:	c3                   	ret    
+     f5b:	90                   	nop
+
+00000f5c <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+     f5c:	b8 01 00 00 00       	mov    $0x1,%eax
+     f61:	cd 40                	int    $0x40
+     f63:	c3                   	ret    
+
+00000f64 <exit>:
+SYSCALL(exit)
+     f64:	b8 02 00 00 00       	mov    $0x2,%eax
+     f69:	cd 40                	int    $0x40
+     f6b:	c3                   	ret    
+
+00000f6c <wait>:
+SYSCALL(wait)
+     f6c:	b8 03 00 00 00       	mov    $0x3,%eax
+     f71:	cd 40                	int    $0x40
+     f73:	c3                   	ret    
+
+00000f74 <pipe>:
+SYSCALL(pipe)
+     f74:	b8 04 00 00 00       	mov    $0x4,%eax
+     f79:	cd 40                	int    $0x40
+     f7b:	c3                   	ret    
+
+00000f7c <read>:
+SYSCALL(read)
+     f7c:	b8 05 00 00 00       	mov    $0x5,%eax
+     f81:	cd 40                	int    $0x40
+     f83:	c3                   	ret    
+
+00000f84 <write>:
+SYSCALL(write)
+     f84:	b8 10 00 00 00       	mov    $0x10,%eax
+     f89:	cd 40                	int    $0x40
+     f8b:	c3                   	ret    
+
+00000f8c <close>:
+SYSCALL(close)
+     f8c:	b8 15 00 00 00       	mov    $0x15,%eax
+     f91:	cd 40                	int    $0x40
+     f93:	c3                   	ret    
+
+00000f94 <kill>:
+SYSCALL(kill)
+     f94:	b8 06 00 00 00       	mov    $0x6,%eax
+     f99:	cd 40                	int    $0x40
+     f9b:	c3                   	ret    
+
+00000f9c <exec>:
+SYSCALL(exec)
+     f9c:	b8 07 00 00 00       	mov    $0x7,%eax
+     fa1:	cd 40                	int    $0x40
+     fa3:	c3                   	ret    
+
+00000fa4 <open>:
+SYSCALL(open)
+     fa4:	b8 0f 00 00 00       	mov    $0xf,%eax
+     fa9:	cd 40                	int    $0x40
+     fab:	c3                   	ret    
+
+00000fac <mknod>:
+SYSCALL(mknod)
+     fac:	b8 11 00 00 00       	mov    $0x11,%eax
+     fb1:	cd 40                	int    $0x40
+     fb3:	c3                   	ret    
+
+00000fb4 <unlink>:
+SYSCALL(unlink)
+     fb4:	b8 12 00 00 00       	mov    $0x12,%eax
+     fb9:	cd 40                	int    $0x40
+     fbb:	c3                   	ret    
+
+00000fbc <fstat>:
+SYSCALL(fstat)
+     fbc:	b8 08 00 00 00       	mov    $0x8,%eax
+     fc1:	cd 40                	int    $0x40
+     fc3:	c3                   	ret    
+
+00000fc4 <link>:
+SYSCALL(link)
+     fc4:	b8 13 00 00 00       	mov    $0x13,%eax
+     fc9:	cd 40                	int    $0x40
+     fcb:	c3                   	ret    
+
+00000fcc <mkdir>:
+SYSCALL(mkdir)
+     fcc:	b8 14 00 00 00       	mov    $0x14,%eax
+     fd1:	cd 40                	int    $0x40
+     fd3:	c3                   	ret    
+
+00000fd4 <chdir>:
+SYSCALL(chdir)
+     fd4:	b8 09 00 00 00       	mov    $0x9,%eax
+     fd9:	cd 40                	int    $0x40
+     fdb:	c3                   	ret    
+
+00000fdc <dup>:
+SYSCALL(dup)
+     fdc:	b8 0a 00 00 00       	mov    $0xa,%eax
+     fe1:	cd 40                	int    $0x40
+     fe3:	c3                   	ret    
+
+00000fe4 <getpid>:
+SYSCALL(getpid)
+     fe4:	b8 0b 00 00 00       	mov    $0xb,%eax
+     fe9:	cd 40                	int    $0x40
+     feb:	c3                   	ret    
+
+00000fec <sbrk>:
+SYSCALL(sbrk)
+     fec:	b8 0c 00 00 00       	mov    $0xc,%eax
+     ff1:	cd 40                	int    $0x40
+     ff3:	c3                   	ret    
+
+00000ff4 <sleep>:
+SYSCALL(sleep)
+     ff4:	b8 0d 00 00 00       	mov    $0xd,%eax
+     ff9:	cd 40                	int    $0x40
+     ffb:	c3                   	ret    
+
+00000ffc <uptime>:
+SYSCALL(uptime)
+     ffc:	b8 0e 00 00 00       	mov    $0xe,%eax
+    1001:	cd 40                	int    $0x40
+    1003:	c3                   	ret    
+
+00001004 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+    1004:	b8 16 00 00 00       	mov    $0x16,%eax
+    1009:	cd 40                	int    $0x40
+    100b:	c3                   	ret    
+
+0000100c <shutdown>:
+SYSCALL(shutdown)
+    100c:	b8 17 00 00 00       	mov    $0x17,%eax
+    1011:	cd 40                	int    $0x40
+    1013:	c3                   	ret    
+
+00001014 <fork_winner>:
+SYSCALL(fork_winner)
+    1014:	b8 18 00 00 00       	mov    $0x18,%eax
+    1019:	cd 40                	int    $0x40
+    101b:	c3                   	ret    
+
+0000101c <set_sched>:
+SYSCALL(set_sched)
+    101c:	b8 19 00 00 00       	mov    $0x19,%eax
+    1021:	cd 40                	int    $0x40
+    1023:	c3                   	ret    
+
+00001024 <set_priority>:
+SYSCALL(set_priority)
+    1024:	b8 1a 00 00 00       	mov    $0x1a,%eax
+    1029:	cd 40                	int    $0x40
+    102b:	c3                   	ret    
+
+0000102c <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+    102c:	55                   	push   %ebp
+    102d:	89 e5                	mov    %esp,%ebp
+    102f:	83 ec 28             	sub    $0x28,%esp
+    1032:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1035:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+    1038:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    103f:	00 
+    1040:	8d 45 f4             	lea    -0xc(%ebp),%eax
+    1043:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1047:	8b 45 08             	mov    0x8(%ebp),%eax
+    104a:	89 04 24             	mov    %eax,(%esp)
+    104d:	e8 32 ff ff ff       	call   f84 <write>
+}
+    1052:	c9                   	leave  
+    1053:	c3                   	ret    
+
+00001054 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1054:	55                   	push   %ebp
+    1055:	89 e5                	mov    %esp,%ebp
+    1057:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+    105a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+    1061:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+    1065:	74 17                	je     107e <printint+0x2a>
+    1067:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+    106b:	79 11                	jns    107e <printint+0x2a>
+    neg = 1;
+    106d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+    1074:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1077:	f7 d8                	neg    %eax
+    1079:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    107c:	eb 06                	jmp    1084 <printint+0x30>
+  } else {
+    x = xx;
+    107e:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1081:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+    1084:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+    108b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    108e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    1091:	ba 00 00 00 00       	mov    $0x0,%edx
+    1096:	f7 f1                	div    %ecx
+    1098:	89 d0                	mov    %edx,%eax
+    109a:	0f b6 80 5c 1a 00 00 	movzbl 0x1a5c(%eax),%eax
+    10a1:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+    10a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    10a7:	01 ca                	add    %ecx,%edx
+    10a9:	88 02                	mov    %al,(%edx)
+    10ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+    10af:	8b 55 10             	mov    0x10(%ebp),%edx
+    10b2:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    10b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    10b8:	ba 00 00 00 00       	mov    $0x0,%edx
+    10bd:	f7 75 d4             	divl   -0x2c(%ebp)
+    10c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    10c3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    10c7:	75 c2                	jne    108b <printint+0x37>
+  if(neg)
+    10c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    10cd:	74 2e                	je     10fd <printint+0xa9>
+    buf[i++] = '-';
+    10cf:	8d 55 dc             	lea    -0x24(%ebp),%edx
+    10d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    10d5:	01 d0                	add    %edx,%eax
+    10d7:	c6 00 2d             	movb   $0x2d,(%eax)
+    10da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+    10de:	eb 1d                	jmp    10fd <printint+0xa9>
+    putc(fd, buf[i]);
+    10e0:	8d 55 dc             	lea    -0x24(%ebp),%edx
+    10e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    10e6:	01 d0                	add    %edx,%eax
+    10e8:	0f b6 00             	movzbl (%eax),%eax
+    10eb:	0f be c0             	movsbl %al,%eax
+    10ee:	89 44 24 04          	mov    %eax,0x4(%esp)
+    10f2:	8b 45 08             	mov    0x8(%ebp),%eax
+    10f5:	89 04 24             	mov    %eax,(%esp)
+    10f8:	e8 2f ff ff ff       	call   102c <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+    10fd:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    1101:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1105:	79 d9                	jns    10e0 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+    1107:	c9                   	leave  
+    1108:	c3                   	ret    
+
+00001109 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1109:	55                   	push   %ebp
+    110a:	89 e5                	mov    %esp,%ebp
+    110c:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    110f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+    1116:	8d 45 0c             	lea    0xc(%ebp),%eax
+    1119:	83 c0 04             	add    $0x4,%eax
+    111c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+    111f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    1126:	e9 7d 01 00 00       	jmp    12a8 <printf+0x19f>
+    c = fmt[i] & 0xff;
+    112b:	8b 55 0c             	mov    0xc(%ebp),%edx
+    112e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1131:	01 d0                	add    %edx,%eax
+    1133:	0f b6 00             	movzbl (%eax),%eax
+    1136:	0f be c0             	movsbl %al,%eax
+    1139:	25 ff 00 00 00       	and    $0xff,%eax
+    113e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+    1141:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1145:	75 2c                	jne    1173 <printf+0x6a>
+      if(c == '%'){
+    1147:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    114b:	75 0c                	jne    1159 <printf+0x50>
+        state = '%';
+    114d:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+    1154:	e9 4b 01 00 00       	jmp    12a4 <printf+0x19b>
+      } else {
+        putc(fd, c);
+    1159:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    115c:	0f be c0             	movsbl %al,%eax
+    115f:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1163:	8b 45 08             	mov    0x8(%ebp),%eax
+    1166:	89 04 24             	mov    %eax,(%esp)
+    1169:	e8 be fe ff ff       	call   102c <putc>
+    116e:	e9 31 01 00 00       	jmp    12a4 <printf+0x19b>
+      }
+    } else if(state == '%'){
+    1173:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+    1177:	0f 85 27 01 00 00    	jne    12a4 <printf+0x19b>
+      if(c == 'd'){
+    117d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+    1181:	75 2d                	jne    11b0 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+    1183:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1186:	8b 00                	mov    (%eax),%eax
+    1188:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+    118f:	00 
+    1190:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    1197:	00 
+    1198:	89 44 24 04          	mov    %eax,0x4(%esp)
+    119c:	8b 45 08             	mov    0x8(%ebp),%eax
+    119f:	89 04 24             	mov    %eax,(%esp)
+    11a2:	e8 ad fe ff ff       	call   1054 <printint>
+        ap++;
+    11a7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    11ab:	e9 ed 00 00 00       	jmp    129d <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+    11b0:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+    11b4:	74 06                	je     11bc <printf+0xb3>
+    11b6:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+    11ba:	75 2d                	jne    11e9 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+    11bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    11bf:	8b 00                	mov    (%eax),%eax
+    11c1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    11c8:	00 
+    11c9:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+    11d0:	00 
+    11d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+    11d5:	8b 45 08             	mov    0x8(%ebp),%eax
+    11d8:	89 04 24             	mov    %eax,(%esp)
+    11db:	e8 74 fe ff ff       	call   1054 <printint>
+        ap++;
+    11e0:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    11e4:	e9 b4 00 00 00       	jmp    129d <printf+0x194>
+      } else if(c == 's'){
+    11e9:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+    11ed:	75 46                	jne    1235 <printf+0x12c>
+        s = (char*)*ap;
+    11ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    11f2:	8b 00                	mov    (%eax),%eax
+    11f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+    11f7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+    11fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    11ff:	75 27                	jne    1228 <printf+0x11f>
+          s = "(null)";
+    1201:	c7 45 f4 cc 15 00 00 	movl   $0x15cc,-0xc(%ebp)
+        while(*s != 0){
+    1208:	eb 1e                	jmp    1228 <printf+0x11f>
+          putc(fd, *s);
+    120a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    120d:	0f b6 00             	movzbl (%eax),%eax
+    1210:	0f be c0             	movsbl %al,%eax
+    1213:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1217:	8b 45 08             	mov    0x8(%ebp),%eax
+    121a:	89 04 24             	mov    %eax,(%esp)
+    121d:	e8 0a fe ff ff       	call   102c <putc>
+          s++;
+    1222:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1226:	eb 01                	jmp    1229 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+    1228:	90                   	nop
+    1229:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    122c:	0f b6 00             	movzbl (%eax),%eax
+    122f:	84 c0                	test   %al,%al
+    1231:	75 d7                	jne    120a <printf+0x101>
+    1233:	eb 68                	jmp    129d <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1235:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+    1239:	75 1d                	jne    1258 <printf+0x14f>
+        putc(fd, *ap);
+    123b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    123e:	8b 00                	mov    (%eax),%eax
+    1240:	0f be c0             	movsbl %al,%eax
+    1243:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1247:	8b 45 08             	mov    0x8(%ebp),%eax
+    124a:	89 04 24             	mov    %eax,(%esp)
+    124d:	e8 da fd ff ff       	call   102c <putc>
+        ap++;
+    1252:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    1256:	eb 45                	jmp    129d <printf+0x194>
+      } else if(c == '%'){
+    1258:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    125c:	75 17                	jne    1275 <printf+0x16c>
+        putc(fd, c);
+    125e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1261:	0f be c0             	movsbl %al,%eax
+    1264:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1268:	8b 45 08             	mov    0x8(%ebp),%eax
+    126b:	89 04 24             	mov    %eax,(%esp)
+    126e:	e8 b9 fd ff ff       	call   102c <putc>
+    1273:	eb 28                	jmp    129d <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+    1275:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+    127c:	00 
+    127d:	8b 45 08             	mov    0x8(%ebp),%eax
+    1280:	89 04 24             	mov    %eax,(%esp)
+    1283:	e8 a4 fd ff ff       	call   102c <putc>
+        putc(fd, c);
+    1288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    128b:	0f be c0             	movsbl %al,%eax
+    128e:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1292:	8b 45 08             	mov    0x8(%ebp),%eax
+    1295:	89 04 24             	mov    %eax,(%esp)
+    1298:	e8 8f fd ff ff       	call   102c <putc>
+      }
+      state = 0;
+    129d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    12a4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    12a8:	8b 55 0c             	mov    0xc(%ebp),%edx
+    12ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    12ae:	01 d0                	add    %edx,%eax
+    12b0:	0f b6 00             	movzbl (%eax),%eax
+    12b3:	84 c0                	test   %al,%al
+    12b5:	0f 85 70 fe ff ff    	jne    112b <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+    12bb:	c9                   	leave  
+    12bc:	c3                   	ret    
+    12bd:	90                   	nop
+    12be:	90                   	nop
+    12bf:	90                   	nop
+
+000012c0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    12c0:	55                   	push   %ebp
+    12c1:	89 e5                	mov    %esp,%ebp
+    12c3:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+    12c6:	8b 45 08             	mov    0x8(%ebp),%eax
+    12c9:	83 e8 08             	sub    $0x8,%eax
+    12cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    12cf:	a1 ec 1a 00 00       	mov    0x1aec,%eax
+    12d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    12d7:	eb 24                	jmp    12fd <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    12d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12dc:	8b 00                	mov    (%eax),%eax
+    12de:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    12e1:	77 12                	ja     12f5 <free+0x35>
+    12e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    12e6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    12e9:	77 24                	ja     130f <free+0x4f>
+    12eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12ee:	8b 00                	mov    (%eax),%eax
+    12f0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+    12f3:	77 1a                	ja     130f <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    12f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12f8:	8b 00                	mov    (%eax),%eax
+    12fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    12fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1300:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    1303:	76 d4                	jbe    12d9 <free+0x19>
+    1305:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1308:	8b 00                	mov    (%eax),%eax
+    130a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+    130d:	76 ca                	jbe    12d9 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    130f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1312:	8b 40 04             	mov    0x4(%eax),%eax
+    1315:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    131c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    131f:	01 c2                	add    %eax,%edx
+    1321:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1324:	8b 00                	mov    (%eax),%eax
+    1326:	39 c2                	cmp    %eax,%edx
+    1328:	75 24                	jne    134e <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+    132a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    132d:	8b 50 04             	mov    0x4(%eax),%edx
+    1330:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1333:	8b 00                	mov    (%eax),%eax
+    1335:	8b 40 04             	mov    0x4(%eax),%eax
+    1338:	01 c2                	add    %eax,%edx
+    133a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    133d:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    1340:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1343:	8b 00                	mov    (%eax),%eax
+    1345:	8b 10                	mov    (%eax),%edx
+    1347:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    134a:	89 10                	mov    %edx,(%eax)
+    134c:	eb 0a                	jmp    1358 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+    134e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1351:	8b 10                	mov    (%eax),%edx
+    1353:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1356:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+    1358:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    135b:	8b 40 04             	mov    0x4(%eax),%eax
+    135e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    1365:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1368:	01 d0                	add    %edx,%eax
+    136a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+    136d:	75 20                	jne    138f <free+0xcf>
+    p->s.size += bp->s.size;
+    136f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1372:	8b 50 04             	mov    0x4(%eax),%edx
+    1375:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1378:	8b 40 04             	mov    0x4(%eax),%eax
+    137b:	01 c2                	add    %eax,%edx
+    137d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1380:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    1383:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1386:	8b 10                	mov    (%eax),%edx
+    1388:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    138b:	89 10                	mov    %edx,(%eax)
+    138d:	eb 08                	jmp    1397 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+    138f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1392:	8b 55 f8             	mov    -0x8(%ebp),%edx
+    1395:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1397:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    139a:	a3 ec 1a 00 00       	mov    %eax,0x1aec
+}
+    139f:	c9                   	leave  
+    13a0:	c3                   	ret    
+
+000013a1 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+    13a1:	55                   	push   %ebp
+    13a2:	89 e5                	mov    %esp,%ebp
+    13a4:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+    13a7:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+    13ae:	77 07                	ja     13b7 <morecore+0x16>
+    nu = 4096;
+    13b0:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+    13b7:	8b 45 08             	mov    0x8(%ebp),%eax
+    13ba:	c1 e0 03             	shl    $0x3,%eax
+    13bd:	89 04 24             	mov    %eax,(%esp)
+    13c0:	e8 27 fc ff ff       	call   fec <sbrk>
+    13c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+    13c8:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+    13cc:	75 07                	jne    13d5 <morecore+0x34>
+    return 0;
+    13ce:	b8 00 00 00 00       	mov    $0x0,%eax
+    13d3:	eb 22                	jmp    13f7 <morecore+0x56>
+  hp = (Header*)p;
+    13d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    13d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+    13db:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    13de:	8b 55 08             	mov    0x8(%ebp),%edx
+    13e1:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+    13e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    13e7:	83 c0 08             	add    $0x8,%eax
+    13ea:	89 04 24             	mov    %eax,(%esp)
+    13ed:	e8 ce fe ff ff       	call   12c0 <free>
+  return freep;
+    13f2:	a1 ec 1a 00 00       	mov    0x1aec,%eax
+}
+    13f7:	c9                   	leave  
+    13f8:	c3                   	ret    
+
+000013f9 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+    13f9:	55                   	push   %ebp
+    13fa:	89 e5                	mov    %esp,%ebp
+    13fc:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    13ff:	8b 45 08             	mov    0x8(%ebp),%eax
+    1402:	83 c0 07             	add    $0x7,%eax
+    1405:	c1 e8 03             	shr    $0x3,%eax
+    1408:	83 c0 01             	add    $0x1,%eax
+    140b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+    140e:	a1 ec 1a 00 00       	mov    0x1aec,%eax
+    1413:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    1416:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    141a:	75 23                	jne    143f <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+    141c:	c7 45 f0 e4 1a 00 00 	movl   $0x1ae4,-0x10(%ebp)
+    1423:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1426:	a3 ec 1a 00 00       	mov    %eax,0x1aec
+    142b:	a1 ec 1a 00 00       	mov    0x1aec,%eax
+    1430:	a3 e4 1a 00 00       	mov    %eax,0x1ae4
+    base.s.size = 0;
+    1435:	c7 05 e8 1a 00 00 00 	movl   $0x0,0x1ae8
+    143c:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    143f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1442:	8b 00                	mov    (%eax),%eax
+    1444:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+    1447:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    144a:	8b 40 04             	mov    0x4(%eax),%eax
+    144d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+    1450:	72 4d                	jb     149f <malloc+0xa6>
+      if(p->s.size == nunits)
+    1452:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1455:	8b 40 04             	mov    0x4(%eax),%eax
+    1458:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+    145b:	75 0c                	jne    1469 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+    145d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1460:	8b 10                	mov    (%eax),%edx
+    1462:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1465:	89 10                	mov    %edx,(%eax)
+    1467:	eb 26                	jmp    148f <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+    1469:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    146c:	8b 40 04             	mov    0x4(%eax),%eax
+    146f:	89 c2                	mov    %eax,%edx
+    1471:	2b 55 ec             	sub    -0x14(%ebp),%edx
+    1474:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1477:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+    147a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    147d:	8b 40 04             	mov    0x4(%eax),%eax
+    1480:	c1 e0 03             	shl    $0x3,%eax
+    1483:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+    1486:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1489:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    148c:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+    148f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1492:	a3 ec 1a 00 00       	mov    %eax,0x1aec
+      return (void*)(p + 1);
+    1497:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    149a:	83 c0 08             	add    $0x8,%eax
+    149d:	eb 38                	jmp    14d7 <malloc+0xde>
+    }
+    if(p == freep)
+    149f:	a1 ec 1a 00 00       	mov    0x1aec,%eax
+    14a4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+    14a7:	75 1b                	jne    14c4 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+    14a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    14ac:	89 04 24             	mov    %eax,(%esp)
+    14af:	e8 ed fe ff ff       	call   13a1 <morecore>
+    14b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    14b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    14bb:	75 07                	jne    14c4 <malloc+0xcb>
+        return 0;
+    14bd:	b8 00 00 00 00       	mov    $0x0,%eax
+    14c2:	eb 13                	jmp    14d7 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    14c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    14c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    14ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    14cd:	8b 00                	mov    (%eax),%eax
+    14cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+    14d2:	e9 70 ff ff ff       	jmp    1447 <malloc+0x4e>
+}
+    14d7:	c9                   	leave  
+    14d8:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/sh.d cs550-16s-proj1-working/sh.d
--- cs550-16s-proj1-base/sh.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/sh.d	2016-03-04 14:37:05.000000000 -0500
@@ -0,0 +1 @@
+sh.o: sh.c types.h user.h fcntl.h
Binary files cs550-16s-proj1-base/sh.o and cs550-16s-proj1-working/sh.o differ
diff -uNr cs550-16s-proj1-base/sh.sym cs550-16s-proj1-working/sh.sym
--- cs550-16s-proj1-base/sh.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/sh.sym	2016-03-04 14:37:06.000000000 -0500
@@ -0,0 +1,86 @@
+00000000 .text
+000014dc .rodata
+000015d4 .eh_frame
+00001a4c .data
+00001a80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 sh.c
+00001a80 buf.1066
+00000000 ulib.c
+00000cfc stosb
+00000000 printf.c
+0000102c putc
+00001054 printint
+00001a5c digits.1028
+00000000 umalloc.c
+00001ae4 base
+00001aec freep
+000013a1 morecore
+00000d21 strcpy
+00001109 printf
+00000f20 memmove
+00000fac mknod
+000003a5 execcmd
+00000e14 gets
+00000fe4 getpid
+00000852 parsepipe
+000006f2 parsecmd
+000004ee backcmd
+0000067d peek
+000008d6 parseredirs
+00000535 gettoken
+000013f9 malloc
+00000ff4 sleep
+00001a4c whitespace
+00001024 set_priority
+00000380 fork1
+00000c1a nulterminate
+00000f74 pipe
+00000209 getcmd
+00000f84 write
+00000fbc fstat
+00000f94 kill
+00000fd4 chdir
+0000077e parseline
+00000000 runcmd
+000009fe parseblock
+00000f9c exec
+00000f6c wait
+00001a52 symbols
+00000f7c read
+00000ad2 parseexec
+00000fb4 unlink
+0000035a panic
+00000f5c fork
+00000fec sbrk
+00000ffc uptime
+00001a70 __bss_start
+00000dbd memset
+00000267 main
+00001004 enable_sched_trace
+00000d55 strcmp
+0000100c shutdown
+00000fdc dup
+0000044e pipecmd
+000003e3 redircmd
+0000101c set_sched
+00000e87 stat
+00001a70 _edata
+00001af0 _end
+00000fc4 link
+00000f64 exit
+00000ed5 atoi
+00001014 fork_winner
+00000d96 strlen
+00000fa4 open
+00000de1 strchr
+00000fcc mkdir
+00000f8c close
+0000049e listcmd
+000012c0 free
Binary files cs550-16s-proj1-base/_shutdown and cs550-16s-proj1-working/_shutdown differ
diff -uNr cs550-16s-proj1-base/shutdown.asm cs550-16s-proj1-working/shutdown.asm
--- cs550-16s-proj1-base/shutdown.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/shutdown.asm	2016-03-04 14:37:11.000000000 -0500
@@ -0,0 +1,1181 @@
+
+_shutdown:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+   REMEMBER to disable the stub functions (by commenting the following macro) to 
+   allow your implementation to work properly. */
+
+int 
+main(int argc, char * argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+    shutdown();
+   6:	e8 19 03 00 00       	call   324 <shutdown>
+    return 0;
+   b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  10:	c9                   	leave  
+  11:	c3                   	ret    
+  12:	90                   	nop
+  13:	90                   	nop
+
+00000014 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  14:	55                   	push   %ebp
+  15:	89 e5                	mov    %esp,%ebp
+  17:	57                   	push   %edi
+  18:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  19:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  1c:	8b 55 10             	mov    0x10(%ebp),%edx
+  1f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  22:	89 cb                	mov    %ecx,%ebx
+  24:	89 df                	mov    %ebx,%edi
+  26:	89 d1                	mov    %edx,%ecx
+  28:	fc                   	cld    
+  29:	f3 aa                	rep stos %al,%es:(%edi)
+  2b:	89 ca                	mov    %ecx,%edx
+  2d:	89 fb                	mov    %edi,%ebx
+  2f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  32:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  35:	5b                   	pop    %ebx
+  36:	5f                   	pop    %edi
+  37:	5d                   	pop    %ebp
+  38:	c3                   	ret    
+
+00000039 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  39:	55                   	push   %ebp
+  3a:	89 e5                	mov    %esp,%ebp
+  3c:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  3f:	8b 45 08             	mov    0x8(%ebp),%eax
+  42:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  45:	90                   	nop
+  46:	8b 45 0c             	mov    0xc(%ebp),%eax
+  49:	0f b6 10             	movzbl (%eax),%edx
+  4c:	8b 45 08             	mov    0x8(%ebp),%eax
+  4f:	88 10                	mov    %dl,(%eax)
+  51:	8b 45 08             	mov    0x8(%ebp),%eax
+  54:	0f b6 00             	movzbl (%eax),%eax
+  57:	84 c0                	test   %al,%al
+  59:	0f 95 c0             	setne  %al
+  5c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  60:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  64:	84 c0                	test   %al,%al
+  66:	75 de                	jne    46 <strcpy+0xd>
+    ;
+  return os;
+  68:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  6b:	c9                   	leave  
+  6c:	c3                   	ret    
+
+0000006d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  6d:	55                   	push   %ebp
+  6e:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  70:	eb 08                	jmp    7a <strcmp+0xd>
+    p++, q++;
+  72:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  76:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  7a:	8b 45 08             	mov    0x8(%ebp),%eax
+  7d:	0f b6 00             	movzbl (%eax),%eax
+  80:	84 c0                	test   %al,%al
+  82:	74 10                	je     94 <strcmp+0x27>
+  84:	8b 45 08             	mov    0x8(%ebp),%eax
+  87:	0f b6 10             	movzbl (%eax),%edx
+  8a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8d:	0f b6 00             	movzbl (%eax),%eax
+  90:	38 c2                	cmp    %al,%dl
+  92:	74 de                	je     72 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+  94:	8b 45 08             	mov    0x8(%ebp),%eax
+  97:	0f b6 00             	movzbl (%eax),%eax
+  9a:	0f b6 d0             	movzbl %al,%edx
+  9d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  a0:	0f b6 00             	movzbl (%eax),%eax
+  a3:	0f b6 c0             	movzbl %al,%eax
+  a6:	89 d1                	mov    %edx,%ecx
+  a8:	29 c1                	sub    %eax,%ecx
+  aa:	89 c8                	mov    %ecx,%eax
+}
+  ac:	5d                   	pop    %ebp
+  ad:	c3                   	ret    
+
+000000ae <strlen>:
+
+uint
+strlen(char *s)
+{
+  ae:	55                   	push   %ebp
+  af:	89 e5                	mov    %esp,%ebp
+  b1:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+  b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  bb:	eb 04                	jmp    c1 <strlen+0x13>
+  bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  c7:	01 d0                	add    %edx,%eax
+  c9:	0f b6 00             	movzbl (%eax),%eax
+  cc:	84 c0                	test   %al,%al
+  ce:	75 ed                	jne    bd <strlen+0xf>
+    ;
+  return n;
+  d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  d3:	c9                   	leave  
+  d4:	c3                   	ret    
+
+000000d5 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  d5:	55                   	push   %ebp
+  d6:	89 e5                	mov    %esp,%ebp
+  d8:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+  db:	8b 45 10             	mov    0x10(%ebp),%eax
+  de:	89 44 24 08          	mov    %eax,0x8(%esp)
+  e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  e9:	8b 45 08             	mov    0x8(%ebp),%eax
+  ec:	89 04 24             	mov    %eax,(%esp)
+  ef:	e8 20 ff ff ff       	call   14 <stosb>
+  return dst;
+  f4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  f7:	c9                   	leave  
+  f8:	c3                   	ret    
+
+000000f9 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+  f9:	55                   	push   %ebp
+  fa:	89 e5                	mov    %esp,%ebp
+  fc:	83 ec 04             	sub    $0x4,%esp
+  ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 102:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 105:	eb 14                	jmp    11b <strchr+0x22>
+    if(*s == c)
+ 107:	8b 45 08             	mov    0x8(%ebp),%eax
+ 10a:	0f b6 00             	movzbl (%eax),%eax
+ 10d:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 110:	75 05                	jne    117 <strchr+0x1e>
+      return (char*)s;
+ 112:	8b 45 08             	mov    0x8(%ebp),%eax
+ 115:	eb 13                	jmp    12a <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 117:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 11b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11e:	0f b6 00             	movzbl (%eax),%eax
+ 121:	84 c0                	test   %al,%al
+ 123:	75 e2                	jne    107 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 125:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 12a:	c9                   	leave  
+ 12b:	c3                   	ret    
+
+0000012c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 12c:	55                   	push   %ebp
+ 12d:	89 e5                	mov    %esp,%ebp
+ 12f:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 132:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 139:	eb 46                	jmp    181 <gets+0x55>
+    cc = read(0, &c, 1);
+ 13b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 142:	00 
+ 143:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 146:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 14a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 151:	e8 3e 01 00 00       	call   294 <read>
+ 156:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 159:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 15d:	7e 2f                	jle    18e <gets+0x62>
+      break;
+    buf[i++] = c;
+ 15f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 162:	8b 45 08             	mov    0x8(%ebp),%eax
+ 165:	01 c2                	add    %eax,%edx
+ 167:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 16b:	88 02                	mov    %al,(%edx)
+ 16d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 171:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 175:	3c 0a                	cmp    $0xa,%al
+ 177:	74 16                	je     18f <gets+0x63>
+ 179:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 17d:	3c 0d                	cmp    $0xd,%al
+ 17f:	74 0e                	je     18f <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 181:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 184:	83 c0 01             	add    $0x1,%eax
+ 187:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 18a:	7c af                	jl     13b <gets+0xf>
+ 18c:	eb 01                	jmp    18f <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 18e:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 18f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 192:	8b 45 08             	mov    0x8(%ebp),%eax
+ 195:	01 d0                	add    %edx,%eax
+ 197:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 19a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 19d:	c9                   	leave  
+ 19e:	c3                   	ret    
+
+0000019f <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 19f:	55                   	push   %ebp
+ 1a0:	89 e5                	mov    %esp,%ebp
+ 1a2:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1a5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 1ac:	00 
+ 1ad:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1b0:	89 04 24             	mov    %eax,(%esp)
+ 1b3:	e8 04 01 00 00       	call   2bc <open>
+ 1b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 1bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 1bf:	79 07                	jns    1c8 <stat+0x29>
+    return -1;
+ 1c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 1c6:	eb 23                	jmp    1eb <stat+0x4c>
+  r = fstat(fd, st);
+ 1c8:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1d2:	89 04 24             	mov    %eax,(%esp)
+ 1d5:	e8 fa 00 00 00       	call   2d4 <fstat>
+ 1da:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 1dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1e0:	89 04 24             	mov    %eax,(%esp)
+ 1e3:	e8 bc 00 00 00       	call   2a4 <close>
+  return r;
+ 1e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 1eb:	c9                   	leave  
+ 1ec:	c3                   	ret    
+
+000001ed <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1ed:	55                   	push   %ebp
+ 1ee:	89 e5                	mov    %esp,%ebp
+ 1f0:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 1f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 1fa:	eb 23                	jmp    21f <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 1fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1ff:	89 d0                	mov    %edx,%eax
+ 201:	c1 e0 02             	shl    $0x2,%eax
+ 204:	01 d0                	add    %edx,%eax
+ 206:	01 c0                	add    %eax,%eax
+ 208:	89 c2                	mov    %eax,%edx
+ 20a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20d:	0f b6 00             	movzbl (%eax),%eax
+ 210:	0f be c0             	movsbl %al,%eax
+ 213:	01 d0                	add    %edx,%eax
+ 215:	83 e8 30             	sub    $0x30,%eax
+ 218:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 21b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 21f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 222:	0f b6 00             	movzbl (%eax),%eax
+ 225:	3c 2f                	cmp    $0x2f,%al
+ 227:	7e 0a                	jle    233 <atoi+0x46>
+ 229:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22c:	0f b6 00             	movzbl (%eax),%eax
+ 22f:	3c 39                	cmp    $0x39,%al
+ 231:	7e c9                	jle    1fc <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 233:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 236:	c9                   	leave  
+ 237:	c3                   	ret    
+
+00000238 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 238:	55                   	push   %ebp
+ 239:	89 e5                	mov    %esp,%ebp
+ 23b:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 23e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 241:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 244:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 247:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 24a:	eb 13                	jmp    25f <memmove+0x27>
+    *dst++ = *src++;
+ 24c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 24f:	0f b6 10             	movzbl (%eax),%edx
+ 252:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 255:	88 10                	mov    %dl,(%eax)
+ 257:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 25b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 25f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 263:	0f 9f c0             	setg   %al
+ 266:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 26a:	84 c0                	test   %al,%al
+ 26c:	75 de                	jne    24c <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 26e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 271:	c9                   	leave  
+ 272:	c3                   	ret    
+ 273:	90                   	nop
+
+00000274 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 274:	b8 01 00 00 00       	mov    $0x1,%eax
+ 279:	cd 40                	int    $0x40
+ 27b:	c3                   	ret    
+
+0000027c <exit>:
+SYSCALL(exit)
+ 27c:	b8 02 00 00 00       	mov    $0x2,%eax
+ 281:	cd 40                	int    $0x40
+ 283:	c3                   	ret    
+
+00000284 <wait>:
+SYSCALL(wait)
+ 284:	b8 03 00 00 00       	mov    $0x3,%eax
+ 289:	cd 40                	int    $0x40
+ 28b:	c3                   	ret    
+
+0000028c <pipe>:
+SYSCALL(pipe)
+ 28c:	b8 04 00 00 00       	mov    $0x4,%eax
+ 291:	cd 40                	int    $0x40
+ 293:	c3                   	ret    
+
+00000294 <read>:
+SYSCALL(read)
+ 294:	b8 05 00 00 00       	mov    $0x5,%eax
+ 299:	cd 40                	int    $0x40
+ 29b:	c3                   	ret    
+
+0000029c <write>:
+SYSCALL(write)
+ 29c:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2a1:	cd 40                	int    $0x40
+ 2a3:	c3                   	ret    
+
+000002a4 <close>:
+SYSCALL(close)
+ 2a4:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2a9:	cd 40                	int    $0x40
+ 2ab:	c3                   	ret    
+
+000002ac <kill>:
+SYSCALL(kill)
+ 2ac:	b8 06 00 00 00       	mov    $0x6,%eax
+ 2b1:	cd 40                	int    $0x40
+ 2b3:	c3                   	ret    
+
+000002b4 <exec>:
+SYSCALL(exec)
+ 2b4:	b8 07 00 00 00       	mov    $0x7,%eax
+ 2b9:	cd 40                	int    $0x40
+ 2bb:	c3                   	ret    
+
+000002bc <open>:
+SYSCALL(open)
+ 2bc:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 2c1:	cd 40                	int    $0x40
+ 2c3:	c3                   	ret    
+
+000002c4 <mknod>:
+SYSCALL(mknod)
+ 2c4:	b8 11 00 00 00       	mov    $0x11,%eax
+ 2c9:	cd 40                	int    $0x40
+ 2cb:	c3                   	ret    
+
+000002cc <unlink>:
+SYSCALL(unlink)
+ 2cc:	b8 12 00 00 00       	mov    $0x12,%eax
+ 2d1:	cd 40                	int    $0x40
+ 2d3:	c3                   	ret    
+
+000002d4 <fstat>:
+SYSCALL(fstat)
+ 2d4:	b8 08 00 00 00       	mov    $0x8,%eax
+ 2d9:	cd 40                	int    $0x40
+ 2db:	c3                   	ret    
+
+000002dc <link>:
+SYSCALL(link)
+ 2dc:	b8 13 00 00 00       	mov    $0x13,%eax
+ 2e1:	cd 40                	int    $0x40
+ 2e3:	c3                   	ret    
+
+000002e4 <mkdir>:
+SYSCALL(mkdir)
+ 2e4:	b8 14 00 00 00       	mov    $0x14,%eax
+ 2e9:	cd 40                	int    $0x40
+ 2eb:	c3                   	ret    
+
+000002ec <chdir>:
+SYSCALL(chdir)
+ 2ec:	b8 09 00 00 00       	mov    $0x9,%eax
+ 2f1:	cd 40                	int    $0x40
+ 2f3:	c3                   	ret    
+
+000002f4 <dup>:
+SYSCALL(dup)
+ 2f4:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 2f9:	cd 40                	int    $0x40
+ 2fb:	c3                   	ret    
+
+000002fc <getpid>:
+SYSCALL(getpid)
+ 2fc:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 301:	cd 40                	int    $0x40
+ 303:	c3                   	ret    
+
+00000304 <sbrk>:
+SYSCALL(sbrk)
+ 304:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 309:	cd 40                	int    $0x40
+ 30b:	c3                   	ret    
+
+0000030c <sleep>:
+SYSCALL(sleep)
+ 30c:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 311:	cd 40                	int    $0x40
+ 313:	c3                   	ret    
+
+00000314 <uptime>:
+SYSCALL(uptime)
+ 314:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 319:	cd 40                	int    $0x40
+ 31b:	c3                   	ret    
+
+0000031c <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 31c:	b8 16 00 00 00       	mov    $0x16,%eax
+ 321:	cd 40                	int    $0x40
+ 323:	c3                   	ret    
+
+00000324 <shutdown>:
+SYSCALL(shutdown)
+ 324:	b8 17 00 00 00       	mov    $0x17,%eax
+ 329:	cd 40                	int    $0x40
+ 32b:	c3                   	ret    
+
+0000032c <fork_winner>:
+SYSCALL(fork_winner)
+ 32c:	b8 18 00 00 00       	mov    $0x18,%eax
+ 331:	cd 40                	int    $0x40
+ 333:	c3                   	ret    
+
+00000334 <set_sched>:
+SYSCALL(set_sched)
+ 334:	b8 19 00 00 00       	mov    $0x19,%eax
+ 339:	cd 40                	int    $0x40
+ 33b:	c3                   	ret    
+
+0000033c <set_priority>:
+SYSCALL(set_priority)
+ 33c:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 341:	cd 40                	int    $0x40
+ 343:	c3                   	ret    
+
+00000344 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 344:	55                   	push   %ebp
+ 345:	89 e5                	mov    %esp,%ebp
+ 347:	83 ec 28             	sub    $0x28,%esp
+ 34a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 34d:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 350:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 357:	00 
+ 358:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 35b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 35f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 362:	89 04 24             	mov    %eax,(%esp)
+ 365:	e8 32 ff ff ff       	call   29c <write>
+}
+ 36a:	c9                   	leave  
+ 36b:	c3                   	ret    
+
+0000036c <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 36c:	55                   	push   %ebp
+ 36d:	89 e5                	mov    %esp,%ebp
+ 36f:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 372:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 379:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 37d:	74 17                	je     396 <printint+0x2a>
+ 37f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 383:	79 11                	jns    396 <printint+0x2a>
+    neg = 1;
+ 385:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 38c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 38f:	f7 d8                	neg    %eax
+ 391:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 394:	eb 06                	jmp    39c <printint+0x30>
+  } else {
+    x = xx;
+ 396:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 399:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 39c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 3a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 3a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3a9:	ba 00 00 00 00       	mov    $0x0,%edx
+ 3ae:	f7 f1                	div    %ecx
+ 3b0:	89 d0                	mov    %edx,%eax
+ 3b2:	0f b6 80 38 0a 00 00 	movzbl 0xa38(%eax),%eax
+ 3b9:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 3bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 3bf:	01 ca                	add    %ecx,%edx
+ 3c1:	88 02                	mov    %al,(%edx)
+ 3c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 3c7:	8b 55 10             	mov    0x10(%ebp),%edx
+ 3ca:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 3cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3d0:	ba 00 00 00 00       	mov    $0x0,%edx
+ 3d5:	f7 75 d4             	divl   -0x2c(%ebp)
+ 3d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3db:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 3df:	75 c2                	jne    3a3 <printint+0x37>
+  if(neg)
+ 3e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 3e5:	74 2e                	je     415 <printint+0xa9>
+    buf[i++] = '-';
+ 3e7:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 3ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 3ed:	01 d0                	add    %edx,%eax
+ 3ef:	c6 00 2d             	movb   $0x2d,(%eax)
+ 3f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 3f6:	eb 1d                	jmp    415 <printint+0xa9>
+    putc(fd, buf[i]);
+ 3f8:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 3fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 3fe:	01 d0                	add    %edx,%eax
+ 400:	0f b6 00             	movzbl (%eax),%eax
+ 403:	0f be c0             	movsbl %al,%eax
+ 406:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 40a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 40d:	89 04 24             	mov    %eax,(%esp)
+ 410:	e8 2f ff ff ff       	call   344 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 415:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 419:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 41d:	79 d9                	jns    3f8 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 41f:	c9                   	leave  
+ 420:	c3                   	ret    
+
+00000421 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 421:	55                   	push   %ebp
+ 422:	89 e5                	mov    %esp,%ebp
+ 424:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 427:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 42e:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 431:	83 c0 04             	add    $0x4,%eax
+ 434:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 437:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 43e:	e9 7d 01 00 00       	jmp    5c0 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 443:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 446:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 449:	01 d0                	add    %edx,%eax
+ 44b:	0f b6 00             	movzbl (%eax),%eax
+ 44e:	0f be c0             	movsbl %al,%eax
+ 451:	25 ff 00 00 00       	and    $0xff,%eax
+ 456:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 459:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 45d:	75 2c                	jne    48b <printf+0x6a>
+      if(c == '%'){
+ 45f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 463:	75 0c                	jne    471 <printf+0x50>
+        state = '%';
+ 465:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 46c:	e9 4b 01 00 00       	jmp    5bc <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 471:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 474:	0f be c0             	movsbl %al,%eax
+ 477:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 47b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 47e:	89 04 24             	mov    %eax,(%esp)
+ 481:	e8 be fe ff ff       	call   344 <putc>
+ 486:	e9 31 01 00 00       	jmp    5bc <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 48b:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 48f:	0f 85 27 01 00 00    	jne    5bc <printf+0x19b>
+      if(c == 'd'){
+ 495:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 499:	75 2d                	jne    4c8 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 49b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 49e:	8b 00                	mov    (%eax),%eax
+ 4a0:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 4a7:	00 
+ 4a8:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 4af:	00 
+ 4b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4b4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4b7:	89 04 24             	mov    %eax,(%esp)
+ 4ba:	e8 ad fe ff ff       	call   36c <printint>
+        ap++;
+ 4bf:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 4c3:	e9 ed 00 00 00       	jmp    5b5 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 4c8:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 4cc:	74 06                	je     4d4 <printf+0xb3>
+ 4ce:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 4d2:	75 2d                	jne    501 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 4d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4d7:	8b 00                	mov    (%eax),%eax
+ 4d9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 4e0:	00 
+ 4e1:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 4e8:	00 
+ 4e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4ed:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4f0:	89 04 24             	mov    %eax,(%esp)
+ 4f3:	e8 74 fe ff ff       	call   36c <printint>
+        ap++;
+ 4f8:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 4fc:	e9 b4 00 00 00       	jmp    5b5 <printf+0x194>
+      } else if(c == 's'){
+ 501:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 505:	75 46                	jne    54d <printf+0x12c>
+        s = (char*)*ap;
+ 507:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 50a:	8b 00                	mov    (%eax),%eax
+ 50c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 50f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 513:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 517:	75 27                	jne    540 <printf+0x11f>
+          s = "(null)";
+ 519:	c7 45 f4 f1 07 00 00 	movl   $0x7f1,-0xc(%ebp)
+        while(*s != 0){
+ 520:	eb 1e                	jmp    540 <printf+0x11f>
+          putc(fd, *s);
+ 522:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 525:	0f b6 00             	movzbl (%eax),%eax
+ 528:	0f be c0             	movsbl %al,%eax
+ 52b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 52f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 532:	89 04 24             	mov    %eax,(%esp)
+ 535:	e8 0a fe ff ff       	call   344 <putc>
+          s++;
+ 53a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 53e:	eb 01                	jmp    541 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 540:	90                   	nop
+ 541:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 544:	0f b6 00             	movzbl (%eax),%eax
+ 547:	84 c0                	test   %al,%al
+ 549:	75 d7                	jne    522 <printf+0x101>
+ 54b:	eb 68                	jmp    5b5 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 54d:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 551:	75 1d                	jne    570 <printf+0x14f>
+        putc(fd, *ap);
+ 553:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 556:	8b 00                	mov    (%eax),%eax
+ 558:	0f be c0             	movsbl %al,%eax
+ 55b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 55f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 562:	89 04 24             	mov    %eax,(%esp)
+ 565:	e8 da fd ff ff       	call   344 <putc>
+        ap++;
+ 56a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 56e:	eb 45                	jmp    5b5 <printf+0x194>
+      } else if(c == '%'){
+ 570:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 574:	75 17                	jne    58d <printf+0x16c>
+        putc(fd, c);
+ 576:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 579:	0f be c0             	movsbl %al,%eax
+ 57c:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 580:	8b 45 08             	mov    0x8(%ebp),%eax
+ 583:	89 04 24             	mov    %eax,(%esp)
+ 586:	e8 b9 fd ff ff       	call   344 <putc>
+ 58b:	eb 28                	jmp    5b5 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 58d:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 594:	00 
+ 595:	8b 45 08             	mov    0x8(%ebp),%eax
+ 598:	89 04 24             	mov    %eax,(%esp)
+ 59b:	e8 a4 fd ff ff       	call   344 <putc>
+        putc(fd, c);
+ 5a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5a3:	0f be c0             	movsbl %al,%eax
+ 5a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5aa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ad:	89 04 24             	mov    %eax,(%esp)
+ 5b0:	e8 8f fd ff ff       	call   344 <putc>
+      }
+      state = 0;
+ 5b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 5bc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 5c0:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 5c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 5c6:	01 d0                	add    %edx,%eax
+ 5c8:	0f b6 00             	movzbl (%eax),%eax
+ 5cb:	84 c0                	test   %al,%al
+ 5cd:	0f 85 70 fe ff ff    	jne    443 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 5d3:	c9                   	leave  
+ 5d4:	c3                   	ret    
+ 5d5:	90                   	nop
+ 5d6:	90                   	nop
+ 5d7:	90                   	nop
+
+000005d8 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 5d8:	55                   	push   %ebp
+ 5d9:	89 e5                	mov    %esp,%ebp
+ 5db:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 5de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5e1:	83 e8 08             	sub    $0x8,%eax
+ 5e4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 5e7:	a1 54 0a 00 00       	mov    0xa54,%eax
+ 5ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 5ef:	eb 24                	jmp    615 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 5f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 5f4:	8b 00                	mov    (%eax),%eax
+ 5f6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 5f9:	77 12                	ja     60d <free+0x35>
+ 5fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 5fe:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 601:	77 24                	ja     627 <free+0x4f>
+ 603:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 606:	8b 00                	mov    (%eax),%eax
+ 608:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 60b:	77 1a                	ja     627 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 60d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 610:	8b 00                	mov    (%eax),%eax
+ 612:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 615:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 618:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 61b:	76 d4                	jbe    5f1 <free+0x19>
+ 61d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 620:	8b 00                	mov    (%eax),%eax
+ 622:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 625:	76 ca                	jbe    5f1 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 627:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 62a:	8b 40 04             	mov    0x4(%eax),%eax
+ 62d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 634:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 637:	01 c2                	add    %eax,%edx
+ 639:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 63c:	8b 00                	mov    (%eax),%eax
+ 63e:	39 c2                	cmp    %eax,%edx
+ 640:	75 24                	jne    666 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 642:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 645:	8b 50 04             	mov    0x4(%eax),%edx
+ 648:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 64b:	8b 00                	mov    (%eax),%eax
+ 64d:	8b 40 04             	mov    0x4(%eax),%eax
+ 650:	01 c2                	add    %eax,%edx
+ 652:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 655:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 658:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65b:	8b 00                	mov    (%eax),%eax
+ 65d:	8b 10                	mov    (%eax),%edx
+ 65f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 662:	89 10                	mov    %edx,(%eax)
+ 664:	eb 0a                	jmp    670 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 666:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 669:	8b 10                	mov    (%eax),%edx
+ 66b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 66e:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 670:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 673:	8b 40 04             	mov    0x4(%eax),%eax
+ 676:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 67d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 680:	01 d0                	add    %edx,%eax
+ 682:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 685:	75 20                	jne    6a7 <free+0xcf>
+    p->s.size += bp->s.size;
+ 687:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 68a:	8b 50 04             	mov    0x4(%eax),%edx
+ 68d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 690:	8b 40 04             	mov    0x4(%eax),%eax
+ 693:	01 c2                	add    %eax,%edx
+ 695:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 698:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 69b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69e:	8b 10                	mov    (%eax),%edx
+ 6a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a3:	89 10                	mov    %edx,(%eax)
+ 6a5:	eb 08                	jmp    6af <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 6a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 6ad:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 6af:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b2:	a3 54 0a 00 00       	mov    %eax,0xa54
+}
+ 6b7:	c9                   	leave  
+ 6b8:	c3                   	ret    
+
+000006b9 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 6b9:	55                   	push   %ebp
+ 6ba:	89 e5                	mov    %esp,%ebp
+ 6bc:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 6bf:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 6c6:	77 07                	ja     6cf <morecore+0x16>
+    nu = 4096;
+ 6c8:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 6cf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6d2:	c1 e0 03             	shl    $0x3,%eax
+ 6d5:	89 04 24             	mov    %eax,(%esp)
+ 6d8:	e8 27 fc ff ff       	call   304 <sbrk>
+ 6dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 6e0:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 6e4:	75 07                	jne    6ed <morecore+0x34>
+    return 0;
+ 6e6:	b8 00 00 00 00       	mov    $0x0,%eax
+ 6eb:	eb 22                	jmp    70f <morecore+0x56>
+  hp = (Header*)p;
+ 6ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 6f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6f6:	8b 55 08             	mov    0x8(%ebp),%edx
+ 6f9:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 6fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6ff:	83 c0 08             	add    $0x8,%eax
+ 702:	89 04 24             	mov    %eax,(%esp)
+ 705:	e8 ce fe ff ff       	call   5d8 <free>
+  return freep;
+ 70a:	a1 54 0a 00 00       	mov    0xa54,%eax
+}
+ 70f:	c9                   	leave  
+ 710:	c3                   	ret    
+
+00000711 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 711:	55                   	push   %ebp
+ 712:	89 e5                	mov    %esp,%ebp
+ 714:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 717:	8b 45 08             	mov    0x8(%ebp),%eax
+ 71a:	83 c0 07             	add    $0x7,%eax
+ 71d:	c1 e8 03             	shr    $0x3,%eax
+ 720:	83 c0 01             	add    $0x1,%eax
+ 723:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 726:	a1 54 0a 00 00       	mov    0xa54,%eax
+ 72b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 72e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 732:	75 23                	jne    757 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 734:	c7 45 f0 4c 0a 00 00 	movl   $0xa4c,-0x10(%ebp)
+ 73b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 73e:	a3 54 0a 00 00       	mov    %eax,0xa54
+ 743:	a1 54 0a 00 00       	mov    0xa54,%eax
+ 748:	a3 4c 0a 00 00       	mov    %eax,0xa4c
+    base.s.size = 0;
+ 74d:	c7 05 50 0a 00 00 00 	movl   $0x0,0xa50
+ 754:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 757:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 75a:	8b 00                	mov    (%eax),%eax
+ 75c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 75f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 762:	8b 40 04             	mov    0x4(%eax),%eax
+ 765:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 768:	72 4d                	jb     7b7 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 76a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 76d:	8b 40 04             	mov    0x4(%eax),%eax
+ 770:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 773:	75 0c                	jne    781 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 775:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 778:	8b 10                	mov    (%eax),%edx
+ 77a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 77d:	89 10                	mov    %edx,(%eax)
+ 77f:	eb 26                	jmp    7a7 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 781:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 784:	8b 40 04             	mov    0x4(%eax),%eax
+ 787:	89 c2                	mov    %eax,%edx
+ 789:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 78c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 78f:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 792:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 795:	8b 40 04             	mov    0x4(%eax),%eax
+ 798:	c1 e0 03             	shl    $0x3,%eax
+ 79b:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 79e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 7a4:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 7a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7aa:	a3 54 0a 00 00       	mov    %eax,0xa54
+      return (void*)(p + 1);
+ 7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7b2:	83 c0 08             	add    $0x8,%eax
+ 7b5:	eb 38                	jmp    7ef <malloc+0xde>
+    }
+    if(p == freep)
+ 7b7:	a1 54 0a 00 00       	mov    0xa54,%eax
+ 7bc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 7bf:	75 1b                	jne    7dc <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 7c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 7c4:	89 04 24             	mov    %eax,(%esp)
+ 7c7:	e8 ed fe ff ff       	call   6b9 <morecore>
+ 7cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 7cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 7d3:	75 07                	jne    7dc <malloc+0xcb>
+        return 0;
+ 7d5:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7da:	eb 13                	jmp    7ef <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7df:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e5:	8b 00                	mov    (%eax),%eax
+ 7e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 7ea:	e9 70 ff ff ff       	jmp    75f <malloc+0x4e>
+}
+ 7ef:	c9                   	leave  
+ 7f0:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/shutdown.c cs550-16s-proj1-working/shutdown.c
--- cs550-16s-proj1-base/shutdown.c	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/shutdown.c	2016-03-04 14:36:42.000000000 -0500
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "x86.h"
+/* CS550 ATTENTION: to ensure correct compilation of the base code, 
+   stub functions for the system call user space wrapper functions are provided. 
+   REMEMBER to disable the stub functions (by commenting the following macro) to 
+   allow your implementation to work properly. */
+
+int 
+main(int argc, char * argv[])
+{
+    shutdown();
+    return 0;
+}
diff -uNr cs550-16s-proj1-base/shutdown.d cs550-16s-proj1-working/shutdown.d
--- cs550-16s-proj1-base/shutdown.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/shutdown.d	2016-03-04 14:37:10.000000000 -0500
@@ -0,0 +1 @@
+shutdown.o: shutdown.c types.h stat.h user.h x86.h
Binary files cs550-16s-proj1-base/shutdown.o and cs550-16s-proj1-working/shutdown.o differ
diff -uNr cs550-16s-proj1-base/shutdown.sym cs550-16s-proj1-working/shutdown.sym
--- cs550-16s-proj1-base/shutdown.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/shutdown.sym	2016-03-04 14:37:11.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+000007f1 .rodata
+000007f8 .eh_frame
+00000a38 .data
+00000a4c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 shutdown.c
+00000000 ulib.c
+00000014 stosb
+00000000 printf.c
+00000344 putc
+0000036c printint
+00000a38 digits.1028
+00000000 umalloc.c
+00000a4c base
+00000a54 freep
+000006b9 morecore
+00000039 strcpy
+00000421 printf
+00000238 memmove
+000002c4 mknod
+0000012c gets
+000002fc getpid
+00000711 malloc
+0000030c sleep
+0000033c set_priority
+0000028c pipe
+0000029c write
+000002d4 fstat
+000002ac kill
+000002ec chdir
+000002b4 exec
+00000284 wait
+00000294 read
+000002cc unlink
+00000274 fork
+00000304 sbrk
+00000314 uptime
+00000a4c __bss_start
+000000d5 memset
+00000000 main
+0000031c enable_sched_trace
+0000006d strcmp
+00000324 shutdown
+000002f4 dup
+00000334 set_sched
+0000019f stat
+00000a4c _edata
+00000a58 _end
+000002dc link
+0000027c exit
+000001ed atoi
+0000032c fork_winner
+000000ae strlen
+000002bc open
+000000f9 strchr
+000002e4 mkdir
+000002a4 close
+000005d8 free
diff -uNr cs550-16s-proj1-base/spinlock.d cs550-16s-proj1-working/spinlock.d
--- cs550-16s-proj1-base/spinlock.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/spinlock.d	2016-03-04 15:52:34.202702148 -0500
@@ -0,0 +1,2 @@
+spinlock.o: spinlock.c types.h defs.h param.h x86.h memlayout.h mmu.h \
+ proc.h spinlock.h
Binary files cs550-16s-proj1-base/spinlock.o and cs550-16s-proj1-working/spinlock.o differ
Binary files cs550-16s-proj1-base/_stressfs and cs550-16s-proj1-working/_stressfs differ
diff -uNr cs550-16s-proj1-base/stressfs.asm cs550-16s-proj1-working/stressfs.asm
--- cs550-16s-proj1-base/stressfs.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/stressfs.asm	2016-03-04 14:37:07.000000000 -0500
@@ -0,0 +1,1321 @@
+
+_stressfs:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "fs.h"
+#include "fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	81 ec 30 02 00 00    	sub    $0x230,%esp
+  int fd, i;
+  char path[] = "stressfs0";
+   c:	c7 84 24 1e 02 00 00 	movl   $0x65727473,0x21e(%esp)
+  13:	73 74 72 65 
+  17:	c7 84 24 22 02 00 00 	movl   $0x73667373,0x222(%esp)
+  1e:	73 73 66 73 
+  22:	66 c7 84 24 26 02 00 	movw   $0x30,0x226(%esp)
+  29:	00 30 00 
+  char data[512];
+
+  printf(1, "stressfs starting\n");
+  2c:	c7 44 24 04 91 09 00 	movl   $0x991,0x4(%esp)
+  33:	00 
+  34:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  3b:	e8 81 05 00 00       	call   5c1 <printf>
+  memset(data, 'a', sizeof(data));
+  40:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+  47:	00 
+  48:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
+  4f:	00 
+  50:	8d 44 24 1e          	lea    0x1e(%esp),%eax
+  54:	89 04 24             	mov    %eax,(%esp)
+  57:	e8 19 02 00 00       	call   275 <memset>
+
+  for(i = 0; i < 4; i++)
+  5c:	c7 84 24 2c 02 00 00 	movl   $0x0,0x22c(%esp)
+  63:	00 00 00 00 
+  67:	eb 11                	jmp    7a <main+0x7a>
+    if(fork() > 0)
+  69:	e8 a6 03 00 00       	call   414 <fork>
+  6e:	85 c0                	test   %eax,%eax
+  70:	7f 14                	jg     86 <main+0x86>
+  char data[512];
+
+  printf(1, "stressfs starting\n");
+  memset(data, 'a', sizeof(data));
+
+  for(i = 0; i < 4; i++)
+  72:	83 84 24 2c 02 00 00 	addl   $0x1,0x22c(%esp)
+  79:	01 
+  7a:	83 bc 24 2c 02 00 00 	cmpl   $0x3,0x22c(%esp)
+  81:	03 
+  82:	7e e5                	jle    69 <main+0x69>
+  84:	eb 01                	jmp    87 <main+0x87>
+    if(fork() > 0)
+      break;
+  86:	90                   	nop
+
+  printf(1, "write %d\n", i);
+  87:	8b 84 24 2c 02 00 00 	mov    0x22c(%esp),%eax
+  8e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  92:	c7 44 24 04 a4 09 00 	movl   $0x9a4,0x4(%esp)
+  99:	00 
+  9a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  a1:	e8 1b 05 00 00       	call   5c1 <printf>
+
+  path[8] += i;
+  a6:	0f b6 84 24 26 02 00 	movzbl 0x226(%esp),%eax
+  ad:	00 
+  ae:	89 c2                	mov    %eax,%edx
+  b0:	8b 84 24 2c 02 00 00 	mov    0x22c(%esp),%eax
+  b7:	01 d0                	add    %edx,%eax
+  b9:	88 84 24 26 02 00 00 	mov    %al,0x226(%esp)
+  fd = open(path, O_CREATE | O_RDWR);
+  c0:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+  c7:	00 
+  c8:	8d 84 24 1e 02 00 00 	lea    0x21e(%esp),%eax
+  cf:	89 04 24             	mov    %eax,(%esp)
+  d2:	e8 85 03 00 00       	call   45c <open>
+  d7:	89 84 24 28 02 00 00 	mov    %eax,0x228(%esp)
+  for(i = 0; i < 20; i++)
+  de:	c7 84 24 2c 02 00 00 	movl   $0x0,0x22c(%esp)
+  e5:	00 00 00 00 
+  e9:	eb 27                	jmp    112 <main+0x112>
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+  eb:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+  f2:	00 
+  f3:	8d 44 24 1e          	lea    0x1e(%esp),%eax
+  f7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  fb:	8b 84 24 28 02 00 00 	mov    0x228(%esp),%eax
+ 102:	89 04 24             	mov    %eax,(%esp)
+ 105:	e8 32 03 00 00       	call   43c <write>
+
+  printf(1, "write %d\n", i);
+
+  path[8] += i;
+  fd = open(path, O_CREATE | O_RDWR);
+  for(i = 0; i < 20; i++)
+ 10a:	83 84 24 2c 02 00 00 	addl   $0x1,0x22c(%esp)
+ 111:	01 
+ 112:	83 bc 24 2c 02 00 00 	cmpl   $0x13,0x22c(%esp)
+ 119:	13 
+ 11a:	7e cf                	jle    eb <main+0xeb>
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+  close(fd);
+ 11c:	8b 84 24 28 02 00 00 	mov    0x228(%esp),%eax
+ 123:	89 04 24             	mov    %eax,(%esp)
+ 126:	e8 19 03 00 00       	call   444 <close>
+
+  printf(1, "read\n");
+ 12b:	c7 44 24 04 ae 09 00 	movl   $0x9ae,0x4(%esp)
+ 132:	00 
+ 133:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 13a:	e8 82 04 00 00       	call   5c1 <printf>
+
+  fd = open(path, O_RDONLY);
+ 13f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 146:	00 
+ 147:	8d 84 24 1e 02 00 00 	lea    0x21e(%esp),%eax
+ 14e:	89 04 24             	mov    %eax,(%esp)
+ 151:	e8 06 03 00 00       	call   45c <open>
+ 156:	89 84 24 28 02 00 00 	mov    %eax,0x228(%esp)
+  for (i = 0; i < 20; i++)
+ 15d:	c7 84 24 2c 02 00 00 	movl   $0x0,0x22c(%esp)
+ 164:	00 00 00 00 
+ 168:	eb 27                	jmp    191 <main+0x191>
+    read(fd, data, sizeof(data));
+ 16a:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+ 171:	00 
+ 172:	8d 44 24 1e          	lea    0x1e(%esp),%eax
+ 176:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 17a:	8b 84 24 28 02 00 00 	mov    0x228(%esp),%eax
+ 181:	89 04 24             	mov    %eax,(%esp)
+ 184:	e8 ab 02 00 00       	call   434 <read>
+  close(fd);
+
+  printf(1, "read\n");
+
+  fd = open(path, O_RDONLY);
+  for (i = 0; i < 20; i++)
+ 189:	83 84 24 2c 02 00 00 	addl   $0x1,0x22c(%esp)
+ 190:	01 
+ 191:	83 bc 24 2c 02 00 00 	cmpl   $0x13,0x22c(%esp)
+ 198:	13 
+ 199:	7e cf                	jle    16a <main+0x16a>
+    read(fd, data, sizeof(data));
+  close(fd);
+ 19b:	8b 84 24 28 02 00 00 	mov    0x228(%esp),%eax
+ 1a2:	89 04 24             	mov    %eax,(%esp)
+ 1a5:	e8 9a 02 00 00       	call   444 <close>
+
+  wait();
+ 1aa:	e8 75 02 00 00       	call   424 <wait>
+  
+  exit();
+ 1af:	e8 68 02 00 00       	call   41c <exit>
+
+000001b4 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 1b4:	55                   	push   %ebp
+ 1b5:	89 e5                	mov    %esp,%ebp
+ 1b7:	57                   	push   %edi
+ 1b8:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 1b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 1bc:	8b 55 10             	mov    0x10(%ebp),%edx
+ 1bf:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1c2:	89 cb                	mov    %ecx,%ebx
+ 1c4:	89 df                	mov    %ebx,%edi
+ 1c6:	89 d1                	mov    %edx,%ecx
+ 1c8:	fc                   	cld    
+ 1c9:	f3 aa                	rep stos %al,%es:(%edi)
+ 1cb:	89 ca                	mov    %ecx,%edx
+ 1cd:	89 fb                	mov    %edi,%ebx
+ 1cf:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 1d2:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 1d5:	5b                   	pop    %ebx
+ 1d6:	5f                   	pop    %edi
+ 1d7:	5d                   	pop    %ebp
+ 1d8:	c3                   	ret    
+
+000001d9 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 1d9:	55                   	push   %ebp
+ 1da:	89 e5                	mov    %esp,%ebp
+ 1dc:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 1df:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 1e5:	90                   	nop
+ 1e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1e9:	0f b6 10             	movzbl (%eax),%edx
+ 1ec:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ef:	88 10                	mov    %dl,(%eax)
+ 1f1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1f4:	0f b6 00             	movzbl (%eax),%eax
+ 1f7:	84 c0                	test   %al,%al
+ 1f9:	0f 95 c0             	setne  %al
+ 1fc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 200:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 204:	84 c0                	test   %al,%al
+ 206:	75 de                	jne    1e6 <strcpy+0xd>
+    ;
+  return os;
+ 208:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 20b:	c9                   	leave  
+ 20c:	c3                   	ret    
+
+0000020d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 20d:	55                   	push   %ebp
+ 20e:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 210:	eb 08                	jmp    21a <strcmp+0xd>
+    p++, q++;
+ 212:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 216:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 21a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21d:	0f b6 00             	movzbl (%eax),%eax
+ 220:	84 c0                	test   %al,%al
+ 222:	74 10                	je     234 <strcmp+0x27>
+ 224:	8b 45 08             	mov    0x8(%ebp),%eax
+ 227:	0f b6 10             	movzbl (%eax),%edx
+ 22a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 22d:	0f b6 00             	movzbl (%eax),%eax
+ 230:	38 c2                	cmp    %al,%dl
+ 232:	74 de                	je     212 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 234:	8b 45 08             	mov    0x8(%ebp),%eax
+ 237:	0f b6 00             	movzbl (%eax),%eax
+ 23a:	0f b6 d0             	movzbl %al,%edx
+ 23d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 240:	0f b6 00             	movzbl (%eax),%eax
+ 243:	0f b6 c0             	movzbl %al,%eax
+ 246:	89 d1                	mov    %edx,%ecx
+ 248:	29 c1                	sub    %eax,%ecx
+ 24a:	89 c8                	mov    %ecx,%eax
+}
+ 24c:	5d                   	pop    %ebp
+ 24d:	c3                   	ret    
+
+0000024e <strlen>:
+
+uint
+strlen(char *s)
+{
+ 24e:	55                   	push   %ebp
+ 24f:	89 e5                	mov    %esp,%ebp
+ 251:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 254:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 25b:	eb 04                	jmp    261 <strlen+0x13>
+ 25d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 261:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 264:	8b 45 08             	mov    0x8(%ebp),%eax
+ 267:	01 d0                	add    %edx,%eax
+ 269:	0f b6 00             	movzbl (%eax),%eax
+ 26c:	84 c0                	test   %al,%al
+ 26e:	75 ed                	jne    25d <strlen+0xf>
+    ;
+  return n;
+ 270:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 273:	c9                   	leave  
+ 274:	c3                   	ret    
+
+00000275 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 275:	55                   	push   %ebp
+ 276:	89 e5                	mov    %esp,%ebp
+ 278:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 27b:	8b 45 10             	mov    0x10(%ebp),%eax
+ 27e:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 282:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 285:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 289:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28c:	89 04 24             	mov    %eax,(%esp)
+ 28f:	e8 20 ff ff ff       	call   1b4 <stosb>
+  return dst;
+ 294:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 297:	c9                   	leave  
+ 298:	c3                   	ret    
+
+00000299 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 299:	55                   	push   %ebp
+ 29a:	89 e5                	mov    %esp,%ebp
+ 29c:	83 ec 04             	sub    $0x4,%esp
+ 29f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2a2:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 2a5:	eb 14                	jmp    2bb <strchr+0x22>
+    if(*s == c)
+ 2a7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2aa:	0f b6 00             	movzbl (%eax),%eax
+ 2ad:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 2b0:	75 05                	jne    2b7 <strchr+0x1e>
+      return (char*)s;
+ 2b2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b5:	eb 13                	jmp    2ca <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 2b7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 2bb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2be:	0f b6 00             	movzbl (%eax),%eax
+ 2c1:	84 c0                	test   %al,%al
+ 2c3:	75 e2                	jne    2a7 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 2c5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 2ca:	c9                   	leave  
+ 2cb:	c3                   	ret    
+
+000002cc <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 2cc:	55                   	push   %ebp
+ 2cd:	89 e5                	mov    %esp,%ebp
+ 2cf:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 2d9:	eb 46                	jmp    321 <gets+0x55>
+    cc = read(0, &c, 1);
+ 2db:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 2e2:	00 
+ 2e3:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 2e6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2ea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 2f1:	e8 3e 01 00 00       	call   434 <read>
+ 2f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 2f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 2fd:	7e 2f                	jle    32e <gets+0x62>
+      break;
+    buf[i++] = c;
+ 2ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 302:	8b 45 08             	mov    0x8(%ebp),%eax
+ 305:	01 c2                	add    %eax,%edx
+ 307:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 30b:	88 02                	mov    %al,(%edx)
+ 30d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 311:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 315:	3c 0a                	cmp    $0xa,%al
+ 317:	74 16                	je     32f <gets+0x63>
+ 319:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 31d:	3c 0d                	cmp    $0xd,%al
+ 31f:	74 0e                	je     32f <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 321:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 324:	83 c0 01             	add    $0x1,%eax
+ 327:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 32a:	7c af                	jl     2db <gets+0xf>
+ 32c:	eb 01                	jmp    32f <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 32e:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 32f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 332:	8b 45 08             	mov    0x8(%ebp),%eax
+ 335:	01 d0                	add    %edx,%eax
+ 337:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 33a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 33d:	c9                   	leave  
+ 33e:	c3                   	ret    
+
+0000033f <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 33f:	55                   	push   %ebp
+ 340:	89 e5                	mov    %esp,%ebp
+ 342:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 345:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 34c:	00 
+ 34d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 350:	89 04 24             	mov    %eax,(%esp)
+ 353:	e8 04 01 00 00       	call   45c <open>
+ 358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 35b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 35f:	79 07                	jns    368 <stat+0x29>
+    return -1;
+ 361:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 366:	eb 23                	jmp    38b <stat+0x4c>
+  r = fstat(fd, st);
+ 368:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 36b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 36f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 372:	89 04 24             	mov    %eax,(%esp)
+ 375:	e8 fa 00 00 00       	call   474 <fstat>
+ 37a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 37d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 380:	89 04 24             	mov    %eax,(%esp)
+ 383:	e8 bc 00 00 00       	call   444 <close>
+  return r;
+ 388:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 38b:	c9                   	leave  
+ 38c:	c3                   	ret    
+
+0000038d <atoi>:
+
+int
+atoi(const char *s)
+{
+ 38d:	55                   	push   %ebp
+ 38e:	89 e5                	mov    %esp,%ebp
+ 390:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 393:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 39a:	eb 23                	jmp    3bf <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 39c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 39f:	89 d0                	mov    %edx,%eax
+ 3a1:	c1 e0 02             	shl    $0x2,%eax
+ 3a4:	01 d0                	add    %edx,%eax
+ 3a6:	01 c0                	add    %eax,%eax
+ 3a8:	89 c2                	mov    %eax,%edx
+ 3aa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3ad:	0f b6 00             	movzbl (%eax),%eax
+ 3b0:	0f be c0             	movsbl %al,%eax
+ 3b3:	01 d0                	add    %edx,%eax
+ 3b5:	83 e8 30             	sub    $0x30,%eax
+ 3b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 3bb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 3bf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3c2:	0f b6 00             	movzbl (%eax),%eax
+ 3c5:	3c 2f                	cmp    $0x2f,%al
+ 3c7:	7e 0a                	jle    3d3 <atoi+0x46>
+ 3c9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3cc:	0f b6 00             	movzbl (%eax),%eax
+ 3cf:	3c 39                	cmp    $0x39,%al
+ 3d1:	7e c9                	jle    39c <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 3d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3d6:	c9                   	leave  
+ 3d7:	c3                   	ret    
+
+000003d8 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 3d8:	55                   	push   %ebp
+ 3d9:	89 e5                	mov    %esp,%ebp
+ 3db:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 3de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3e1:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 3e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3e7:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 3ea:	eb 13                	jmp    3ff <memmove+0x27>
+    *dst++ = *src++;
+ 3ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 3ef:	0f b6 10             	movzbl (%eax),%edx
+ 3f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 3f5:	88 10                	mov    %dl,(%eax)
+ 3f7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 3fb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 3ff:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 403:	0f 9f c0             	setg   %al
+ 406:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 40a:	84 c0                	test   %al,%al
+ 40c:	75 de                	jne    3ec <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 40e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 411:	c9                   	leave  
+ 412:	c3                   	ret    
+ 413:	90                   	nop
+
+00000414 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 414:	b8 01 00 00 00       	mov    $0x1,%eax
+ 419:	cd 40                	int    $0x40
+ 41b:	c3                   	ret    
+
+0000041c <exit>:
+SYSCALL(exit)
+ 41c:	b8 02 00 00 00       	mov    $0x2,%eax
+ 421:	cd 40                	int    $0x40
+ 423:	c3                   	ret    
+
+00000424 <wait>:
+SYSCALL(wait)
+ 424:	b8 03 00 00 00       	mov    $0x3,%eax
+ 429:	cd 40                	int    $0x40
+ 42b:	c3                   	ret    
+
+0000042c <pipe>:
+SYSCALL(pipe)
+ 42c:	b8 04 00 00 00       	mov    $0x4,%eax
+ 431:	cd 40                	int    $0x40
+ 433:	c3                   	ret    
+
+00000434 <read>:
+SYSCALL(read)
+ 434:	b8 05 00 00 00       	mov    $0x5,%eax
+ 439:	cd 40                	int    $0x40
+ 43b:	c3                   	ret    
+
+0000043c <write>:
+SYSCALL(write)
+ 43c:	b8 10 00 00 00       	mov    $0x10,%eax
+ 441:	cd 40                	int    $0x40
+ 443:	c3                   	ret    
+
+00000444 <close>:
+SYSCALL(close)
+ 444:	b8 15 00 00 00       	mov    $0x15,%eax
+ 449:	cd 40                	int    $0x40
+ 44b:	c3                   	ret    
+
+0000044c <kill>:
+SYSCALL(kill)
+ 44c:	b8 06 00 00 00       	mov    $0x6,%eax
+ 451:	cd 40                	int    $0x40
+ 453:	c3                   	ret    
+
+00000454 <exec>:
+SYSCALL(exec)
+ 454:	b8 07 00 00 00       	mov    $0x7,%eax
+ 459:	cd 40                	int    $0x40
+ 45b:	c3                   	ret    
+
+0000045c <open>:
+SYSCALL(open)
+ 45c:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 461:	cd 40                	int    $0x40
+ 463:	c3                   	ret    
+
+00000464 <mknod>:
+SYSCALL(mknod)
+ 464:	b8 11 00 00 00       	mov    $0x11,%eax
+ 469:	cd 40                	int    $0x40
+ 46b:	c3                   	ret    
+
+0000046c <unlink>:
+SYSCALL(unlink)
+ 46c:	b8 12 00 00 00       	mov    $0x12,%eax
+ 471:	cd 40                	int    $0x40
+ 473:	c3                   	ret    
+
+00000474 <fstat>:
+SYSCALL(fstat)
+ 474:	b8 08 00 00 00       	mov    $0x8,%eax
+ 479:	cd 40                	int    $0x40
+ 47b:	c3                   	ret    
+
+0000047c <link>:
+SYSCALL(link)
+ 47c:	b8 13 00 00 00       	mov    $0x13,%eax
+ 481:	cd 40                	int    $0x40
+ 483:	c3                   	ret    
+
+00000484 <mkdir>:
+SYSCALL(mkdir)
+ 484:	b8 14 00 00 00       	mov    $0x14,%eax
+ 489:	cd 40                	int    $0x40
+ 48b:	c3                   	ret    
+
+0000048c <chdir>:
+SYSCALL(chdir)
+ 48c:	b8 09 00 00 00       	mov    $0x9,%eax
+ 491:	cd 40                	int    $0x40
+ 493:	c3                   	ret    
+
+00000494 <dup>:
+SYSCALL(dup)
+ 494:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 499:	cd 40                	int    $0x40
+ 49b:	c3                   	ret    
+
+0000049c <getpid>:
+SYSCALL(getpid)
+ 49c:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 4a1:	cd 40                	int    $0x40
+ 4a3:	c3                   	ret    
+
+000004a4 <sbrk>:
+SYSCALL(sbrk)
+ 4a4:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 4a9:	cd 40                	int    $0x40
+ 4ab:	c3                   	ret    
+
+000004ac <sleep>:
+SYSCALL(sleep)
+ 4ac:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 4b1:	cd 40                	int    $0x40
+ 4b3:	c3                   	ret    
+
+000004b4 <uptime>:
+SYSCALL(uptime)
+ 4b4:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 4b9:	cd 40                	int    $0x40
+ 4bb:	c3                   	ret    
+
+000004bc <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 4bc:	b8 16 00 00 00       	mov    $0x16,%eax
+ 4c1:	cd 40                	int    $0x40
+ 4c3:	c3                   	ret    
+
+000004c4 <shutdown>:
+SYSCALL(shutdown)
+ 4c4:	b8 17 00 00 00       	mov    $0x17,%eax
+ 4c9:	cd 40                	int    $0x40
+ 4cb:	c3                   	ret    
+
+000004cc <fork_winner>:
+SYSCALL(fork_winner)
+ 4cc:	b8 18 00 00 00       	mov    $0x18,%eax
+ 4d1:	cd 40                	int    $0x40
+ 4d3:	c3                   	ret    
+
+000004d4 <set_sched>:
+SYSCALL(set_sched)
+ 4d4:	b8 19 00 00 00       	mov    $0x19,%eax
+ 4d9:	cd 40                	int    $0x40
+ 4db:	c3                   	ret    
+
+000004dc <set_priority>:
+SYSCALL(set_priority)
+ 4dc:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 4e1:	cd 40                	int    $0x40
+ 4e3:	c3                   	ret    
+
+000004e4 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 4e4:	55                   	push   %ebp
+ 4e5:	89 e5                	mov    %esp,%ebp
+ 4e7:	83 ec 28             	sub    $0x28,%esp
+ 4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4ed:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 4f0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 4f7:	00 
+ 4f8:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 4fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4ff:	8b 45 08             	mov    0x8(%ebp),%eax
+ 502:	89 04 24             	mov    %eax,(%esp)
+ 505:	e8 32 ff ff ff       	call   43c <write>
+}
+ 50a:	c9                   	leave  
+ 50b:	c3                   	ret    
+
+0000050c <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 50c:	55                   	push   %ebp
+ 50d:	89 e5                	mov    %esp,%ebp
+ 50f:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 512:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 519:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 51d:	74 17                	je     536 <printint+0x2a>
+ 51f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 523:	79 11                	jns    536 <printint+0x2a>
+    neg = 1;
+ 525:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 52c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 52f:	f7 d8                	neg    %eax
+ 531:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 534:	eb 06                	jmp    53c <printint+0x30>
+  } else {
+    x = xx;
+ 536:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 539:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 53c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 543:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 546:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 549:	ba 00 00 00 00       	mov    $0x0,%edx
+ 54e:	f7 f1                	div    %ecx
+ 550:	89 d0                	mov    %edx,%eax
+ 552:	0f b6 80 f8 0b 00 00 	movzbl 0xbf8(%eax),%eax
+ 559:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 55c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 55f:	01 ca                	add    %ecx,%edx
+ 561:	88 02                	mov    %al,(%edx)
+ 563:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 567:	8b 55 10             	mov    0x10(%ebp),%edx
+ 56a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 56d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 570:	ba 00 00 00 00       	mov    $0x0,%edx
+ 575:	f7 75 d4             	divl   -0x2c(%ebp)
+ 578:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 57b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 57f:	75 c2                	jne    543 <printint+0x37>
+  if(neg)
+ 581:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 585:	74 2e                	je     5b5 <printint+0xa9>
+    buf[i++] = '-';
+ 587:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 58a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 58d:	01 d0                	add    %edx,%eax
+ 58f:	c6 00 2d             	movb   $0x2d,(%eax)
+ 592:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 596:	eb 1d                	jmp    5b5 <printint+0xa9>
+    putc(fd, buf[i]);
+ 598:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 59b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59e:	01 d0                	add    %edx,%eax
+ 5a0:	0f b6 00             	movzbl (%eax),%eax
+ 5a3:	0f be c0             	movsbl %al,%eax
+ 5a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5aa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ad:	89 04 24             	mov    %eax,(%esp)
+ 5b0:	e8 2f ff ff ff       	call   4e4 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 5b5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 5b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 5bd:	79 d9                	jns    598 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 5bf:	c9                   	leave  
+ 5c0:	c3                   	ret    
+
+000005c1 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 5c1:	55                   	push   %ebp
+ 5c2:	89 e5                	mov    %esp,%ebp
+ 5c4:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 5c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 5ce:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 5d1:	83 c0 04             	add    $0x4,%eax
+ 5d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 5d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 5de:	e9 7d 01 00 00       	jmp    760 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 5e3:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 5e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 5e9:	01 d0                	add    %edx,%eax
+ 5eb:	0f b6 00             	movzbl (%eax),%eax
+ 5ee:	0f be c0             	movsbl %al,%eax
+ 5f1:	25 ff 00 00 00       	and    $0xff,%eax
+ 5f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 5f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 5fd:	75 2c                	jne    62b <printf+0x6a>
+      if(c == '%'){
+ 5ff:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 603:	75 0c                	jne    611 <printf+0x50>
+        state = '%';
+ 605:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 60c:	e9 4b 01 00 00       	jmp    75c <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 611:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 614:	0f be c0             	movsbl %al,%eax
+ 617:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 61b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 61e:	89 04 24             	mov    %eax,(%esp)
+ 621:	e8 be fe ff ff       	call   4e4 <putc>
+ 626:	e9 31 01 00 00       	jmp    75c <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 62b:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 62f:	0f 85 27 01 00 00    	jne    75c <printf+0x19b>
+      if(c == 'd'){
+ 635:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 639:	75 2d                	jne    668 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 63b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 63e:	8b 00                	mov    (%eax),%eax
+ 640:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 647:	00 
+ 648:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 64f:	00 
+ 650:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 654:	8b 45 08             	mov    0x8(%ebp),%eax
+ 657:	89 04 24             	mov    %eax,(%esp)
+ 65a:	e8 ad fe ff ff       	call   50c <printint>
+        ap++;
+ 65f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 663:	e9 ed 00 00 00       	jmp    755 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 668:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 66c:	74 06                	je     674 <printf+0xb3>
+ 66e:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 672:	75 2d                	jne    6a1 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 674:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 677:	8b 00                	mov    (%eax),%eax
+ 679:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 680:	00 
+ 681:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 688:	00 
+ 689:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 68d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 690:	89 04 24             	mov    %eax,(%esp)
+ 693:	e8 74 fe ff ff       	call   50c <printint>
+        ap++;
+ 698:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 69c:	e9 b4 00 00 00       	jmp    755 <printf+0x194>
+      } else if(c == 's'){
+ 6a1:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 6a5:	75 46                	jne    6ed <printf+0x12c>
+        s = (char*)*ap;
+ 6a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 6aa:	8b 00                	mov    (%eax),%eax
+ 6ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 6af:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 6b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 6b7:	75 27                	jne    6e0 <printf+0x11f>
+          s = "(null)";
+ 6b9:	c7 45 f4 b4 09 00 00 	movl   $0x9b4,-0xc(%ebp)
+        while(*s != 0){
+ 6c0:	eb 1e                	jmp    6e0 <printf+0x11f>
+          putc(fd, *s);
+ 6c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6c5:	0f b6 00             	movzbl (%eax),%eax
+ 6c8:	0f be c0             	movsbl %al,%eax
+ 6cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6cf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6d2:	89 04 24             	mov    %eax,(%esp)
+ 6d5:	e8 0a fe ff ff       	call   4e4 <putc>
+          s++;
+ 6da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 6de:	eb 01                	jmp    6e1 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 6e0:	90                   	nop
+ 6e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6e4:	0f b6 00             	movzbl (%eax),%eax
+ 6e7:	84 c0                	test   %al,%al
+ 6e9:	75 d7                	jne    6c2 <printf+0x101>
+ 6eb:	eb 68                	jmp    755 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 6ed:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 6f1:	75 1d                	jne    710 <printf+0x14f>
+        putc(fd, *ap);
+ 6f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 6f6:	8b 00                	mov    (%eax),%eax
+ 6f8:	0f be c0             	movsbl %al,%eax
+ 6fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6ff:	8b 45 08             	mov    0x8(%ebp),%eax
+ 702:	89 04 24             	mov    %eax,(%esp)
+ 705:	e8 da fd ff ff       	call   4e4 <putc>
+        ap++;
+ 70a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 70e:	eb 45                	jmp    755 <printf+0x194>
+      } else if(c == '%'){
+ 710:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 714:	75 17                	jne    72d <printf+0x16c>
+        putc(fd, c);
+ 716:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 719:	0f be c0             	movsbl %al,%eax
+ 71c:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 720:	8b 45 08             	mov    0x8(%ebp),%eax
+ 723:	89 04 24             	mov    %eax,(%esp)
+ 726:	e8 b9 fd ff ff       	call   4e4 <putc>
+ 72b:	eb 28                	jmp    755 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 72d:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 734:	00 
+ 735:	8b 45 08             	mov    0x8(%ebp),%eax
+ 738:	89 04 24             	mov    %eax,(%esp)
+ 73b:	e8 a4 fd ff ff       	call   4e4 <putc>
+        putc(fd, c);
+ 740:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 743:	0f be c0             	movsbl %al,%eax
+ 746:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 74a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 74d:	89 04 24             	mov    %eax,(%esp)
+ 750:	e8 8f fd ff ff       	call   4e4 <putc>
+      }
+      state = 0;
+ 755:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 75c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 760:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 763:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 766:	01 d0                	add    %edx,%eax
+ 768:	0f b6 00             	movzbl (%eax),%eax
+ 76b:	84 c0                	test   %al,%al
+ 76d:	0f 85 70 fe ff ff    	jne    5e3 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 773:	c9                   	leave  
+ 774:	c3                   	ret    
+ 775:	90                   	nop
+ 776:	90                   	nop
+ 777:	90                   	nop
+
+00000778 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 778:	55                   	push   %ebp
+ 779:	89 e5                	mov    %esp,%ebp
+ 77b:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 77e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 781:	83 e8 08             	sub    $0x8,%eax
+ 784:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 787:	a1 14 0c 00 00       	mov    0xc14,%eax
+ 78c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 78f:	eb 24                	jmp    7b5 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 791:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 794:	8b 00                	mov    (%eax),%eax
+ 796:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 799:	77 12                	ja     7ad <free+0x35>
+ 79b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 79e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7a1:	77 24                	ja     7c7 <free+0x4f>
+ 7a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7a6:	8b 00                	mov    (%eax),%eax
+ 7a8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 7ab:	77 1a                	ja     7c7 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b0:	8b 00                	mov    (%eax),%eax
+ 7b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 7b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7b8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7bb:	76 d4                	jbe    791 <free+0x19>
+ 7bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7c0:	8b 00                	mov    (%eax),%eax
+ 7c2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 7c5:	76 ca                	jbe    791 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 7c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7ca:	8b 40 04             	mov    0x4(%eax),%eax
+ 7cd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 7d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7d7:	01 c2                	add    %eax,%edx
+ 7d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7dc:	8b 00                	mov    (%eax),%eax
+ 7de:	39 c2                	cmp    %eax,%edx
+ 7e0:	75 24                	jne    806 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 7e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7e5:	8b 50 04             	mov    0x4(%eax),%edx
+ 7e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7eb:	8b 00                	mov    (%eax),%eax
+ 7ed:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f0:	01 c2                	add    %eax,%edx
+ 7f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7f5:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7fb:	8b 00                	mov    (%eax),%eax
+ 7fd:	8b 10                	mov    (%eax),%edx
+ 7ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 802:	89 10                	mov    %edx,(%eax)
+ 804:	eb 0a                	jmp    810 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 806:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 809:	8b 10                	mov    (%eax),%edx
+ 80b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 80e:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 810:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 813:	8b 40 04             	mov    0x4(%eax),%eax
+ 816:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 81d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 820:	01 d0                	add    %edx,%eax
+ 822:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 825:	75 20                	jne    847 <free+0xcf>
+    p->s.size += bp->s.size;
+ 827:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 82a:	8b 50 04             	mov    0x4(%eax),%edx
+ 82d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 830:	8b 40 04             	mov    0x4(%eax),%eax
+ 833:	01 c2                	add    %eax,%edx
+ 835:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 838:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 83b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 83e:	8b 10                	mov    (%eax),%edx
+ 840:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 843:	89 10                	mov    %edx,(%eax)
+ 845:	eb 08                	jmp    84f <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 847:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 84a:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 84d:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 84f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 852:	a3 14 0c 00 00       	mov    %eax,0xc14
+}
+ 857:	c9                   	leave  
+ 858:	c3                   	ret    
+
+00000859 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 859:	55                   	push   %ebp
+ 85a:	89 e5                	mov    %esp,%ebp
+ 85c:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 85f:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 866:	77 07                	ja     86f <morecore+0x16>
+    nu = 4096;
+ 868:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 86f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 872:	c1 e0 03             	shl    $0x3,%eax
+ 875:	89 04 24             	mov    %eax,(%esp)
+ 878:	e8 27 fc ff ff       	call   4a4 <sbrk>
+ 87d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 880:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 884:	75 07                	jne    88d <morecore+0x34>
+    return 0;
+ 886:	b8 00 00 00 00       	mov    $0x0,%eax
+ 88b:	eb 22                	jmp    8af <morecore+0x56>
+  hp = (Header*)p;
+ 88d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 890:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 893:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 896:	8b 55 08             	mov    0x8(%ebp),%edx
+ 899:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 89c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 89f:	83 c0 08             	add    $0x8,%eax
+ 8a2:	89 04 24             	mov    %eax,(%esp)
+ 8a5:	e8 ce fe ff ff       	call   778 <free>
+  return freep;
+ 8aa:	a1 14 0c 00 00       	mov    0xc14,%eax
+}
+ 8af:	c9                   	leave  
+ 8b0:	c3                   	ret    
+
+000008b1 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 8b1:	55                   	push   %ebp
+ 8b2:	89 e5                	mov    %esp,%ebp
+ 8b4:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 8b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8ba:	83 c0 07             	add    $0x7,%eax
+ 8bd:	c1 e8 03             	shr    $0x3,%eax
+ 8c0:	83 c0 01             	add    $0x1,%eax
+ 8c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 8c6:	a1 14 0c 00 00       	mov    0xc14,%eax
+ 8cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8ce:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 8d2:	75 23                	jne    8f7 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 8d4:	c7 45 f0 0c 0c 00 00 	movl   $0xc0c,-0x10(%ebp)
+ 8db:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8de:	a3 14 0c 00 00       	mov    %eax,0xc14
+ 8e3:	a1 14 0c 00 00       	mov    0xc14,%eax
+ 8e8:	a3 0c 0c 00 00       	mov    %eax,0xc0c
+    base.s.size = 0;
+ 8ed:	c7 05 10 0c 00 00 00 	movl   $0x0,0xc10
+ 8f4:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8fa:	8b 00                	mov    (%eax),%eax
+ 8fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 8ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 902:	8b 40 04             	mov    0x4(%eax),%eax
+ 905:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 908:	72 4d                	jb     957 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 90d:	8b 40 04             	mov    0x4(%eax),%eax
+ 910:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 913:	75 0c                	jne    921 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 915:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 918:	8b 10                	mov    (%eax),%edx
+ 91a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 91d:	89 10                	mov    %edx,(%eax)
+ 91f:	eb 26                	jmp    947 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 921:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 924:	8b 40 04             	mov    0x4(%eax),%eax
+ 927:	89 c2                	mov    %eax,%edx
+ 929:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 92f:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 932:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 935:	8b 40 04             	mov    0x4(%eax),%eax
+ 938:	c1 e0 03             	shl    $0x3,%eax
+ 93b:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 93e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 941:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 944:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 947:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 94a:	a3 14 0c 00 00       	mov    %eax,0xc14
+      return (void*)(p + 1);
+ 94f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 952:	83 c0 08             	add    $0x8,%eax
+ 955:	eb 38                	jmp    98f <malloc+0xde>
+    }
+    if(p == freep)
+ 957:	a1 14 0c 00 00       	mov    0xc14,%eax
+ 95c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 95f:	75 1b                	jne    97c <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 961:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 964:	89 04 24             	mov    %eax,(%esp)
+ 967:	e8 ed fe ff ff       	call   859 <morecore>
+ 96c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 96f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 973:	75 07                	jne    97c <malloc+0xcb>
+        return 0;
+ 975:	b8 00 00 00 00       	mov    $0x0,%eax
+ 97a:	eb 13                	jmp    98f <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 97c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 97f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 982:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 985:	8b 00                	mov    (%eax),%eax
+ 987:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 98a:	e9 70 ff ff ff       	jmp    8ff <malloc+0x4e>
+}
+ 98f:	c9                   	leave  
+ 990:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/stressfs.d cs550-16s-proj1-working/stressfs.d
--- cs550-16s-proj1-base/stressfs.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/stressfs.d	2016-03-04 14:37:06.000000000 -0500
@@ -0,0 +1 @@
+stressfs.o: stressfs.c types.h stat.h user.h fs.h fcntl.h
Binary files cs550-16s-proj1-base/stressfs.o and cs550-16s-proj1-working/stressfs.o differ
diff -uNr cs550-16s-proj1-base/stressfs.sym cs550-16s-proj1-working/stressfs.sym
--- cs550-16s-proj1-base/stressfs.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/stressfs.sym	2016-03-04 14:37:07.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+00000991 .rodata
+000009bc .eh_frame
+00000bf8 .data
+00000c0c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 stressfs.c
+00000000 ulib.c
+000001b4 stosb
+00000000 printf.c
+000004e4 putc
+0000050c printint
+00000bf8 digits.1028
+00000000 umalloc.c
+00000c0c base
+00000c14 freep
+00000859 morecore
+000001d9 strcpy
+000005c1 printf
+000003d8 memmove
+00000464 mknod
+000002cc gets
+0000049c getpid
+000008b1 malloc
+000004ac sleep
+000004dc set_priority
+0000042c pipe
+0000043c write
+00000474 fstat
+0000044c kill
+0000048c chdir
+00000454 exec
+00000424 wait
+00000434 read
+0000046c unlink
+00000414 fork
+000004a4 sbrk
+000004b4 uptime
+00000c0c __bss_start
+00000275 memset
+00000000 main
+000004bc enable_sched_trace
+0000020d strcmp
+000004c4 shutdown
+00000494 dup
+000004d4 set_sched
+0000033f stat
+00000c0c _edata
+00000c18 _end
+0000047c link
+0000041c exit
+0000038d atoi
+000004cc fork_winner
+0000024e strlen
+0000045c open
+00000299 strchr
+00000484 mkdir
+00000444 close
+00000778 free
diff -uNr cs550-16s-proj1-base/string.d cs550-16s-proj1-working/string.d
--- cs550-16s-proj1-base/string.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/string.d	2016-03-04 14:37:24.000000000 -0500
@@ -0,0 +1 @@
+string.o: string.c types.h x86.h
Binary files cs550-16s-proj1-base/string.o and cs550-16s-proj1-working/string.o differ
Binary files cs550-16s-proj1-base/swtch.o and cs550-16s-proj1-working/swtch.o differ
diff -uNr cs550-16s-proj1-base/syscall.c cs550-16s-proj1-working/syscall.c
--- cs550-16s-proj1-base/syscall.c	2016-02-15 19:34:32.000000000 -0500
+++ cs550-16s-proj1-working/syscall.c	2016-03-04 14:36:42.000000000 -0500
@@ -99,7 +99,10 @@
 extern int sys_write(void);
 extern int sys_uptime(void);
 extern int sys_enable_sched_trace(void);
-
+extern int sys_shutdown(void);
+extern int sys_fork_winner(void);
+extern int sys_set_sched(void);
+extern int sys_set_priority(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -124,7 +127,10 @@
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
 [SYS_enable_sched_trace]   sys_enable_sched_trace,
-
+[SYS_shutdown]   sys_shutdown,
+[SYS_fork_winner]   sys_fork_winner,
+[SYS_set_sched]  sys_set_sched,
+[SYS_set_priority]  sys_set_priority,
 };
 
 void
diff -uNr cs550-16s-proj1-base/syscall.d cs550-16s-proj1-working/syscall.d
--- cs550-16s-proj1-base/syscall.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/syscall.d	2016-03-04 15:52:34.698695011 -0500
@@ -0,0 +1,2 @@
+syscall.o: syscall.c types.h defs.h param.h memlayout.h mmu.h proc.h \
+ x86.h syscall.h
diff -uNr cs550-16s-proj1-base/syscall.h cs550-16s-proj1-working/syscall.h
--- cs550-16s-proj1-base/syscall.h	2016-02-15 19:35:00.000000000 -0500
+++ cs550-16s-proj1-working/syscall.h	2016-03-04 14:36:43.000000000 -0500
@@ -21,4 +21,7 @@
 #define SYS_mkdir  20
 #define SYS_close  21
 #define SYS_enable_sched_trace  22
-
+#define SYS_shutdown  23
+#define SYS_fork_winner  24
+#define SYS_set_sched  25
+#define SYS_set_priority  26
Binary files cs550-16s-proj1-base/syscall.o and cs550-16s-proj1-working/syscall.o differ
diff -uNr cs550-16s-proj1-base/sysfile.d cs550-16s-proj1-working/sysfile.d
--- cs550-16s-proj1-base/sysfile.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/sysfile.d	2016-03-04 15:52:35.210687646 -0500
@@ -0,0 +1,2 @@
+sysfile.o: sysfile.c types.h defs.h param.h stat.h mmu.h proc.h fs.h \
+ file.h fcntl.h
Binary files cs550-16s-proj1-base/sysfile.o and cs550-16s-proj1-working/sysfile.o differ
diff -uNr cs550-16s-proj1-base/sysproc.c cs550-16s-proj1-working/sysproc.c
--- cs550-16s-proj1-base/sysproc.c	2016-02-15 19:35:25.000000000 -0500
+++ cs550-16s-proj1-working/sysproc.c	2016-03-04 15:54:51.000000000 -0500
@@ -7,6 +7,44 @@
 #include "mmu.h"
 #include "proc.h"
 
+extern int schd_choice;
+int
+sys_set_sched(void)
+{
+   if (argint(0, &schd_choice) < 0) {
+       cprintf("set_sched() failed!\n");
+    }
+   return 0;
+}
+
+extern int process_id;
+extern int process_priority;
+extern void set_priority(int pid,int priority);
+int
+sys_set_priority(void)
+{
+   if ((argint(0, &process_id) < 0)||(argint(1, &process_priority) < 0)) {
+       cprintf("set_priority() failed!\n");
+        return -1;
+    }
+   set_priority(process_id,process_priority);
+   return 0;
+}
+extern int win;
+int
+sys_fork_winner(void)
+{
+   if (argint(0, &win) < 0) {
+       cprintf("fork_winner() failed!\n");
+    }
+    return 0;
+}
+int
+sys_shutdown(void)
+{
+   outw(0xB004, 0x0|0x2000);
+   return 0;
+}
 int
 sys_fork(void)
 {
@@ -89,8 +127,8 @@
   release(&tickslock);
   return xticks;
 }
-
 extern int sched_trace_enabled;
+//extern int sched_trace_enabled;
 int sys_enable_sched_trace(void)
 {
   if (argint(0, &sched_trace_enabled) < 0)
diff -uNr cs550-16s-proj1-base/sysproc.d cs550-16s-proj1-working/sysproc.d
--- cs550-16s-proj1-base/sysproc.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/sysproc.d	2016-03-04 15:55:03.344553997 -0500
@@ -0,0 +1,2 @@
+sysproc.o: sysproc.c types.h x86.h defs.h date.h param.h memlayout.h \
+ mmu.h proc.h
Binary files cs550-16s-proj1-base/sysproc.o and cs550-16s-proj1-working/sysproc.o differ
diff -uNr cs550-16s-proj1-base/timer.d cs550-16s-proj1-working/timer.d
--- cs550-16s-proj1-base/timer.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/timer.d	2016-03-04 14:37:26.000000000 -0500
@@ -0,0 +1 @@
+timer.o: timer.c types.h defs.h traps.h x86.h
Binary files cs550-16s-proj1-base/timer.o and cs550-16s-proj1-working/timer.o differ
Binary files cs550-16s-proj1-base/trapasm.o and cs550-16s-proj1-working/trapasm.o differ
diff -uNr cs550-16s-proj1-base/trap.d cs550-16s-proj1-working/trap.d
--- cs550-16s-proj1-base/trap.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/trap.d	2016-03-04 15:55:03.812547249 -0500
@@ -0,0 +1,2 @@
+trap.o: trap.c types.h defs.h param.h memlayout.h mmu.h proc.h x86.h \
+ traps.h spinlock.h
Binary files cs550-16s-proj1-base/trap.o and cs550-16s-proj1-working/trap.o differ
diff -uNr cs550-16s-proj1-base/uart.d cs550-16s-proj1-working/uart.d
--- cs550-16s-proj1-base/uart.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/uart.d	2016-03-04 15:55:04.320539924 -0500
@@ -0,0 +1,2 @@
+uart.o: uart.c types.h defs.h param.h traps.h spinlock.h fs.h file.h \
+ mmu.h proc.h x86.h
Binary files cs550-16s-proj1-base/uart.o and cs550-16s-proj1-working/uart.o differ
diff -uNr cs550-16s-proj1-base/ulib.d cs550-16s-proj1-working/ulib.d
--- cs550-16s-proj1-base/ulib.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/ulib.d	2016-03-04 14:36:52.000000000 -0500
@@ -0,0 +1 @@
+ulib.o: ulib.c types.h stat.h fcntl.h user.h x86.h
Binary files cs550-16s-proj1-base/ulib.o and cs550-16s-proj1-working/ulib.o differ
diff -uNr cs550-16s-proj1-base/umalloc.d cs550-16s-proj1-working/umalloc.d
--- cs550-16s-proj1-base/umalloc.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/umalloc.d	2016-03-04 14:36:53.000000000 -0500
@@ -0,0 +1 @@
+umalloc.o: umalloc.c types.h stat.h user.h param.h
Binary files cs550-16s-proj1-base/umalloc.o and cs550-16s-proj1-working/umalloc.o differ
diff -uNr cs550-16s-proj1-base/user.h cs550-16s-proj1-working/user.h
--- cs550-16s-proj1-base/user.h	2016-02-15 19:35:38.000000000 -0500
+++ cs550-16s-proj1-working/user.h	2016-03-04 14:36:43.000000000 -0500
@@ -23,6 +23,10 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+void shutdown(void);
+void fork_winner(int);
+void set_sched(int);
+void set_priority(int,int);
 
 // ulib.c
 int stat(char*, struct stat*);
Binary files cs550-16s-proj1-base/_usertests and cs550-16s-proj1-working/_usertests differ
diff -uNr cs550-16s-proj1-base/usertests.asm cs550-16s-proj1-working/usertests.asm
--- cs550-16s-proj1-base/usertests.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/usertests.asm	2016-03-04 14:37:08.000000000 -0500
@@ -0,0 +1,7376 @@
+
+_usertests:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <iputtest>:
+int stdout = 1;
+
+// does chdir() call iput(p->cwd) in a transaction?
+void
+iputtest(void)
+{
+       0:	55                   	push   %ebp
+       1:	89 e5                	mov    %esp,%ebp
+       3:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "iput test\n");
+       6:	a1 10 63 00 00       	mov    0x6310,%eax
+       b:	c7 44 24 04 6a 44 00 	movl   $0x446a,0x4(%esp)
+      12:	00 
+      13:	89 04 24             	mov    %eax,(%esp)
+      16:	e8 66 40 00 00       	call   4081 <printf>
+
+  if(mkdir("iputdir") < 0){
+      1b:	c7 04 24 75 44 00 00 	movl   $0x4475,(%esp)
+      22:	e8 1d 3f 00 00       	call   3f44 <mkdir>
+      27:	85 c0                	test   %eax,%eax
+      29:	79 1a                	jns    45 <iputtest+0x45>
+    printf(stdout, "mkdir failed\n");
+      2b:	a1 10 63 00 00       	mov    0x6310,%eax
+      30:	c7 44 24 04 7d 44 00 	movl   $0x447d,0x4(%esp)
+      37:	00 
+      38:	89 04 24             	mov    %eax,(%esp)
+      3b:	e8 41 40 00 00       	call   4081 <printf>
+    exit();
+      40:	e8 97 3e 00 00       	call   3edc <exit>
+  }
+  if(chdir("iputdir") < 0){
+      45:	c7 04 24 75 44 00 00 	movl   $0x4475,(%esp)
+      4c:	e8 fb 3e 00 00       	call   3f4c <chdir>
+      51:	85 c0                	test   %eax,%eax
+      53:	79 1a                	jns    6f <iputtest+0x6f>
+    printf(stdout, "chdir iputdir failed\n");
+      55:	a1 10 63 00 00       	mov    0x6310,%eax
+      5a:	c7 44 24 04 8b 44 00 	movl   $0x448b,0x4(%esp)
+      61:	00 
+      62:	89 04 24             	mov    %eax,(%esp)
+      65:	e8 17 40 00 00       	call   4081 <printf>
+    exit();
+      6a:	e8 6d 3e 00 00       	call   3edc <exit>
+  }
+  if(unlink("../iputdir") < 0){
+      6f:	c7 04 24 a1 44 00 00 	movl   $0x44a1,(%esp)
+      76:	e8 b1 3e 00 00       	call   3f2c <unlink>
+      7b:	85 c0                	test   %eax,%eax
+      7d:	79 1a                	jns    99 <iputtest+0x99>
+    printf(stdout, "unlink ../iputdir failed\n");
+      7f:	a1 10 63 00 00       	mov    0x6310,%eax
+      84:	c7 44 24 04 ac 44 00 	movl   $0x44ac,0x4(%esp)
+      8b:	00 
+      8c:	89 04 24             	mov    %eax,(%esp)
+      8f:	e8 ed 3f 00 00       	call   4081 <printf>
+    exit();
+      94:	e8 43 3e 00 00       	call   3edc <exit>
+  }
+  if(chdir("/") < 0){
+      99:	c7 04 24 c6 44 00 00 	movl   $0x44c6,(%esp)
+      a0:	e8 a7 3e 00 00       	call   3f4c <chdir>
+      a5:	85 c0                	test   %eax,%eax
+      a7:	79 1a                	jns    c3 <iputtest+0xc3>
+    printf(stdout, "chdir / failed\n");
+      a9:	a1 10 63 00 00       	mov    0x6310,%eax
+      ae:	c7 44 24 04 c8 44 00 	movl   $0x44c8,0x4(%esp)
+      b5:	00 
+      b6:	89 04 24             	mov    %eax,(%esp)
+      b9:	e8 c3 3f 00 00       	call   4081 <printf>
+    exit();
+      be:	e8 19 3e 00 00       	call   3edc <exit>
+  }
+  printf(stdout, "iput test ok\n");
+      c3:	a1 10 63 00 00       	mov    0x6310,%eax
+      c8:	c7 44 24 04 d8 44 00 	movl   $0x44d8,0x4(%esp)
+      cf:	00 
+      d0:	89 04 24             	mov    %eax,(%esp)
+      d3:	e8 a9 3f 00 00       	call   4081 <printf>
+}
+      d8:	c9                   	leave  
+      d9:	c3                   	ret    
+
+000000da <exitiputtest>:
+
+// does exit() call iput(p->cwd) in a transaction?
+void
+exitiputtest(void)
+{
+      da:	55                   	push   %ebp
+      db:	89 e5                	mov    %esp,%ebp
+      dd:	83 ec 28             	sub    $0x28,%esp
+  int pid;
+
+  printf(stdout, "exitiput test\n");
+      e0:	a1 10 63 00 00       	mov    0x6310,%eax
+      e5:	c7 44 24 04 e6 44 00 	movl   $0x44e6,0x4(%esp)
+      ec:	00 
+      ed:	89 04 24             	mov    %eax,(%esp)
+      f0:	e8 8c 3f 00 00       	call   4081 <printf>
+
+  pid = fork();
+      f5:	e8 da 3d 00 00       	call   3ed4 <fork>
+      fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid < 0){
+      fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     101:	79 1a                	jns    11d <exitiputtest+0x43>
+    printf(stdout, "fork failed\n");
+     103:	a1 10 63 00 00       	mov    0x6310,%eax
+     108:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+     10f:	00 
+     110:	89 04 24             	mov    %eax,(%esp)
+     113:	e8 69 3f 00 00       	call   4081 <printf>
+    exit();
+     118:	e8 bf 3d 00 00       	call   3edc <exit>
+  }
+  if(pid == 0){
+     11d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     121:	0f 85 83 00 00 00    	jne    1aa <exitiputtest+0xd0>
+    if(mkdir("iputdir") < 0){
+     127:	c7 04 24 75 44 00 00 	movl   $0x4475,(%esp)
+     12e:	e8 11 3e 00 00       	call   3f44 <mkdir>
+     133:	85 c0                	test   %eax,%eax
+     135:	79 1a                	jns    151 <exitiputtest+0x77>
+      printf(stdout, "mkdir failed\n");
+     137:	a1 10 63 00 00       	mov    0x6310,%eax
+     13c:	c7 44 24 04 7d 44 00 	movl   $0x447d,0x4(%esp)
+     143:	00 
+     144:	89 04 24             	mov    %eax,(%esp)
+     147:	e8 35 3f 00 00       	call   4081 <printf>
+      exit();
+     14c:	e8 8b 3d 00 00       	call   3edc <exit>
+    }
+    if(chdir("iputdir") < 0){
+     151:	c7 04 24 75 44 00 00 	movl   $0x4475,(%esp)
+     158:	e8 ef 3d 00 00       	call   3f4c <chdir>
+     15d:	85 c0                	test   %eax,%eax
+     15f:	79 1a                	jns    17b <exitiputtest+0xa1>
+      printf(stdout, "child chdir failed\n");
+     161:	a1 10 63 00 00       	mov    0x6310,%eax
+     166:	c7 44 24 04 02 45 00 	movl   $0x4502,0x4(%esp)
+     16d:	00 
+     16e:	89 04 24             	mov    %eax,(%esp)
+     171:	e8 0b 3f 00 00       	call   4081 <printf>
+      exit();
+     176:	e8 61 3d 00 00       	call   3edc <exit>
+    }
+    if(unlink("../iputdir") < 0){
+     17b:	c7 04 24 a1 44 00 00 	movl   $0x44a1,(%esp)
+     182:	e8 a5 3d 00 00       	call   3f2c <unlink>
+     187:	85 c0                	test   %eax,%eax
+     189:	79 1a                	jns    1a5 <exitiputtest+0xcb>
+      printf(stdout, "unlink ../iputdir failed\n");
+     18b:	a1 10 63 00 00       	mov    0x6310,%eax
+     190:	c7 44 24 04 ac 44 00 	movl   $0x44ac,0x4(%esp)
+     197:	00 
+     198:	89 04 24             	mov    %eax,(%esp)
+     19b:	e8 e1 3e 00 00       	call   4081 <printf>
+      exit();
+     1a0:	e8 37 3d 00 00       	call   3edc <exit>
+    }
+    exit();
+     1a5:	e8 32 3d 00 00       	call   3edc <exit>
+  }
+  wait();
+     1aa:	e8 35 3d 00 00       	call   3ee4 <wait>
+  printf(stdout, "exitiput test ok\n");
+     1af:	a1 10 63 00 00       	mov    0x6310,%eax
+     1b4:	c7 44 24 04 16 45 00 	movl   $0x4516,0x4(%esp)
+     1bb:	00 
+     1bc:	89 04 24             	mov    %eax,(%esp)
+     1bf:	e8 bd 3e 00 00       	call   4081 <printf>
+}
+     1c4:	c9                   	leave  
+     1c5:	c3                   	ret    
+
+000001c6 <openiputtest>:
+//      for(i = 0; i < 10000; i++)
+//        yield();
+//    }
+void
+openiputtest(void)
+{
+     1c6:	55                   	push   %ebp
+     1c7:	89 e5                	mov    %esp,%ebp
+     1c9:	83 ec 28             	sub    $0x28,%esp
+  int pid;
+
+  printf(stdout, "openiput test\n");
+     1cc:	a1 10 63 00 00       	mov    0x6310,%eax
+     1d1:	c7 44 24 04 28 45 00 	movl   $0x4528,0x4(%esp)
+     1d8:	00 
+     1d9:	89 04 24             	mov    %eax,(%esp)
+     1dc:	e8 a0 3e 00 00       	call   4081 <printf>
+  if(mkdir("oidir") < 0){
+     1e1:	c7 04 24 37 45 00 00 	movl   $0x4537,(%esp)
+     1e8:	e8 57 3d 00 00       	call   3f44 <mkdir>
+     1ed:	85 c0                	test   %eax,%eax
+     1ef:	79 1a                	jns    20b <openiputtest+0x45>
+    printf(stdout, "mkdir oidir failed\n");
+     1f1:	a1 10 63 00 00       	mov    0x6310,%eax
+     1f6:	c7 44 24 04 3d 45 00 	movl   $0x453d,0x4(%esp)
+     1fd:	00 
+     1fe:	89 04 24             	mov    %eax,(%esp)
+     201:	e8 7b 3e 00 00       	call   4081 <printf>
+    exit();
+     206:	e8 d1 3c 00 00       	call   3edc <exit>
+  }
+  pid = fork();
+     20b:	e8 c4 3c 00 00       	call   3ed4 <fork>
+     210:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid < 0){
+     213:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     217:	79 1a                	jns    233 <openiputtest+0x6d>
+    printf(stdout, "fork failed\n");
+     219:	a1 10 63 00 00       	mov    0x6310,%eax
+     21e:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+     225:	00 
+     226:	89 04 24             	mov    %eax,(%esp)
+     229:	e8 53 3e 00 00       	call   4081 <printf>
+    exit();
+     22e:	e8 a9 3c 00 00       	call   3edc <exit>
+  }
+  if(pid == 0){
+     233:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     237:	75 3c                	jne    275 <openiputtest+0xaf>
+    int fd = open("oidir", O_RDWR);
+     239:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+     240:	00 
+     241:	c7 04 24 37 45 00 00 	movl   $0x4537,(%esp)
+     248:	e8 cf 3c 00 00       	call   3f1c <open>
+     24d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fd >= 0){
+     250:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     254:	78 1a                	js     270 <openiputtest+0xaa>
+      printf(stdout, "open directory for write succeeded\n");
+     256:	a1 10 63 00 00       	mov    0x6310,%eax
+     25b:	c7 44 24 04 54 45 00 	movl   $0x4554,0x4(%esp)
+     262:	00 
+     263:	89 04 24             	mov    %eax,(%esp)
+     266:	e8 16 3e 00 00       	call   4081 <printf>
+      exit();
+     26b:	e8 6c 3c 00 00       	call   3edc <exit>
+    }
+    exit();
+     270:	e8 67 3c 00 00       	call   3edc <exit>
+  }
+  sleep(1);
+     275:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     27c:	e8 eb 3c 00 00       	call   3f6c <sleep>
+  if(unlink("oidir") != 0){
+     281:	c7 04 24 37 45 00 00 	movl   $0x4537,(%esp)
+     288:	e8 9f 3c 00 00       	call   3f2c <unlink>
+     28d:	85 c0                	test   %eax,%eax
+     28f:	74 1a                	je     2ab <openiputtest+0xe5>
+    printf(stdout, "unlink failed\n");
+     291:	a1 10 63 00 00       	mov    0x6310,%eax
+     296:	c7 44 24 04 78 45 00 	movl   $0x4578,0x4(%esp)
+     29d:	00 
+     29e:	89 04 24             	mov    %eax,(%esp)
+     2a1:	e8 db 3d 00 00       	call   4081 <printf>
+    exit();
+     2a6:	e8 31 3c 00 00       	call   3edc <exit>
+  }
+  wait();
+     2ab:	e8 34 3c 00 00       	call   3ee4 <wait>
+  printf(stdout, "openiput test ok\n");
+     2b0:	a1 10 63 00 00       	mov    0x6310,%eax
+     2b5:	c7 44 24 04 87 45 00 	movl   $0x4587,0x4(%esp)
+     2bc:	00 
+     2bd:	89 04 24             	mov    %eax,(%esp)
+     2c0:	e8 bc 3d 00 00       	call   4081 <printf>
+}
+     2c5:	c9                   	leave  
+     2c6:	c3                   	ret    
+
+000002c7 <opentest>:
+
+// simple file system tests
+
+void
+opentest(void)
+{
+     2c7:	55                   	push   %ebp
+     2c8:	89 e5                	mov    %esp,%ebp
+     2ca:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+
+  printf(stdout, "open test\n");
+     2cd:	a1 10 63 00 00       	mov    0x6310,%eax
+     2d2:	c7 44 24 04 99 45 00 	movl   $0x4599,0x4(%esp)
+     2d9:	00 
+     2da:	89 04 24             	mov    %eax,(%esp)
+     2dd:	e8 9f 3d 00 00       	call   4081 <printf>
+  fd = open("echo", 0);
+     2e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     2e9:	00 
+     2ea:	c7 04 24 54 44 00 00 	movl   $0x4454,(%esp)
+     2f1:	e8 26 3c 00 00       	call   3f1c <open>
+     2f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+     2f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     2fd:	79 1a                	jns    319 <opentest+0x52>
+    printf(stdout, "open echo failed!\n");
+     2ff:	a1 10 63 00 00       	mov    0x6310,%eax
+     304:	c7 44 24 04 a4 45 00 	movl   $0x45a4,0x4(%esp)
+     30b:	00 
+     30c:	89 04 24             	mov    %eax,(%esp)
+     30f:	e8 6d 3d 00 00       	call   4081 <printf>
+    exit();
+     314:	e8 c3 3b 00 00       	call   3edc <exit>
+  }
+  close(fd);
+     319:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     31c:	89 04 24             	mov    %eax,(%esp)
+     31f:	e8 e0 3b 00 00       	call   3f04 <close>
+  fd = open("doesnotexist", 0);
+     324:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     32b:	00 
+     32c:	c7 04 24 b7 45 00 00 	movl   $0x45b7,(%esp)
+     333:	e8 e4 3b 00 00       	call   3f1c <open>
+     338:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+     33b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     33f:	78 1a                	js     35b <opentest+0x94>
+    printf(stdout, "open doesnotexist succeeded!\n");
+     341:	a1 10 63 00 00       	mov    0x6310,%eax
+     346:	c7 44 24 04 c4 45 00 	movl   $0x45c4,0x4(%esp)
+     34d:	00 
+     34e:	89 04 24             	mov    %eax,(%esp)
+     351:	e8 2b 3d 00 00       	call   4081 <printf>
+    exit();
+     356:	e8 81 3b 00 00       	call   3edc <exit>
+  }
+  printf(stdout, "open test ok\n");
+     35b:	a1 10 63 00 00       	mov    0x6310,%eax
+     360:	c7 44 24 04 e2 45 00 	movl   $0x45e2,0x4(%esp)
+     367:	00 
+     368:	89 04 24             	mov    %eax,(%esp)
+     36b:	e8 11 3d 00 00       	call   4081 <printf>
+}
+     370:	c9                   	leave  
+     371:	c3                   	ret    
+
+00000372 <writetest>:
+
+void
+writetest(void)
+{
+     372:	55                   	push   %ebp
+     373:	89 e5                	mov    %esp,%ebp
+     375:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int i;
+
+  printf(stdout, "small file test\n");
+     378:	a1 10 63 00 00       	mov    0x6310,%eax
+     37d:	c7 44 24 04 f0 45 00 	movl   $0x45f0,0x4(%esp)
+     384:	00 
+     385:	89 04 24             	mov    %eax,(%esp)
+     388:	e8 f4 3c 00 00       	call   4081 <printf>
+  fd = open("small", O_CREATE|O_RDWR);
+     38d:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+     394:	00 
+     395:	c7 04 24 01 46 00 00 	movl   $0x4601,(%esp)
+     39c:	e8 7b 3b 00 00       	call   3f1c <open>
+     3a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(fd >= 0){
+     3a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     3a8:	78 21                	js     3cb <writetest+0x59>
+    printf(stdout, "creat small succeeded; ok\n");
+     3aa:	a1 10 63 00 00       	mov    0x6310,%eax
+     3af:	c7 44 24 04 07 46 00 	movl   $0x4607,0x4(%esp)
+     3b6:	00 
+     3b7:	89 04 24             	mov    %eax,(%esp)
+     3ba:	e8 c2 3c 00 00       	call   4081 <printf>
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+    exit();
+  }
+  for(i = 0; i < 100; i++){
+     3bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     3c6:	e9 a0 00 00 00       	jmp    46b <writetest+0xf9>
+  printf(stdout, "small file test\n");
+  fd = open("small", O_CREATE|O_RDWR);
+  if(fd >= 0){
+    printf(stdout, "creat small succeeded; ok\n");
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+     3cb:	a1 10 63 00 00       	mov    0x6310,%eax
+     3d0:	c7 44 24 04 22 46 00 	movl   $0x4622,0x4(%esp)
+     3d7:	00 
+     3d8:	89 04 24             	mov    %eax,(%esp)
+     3db:	e8 a1 3c 00 00       	call   4081 <printf>
+    exit();
+     3e0:	e8 f7 3a 00 00       	call   3edc <exit>
+  }
+  for(i = 0; i < 100; i++){
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+     3e5:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+     3ec:	00 
+     3ed:	c7 44 24 04 3e 46 00 	movl   $0x463e,0x4(%esp)
+     3f4:	00 
+     3f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     3f8:	89 04 24             	mov    %eax,(%esp)
+     3fb:	e8 fc 3a 00 00       	call   3efc <write>
+     400:	83 f8 0a             	cmp    $0xa,%eax
+     403:	74 21                	je     426 <writetest+0xb4>
+      printf(stdout, "error: write aa %d new file failed\n", i);
+     405:	a1 10 63 00 00       	mov    0x6310,%eax
+     40a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     40d:	89 54 24 08          	mov    %edx,0x8(%esp)
+     411:	c7 44 24 04 4c 46 00 	movl   $0x464c,0x4(%esp)
+     418:	00 
+     419:	89 04 24             	mov    %eax,(%esp)
+     41c:	e8 60 3c 00 00       	call   4081 <printf>
+      exit();
+     421:	e8 b6 3a 00 00       	call   3edc <exit>
+    }
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+     426:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+     42d:	00 
+     42e:	c7 44 24 04 70 46 00 	movl   $0x4670,0x4(%esp)
+     435:	00 
+     436:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     439:	89 04 24             	mov    %eax,(%esp)
+     43c:	e8 bb 3a 00 00       	call   3efc <write>
+     441:	83 f8 0a             	cmp    $0xa,%eax
+     444:	74 21                	je     467 <writetest+0xf5>
+      printf(stdout, "error: write bb %d new file failed\n", i);
+     446:	a1 10 63 00 00       	mov    0x6310,%eax
+     44b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     44e:	89 54 24 08          	mov    %edx,0x8(%esp)
+     452:	c7 44 24 04 7c 46 00 	movl   $0x467c,0x4(%esp)
+     459:	00 
+     45a:	89 04 24             	mov    %eax,(%esp)
+     45d:	e8 1f 3c 00 00       	call   4081 <printf>
+      exit();
+     462:	e8 75 3a 00 00       	call   3edc <exit>
+    printf(stdout, "creat small succeeded; ok\n");
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+    exit();
+  }
+  for(i = 0; i < 100; i++){
+     467:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     46b:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+     46f:	0f 8e 70 ff ff ff    	jle    3e5 <writetest+0x73>
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+      printf(stdout, "error: write bb %d new file failed\n", i);
+      exit();
+    }
+  }
+  printf(stdout, "writes ok\n");
+     475:	a1 10 63 00 00       	mov    0x6310,%eax
+     47a:	c7 44 24 04 a0 46 00 	movl   $0x46a0,0x4(%esp)
+     481:	00 
+     482:	89 04 24             	mov    %eax,(%esp)
+     485:	e8 f7 3b 00 00       	call   4081 <printf>
+  close(fd);
+     48a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     48d:	89 04 24             	mov    %eax,(%esp)
+     490:	e8 6f 3a 00 00       	call   3f04 <close>
+  fd = open("small", O_RDONLY);
+     495:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     49c:	00 
+     49d:	c7 04 24 01 46 00 00 	movl   $0x4601,(%esp)
+     4a4:	e8 73 3a 00 00       	call   3f1c <open>
+     4a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(fd >= 0){
+     4ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     4b0:	78 3e                	js     4f0 <writetest+0x17e>
+    printf(stdout, "open small succeeded ok\n");
+     4b2:	a1 10 63 00 00       	mov    0x6310,%eax
+     4b7:	c7 44 24 04 ab 46 00 	movl   $0x46ab,0x4(%esp)
+     4be:	00 
+     4bf:	89 04 24             	mov    %eax,(%esp)
+     4c2:	e8 ba 3b 00 00       	call   4081 <printf>
+  } else {
+    printf(stdout, "error: open small failed!\n");
+    exit();
+  }
+  i = read(fd, buf, 2000);
+     4c7:	c7 44 24 08 d0 07 00 	movl   $0x7d0,0x8(%esp)
+     4ce:	00 
+     4cf:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+     4d6:	00 
+     4d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     4da:	89 04 24             	mov    %eax,(%esp)
+     4dd:	e8 12 3a 00 00       	call   3ef4 <read>
+     4e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(i == 2000){
+     4e5:	81 7d f4 d0 07 00 00 	cmpl   $0x7d0,-0xc(%ebp)
+     4ec:	74 1c                	je     50a <writetest+0x198>
+     4ee:	eb 4c                	jmp    53c <writetest+0x1ca>
+  close(fd);
+  fd = open("small", O_RDONLY);
+  if(fd >= 0){
+    printf(stdout, "open small succeeded ok\n");
+  } else {
+    printf(stdout, "error: open small failed!\n");
+     4f0:	a1 10 63 00 00       	mov    0x6310,%eax
+     4f5:	c7 44 24 04 c4 46 00 	movl   $0x46c4,0x4(%esp)
+     4fc:	00 
+     4fd:	89 04 24             	mov    %eax,(%esp)
+     500:	e8 7c 3b 00 00       	call   4081 <printf>
+    exit();
+     505:	e8 d2 39 00 00       	call   3edc <exit>
+  }
+  i = read(fd, buf, 2000);
+  if(i == 2000){
+    printf(stdout, "read succeeded ok\n");
+     50a:	a1 10 63 00 00       	mov    0x6310,%eax
+     50f:	c7 44 24 04 df 46 00 	movl   $0x46df,0x4(%esp)
+     516:	00 
+     517:	89 04 24             	mov    %eax,(%esp)
+     51a:	e8 62 3b 00 00       	call   4081 <printf>
+  } else {
+    printf(stdout, "read failed\n");
+    exit();
+  }
+  close(fd);
+     51f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     522:	89 04 24             	mov    %eax,(%esp)
+     525:	e8 da 39 00 00       	call   3f04 <close>
+
+  if(unlink("small") < 0){
+     52a:	c7 04 24 01 46 00 00 	movl   $0x4601,(%esp)
+     531:	e8 f6 39 00 00       	call   3f2c <unlink>
+     536:	85 c0                	test   %eax,%eax
+     538:	78 1c                	js     556 <writetest+0x1e4>
+     53a:	eb 34                	jmp    570 <writetest+0x1fe>
+  }
+  i = read(fd, buf, 2000);
+  if(i == 2000){
+    printf(stdout, "read succeeded ok\n");
+  } else {
+    printf(stdout, "read failed\n");
+     53c:	a1 10 63 00 00       	mov    0x6310,%eax
+     541:	c7 44 24 04 f2 46 00 	movl   $0x46f2,0x4(%esp)
+     548:	00 
+     549:	89 04 24             	mov    %eax,(%esp)
+     54c:	e8 30 3b 00 00       	call   4081 <printf>
+    exit();
+     551:	e8 86 39 00 00       	call   3edc <exit>
+  }
+  close(fd);
+
+  if(unlink("small") < 0){
+    printf(stdout, "unlink small failed\n");
+     556:	a1 10 63 00 00       	mov    0x6310,%eax
+     55b:	c7 44 24 04 ff 46 00 	movl   $0x46ff,0x4(%esp)
+     562:	00 
+     563:	89 04 24             	mov    %eax,(%esp)
+     566:	e8 16 3b 00 00       	call   4081 <printf>
+    exit();
+     56b:	e8 6c 39 00 00       	call   3edc <exit>
+  }
+  printf(stdout, "small file test ok\n");
+     570:	a1 10 63 00 00       	mov    0x6310,%eax
+     575:	c7 44 24 04 14 47 00 	movl   $0x4714,0x4(%esp)
+     57c:	00 
+     57d:	89 04 24             	mov    %eax,(%esp)
+     580:	e8 fc 3a 00 00       	call   4081 <printf>
+}
+     585:	c9                   	leave  
+     586:	c3                   	ret    
+
+00000587 <writetest1>:
+
+void
+writetest1(void)
+{
+     587:	55                   	push   %ebp
+     588:	89 e5                	mov    %esp,%ebp
+     58a:	83 ec 28             	sub    $0x28,%esp
+  int i, fd, n;
+
+  printf(stdout, "big files test\n");
+     58d:	a1 10 63 00 00       	mov    0x6310,%eax
+     592:	c7 44 24 04 28 47 00 	movl   $0x4728,0x4(%esp)
+     599:	00 
+     59a:	89 04 24             	mov    %eax,(%esp)
+     59d:	e8 df 3a 00 00       	call   4081 <printf>
+
+  fd = open("big", O_CREATE|O_RDWR);
+     5a2:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+     5a9:	00 
+     5aa:	c7 04 24 38 47 00 00 	movl   $0x4738,(%esp)
+     5b1:	e8 66 39 00 00       	call   3f1c <open>
+     5b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+     5b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     5bd:	79 1a                	jns    5d9 <writetest1+0x52>
+    printf(stdout, "error: creat big failed!\n");
+     5bf:	a1 10 63 00 00       	mov    0x6310,%eax
+     5c4:	c7 44 24 04 3c 47 00 	movl   $0x473c,0x4(%esp)
+     5cb:	00 
+     5cc:	89 04 24             	mov    %eax,(%esp)
+     5cf:	e8 ad 3a 00 00       	call   4081 <printf>
+    exit();
+     5d4:	e8 03 39 00 00       	call   3edc <exit>
+  }
+
+  for(i = 0; i < MAXFILE; i++){
+     5d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     5e0:	eb 51                	jmp    633 <writetest1+0xac>
+    ((int*)buf)[0] = i;
+     5e2:	b8 00 8b 00 00       	mov    $0x8b00,%eax
+     5e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     5ea:	89 10                	mov    %edx,(%eax)
+    if(write(fd, buf, 512) != 512){
+     5ec:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+     5f3:	00 
+     5f4:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+     5fb:	00 
+     5fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     5ff:	89 04 24             	mov    %eax,(%esp)
+     602:	e8 f5 38 00 00       	call   3efc <write>
+     607:	3d 00 02 00 00       	cmp    $0x200,%eax
+     60c:	74 21                	je     62f <writetest1+0xa8>
+      printf(stdout, "error: write big file failed\n", i);
+     60e:	a1 10 63 00 00       	mov    0x6310,%eax
+     613:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     616:	89 54 24 08          	mov    %edx,0x8(%esp)
+     61a:	c7 44 24 04 56 47 00 	movl   $0x4756,0x4(%esp)
+     621:	00 
+     622:	89 04 24             	mov    %eax,(%esp)
+     625:	e8 57 3a 00 00       	call   4081 <printf>
+      exit();
+     62a:	e8 ad 38 00 00       	call   3edc <exit>
+  if(fd < 0){
+    printf(stdout, "error: creat big failed!\n");
+    exit();
+  }
+
+  for(i = 0; i < MAXFILE; i++){
+     62f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     633:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     636:	3d 8b 00 00 00       	cmp    $0x8b,%eax
+     63b:	76 a5                	jbe    5e2 <writetest1+0x5b>
+      printf(stdout, "error: write big file failed\n", i);
+      exit();
+    }
+  }
+
+  close(fd);
+     63d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     640:	89 04 24             	mov    %eax,(%esp)
+     643:	e8 bc 38 00 00       	call   3f04 <close>
+
+  fd = open("big", O_RDONLY);
+     648:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     64f:	00 
+     650:	c7 04 24 38 47 00 00 	movl   $0x4738,(%esp)
+     657:	e8 c0 38 00 00       	call   3f1c <open>
+     65c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+     65f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     663:	79 1a                	jns    67f <writetest1+0xf8>
+    printf(stdout, "error: open big failed!\n");
+     665:	a1 10 63 00 00       	mov    0x6310,%eax
+     66a:	c7 44 24 04 74 47 00 	movl   $0x4774,0x4(%esp)
+     671:	00 
+     672:	89 04 24             	mov    %eax,(%esp)
+     675:	e8 07 3a 00 00       	call   4081 <printf>
+    exit();
+     67a:	e8 5d 38 00 00       	call   3edc <exit>
+  }
+
+  n = 0;
+     67f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  for(;;){
+    i = read(fd, buf, 512);
+     686:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+     68d:	00 
+     68e:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+     695:	00 
+     696:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     699:	89 04 24             	mov    %eax,(%esp)
+     69c:	e8 53 38 00 00       	call   3ef4 <read>
+     6a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(i == 0){
+     6a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     6a8:	75 2e                	jne    6d8 <writetest1+0x151>
+      if(n == MAXFILE - 1){
+     6aa:	81 7d f0 8b 00 00 00 	cmpl   $0x8b,-0x10(%ebp)
+     6b1:	0f 85 8c 00 00 00    	jne    743 <writetest1+0x1bc>
+        printf(stdout, "read only %d blocks from big", n);
+     6b7:	a1 10 63 00 00       	mov    0x6310,%eax
+     6bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
+     6bf:	89 54 24 08          	mov    %edx,0x8(%esp)
+     6c3:	c7 44 24 04 8d 47 00 	movl   $0x478d,0x4(%esp)
+     6ca:	00 
+     6cb:	89 04 24             	mov    %eax,(%esp)
+     6ce:	e8 ae 39 00 00       	call   4081 <printf>
+        exit();
+     6d3:	e8 04 38 00 00       	call   3edc <exit>
+      }
+      break;
+    } else if(i != 512){
+     6d8:	81 7d f4 00 02 00 00 	cmpl   $0x200,-0xc(%ebp)
+     6df:	74 21                	je     702 <writetest1+0x17b>
+      printf(stdout, "read failed %d\n", i);
+     6e1:	a1 10 63 00 00       	mov    0x6310,%eax
+     6e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     6e9:	89 54 24 08          	mov    %edx,0x8(%esp)
+     6ed:	c7 44 24 04 aa 47 00 	movl   $0x47aa,0x4(%esp)
+     6f4:	00 
+     6f5:	89 04 24             	mov    %eax,(%esp)
+     6f8:	e8 84 39 00 00       	call   4081 <printf>
+      exit();
+     6fd:	e8 da 37 00 00       	call   3edc <exit>
+    }
+    if(((int*)buf)[0] != n){
+     702:	b8 00 8b 00 00       	mov    $0x8b00,%eax
+     707:	8b 00                	mov    (%eax),%eax
+     709:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+     70c:	74 2c                	je     73a <writetest1+0x1b3>
+      printf(stdout, "read content of block %d is %d\n",
+             n, ((int*)buf)[0]);
+     70e:	b8 00 8b 00 00       	mov    $0x8b00,%eax
+    } else if(i != 512){
+      printf(stdout, "read failed %d\n", i);
+      exit();
+    }
+    if(((int*)buf)[0] != n){
+      printf(stdout, "read content of block %d is %d\n",
+     713:	8b 10                	mov    (%eax),%edx
+     715:	a1 10 63 00 00       	mov    0x6310,%eax
+     71a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+     71e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+     721:	89 54 24 08          	mov    %edx,0x8(%esp)
+     725:	c7 44 24 04 bc 47 00 	movl   $0x47bc,0x4(%esp)
+     72c:	00 
+     72d:	89 04 24             	mov    %eax,(%esp)
+     730:	e8 4c 39 00 00       	call   4081 <printf>
+             n, ((int*)buf)[0]);
+      exit();
+     735:	e8 a2 37 00 00       	call   3edc <exit>
+    }
+    n++;
+     73a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  }
+     73e:	e9 43 ff ff ff       	jmp    686 <writetest1+0xff>
+    if(i == 0){
+      if(n == MAXFILE - 1){
+        printf(stdout, "read only %d blocks from big", n);
+        exit();
+      }
+      break;
+     743:	90                   	nop
+             n, ((int*)buf)[0]);
+      exit();
+    }
+    n++;
+  }
+  close(fd);
+     744:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     747:	89 04 24             	mov    %eax,(%esp)
+     74a:	e8 b5 37 00 00       	call   3f04 <close>
+  if(unlink("big") < 0){
+     74f:	c7 04 24 38 47 00 00 	movl   $0x4738,(%esp)
+     756:	e8 d1 37 00 00       	call   3f2c <unlink>
+     75b:	85 c0                	test   %eax,%eax
+     75d:	79 1a                	jns    779 <writetest1+0x1f2>
+    printf(stdout, "unlink big failed\n");
+     75f:	a1 10 63 00 00       	mov    0x6310,%eax
+     764:	c7 44 24 04 dc 47 00 	movl   $0x47dc,0x4(%esp)
+     76b:	00 
+     76c:	89 04 24             	mov    %eax,(%esp)
+     76f:	e8 0d 39 00 00       	call   4081 <printf>
+    exit();
+     774:	e8 63 37 00 00       	call   3edc <exit>
+  }
+  printf(stdout, "big files ok\n");
+     779:	a1 10 63 00 00       	mov    0x6310,%eax
+     77e:	c7 44 24 04 ef 47 00 	movl   $0x47ef,0x4(%esp)
+     785:	00 
+     786:	89 04 24             	mov    %eax,(%esp)
+     789:	e8 f3 38 00 00       	call   4081 <printf>
+}
+     78e:	c9                   	leave  
+     78f:	c3                   	ret    
+
+00000790 <createtest>:
+
+void
+createtest(void)
+{
+     790:	55                   	push   %ebp
+     791:	89 e5                	mov    %esp,%ebp
+     793:	83 ec 28             	sub    $0x28,%esp
+  int i, fd;
+
+  printf(stdout, "many creates, followed by unlink test\n");
+     796:	a1 10 63 00 00       	mov    0x6310,%eax
+     79b:	c7 44 24 04 00 48 00 	movl   $0x4800,0x4(%esp)
+     7a2:	00 
+     7a3:	89 04 24             	mov    %eax,(%esp)
+     7a6:	e8 d6 38 00 00       	call   4081 <printf>
+
+  name[0] = 'a';
+     7ab:	c6 05 00 ab 00 00 61 	movb   $0x61,0xab00
+  name[2] = '\0';
+     7b2:	c6 05 02 ab 00 00 00 	movb   $0x0,0xab02
+  for(i = 0; i < 52; i++){
+     7b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     7c0:	eb 31                	jmp    7f3 <createtest+0x63>
+    name[1] = '0' + i;
+     7c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     7c5:	83 c0 30             	add    $0x30,%eax
+     7c8:	a2 01 ab 00 00       	mov    %al,0xab01
+    fd = open(name, O_CREATE|O_RDWR);
+     7cd:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+     7d4:	00 
+     7d5:	c7 04 24 00 ab 00 00 	movl   $0xab00,(%esp)
+     7dc:	e8 3b 37 00 00       	call   3f1c <open>
+     7e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    close(fd);
+     7e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     7e7:	89 04 24             	mov    %eax,(%esp)
+     7ea:	e8 15 37 00 00       	call   3f04 <close>
+
+  printf(stdout, "many creates, followed by unlink test\n");
+
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+     7ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     7f3:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
+     7f7:	7e c9                	jle    7c2 <createtest+0x32>
+    name[1] = '0' + i;
+    fd = open(name, O_CREATE|O_RDWR);
+    close(fd);
+  }
+  name[0] = 'a';
+     7f9:	c6 05 00 ab 00 00 61 	movb   $0x61,0xab00
+  name[2] = '\0';
+     800:	c6 05 02 ab 00 00 00 	movb   $0x0,0xab02
+  for(i = 0; i < 52; i++){
+     807:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     80e:	eb 1b                	jmp    82b <createtest+0x9b>
+    name[1] = '0' + i;
+     810:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     813:	83 c0 30             	add    $0x30,%eax
+     816:	a2 01 ab 00 00       	mov    %al,0xab01
+    unlink(name);
+     81b:	c7 04 24 00 ab 00 00 	movl   $0xab00,(%esp)
+     822:	e8 05 37 00 00       	call   3f2c <unlink>
+    fd = open(name, O_CREATE|O_RDWR);
+    close(fd);
+  }
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+     827:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     82b:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
+     82f:	7e df                	jle    810 <createtest+0x80>
+    name[1] = '0' + i;
+    unlink(name);
+  }
+  printf(stdout, "many creates, followed by unlink; ok\n");
+     831:	a1 10 63 00 00       	mov    0x6310,%eax
+     836:	c7 44 24 04 28 48 00 	movl   $0x4828,0x4(%esp)
+     83d:	00 
+     83e:	89 04 24             	mov    %eax,(%esp)
+     841:	e8 3b 38 00 00       	call   4081 <printf>
+}
+     846:	c9                   	leave  
+     847:	c3                   	ret    
+
+00000848 <dirtest>:
+
+void dirtest(void)
+{
+     848:	55                   	push   %ebp
+     849:	89 e5                	mov    %esp,%ebp
+     84b:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "mkdir test\n");
+     84e:	a1 10 63 00 00       	mov    0x6310,%eax
+     853:	c7 44 24 04 4e 48 00 	movl   $0x484e,0x4(%esp)
+     85a:	00 
+     85b:	89 04 24             	mov    %eax,(%esp)
+     85e:	e8 1e 38 00 00       	call   4081 <printf>
+
+  if(mkdir("dir0") < 0){
+     863:	c7 04 24 5a 48 00 00 	movl   $0x485a,(%esp)
+     86a:	e8 d5 36 00 00       	call   3f44 <mkdir>
+     86f:	85 c0                	test   %eax,%eax
+     871:	79 1a                	jns    88d <dirtest+0x45>
+    printf(stdout, "mkdir failed\n");
+     873:	a1 10 63 00 00       	mov    0x6310,%eax
+     878:	c7 44 24 04 7d 44 00 	movl   $0x447d,0x4(%esp)
+     87f:	00 
+     880:	89 04 24             	mov    %eax,(%esp)
+     883:	e8 f9 37 00 00       	call   4081 <printf>
+    exit();
+     888:	e8 4f 36 00 00       	call   3edc <exit>
+  }
+
+  if(chdir("dir0") < 0){
+     88d:	c7 04 24 5a 48 00 00 	movl   $0x485a,(%esp)
+     894:	e8 b3 36 00 00       	call   3f4c <chdir>
+     899:	85 c0                	test   %eax,%eax
+     89b:	79 1a                	jns    8b7 <dirtest+0x6f>
+    printf(stdout, "chdir dir0 failed\n");
+     89d:	a1 10 63 00 00       	mov    0x6310,%eax
+     8a2:	c7 44 24 04 5f 48 00 	movl   $0x485f,0x4(%esp)
+     8a9:	00 
+     8aa:	89 04 24             	mov    %eax,(%esp)
+     8ad:	e8 cf 37 00 00       	call   4081 <printf>
+    exit();
+     8b2:	e8 25 36 00 00       	call   3edc <exit>
+  }
+
+  if(chdir("..") < 0){
+     8b7:	c7 04 24 72 48 00 00 	movl   $0x4872,(%esp)
+     8be:	e8 89 36 00 00       	call   3f4c <chdir>
+     8c3:	85 c0                	test   %eax,%eax
+     8c5:	79 1a                	jns    8e1 <dirtest+0x99>
+    printf(stdout, "chdir .. failed\n");
+     8c7:	a1 10 63 00 00       	mov    0x6310,%eax
+     8cc:	c7 44 24 04 75 48 00 	movl   $0x4875,0x4(%esp)
+     8d3:	00 
+     8d4:	89 04 24             	mov    %eax,(%esp)
+     8d7:	e8 a5 37 00 00       	call   4081 <printf>
+    exit();
+     8dc:	e8 fb 35 00 00       	call   3edc <exit>
+  }
+
+  if(unlink("dir0") < 0){
+     8e1:	c7 04 24 5a 48 00 00 	movl   $0x485a,(%esp)
+     8e8:	e8 3f 36 00 00       	call   3f2c <unlink>
+     8ed:	85 c0                	test   %eax,%eax
+     8ef:	79 1a                	jns    90b <dirtest+0xc3>
+    printf(stdout, "unlink dir0 failed\n");
+     8f1:	a1 10 63 00 00       	mov    0x6310,%eax
+     8f6:	c7 44 24 04 86 48 00 	movl   $0x4886,0x4(%esp)
+     8fd:	00 
+     8fe:	89 04 24             	mov    %eax,(%esp)
+     901:	e8 7b 37 00 00       	call   4081 <printf>
+    exit();
+     906:	e8 d1 35 00 00       	call   3edc <exit>
+  }
+  printf(stdout, "mkdir test ok\n");
+     90b:	a1 10 63 00 00       	mov    0x6310,%eax
+     910:	c7 44 24 04 9a 48 00 	movl   $0x489a,0x4(%esp)
+     917:	00 
+     918:	89 04 24             	mov    %eax,(%esp)
+     91b:	e8 61 37 00 00       	call   4081 <printf>
+}
+     920:	c9                   	leave  
+     921:	c3                   	ret    
+
+00000922 <exectest>:
+
+void
+exectest(void)
+{
+     922:	55                   	push   %ebp
+     923:	89 e5                	mov    %esp,%ebp
+     925:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "exec test\n");
+     928:	a1 10 63 00 00       	mov    0x6310,%eax
+     92d:	c7 44 24 04 a9 48 00 	movl   $0x48a9,0x4(%esp)
+     934:	00 
+     935:	89 04 24             	mov    %eax,(%esp)
+     938:	e8 44 37 00 00       	call   4081 <printf>
+  if(exec("echo", echoargv) < 0){
+     93d:	c7 44 24 04 fc 62 00 	movl   $0x62fc,0x4(%esp)
+     944:	00 
+     945:	c7 04 24 54 44 00 00 	movl   $0x4454,(%esp)
+     94c:	e8 c3 35 00 00       	call   3f14 <exec>
+     951:	85 c0                	test   %eax,%eax
+     953:	79 1a                	jns    96f <exectest+0x4d>
+    printf(stdout, "exec echo failed\n");
+     955:	a1 10 63 00 00       	mov    0x6310,%eax
+     95a:	c7 44 24 04 b4 48 00 	movl   $0x48b4,0x4(%esp)
+     961:	00 
+     962:	89 04 24             	mov    %eax,(%esp)
+     965:	e8 17 37 00 00       	call   4081 <printf>
+    exit();
+     96a:	e8 6d 35 00 00       	call   3edc <exit>
+  }
+}
+     96f:	c9                   	leave  
+     970:	c3                   	ret    
+
+00000971 <pipe1>:
+
+// simple fork and pipe read/write
+
+void
+pipe1(void)
+{
+     971:	55                   	push   %ebp
+     972:	89 e5                	mov    %esp,%ebp
+     974:	83 ec 38             	sub    $0x38,%esp
+  int fds[2], pid;
+  int seq, i, n, cc, total;
+
+  if(pipe(fds) != 0){
+     977:	8d 45 d8             	lea    -0x28(%ebp),%eax
+     97a:	89 04 24             	mov    %eax,(%esp)
+     97d:	e8 6a 35 00 00       	call   3eec <pipe>
+     982:	85 c0                	test   %eax,%eax
+     984:	74 19                	je     99f <pipe1+0x2e>
+    printf(1, "pipe() failed\n");
+     986:	c7 44 24 04 c6 48 00 	movl   $0x48c6,0x4(%esp)
+     98d:	00 
+     98e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     995:	e8 e7 36 00 00       	call   4081 <printf>
+    exit();
+     99a:	e8 3d 35 00 00       	call   3edc <exit>
+  }
+  pid = fork();
+     99f:	e8 30 35 00 00       	call   3ed4 <fork>
+     9a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  seq = 0;
+     9a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  if(pid == 0){
+     9ae:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+     9b2:	0f 85 86 00 00 00    	jne    a3e <pipe1+0xcd>
+    close(fds[0]);
+     9b8:	8b 45 d8             	mov    -0x28(%ebp),%eax
+     9bb:	89 04 24             	mov    %eax,(%esp)
+     9be:	e8 41 35 00 00       	call   3f04 <close>
+    for(n = 0; n < 5; n++){
+     9c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+     9ca:	eb 67                	jmp    a33 <pipe1+0xc2>
+      for(i = 0; i < 1033; i++)
+     9cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+     9d3:	eb 16                	jmp    9eb <pipe1+0x7a>
+        buf[i] = seq++;
+     9d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     9d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
+     9db:	81 c2 00 8b 00 00    	add    $0x8b00,%edx
+     9e1:	88 02                	mov    %al,(%edx)
+     9e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  pid = fork();
+  seq = 0;
+  if(pid == 0){
+    close(fds[0]);
+    for(n = 0; n < 5; n++){
+      for(i = 0; i < 1033; i++)
+     9e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+     9eb:	81 7d f0 08 04 00 00 	cmpl   $0x408,-0x10(%ebp)
+     9f2:	7e e1                	jle    9d5 <pipe1+0x64>
+        buf[i] = seq++;
+      if(write(fds[1], buf, 1033) != 1033){
+     9f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     9f7:	c7 44 24 08 09 04 00 	movl   $0x409,0x8(%esp)
+     9fe:	00 
+     9ff:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+     a06:	00 
+     a07:	89 04 24             	mov    %eax,(%esp)
+     a0a:	e8 ed 34 00 00       	call   3efc <write>
+     a0f:	3d 09 04 00 00       	cmp    $0x409,%eax
+     a14:	74 19                	je     a2f <pipe1+0xbe>
+        printf(1, "pipe1 oops 1\n");
+     a16:	c7 44 24 04 d5 48 00 	movl   $0x48d5,0x4(%esp)
+     a1d:	00 
+     a1e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     a25:	e8 57 36 00 00       	call   4081 <printf>
+        exit();
+     a2a:	e8 ad 34 00 00       	call   3edc <exit>
+  }
+  pid = fork();
+  seq = 0;
+  if(pid == 0){
+    close(fds[0]);
+    for(n = 0; n < 5; n++){
+     a2f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+     a33:	83 7d ec 04          	cmpl   $0x4,-0x14(%ebp)
+     a37:	7e 93                	jle    9cc <pipe1+0x5b>
+      if(write(fds[1], buf, 1033) != 1033){
+        printf(1, "pipe1 oops 1\n");
+        exit();
+      }
+    }
+    exit();
+     a39:	e8 9e 34 00 00       	call   3edc <exit>
+  } else if(pid > 0){
+     a3e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+     a42:	0f 8e fc 00 00 00    	jle    b44 <pipe1+0x1d3>
+    close(fds[1]);
+     a48:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     a4b:	89 04 24             	mov    %eax,(%esp)
+     a4e:	e8 b1 34 00 00       	call   3f04 <close>
+    total = 0;
+     a53:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    cc = 1;
+     a5a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
+    while((n = read(fds[0], buf, cc)) > 0){
+     a61:	eb 6b                	jmp    ace <pipe1+0x15d>
+      for(i = 0; i < n; i++){
+     a63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+     a6a:	eb 40                	jmp    aac <pipe1+0x13b>
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+     a6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     a6f:	05 00 8b 00 00       	add    $0x8b00,%eax
+     a74:	0f b6 00             	movzbl (%eax),%eax
+     a77:	0f be c0             	movsbl %al,%eax
+     a7a:	33 45 f4             	xor    -0xc(%ebp),%eax
+     a7d:	25 ff 00 00 00       	and    $0xff,%eax
+     a82:	85 c0                	test   %eax,%eax
+     a84:	0f 95 c0             	setne  %al
+     a87:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     a8b:	84 c0                	test   %al,%al
+     a8d:	74 19                	je     aa8 <pipe1+0x137>
+          printf(1, "pipe1 oops 2\n");
+     a8f:	c7 44 24 04 e3 48 00 	movl   $0x48e3,0x4(%esp)
+     a96:	00 
+     a97:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     a9e:	e8 de 35 00 00       	call   4081 <printf>
+     aa3:	e9 b5 00 00 00       	jmp    b5d <pipe1+0x1ec>
+  } else if(pid > 0){
+    close(fds[1]);
+    total = 0;
+    cc = 1;
+    while((n = read(fds[0], buf, cc)) > 0){
+      for(i = 0; i < n; i++){
+     aa8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+     aac:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     aaf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+     ab2:	7c b8                	jl     a6c <pipe1+0xfb>
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+          printf(1, "pipe1 oops 2\n");
+          return;
+        }
+      }
+      total += n;
+     ab4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     ab7:	01 45 e4             	add    %eax,-0x1c(%ebp)
+      cc = cc * 2;
+     aba:	d1 65 e8             	shll   -0x18(%ebp)
+      if(cc > sizeof(buf))
+     abd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     ac0:	3d 00 20 00 00       	cmp    $0x2000,%eax
+     ac5:	76 07                	jbe    ace <pipe1+0x15d>
+        cc = sizeof(buf);
+     ac7:	c7 45 e8 00 20 00 00 	movl   $0x2000,-0x18(%ebp)
+    exit();
+  } else if(pid > 0){
+    close(fds[1]);
+    total = 0;
+    cc = 1;
+    while((n = read(fds[0], buf, cc)) > 0){
+     ace:	8b 45 d8             	mov    -0x28(%ebp),%eax
+     ad1:	8b 55 e8             	mov    -0x18(%ebp),%edx
+     ad4:	89 54 24 08          	mov    %edx,0x8(%esp)
+     ad8:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+     adf:	00 
+     ae0:	89 04 24             	mov    %eax,(%esp)
+     ae3:	e8 0c 34 00 00       	call   3ef4 <read>
+     ae8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+     aeb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     aef:	0f 8f 6e ff ff ff    	jg     a63 <pipe1+0xf2>
+      total += n;
+      cc = cc * 2;
+      if(cc > sizeof(buf))
+        cc = sizeof(buf);
+    }
+    if(total != 5 * 1033){
+     af5:	81 7d e4 2d 14 00 00 	cmpl   $0x142d,-0x1c(%ebp)
+     afc:	74 20                	je     b1e <pipe1+0x1ad>
+      printf(1, "pipe1 oops 3 total %d\n", total);
+     afe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     b01:	89 44 24 08          	mov    %eax,0x8(%esp)
+     b05:	c7 44 24 04 f1 48 00 	movl   $0x48f1,0x4(%esp)
+     b0c:	00 
+     b0d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     b14:	e8 68 35 00 00       	call   4081 <printf>
+      exit();
+     b19:	e8 be 33 00 00       	call   3edc <exit>
+    }
+    close(fds[0]);
+     b1e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+     b21:	89 04 24             	mov    %eax,(%esp)
+     b24:	e8 db 33 00 00       	call   3f04 <close>
+    wait();
+     b29:	e8 b6 33 00 00       	call   3ee4 <wait>
+  } else {
+    printf(1, "fork() failed\n");
+    exit();
+  }
+  printf(1, "pipe1 ok\n");
+     b2e:	c7 44 24 04 08 49 00 	movl   $0x4908,0x4(%esp)
+     b35:	00 
+     b36:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     b3d:	e8 3f 35 00 00       	call   4081 <printf>
+     b42:	eb 19                	jmp    b5d <pipe1+0x1ec>
+      exit();
+    }
+    close(fds[0]);
+    wait();
+  } else {
+    printf(1, "fork() failed\n");
+     b44:	c7 44 24 04 12 49 00 	movl   $0x4912,0x4(%esp)
+     b4b:	00 
+     b4c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     b53:	e8 29 35 00 00       	call   4081 <printf>
+    exit();
+     b58:	e8 7f 33 00 00       	call   3edc <exit>
+  }
+  printf(1, "pipe1 ok\n");
+}
+     b5d:	c9                   	leave  
+     b5e:	c3                   	ret    
+
+00000b5f <preempt>:
+
+// meant to be run w/ at most two CPUs
+void
+preempt(void)
+{
+     b5f:	55                   	push   %ebp
+     b60:	89 e5                	mov    %esp,%ebp
+     b62:	83 ec 38             	sub    $0x38,%esp
+  int pid1, pid2, pid3;
+  int pfds[2];
+
+  printf(1, "preempt: ");
+     b65:	c7 44 24 04 21 49 00 	movl   $0x4921,0x4(%esp)
+     b6c:	00 
+     b6d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     b74:	e8 08 35 00 00       	call   4081 <printf>
+  pid1 = fork();
+     b79:	e8 56 33 00 00       	call   3ed4 <fork>
+     b7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid1 == 0)
+     b81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     b85:	75 02                	jne    b89 <preempt+0x2a>
+    for(;;)
+      ;
+     b87:	eb fe                	jmp    b87 <preempt+0x28>
+
+  pid2 = fork();
+     b89:	e8 46 33 00 00       	call   3ed4 <fork>
+     b8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(pid2 == 0)
+     b91:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     b95:	75 02                	jne    b99 <preempt+0x3a>
+    for(;;)
+      ;
+     b97:	eb fe                	jmp    b97 <preempt+0x38>
+
+  pipe(pfds);
+     b99:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+     b9c:	89 04 24             	mov    %eax,(%esp)
+     b9f:	e8 48 33 00 00       	call   3eec <pipe>
+  pid3 = fork();
+     ba4:	e8 2b 33 00 00       	call   3ed4 <fork>
+     ba9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(pid3 == 0){
+     bac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     bb0:	75 4c                	jne    bfe <preempt+0x9f>
+    close(pfds[0]);
+     bb2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     bb5:	89 04 24             	mov    %eax,(%esp)
+     bb8:	e8 47 33 00 00       	call   3f04 <close>
+    if(write(pfds[1], "x", 1) != 1)
+     bbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     bc0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+     bc7:	00 
+     bc8:	c7 44 24 04 2b 49 00 	movl   $0x492b,0x4(%esp)
+     bcf:	00 
+     bd0:	89 04 24             	mov    %eax,(%esp)
+     bd3:	e8 24 33 00 00       	call   3efc <write>
+     bd8:	83 f8 01             	cmp    $0x1,%eax
+     bdb:	74 14                	je     bf1 <preempt+0x92>
+      printf(1, "preempt write error");
+     bdd:	c7 44 24 04 2d 49 00 	movl   $0x492d,0x4(%esp)
+     be4:	00 
+     be5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     bec:	e8 90 34 00 00       	call   4081 <printf>
+    close(pfds[1]);
+     bf1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     bf4:	89 04 24             	mov    %eax,(%esp)
+     bf7:	e8 08 33 00 00       	call   3f04 <close>
+    for(;;)
+      ;
+     bfc:	eb fe                	jmp    bfc <preempt+0x9d>
+  }
+
+  close(pfds[1]);
+     bfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     c01:	89 04 24             	mov    %eax,(%esp)
+     c04:	e8 fb 32 00 00       	call   3f04 <close>
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+     c09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     c0c:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+     c13:	00 
+     c14:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+     c1b:	00 
+     c1c:	89 04 24             	mov    %eax,(%esp)
+     c1f:	e8 d0 32 00 00       	call   3ef4 <read>
+     c24:	83 f8 01             	cmp    $0x1,%eax
+     c27:	74 16                	je     c3f <preempt+0xe0>
+    printf(1, "preempt read error");
+     c29:	c7 44 24 04 41 49 00 	movl   $0x4941,0x4(%esp)
+     c30:	00 
+     c31:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     c38:	e8 44 34 00 00       	call   4081 <printf>
+     c3d:	eb 77                	jmp    cb6 <preempt+0x157>
+    return;
+  }
+  close(pfds[0]);
+     c3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     c42:	89 04 24             	mov    %eax,(%esp)
+     c45:	e8 ba 32 00 00       	call   3f04 <close>
+  printf(1, "kill... ");
+     c4a:	c7 44 24 04 54 49 00 	movl   $0x4954,0x4(%esp)
+     c51:	00 
+     c52:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     c59:	e8 23 34 00 00       	call   4081 <printf>
+  kill(pid1);
+     c5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     c61:	89 04 24             	mov    %eax,(%esp)
+     c64:	e8 a3 32 00 00       	call   3f0c <kill>
+  kill(pid2);
+     c69:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     c6c:	89 04 24             	mov    %eax,(%esp)
+     c6f:	e8 98 32 00 00       	call   3f0c <kill>
+  kill(pid3);
+     c74:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     c77:	89 04 24             	mov    %eax,(%esp)
+     c7a:	e8 8d 32 00 00       	call   3f0c <kill>
+  printf(1, "wait... ");
+     c7f:	c7 44 24 04 5d 49 00 	movl   $0x495d,0x4(%esp)
+     c86:	00 
+     c87:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     c8e:	e8 ee 33 00 00       	call   4081 <printf>
+  wait();
+     c93:	e8 4c 32 00 00       	call   3ee4 <wait>
+  wait();
+     c98:	e8 47 32 00 00       	call   3ee4 <wait>
+  wait();
+     c9d:	e8 42 32 00 00       	call   3ee4 <wait>
+  printf(1, "preempt ok\n");
+     ca2:	c7 44 24 04 66 49 00 	movl   $0x4966,0x4(%esp)
+     ca9:	00 
+     caa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     cb1:	e8 cb 33 00 00       	call   4081 <printf>
+}
+     cb6:	c9                   	leave  
+     cb7:	c3                   	ret    
+
+00000cb8 <exitwait>:
+
+// try to find any races between exit and wait
+void
+exitwait(void)
+{
+     cb8:	55                   	push   %ebp
+     cb9:	89 e5                	mov    %esp,%ebp
+     cbb:	83 ec 28             	sub    $0x28,%esp
+  int i, pid;
+
+  for(i = 0; i < 100; i++){
+     cbe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     cc5:	eb 53                	jmp    d1a <exitwait+0x62>
+    pid = fork();
+     cc7:	e8 08 32 00 00       	call   3ed4 <fork>
+     ccc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(pid < 0){
+     ccf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     cd3:	79 16                	jns    ceb <exitwait+0x33>
+      printf(1, "fork failed\n");
+     cd5:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+     cdc:	00 
+     cdd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     ce4:	e8 98 33 00 00       	call   4081 <printf>
+      return;
+     ce9:	eb 49                	jmp    d34 <exitwait+0x7c>
+    }
+    if(pid){
+     ceb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     cef:	74 20                	je     d11 <exitwait+0x59>
+      if(wait() != pid){
+     cf1:	e8 ee 31 00 00       	call   3ee4 <wait>
+     cf6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+     cf9:	74 1b                	je     d16 <exitwait+0x5e>
+        printf(1, "wait wrong pid\n");
+     cfb:	c7 44 24 04 72 49 00 	movl   $0x4972,0x4(%esp)
+     d02:	00 
+     d03:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     d0a:	e8 72 33 00 00       	call   4081 <printf>
+        return;
+     d0f:	eb 23                	jmp    d34 <exitwait+0x7c>
+      }
+    } else {
+      exit();
+     d11:	e8 c6 31 00 00       	call   3edc <exit>
+void
+exitwait(void)
+{
+  int i, pid;
+
+  for(i = 0; i < 100; i++){
+     d16:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     d1a:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+     d1e:	7e a7                	jle    cc7 <exitwait+0xf>
+      }
+    } else {
+      exit();
+    }
+  }
+  printf(1, "exitwait ok\n");
+     d20:	c7 44 24 04 82 49 00 	movl   $0x4982,0x4(%esp)
+     d27:	00 
+     d28:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     d2f:	e8 4d 33 00 00       	call   4081 <printf>
+}
+     d34:	c9                   	leave  
+     d35:	c3                   	ret    
+
+00000d36 <mem>:
+
+void
+mem(void)
+{
+     d36:	55                   	push   %ebp
+     d37:	89 e5                	mov    %esp,%ebp
+     d39:	83 ec 28             	sub    $0x28,%esp
+  void *m1, *m2;
+  int pid, ppid;
+
+  printf(1, "mem test\n");
+     d3c:	c7 44 24 04 8f 49 00 	movl   $0x498f,0x4(%esp)
+     d43:	00 
+     d44:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     d4b:	e8 31 33 00 00       	call   4081 <printf>
+  ppid = getpid();
+     d50:	e8 07 32 00 00       	call   3f5c <getpid>
+     d55:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if((pid = fork()) == 0){
+     d58:	e8 77 31 00 00       	call   3ed4 <fork>
+     d5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+     d60:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     d64:	0f 85 aa 00 00 00    	jne    e14 <mem+0xde>
+    m1 = 0;
+     d6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while((m2 = malloc(10001)) != 0){
+     d71:	eb 0e                	jmp    d81 <mem+0x4b>
+      *(char**)m2 = m1;
+     d73:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     d76:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     d79:	89 10                	mov    %edx,(%eax)
+      m1 = m2;
+     d7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     d7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  printf(1, "mem test\n");
+  ppid = getpid();
+  if((pid = fork()) == 0){
+    m1 = 0;
+    while((m2 = malloc(10001)) != 0){
+     d81:	c7 04 24 11 27 00 00 	movl   $0x2711,(%esp)
+     d88:	e8 e4 35 00 00       	call   4371 <malloc>
+     d8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+     d90:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     d94:	75 dd                	jne    d73 <mem+0x3d>
+      *(char**)m2 = m1;
+      m1 = m2;
+    }
+    while(m1){
+     d96:	eb 19                	jmp    db1 <mem+0x7b>
+      m2 = *(char**)m1;
+     d98:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     d9b:	8b 00                	mov    (%eax),%eax
+     d9d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      free(m1);
+     da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     da3:	89 04 24             	mov    %eax,(%esp)
+     da6:	e8 8d 34 00 00       	call   4238 <free>
+      m1 = m2;
+     dab:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     dae:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    m1 = 0;
+    while((m2 = malloc(10001)) != 0){
+      *(char**)m2 = m1;
+      m1 = m2;
+    }
+    while(m1){
+     db1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     db5:	75 e1                	jne    d98 <mem+0x62>
+      m2 = *(char**)m1;
+      free(m1);
+      m1 = m2;
+    }
+    m1 = malloc(1024*20);
+     db7:	c7 04 24 00 50 00 00 	movl   $0x5000,(%esp)
+     dbe:	e8 ae 35 00 00       	call   4371 <malloc>
+     dc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(m1 == 0){
+     dc6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     dca:	75 24                	jne    df0 <mem+0xba>
+      printf(1, "couldn't allocate mem?!!\n");
+     dcc:	c7 44 24 04 99 49 00 	movl   $0x4999,0x4(%esp)
+     dd3:	00 
+     dd4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     ddb:	e8 a1 32 00 00       	call   4081 <printf>
+      kill(ppid);
+     de0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     de3:	89 04 24             	mov    %eax,(%esp)
+     de6:	e8 21 31 00 00       	call   3f0c <kill>
+      exit();
+     deb:	e8 ec 30 00 00       	call   3edc <exit>
+    }
+    free(m1);
+     df0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     df3:	89 04 24             	mov    %eax,(%esp)
+     df6:	e8 3d 34 00 00       	call   4238 <free>
+    printf(1, "mem ok\n");
+     dfb:	c7 44 24 04 b3 49 00 	movl   $0x49b3,0x4(%esp)
+     e02:	00 
+     e03:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     e0a:	e8 72 32 00 00       	call   4081 <printf>
+    exit();
+     e0f:	e8 c8 30 00 00       	call   3edc <exit>
+  } else {
+    wait();
+     e14:	e8 cb 30 00 00       	call   3ee4 <wait>
+  }
+}
+     e19:	c9                   	leave  
+     e1a:	c3                   	ret    
+
+00000e1b <sharedfd>:
+
+// two processes write to the same file descriptor
+// is the offset shared? does inode locking work?
+void
+sharedfd(void)
+{
+     e1b:	55                   	push   %ebp
+     e1c:	89 e5                	mov    %esp,%ebp
+     e1e:	83 ec 48             	sub    $0x48,%esp
+  int fd, pid, i, n, nc, np;
+  char buf[10];
+
+  printf(1, "sharedfd test\n");
+     e21:	c7 44 24 04 bb 49 00 	movl   $0x49bb,0x4(%esp)
+     e28:	00 
+     e29:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     e30:	e8 4c 32 00 00       	call   4081 <printf>
+
+  unlink("sharedfd");
+     e35:	c7 04 24 ca 49 00 00 	movl   $0x49ca,(%esp)
+     e3c:	e8 eb 30 00 00       	call   3f2c <unlink>
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+     e41:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+     e48:	00 
+     e49:	c7 04 24 ca 49 00 00 	movl   $0x49ca,(%esp)
+     e50:	e8 c7 30 00 00       	call   3f1c <open>
+     e55:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(fd < 0){
+     e58:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     e5c:	79 19                	jns    e77 <sharedfd+0x5c>
+    printf(1, "fstests: cannot open sharedfd for writing");
+     e5e:	c7 44 24 04 d4 49 00 	movl   $0x49d4,0x4(%esp)
+     e65:	00 
+     e66:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     e6d:	e8 0f 32 00 00       	call   4081 <printf>
+     e72:	e9 a0 01 00 00       	jmp    1017 <sharedfd+0x1fc>
+    return;
+  }
+  pid = fork();
+     e77:	e8 58 30 00 00       	call   3ed4 <fork>
+     e7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+     e7f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+     e83:	75 07                	jne    e8c <sharedfd+0x71>
+     e85:	b8 63 00 00 00       	mov    $0x63,%eax
+     e8a:	eb 05                	jmp    e91 <sharedfd+0x76>
+     e8c:	b8 70 00 00 00       	mov    $0x70,%eax
+     e91:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+     e98:	00 
+     e99:	89 44 24 04          	mov    %eax,0x4(%esp)
+     e9d:	8d 45 d6             	lea    -0x2a(%ebp),%eax
+     ea0:	89 04 24             	mov    %eax,(%esp)
+     ea3:	e8 8d 2e 00 00       	call   3d35 <memset>
+  for(i = 0; i < 1000; i++){
+     ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     eaf:	eb 39                	jmp    eea <sharedfd+0xcf>
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+     eb1:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+     eb8:	00 
+     eb9:	8d 45 d6             	lea    -0x2a(%ebp),%eax
+     ebc:	89 44 24 04          	mov    %eax,0x4(%esp)
+     ec0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     ec3:	89 04 24             	mov    %eax,(%esp)
+     ec6:	e8 31 30 00 00       	call   3efc <write>
+     ecb:	83 f8 0a             	cmp    $0xa,%eax
+     ece:	74 16                	je     ee6 <sharedfd+0xcb>
+      printf(1, "fstests: write sharedfd failed\n");
+     ed0:	c7 44 24 04 00 4a 00 	movl   $0x4a00,0x4(%esp)
+     ed7:	00 
+     ed8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     edf:	e8 9d 31 00 00       	call   4081 <printf>
+      break;
+     ee4:	eb 0d                	jmp    ef3 <sharedfd+0xd8>
+    printf(1, "fstests: cannot open sharedfd for writing");
+    return;
+  }
+  pid = fork();
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+  for(i = 0; i < 1000; i++){
+     ee6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     eea:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+     ef1:	7e be                	jle    eb1 <sharedfd+0x96>
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+      printf(1, "fstests: write sharedfd failed\n");
+      break;
+    }
+  }
+  if(pid == 0)
+     ef3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+     ef7:	75 05                	jne    efe <sharedfd+0xe3>
+    exit();
+     ef9:	e8 de 2f 00 00       	call   3edc <exit>
+  else
+    wait();
+     efe:	e8 e1 2f 00 00       	call   3ee4 <wait>
+  close(fd);
+     f03:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     f06:	89 04 24             	mov    %eax,(%esp)
+     f09:	e8 f6 2f 00 00       	call   3f04 <close>
+  fd = open("sharedfd", 0);
+     f0e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+     f15:	00 
+     f16:	c7 04 24 ca 49 00 00 	movl   $0x49ca,(%esp)
+     f1d:	e8 fa 2f 00 00       	call   3f1c <open>
+     f22:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(fd < 0){
+     f25:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     f29:	79 19                	jns    f44 <sharedfd+0x129>
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+     f2b:	c7 44 24 04 20 4a 00 	movl   $0x4a20,0x4(%esp)
+     f32:	00 
+     f33:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     f3a:	e8 42 31 00 00       	call   4081 <printf>
+     f3f:	e9 d3 00 00 00       	jmp    1017 <sharedfd+0x1fc>
+    return;
+  }
+  nc = np = 0;
+     f44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+     f4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     f4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+     f51:	eb 3b                	jmp    f8e <sharedfd+0x173>
+    for(i = 0; i < sizeof(buf); i++){
+     f53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     f5a:	eb 2a                	jmp    f86 <sharedfd+0x16b>
+      if(buf[i] == 'c')
+     f5c:	8d 55 d6             	lea    -0x2a(%ebp),%edx
+     f5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     f62:	01 d0                	add    %edx,%eax
+     f64:	0f b6 00             	movzbl (%eax),%eax
+     f67:	3c 63                	cmp    $0x63,%al
+     f69:	75 04                	jne    f6f <sharedfd+0x154>
+        nc++;
+     f6b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+      if(buf[i] == 'p')
+     f6f:	8d 55 d6             	lea    -0x2a(%ebp),%edx
+     f72:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     f75:	01 d0                	add    %edx,%eax
+     f77:	0f b6 00             	movzbl (%eax),%eax
+     f7a:	3c 70                	cmp    $0x70,%al
+     f7c:	75 04                	jne    f82 <sharedfd+0x167>
+        np++;
+     f7e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    return;
+  }
+  nc = np = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    for(i = 0; i < sizeof(buf); i++){
+     f82:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     f89:	83 f8 09             	cmp    $0x9,%eax
+     f8c:	76 ce                	jbe    f5c <sharedfd+0x141>
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    return;
+  }
+  nc = np = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+     f8e:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+     f95:	00 
+     f96:	8d 45 d6             	lea    -0x2a(%ebp),%eax
+     f99:	89 44 24 04          	mov    %eax,0x4(%esp)
+     f9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     fa0:	89 04 24             	mov    %eax,(%esp)
+     fa3:	e8 4c 2f 00 00       	call   3ef4 <read>
+     fa8:	89 45 e0             	mov    %eax,-0x20(%ebp)
+     fab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+     faf:	7f a2                	jg     f53 <sharedfd+0x138>
+        nc++;
+      if(buf[i] == 'p')
+        np++;
+    }
+  }
+  close(fd);
+     fb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     fb4:	89 04 24             	mov    %eax,(%esp)
+     fb7:	e8 48 2f 00 00       	call   3f04 <close>
+  unlink("sharedfd");
+     fbc:	c7 04 24 ca 49 00 00 	movl   $0x49ca,(%esp)
+     fc3:	e8 64 2f 00 00       	call   3f2c <unlink>
+  if(nc == 10000 && np == 10000){
+     fc8:	81 7d f0 10 27 00 00 	cmpl   $0x2710,-0x10(%ebp)
+     fcf:	75 1f                	jne    ff0 <sharedfd+0x1d5>
+     fd1:	81 7d ec 10 27 00 00 	cmpl   $0x2710,-0x14(%ebp)
+     fd8:	75 16                	jne    ff0 <sharedfd+0x1d5>
+    printf(1, "sharedfd ok\n");
+     fda:	c7 44 24 04 4b 4a 00 	movl   $0x4a4b,0x4(%esp)
+     fe1:	00 
+     fe2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+     fe9:	e8 93 30 00 00       	call   4081 <printf>
+     fee:	eb 27                	jmp    1017 <sharedfd+0x1fc>
+  } else {
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+     ff0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     ff3:	89 44 24 0c          	mov    %eax,0xc(%esp)
+     ff7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     ffa:	89 44 24 08          	mov    %eax,0x8(%esp)
+     ffe:	c7 44 24 04 58 4a 00 	movl   $0x4a58,0x4(%esp)
+    1005:	00 
+    1006:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    100d:	e8 6f 30 00 00       	call   4081 <printf>
+    exit();
+    1012:	e8 c5 2e 00 00       	call   3edc <exit>
+  }
+}
+    1017:	c9                   	leave  
+    1018:	c3                   	ret    
+
+00001019 <fourfiles>:
+
+// four processes write different files at the same
+// time, to test block allocation.
+void
+fourfiles(void)
+{
+    1019:	55                   	push   %ebp
+    101a:	89 e5                	mov    %esp,%ebp
+    101c:	83 ec 48             	sub    $0x48,%esp
+  int fd, pid, i, j, n, total, pi;
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    101f:	c7 45 c8 6d 4a 00 00 	movl   $0x4a6d,-0x38(%ebp)
+    1026:	c7 45 cc 70 4a 00 00 	movl   $0x4a70,-0x34(%ebp)
+    102d:	c7 45 d0 73 4a 00 00 	movl   $0x4a73,-0x30(%ebp)
+    1034:	c7 45 d4 76 4a 00 00 	movl   $0x4a76,-0x2c(%ebp)
+  char *fname;
+
+  printf(1, "fourfiles test\n");
+    103b:	c7 44 24 04 79 4a 00 	movl   $0x4a79,0x4(%esp)
+    1042:	00 
+    1043:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    104a:	e8 32 30 00 00       	call   4081 <printf>
+
+  for(pi = 0; pi < 4; pi++){
+    104f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+    1056:	e9 fc 00 00 00       	jmp    1157 <fourfiles+0x13e>
+    fname = names[pi];
+    105b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    105e:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
+    1062:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    unlink(fname);
+    1065:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1068:	89 04 24             	mov    %eax,(%esp)
+    106b:	e8 bc 2e 00 00       	call   3f2c <unlink>
+
+    pid = fork();
+    1070:	e8 5f 2e 00 00       	call   3ed4 <fork>
+    1075:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    if(pid < 0){
+    1078:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+    107c:	79 19                	jns    1097 <fourfiles+0x7e>
+      printf(1, "fork failed\n");
+    107e:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+    1085:	00 
+    1086:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    108d:	e8 ef 2f 00 00       	call   4081 <printf>
+      exit();
+    1092:	e8 45 2e 00 00       	call   3edc <exit>
+    }
+
+    if(pid == 0){
+    1097:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+    109b:	0f 85 b2 00 00 00    	jne    1153 <fourfiles+0x13a>
+      fd = open(fname, O_CREATE | O_RDWR);
+    10a1:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    10a8:	00 
+    10a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    10ac:	89 04 24             	mov    %eax,(%esp)
+    10af:	e8 68 2e 00 00       	call   3f1c <open>
+    10b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
+      if(fd < 0){
+    10b7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+    10bb:	79 19                	jns    10d6 <fourfiles+0xbd>
+        printf(1, "create failed\n");
+    10bd:	c7 44 24 04 89 4a 00 	movl   $0x4a89,0x4(%esp)
+    10c4:	00 
+    10c5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10cc:	e8 b0 2f 00 00       	call   4081 <printf>
+        exit();
+    10d1:	e8 06 2e 00 00       	call   3edc <exit>
+      }
+      
+      memset(buf, '0'+pi, 512);
+    10d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    10d9:	83 c0 30             	add    $0x30,%eax
+    10dc:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    10e3:	00 
+    10e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+    10e8:	c7 04 24 00 8b 00 00 	movl   $0x8b00,(%esp)
+    10ef:	e8 41 2c 00 00       	call   3d35 <memset>
+      for(i = 0; i < 12; i++){
+    10f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    10fb:	eb 4b                	jmp    1148 <fourfiles+0x12f>
+        if((n = write(fd, buf, 500)) != 500){
+    10fd:	c7 44 24 08 f4 01 00 	movl   $0x1f4,0x8(%esp)
+    1104:	00 
+    1105:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    110c:	00 
+    110d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    1110:	89 04 24             	mov    %eax,(%esp)
+    1113:	e8 e4 2d 00 00       	call   3efc <write>
+    1118:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    111b:	81 7d d8 f4 01 00 00 	cmpl   $0x1f4,-0x28(%ebp)
+    1122:	74 20                	je     1144 <fourfiles+0x12b>
+          printf(1, "write failed %d\n", n);
+    1124:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    1127:	89 44 24 08          	mov    %eax,0x8(%esp)
+    112b:	c7 44 24 04 98 4a 00 	movl   $0x4a98,0x4(%esp)
+    1132:	00 
+    1133:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    113a:	e8 42 2f 00 00       	call   4081 <printf>
+          exit();
+    113f:	e8 98 2d 00 00       	call   3edc <exit>
+        printf(1, "create failed\n");
+        exit();
+      }
+      
+      memset(buf, '0'+pi, 512);
+      for(i = 0; i < 12; i++){
+    1144:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1148:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
+    114c:	7e af                	jle    10fd <fourfiles+0xe4>
+        if((n = write(fd, buf, 500)) != 500){
+          printf(1, "write failed %d\n", n);
+          exit();
+        }
+      }
+      exit();
+    114e:	e8 89 2d 00 00       	call   3edc <exit>
+  char *names[] = { "f0", "f1", "f2", "f3" };
+  char *fname;
+
+  printf(1, "fourfiles test\n");
+
+  for(pi = 0; pi < 4; pi++){
+    1153:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+    1157:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+    115b:	0f 8e fa fe ff ff    	jle    105b <fourfiles+0x42>
+      }
+      exit();
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    1161:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+    1168:	eb 09                	jmp    1173 <fourfiles+0x15a>
+    wait();
+    116a:	e8 75 2d 00 00       	call   3ee4 <wait>
+      }
+      exit();
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    116f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+    1173:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+    1177:	7e f1                	jle    116a <fourfiles+0x151>
+    wait();
+  }
+
+  for(i = 0; i < 2; i++){
+    1179:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1180:	e9 dc 00 00 00       	jmp    1261 <fourfiles+0x248>
+    fname = names[i];
+    1185:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1188:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
+    118c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    fd = open(fname, 0);
+    118f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1196:	00 
+    1197:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    119a:	89 04 24             	mov    %eax,(%esp)
+    119d:	e8 7a 2d 00 00       	call   3f1c <open>
+    11a2:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    total = 0;
+    11a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    11ac:	eb 4c                	jmp    11fa <fourfiles+0x1e1>
+      for(j = 0; j < n; j++){
+    11ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    11b5:	eb 35                	jmp    11ec <fourfiles+0x1d3>
+        if(buf[j] != '0'+i){
+    11b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    11ba:	05 00 8b 00 00       	add    $0x8b00,%eax
+    11bf:	0f b6 00             	movzbl (%eax),%eax
+    11c2:	0f be c0             	movsbl %al,%eax
+    11c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    11c8:	83 c2 30             	add    $0x30,%edx
+    11cb:	39 d0                	cmp    %edx,%eax
+    11cd:	74 19                	je     11e8 <fourfiles+0x1cf>
+          printf(1, "wrong char\n");
+    11cf:	c7 44 24 04 a9 4a 00 	movl   $0x4aa9,0x4(%esp)
+    11d6:	00 
+    11d7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    11de:	e8 9e 2e 00 00       	call   4081 <printf>
+          exit();
+    11e3:	e8 f4 2c 00 00       	call   3edc <exit>
+  for(i = 0; i < 2; i++){
+    fname = names[i];
+    fd = open(fname, 0);
+    total = 0;
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+      for(j = 0; j < n; j++){
+    11e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    11ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    11ef:	3b 45 d8             	cmp    -0x28(%ebp),%eax
+    11f2:	7c c3                	jl     11b7 <fourfiles+0x19e>
+        if(buf[j] != '0'+i){
+          printf(1, "wrong char\n");
+          exit();
+        }
+      }
+      total += n;
+    11f4:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    11f7:	01 45 ec             	add    %eax,-0x14(%ebp)
+
+  for(i = 0; i < 2; i++){
+    fname = names[i];
+    fd = open(fname, 0);
+    total = 0;
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    11fa:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    1201:	00 
+    1202:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    1209:	00 
+    120a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    120d:	89 04 24             	mov    %eax,(%esp)
+    1210:	e8 df 2c 00 00       	call   3ef4 <read>
+    1215:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    1218:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+    121c:	7f 90                	jg     11ae <fourfiles+0x195>
+          exit();
+        }
+      }
+      total += n;
+    }
+    close(fd);
+    121e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    1221:	89 04 24             	mov    %eax,(%esp)
+    1224:	e8 db 2c 00 00       	call   3f04 <close>
+    if(total != 12*500){
+    1229:	81 7d ec 70 17 00 00 	cmpl   $0x1770,-0x14(%ebp)
+    1230:	74 20                	je     1252 <fourfiles+0x239>
+      printf(1, "wrong length %d\n", total);
+    1232:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    1235:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1239:	c7 44 24 04 b5 4a 00 	movl   $0x4ab5,0x4(%esp)
+    1240:	00 
+    1241:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1248:	e8 34 2e 00 00       	call   4081 <printf>
+      exit();
+    124d:	e8 8a 2c 00 00       	call   3edc <exit>
+    }
+    unlink(fname);
+    1252:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1255:	89 04 24             	mov    %eax,(%esp)
+    1258:	e8 cf 2c 00 00       	call   3f2c <unlink>
+
+  for(pi = 0; pi < 4; pi++){
+    wait();
+  }
+
+  for(i = 0; i < 2; i++){
+    125d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1261:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
+    1265:	0f 8e 1a ff ff ff    	jle    1185 <fourfiles+0x16c>
+      exit();
+    }
+    unlink(fname);
+  }
+
+  printf(1, "fourfiles ok\n");
+    126b:	c7 44 24 04 c6 4a 00 	movl   $0x4ac6,0x4(%esp)
+    1272:	00 
+    1273:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    127a:	e8 02 2e 00 00       	call   4081 <printf>
+}
+    127f:	c9                   	leave  
+    1280:	c3                   	ret    
+
+00001281 <createdelete>:
+
+// four processes create and delete different files in same directory
+void
+createdelete(void)
+{
+    1281:	55                   	push   %ebp
+    1282:	89 e5                	mov    %esp,%ebp
+    1284:	83 ec 48             	sub    $0x48,%esp
+  enum { N = 20 };
+  int pid, i, fd, pi;
+  char name[32];
+
+  printf(1, "createdelete test\n");
+    1287:	c7 44 24 04 d4 4a 00 	movl   $0x4ad4,0x4(%esp)
+    128e:	00 
+    128f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1296:	e8 e6 2d 00 00       	call   4081 <printf>
+
+  for(pi = 0; pi < 4; pi++){
+    129b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    12a2:	e9 f4 00 00 00       	jmp    139b <createdelete+0x11a>
+    pid = fork();
+    12a7:	e8 28 2c 00 00       	call   3ed4 <fork>
+    12ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(pid < 0){
+    12af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    12b3:	79 19                	jns    12ce <createdelete+0x4d>
+      printf(1, "fork failed\n");
+    12b5:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+    12bc:	00 
+    12bd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    12c4:	e8 b8 2d 00 00       	call   4081 <printf>
+      exit();
+    12c9:	e8 0e 2c 00 00       	call   3edc <exit>
+    }
+
+    if(pid == 0){
+    12ce:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    12d2:	0f 85 bf 00 00 00    	jne    1397 <createdelete+0x116>
+      name[0] = 'p' + pi;
+    12d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    12db:	83 c0 70             	add    $0x70,%eax
+    12de:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[2] = '\0';
+    12e1:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+      for(i = 0; i < N; i++){
+    12e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    12ec:	e9 97 00 00 00       	jmp    1388 <createdelete+0x107>
+        name[1] = '0' + i;
+    12f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    12f4:	83 c0 30             	add    $0x30,%eax
+    12f7:	88 45 c9             	mov    %al,-0x37(%ebp)
+        fd = open(name, O_CREATE | O_RDWR);
+    12fa:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    1301:	00 
+    1302:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    1305:	89 04 24             	mov    %eax,(%esp)
+    1308:	e8 0f 2c 00 00       	call   3f1c <open>
+    130d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        if(fd < 0){
+    1310:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1314:	79 19                	jns    132f <createdelete+0xae>
+          printf(1, "create failed\n");
+    1316:	c7 44 24 04 89 4a 00 	movl   $0x4a89,0x4(%esp)
+    131d:	00 
+    131e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1325:	e8 57 2d 00 00       	call   4081 <printf>
+          exit();
+    132a:	e8 ad 2b 00 00       	call   3edc <exit>
+        }
+        close(fd);
+    132f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1332:	89 04 24             	mov    %eax,(%esp)
+    1335:	e8 ca 2b 00 00       	call   3f04 <close>
+        if(i > 0 && (i % 2 ) == 0){
+    133a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    133e:	7e 44                	jle    1384 <createdelete+0x103>
+    1340:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1343:	83 e0 01             	and    $0x1,%eax
+    1346:	85 c0                	test   %eax,%eax
+    1348:	75 3a                	jne    1384 <createdelete+0x103>
+          name[1] = '0' + (i / 2);
+    134a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    134d:	89 c2                	mov    %eax,%edx
+    134f:	c1 ea 1f             	shr    $0x1f,%edx
+    1352:	01 d0                	add    %edx,%eax
+    1354:	d1 f8                	sar    %eax
+    1356:	83 c0 30             	add    $0x30,%eax
+    1359:	88 45 c9             	mov    %al,-0x37(%ebp)
+          if(unlink(name) < 0){
+    135c:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    135f:	89 04 24             	mov    %eax,(%esp)
+    1362:	e8 c5 2b 00 00       	call   3f2c <unlink>
+    1367:	85 c0                	test   %eax,%eax
+    1369:	79 19                	jns    1384 <createdelete+0x103>
+            printf(1, "unlink failed\n");
+    136b:	c7 44 24 04 78 45 00 	movl   $0x4578,0x4(%esp)
+    1372:	00 
+    1373:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    137a:	e8 02 2d 00 00       	call   4081 <printf>
+            exit();
+    137f:	e8 58 2b 00 00       	call   3edc <exit>
+    }
+
+    if(pid == 0){
+      name[0] = 'p' + pi;
+      name[2] = '\0';
+      for(i = 0; i < N; i++){
+    1384:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1388:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    138c:	0f 8e 5f ff ff ff    	jle    12f1 <createdelete+0x70>
+            printf(1, "unlink failed\n");
+            exit();
+          }
+        }
+      }
+      exit();
+    1392:	e8 45 2b 00 00       	call   3edc <exit>
+  int pid, i, fd, pi;
+  char name[32];
+
+  printf(1, "createdelete test\n");
+
+  for(pi = 0; pi < 4; pi++){
+    1397:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    139b:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    139f:	0f 8e 02 ff ff ff    	jle    12a7 <createdelete+0x26>
+      }
+      exit();
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    13a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    13ac:	eb 09                	jmp    13b7 <createdelete+0x136>
+    wait();
+    13ae:	e8 31 2b 00 00       	call   3ee4 <wait>
+      }
+      exit();
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    13b3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    13b7:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    13bb:	7e f1                	jle    13ae <createdelete+0x12d>
+    wait();
+  }
+
+  name[0] = name[1] = name[2] = 0;
+    13bd:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+    13c1:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
+    13c5:	88 45 c9             	mov    %al,-0x37(%ebp)
+    13c8:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+    13cc:	88 45 c8             	mov    %al,-0x38(%ebp)
+  for(i = 0; i < N; i++){
+    13cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    13d6:	e9 bb 00 00 00       	jmp    1496 <createdelete+0x215>
+    for(pi = 0; pi < 4; pi++){
+    13db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    13e2:	e9 a1 00 00 00       	jmp    1488 <createdelete+0x207>
+      name[0] = 'p' + pi;
+    13e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    13ea:	83 c0 70             	add    $0x70,%eax
+    13ed:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[1] = '0' + i;
+    13f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    13f3:	83 c0 30             	add    $0x30,%eax
+    13f6:	88 45 c9             	mov    %al,-0x37(%ebp)
+      fd = open(name, 0);
+    13f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1400:	00 
+    1401:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    1404:	89 04 24             	mov    %eax,(%esp)
+    1407:	e8 10 2b 00 00       	call   3f1c <open>
+    140c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if((i == 0 || i >= N/2) && fd < 0){
+    140f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1413:	74 06                	je     141b <createdelete+0x19a>
+    1415:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+    1419:	7e 26                	jle    1441 <createdelete+0x1c0>
+    141b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    141f:	79 20                	jns    1441 <createdelete+0x1c0>
+        printf(1, "oops createdelete %s didn't exist\n", name);
+    1421:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    1424:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1428:	c7 44 24 04 e8 4a 00 	movl   $0x4ae8,0x4(%esp)
+    142f:	00 
+    1430:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1437:	e8 45 2c 00 00       	call   4081 <printf>
+        exit();
+    143c:	e8 9b 2a 00 00       	call   3edc <exit>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    1441:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1445:	7e 2c                	jle    1473 <createdelete+0x1f2>
+    1447:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+    144b:	7f 26                	jg     1473 <createdelete+0x1f2>
+    144d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1451:	78 20                	js     1473 <createdelete+0x1f2>
+        printf(1, "oops createdelete %s did exist\n", name);
+    1453:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    1456:	89 44 24 08          	mov    %eax,0x8(%esp)
+    145a:	c7 44 24 04 0c 4b 00 	movl   $0x4b0c,0x4(%esp)
+    1461:	00 
+    1462:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1469:	e8 13 2c 00 00       	call   4081 <printf>
+        exit();
+    146e:	e8 69 2a 00 00       	call   3edc <exit>
+      }
+      if(fd >= 0)
+    1473:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1477:	78 0b                	js     1484 <createdelete+0x203>
+        close(fd);
+    1479:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    147c:	89 04 24             	mov    %eax,(%esp)
+    147f:	e8 80 2a 00 00       	call   3f04 <close>
+    wait();
+  }
+
+  name[0] = name[1] = name[2] = 0;
+  for(i = 0; i < N; i++){
+    for(pi = 0; pi < 4; pi++){
+    1484:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    1488:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    148c:	0f 8e 55 ff ff ff    	jle    13e7 <createdelete+0x166>
+  for(pi = 0; pi < 4; pi++){
+    wait();
+  }
+
+  name[0] = name[1] = name[2] = 0;
+  for(i = 0; i < N; i++){
+    1492:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1496:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    149a:	0f 8e 3b ff ff ff    	jle    13db <createdelete+0x15a>
+      if(fd >= 0)
+        close(fd);
+    }
+  }
+
+  for(i = 0; i < N; i++){
+    14a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    14a7:	eb 34                	jmp    14dd <createdelete+0x25c>
+    for(pi = 0; pi < 4; pi++){
+    14a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    14b0:	eb 21                	jmp    14d3 <createdelete+0x252>
+      name[0] = 'p' + i;
+    14b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    14b5:	83 c0 70             	add    $0x70,%eax
+    14b8:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[1] = '0' + i;
+    14bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    14be:	83 c0 30             	add    $0x30,%eax
+    14c1:	88 45 c9             	mov    %al,-0x37(%ebp)
+      unlink(name);
+    14c4:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    14c7:	89 04 24             	mov    %eax,(%esp)
+    14ca:	e8 5d 2a 00 00       	call   3f2c <unlink>
+        close(fd);
+    }
+  }
+
+  for(i = 0; i < N; i++){
+    for(pi = 0; pi < 4; pi++){
+    14cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    14d3:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    14d7:	7e d9                	jle    14b2 <createdelete+0x231>
+      if(fd >= 0)
+        close(fd);
+    }
+  }
+
+  for(i = 0; i < N; i++){
+    14d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    14dd:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    14e1:	7e c6                	jle    14a9 <createdelete+0x228>
+      name[1] = '0' + i;
+      unlink(name);
+    }
+  }
+
+  printf(1, "createdelete ok\n");
+    14e3:	c7 44 24 04 2c 4b 00 	movl   $0x4b2c,0x4(%esp)
+    14ea:	00 
+    14eb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    14f2:	e8 8a 2b 00 00       	call   4081 <printf>
+}
+    14f7:	c9                   	leave  
+    14f8:	c3                   	ret    
+
+000014f9 <unlinkread>:
+
+// can I unlink a file and still read it?
+void
+unlinkread(void)
+{
+    14f9:	55                   	push   %ebp
+    14fa:	89 e5                	mov    %esp,%ebp
+    14fc:	83 ec 28             	sub    $0x28,%esp
+  int fd, fd1;
+
+  printf(1, "unlinkread test\n");
+    14ff:	c7 44 24 04 3d 4b 00 	movl   $0x4b3d,0x4(%esp)
+    1506:	00 
+    1507:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    150e:	e8 6e 2b 00 00       	call   4081 <printf>
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+    1513:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    151a:	00 
+    151b:	c7 04 24 4e 4b 00 00 	movl   $0x4b4e,(%esp)
+    1522:	e8 f5 29 00 00       	call   3f1c <open>
+    1527:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    152a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    152e:	79 19                	jns    1549 <unlinkread+0x50>
+    printf(1, "create unlinkread failed\n");
+    1530:	c7 44 24 04 59 4b 00 	movl   $0x4b59,0x4(%esp)
+    1537:	00 
+    1538:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    153f:	e8 3d 2b 00 00       	call   4081 <printf>
+    exit();
+    1544:	e8 93 29 00 00       	call   3edc <exit>
+  }
+  write(fd, "hello", 5);
+    1549:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
+    1550:	00 
+    1551:	c7 44 24 04 73 4b 00 	movl   $0x4b73,0x4(%esp)
+    1558:	00 
+    1559:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    155c:	89 04 24             	mov    %eax,(%esp)
+    155f:	e8 98 29 00 00       	call   3efc <write>
+  close(fd);
+    1564:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1567:	89 04 24             	mov    %eax,(%esp)
+    156a:	e8 95 29 00 00       	call   3f04 <close>
+
+  fd = open("unlinkread", O_RDWR);
+    156f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    1576:	00 
+    1577:	c7 04 24 4e 4b 00 00 	movl   $0x4b4e,(%esp)
+    157e:	e8 99 29 00 00       	call   3f1c <open>
+    1583:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    1586:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    158a:	79 19                	jns    15a5 <unlinkread+0xac>
+    printf(1, "open unlinkread failed\n");
+    158c:	c7 44 24 04 79 4b 00 	movl   $0x4b79,0x4(%esp)
+    1593:	00 
+    1594:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    159b:	e8 e1 2a 00 00       	call   4081 <printf>
+    exit();
+    15a0:	e8 37 29 00 00       	call   3edc <exit>
+  }
+  if(unlink("unlinkread") != 0){
+    15a5:	c7 04 24 4e 4b 00 00 	movl   $0x4b4e,(%esp)
+    15ac:	e8 7b 29 00 00       	call   3f2c <unlink>
+    15b1:	85 c0                	test   %eax,%eax
+    15b3:	74 19                	je     15ce <unlinkread+0xd5>
+    printf(1, "unlink unlinkread failed\n");
+    15b5:	c7 44 24 04 91 4b 00 	movl   $0x4b91,0x4(%esp)
+    15bc:	00 
+    15bd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    15c4:	e8 b8 2a 00 00       	call   4081 <printf>
+    exit();
+    15c9:	e8 0e 29 00 00       	call   3edc <exit>
+  }
+
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+    15ce:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    15d5:	00 
+    15d6:	c7 04 24 4e 4b 00 00 	movl   $0x4b4e,(%esp)
+    15dd:	e8 3a 29 00 00       	call   3f1c <open>
+    15e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  write(fd1, "yyy", 3);
+    15e5:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
+    15ec:	00 
+    15ed:	c7 44 24 04 ab 4b 00 	movl   $0x4bab,0x4(%esp)
+    15f4:	00 
+    15f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    15f8:	89 04 24             	mov    %eax,(%esp)
+    15fb:	e8 fc 28 00 00       	call   3efc <write>
+  close(fd1);
+    1600:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1603:	89 04 24             	mov    %eax,(%esp)
+    1606:	e8 f9 28 00 00       	call   3f04 <close>
+
+  if(read(fd, buf, sizeof(buf)) != 5){
+    160b:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    1612:	00 
+    1613:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    161a:	00 
+    161b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    161e:	89 04 24             	mov    %eax,(%esp)
+    1621:	e8 ce 28 00 00       	call   3ef4 <read>
+    1626:	83 f8 05             	cmp    $0x5,%eax
+    1629:	74 19                	je     1644 <unlinkread+0x14b>
+    printf(1, "unlinkread read failed");
+    162b:	c7 44 24 04 af 4b 00 	movl   $0x4baf,0x4(%esp)
+    1632:	00 
+    1633:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    163a:	e8 42 2a 00 00       	call   4081 <printf>
+    exit();
+    163f:	e8 98 28 00 00       	call   3edc <exit>
+  }
+  if(buf[0] != 'h'){
+    1644:	0f b6 05 00 8b 00 00 	movzbl 0x8b00,%eax
+    164b:	3c 68                	cmp    $0x68,%al
+    164d:	74 19                	je     1668 <unlinkread+0x16f>
+    printf(1, "unlinkread wrong data\n");
+    164f:	c7 44 24 04 c6 4b 00 	movl   $0x4bc6,0x4(%esp)
+    1656:	00 
+    1657:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    165e:	e8 1e 2a 00 00       	call   4081 <printf>
+    exit();
+    1663:	e8 74 28 00 00       	call   3edc <exit>
+  }
+  if(write(fd, buf, 10) != 10){
+    1668:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    166f:	00 
+    1670:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    1677:	00 
+    1678:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    167b:	89 04 24             	mov    %eax,(%esp)
+    167e:	e8 79 28 00 00       	call   3efc <write>
+    1683:	83 f8 0a             	cmp    $0xa,%eax
+    1686:	74 19                	je     16a1 <unlinkread+0x1a8>
+    printf(1, "unlinkread write failed\n");
+    1688:	c7 44 24 04 dd 4b 00 	movl   $0x4bdd,0x4(%esp)
+    168f:	00 
+    1690:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1697:	e8 e5 29 00 00       	call   4081 <printf>
+    exit();
+    169c:	e8 3b 28 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    16a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    16a4:	89 04 24             	mov    %eax,(%esp)
+    16a7:	e8 58 28 00 00       	call   3f04 <close>
+  unlink("unlinkread");
+    16ac:	c7 04 24 4e 4b 00 00 	movl   $0x4b4e,(%esp)
+    16b3:	e8 74 28 00 00       	call   3f2c <unlink>
+  printf(1, "unlinkread ok\n");
+    16b8:	c7 44 24 04 f6 4b 00 	movl   $0x4bf6,0x4(%esp)
+    16bf:	00 
+    16c0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    16c7:	e8 b5 29 00 00       	call   4081 <printf>
+}
+    16cc:	c9                   	leave  
+    16cd:	c3                   	ret    
+
+000016ce <linktest>:
+
+void
+linktest(void)
+{
+    16ce:	55                   	push   %ebp
+    16cf:	89 e5                	mov    %esp,%ebp
+    16d1:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+
+  printf(1, "linktest\n");
+    16d4:	c7 44 24 04 05 4c 00 	movl   $0x4c05,0x4(%esp)
+    16db:	00 
+    16dc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    16e3:	e8 99 29 00 00       	call   4081 <printf>
+
+  unlink("lf1");
+    16e8:	c7 04 24 0f 4c 00 00 	movl   $0x4c0f,(%esp)
+    16ef:	e8 38 28 00 00       	call   3f2c <unlink>
+  unlink("lf2");
+    16f4:	c7 04 24 13 4c 00 00 	movl   $0x4c13,(%esp)
+    16fb:	e8 2c 28 00 00       	call   3f2c <unlink>
+
+  fd = open("lf1", O_CREATE|O_RDWR);
+    1700:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    1707:	00 
+    1708:	c7 04 24 0f 4c 00 00 	movl   $0x4c0f,(%esp)
+    170f:	e8 08 28 00 00       	call   3f1c <open>
+    1714:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    1717:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    171b:	79 19                	jns    1736 <linktest+0x68>
+    printf(1, "create lf1 failed\n");
+    171d:	c7 44 24 04 17 4c 00 	movl   $0x4c17,0x4(%esp)
+    1724:	00 
+    1725:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    172c:	e8 50 29 00 00       	call   4081 <printf>
+    exit();
+    1731:	e8 a6 27 00 00       	call   3edc <exit>
+  }
+  if(write(fd, "hello", 5) != 5){
+    1736:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
+    173d:	00 
+    173e:	c7 44 24 04 73 4b 00 	movl   $0x4b73,0x4(%esp)
+    1745:	00 
+    1746:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1749:	89 04 24             	mov    %eax,(%esp)
+    174c:	e8 ab 27 00 00       	call   3efc <write>
+    1751:	83 f8 05             	cmp    $0x5,%eax
+    1754:	74 19                	je     176f <linktest+0xa1>
+    printf(1, "write lf1 failed\n");
+    1756:	c7 44 24 04 2a 4c 00 	movl   $0x4c2a,0x4(%esp)
+    175d:	00 
+    175e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1765:	e8 17 29 00 00       	call   4081 <printf>
+    exit();
+    176a:	e8 6d 27 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    176f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1772:	89 04 24             	mov    %eax,(%esp)
+    1775:	e8 8a 27 00 00       	call   3f04 <close>
+
+  if(link("lf1", "lf2") < 0){
+    177a:	c7 44 24 04 13 4c 00 	movl   $0x4c13,0x4(%esp)
+    1781:	00 
+    1782:	c7 04 24 0f 4c 00 00 	movl   $0x4c0f,(%esp)
+    1789:	e8 ae 27 00 00       	call   3f3c <link>
+    178e:	85 c0                	test   %eax,%eax
+    1790:	79 19                	jns    17ab <linktest+0xdd>
+    printf(1, "link lf1 lf2 failed\n");
+    1792:	c7 44 24 04 3c 4c 00 	movl   $0x4c3c,0x4(%esp)
+    1799:	00 
+    179a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    17a1:	e8 db 28 00 00       	call   4081 <printf>
+    exit();
+    17a6:	e8 31 27 00 00       	call   3edc <exit>
+  }
+  unlink("lf1");
+    17ab:	c7 04 24 0f 4c 00 00 	movl   $0x4c0f,(%esp)
+    17b2:	e8 75 27 00 00       	call   3f2c <unlink>
+
+  if(open("lf1", 0) >= 0){
+    17b7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    17be:	00 
+    17bf:	c7 04 24 0f 4c 00 00 	movl   $0x4c0f,(%esp)
+    17c6:	e8 51 27 00 00       	call   3f1c <open>
+    17cb:	85 c0                	test   %eax,%eax
+    17cd:	78 19                	js     17e8 <linktest+0x11a>
+    printf(1, "unlinked lf1 but it is still there!\n");
+    17cf:	c7 44 24 04 54 4c 00 	movl   $0x4c54,0x4(%esp)
+    17d6:	00 
+    17d7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    17de:	e8 9e 28 00 00       	call   4081 <printf>
+    exit();
+    17e3:	e8 f4 26 00 00       	call   3edc <exit>
+  }
+
+  fd = open("lf2", 0);
+    17e8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    17ef:	00 
+    17f0:	c7 04 24 13 4c 00 00 	movl   $0x4c13,(%esp)
+    17f7:	e8 20 27 00 00       	call   3f1c <open>
+    17fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    17ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1803:	79 19                	jns    181e <linktest+0x150>
+    printf(1, "open lf2 failed\n");
+    1805:	c7 44 24 04 79 4c 00 	movl   $0x4c79,0x4(%esp)
+    180c:	00 
+    180d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1814:	e8 68 28 00 00       	call   4081 <printf>
+    exit();
+    1819:	e8 be 26 00 00       	call   3edc <exit>
+  }
+  if(read(fd, buf, sizeof(buf)) != 5){
+    181e:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    1825:	00 
+    1826:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    182d:	00 
+    182e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1831:	89 04 24             	mov    %eax,(%esp)
+    1834:	e8 bb 26 00 00       	call   3ef4 <read>
+    1839:	83 f8 05             	cmp    $0x5,%eax
+    183c:	74 19                	je     1857 <linktest+0x189>
+    printf(1, "read lf2 failed\n");
+    183e:	c7 44 24 04 8a 4c 00 	movl   $0x4c8a,0x4(%esp)
+    1845:	00 
+    1846:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    184d:	e8 2f 28 00 00       	call   4081 <printf>
+    exit();
+    1852:	e8 85 26 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    1857:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    185a:	89 04 24             	mov    %eax,(%esp)
+    185d:	e8 a2 26 00 00       	call   3f04 <close>
+
+  if(link("lf2", "lf2") >= 0){
+    1862:	c7 44 24 04 13 4c 00 	movl   $0x4c13,0x4(%esp)
+    1869:	00 
+    186a:	c7 04 24 13 4c 00 00 	movl   $0x4c13,(%esp)
+    1871:	e8 c6 26 00 00       	call   3f3c <link>
+    1876:	85 c0                	test   %eax,%eax
+    1878:	78 19                	js     1893 <linktest+0x1c5>
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    187a:	c7 44 24 04 9b 4c 00 	movl   $0x4c9b,0x4(%esp)
+    1881:	00 
+    1882:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1889:	e8 f3 27 00 00       	call   4081 <printf>
+    exit();
+    188e:	e8 49 26 00 00       	call   3edc <exit>
+  }
+
+  unlink("lf2");
+    1893:	c7 04 24 13 4c 00 00 	movl   $0x4c13,(%esp)
+    189a:	e8 8d 26 00 00       	call   3f2c <unlink>
+  if(link("lf2", "lf1") >= 0){
+    189f:	c7 44 24 04 0f 4c 00 	movl   $0x4c0f,0x4(%esp)
+    18a6:	00 
+    18a7:	c7 04 24 13 4c 00 00 	movl   $0x4c13,(%esp)
+    18ae:	e8 89 26 00 00       	call   3f3c <link>
+    18b3:	85 c0                	test   %eax,%eax
+    18b5:	78 19                	js     18d0 <linktest+0x202>
+    printf(1, "link non-existant succeeded! oops\n");
+    18b7:	c7 44 24 04 bc 4c 00 	movl   $0x4cbc,0x4(%esp)
+    18be:	00 
+    18bf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    18c6:	e8 b6 27 00 00       	call   4081 <printf>
+    exit();
+    18cb:	e8 0c 26 00 00       	call   3edc <exit>
+  }
+
+  if(link(".", "lf1") >= 0){
+    18d0:	c7 44 24 04 0f 4c 00 	movl   $0x4c0f,0x4(%esp)
+    18d7:	00 
+    18d8:	c7 04 24 df 4c 00 00 	movl   $0x4cdf,(%esp)
+    18df:	e8 58 26 00 00       	call   3f3c <link>
+    18e4:	85 c0                	test   %eax,%eax
+    18e6:	78 19                	js     1901 <linktest+0x233>
+    printf(1, "link . lf1 succeeded! oops\n");
+    18e8:	c7 44 24 04 e1 4c 00 	movl   $0x4ce1,0x4(%esp)
+    18ef:	00 
+    18f0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    18f7:	e8 85 27 00 00       	call   4081 <printf>
+    exit();
+    18fc:	e8 db 25 00 00       	call   3edc <exit>
+  }
+
+  printf(1, "linktest ok\n");
+    1901:	c7 44 24 04 fd 4c 00 	movl   $0x4cfd,0x4(%esp)
+    1908:	00 
+    1909:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1910:	e8 6c 27 00 00       	call   4081 <printf>
+}
+    1915:	c9                   	leave  
+    1916:	c3                   	ret    
+
+00001917 <concreate>:
+
+// test concurrent create/link/unlink of the same file
+void
+concreate(void)
+{
+    1917:	55                   	push   %ebp
+    1918:	89 e5                	mov    %esp,%ebp
+    191a:	83 ec 68             	sub    $0x68,%esp
+  struct {
+    ushort inum;
+    char name[14];
+  } de;
+
+  printf(1, "concreate test\n");
+    191d:	c7 44 24 04 0a 4d 00 	movl   $0x4d0a,0x4(%esp)
+    1924:	00 
+    1925:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    192c:	e8 50 27 00 00       	call   4081 <printf>
+  file[0] = 'C';
+    1931:	c6 45 e5 43          	movb   $0x43,-0x1b(%ebp)
+  file[2] = '\0';
+    1935:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
+  for(i = 0; i < 40; i++){
+    1939:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1940:	e9 f7 00 00 00       	jmp    1a3c <concreate+0x125>
+    file[1] = '0' + i;
+    1945:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1948:	83 c0 30             	add    $0x30,%eax
+    194b:	88 45 e6             	mov    %al,-0x1a(%ebp)
+    unlink(file);
+    194e:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1951:	89 04 24             	mov    %eax,(%esp)
+    1954:	e8 d3 25 00 00       	call   3f2c <unlink>
+    pid = fork();
+    1959:	e8 76 25 00 00       	call   3ed4 <fork>
+    195e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(pid && (i % 3) == 1){
+    1961:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1965:	74 3a                	je     19a1 <concreate+0x8a>
+    1967:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    196a:	ba 56 55 55 55       	mov    $0x55555556,%edx
+    196f:	89 c8                	mov    %ecx,%eax
+    1971:	f7 ea                	imul   %edx
+    1973:	89 c8                	mov    %ecx,%eax
+    1975:	c1 f8 1f             	sar    $0x1f,%eax
+    1978:	29 c2                	sub    %eax,%edx
+    197a:	89 d0                	mov    %edx,%eax
+    197c:	01 c0                	add    %eax,%eax
+    197e:	01 d0                	add    %edx,%eax
+    1980:	89 ca                	mov    %ecx,%edx
+    1982:	29 c2                	sub    %eax,%edx
+    1984:	83 fa 01             	cmp    $0x1,%edx
+    1987:	75 18                	jne    19a1 <concreate+0x8a>
+      link("C0", file);
+    1989:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    198c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1990:	c7 04 24 1a 4d 00 00 	movl   $0x4d1a,(%esp)
+    1997:	e8 a0 25 00 00       	call   3f3c <link>
+    199c:	e9 87 00 00 00       	jmp    1a28 <concreate+0x111>
+    } else if(pid == 0 && (i % 5) == 1){
+    19a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    19a5:	75 3a                	jne    19e1 <concreate+0xca>
+    19a7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    19aa:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    19af:	89 c8                	mov    %ecx,%eax
+    19b1:	f7 ea                	imul   %edx
+    19b3:	d1 fa                	sar    %edx
+    19b5:	89 c8                	mov    %ecx,%eax
+    19b7:	c1 f8 1f             	sar    $0x1f,%eax
+    19ba:	29 c2                	sub    %eax,%edx
+    19bc:	89 d0                	mov    %edx,%eax
+    19be:	c1 e0 02             	shl    $0x2,%eax
+    19c1:	01 d0                	add    %edx,%eax
+    19c3:	89 ca                	mov    %ecx,%edx
+    19c5:	29 c2                	sub    %eax,%edx
+    19c7:	83 fa 01             	cmp    $0x1,%edx
+    19ca:	75 15                	jne    19e1 <concreate+0xca>
+      link("C0", file);
+    19cc:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    19cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+    19d3:	c7 04 24 1a 4d 00 00 	movl   $0x4d1a,(%esp)
+    19da:	e8 5d 25 00 00       	call   3f3c <link>
+    19df:	eb 47                	jmp    1a28 <concreate+0x111>
+    } else {
+      fd = open(file, O_CREATE | O_RDWR);
+    19e1:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    19e8:	00 
+    19e9:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    19ec:	89 04 24             	mov    %eax,(%esp)
+    19ef:	e8 28 25 00 00       	call   3f1c <open>
+    19f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if(fd < 0){
+    19f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    19fb:	79 20                	jns    1a1d <concreate+0x106>
+        printf(1, "concreate create %s failed\n", file);
+    19fd:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1a00:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1a04:	c7 44 24 04 1d 4d 00 	movl   $0x4d1d,0x4(%esp)
+    1a0b:	00 
+    1a0c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1a13:	e8 69 26 00 00       	call   4081 <printf>
+        exit();
+    1a18:	e8 bf 24 00 00       	call   3edc <exit>
+      }
+      close(fd);
+    1a1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1a20:	89 04 24             	mov    %eax,(%esp)
+    1a23:	e8 dc 24 00 00       	call   3f04 <close>
+    }
+    if(pid == 0)
+    1a28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1a2c:	75 05                	jne    1a33 <concreate+0x11c>
+      exit();
+    1a2e:	e8 a9 24 00 00       	call   3edc <exit>
+    else
+      wait();
+    1a33:	e8 ac 24 00 00       	call   3ee4 <wait>
+  } de;
+
+  printf(1, "concreate test\n");
+  file[0] = 'C';
+  file[2] = '\0';
+  for(i = 0; i < 40; i++){
+    1a38:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1a3c:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
+    1a40:	0f 8e ff fe ff ff    	jle    1945 <concreate+0x2e>
+      exit();
+    else
+      wait();
+  }
+
+  memset(fa, 0, sizeof(fa));
+    1a46:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
+    1a4d:	00 
+    1a4e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1a55:	00 
+    1a56:	8d 45 bd             	lea    -0x43(%ebp),%eax
+    1a59:	89 04 24             	mov    %eax,(%esp)
+    1a5c:	e8 d4 22 00 00       	call   3d35 <memset>
+  fd = open(".", 0);
+    1a61:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1a68:	00 
+    1a69:	c7 04 24 df 4c 00 00 	movl   $0x4cdf,(%esp)
+    1a70:	e8 a7 24 00 00       	call   3f1c <open>
+    1a75:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  n = 0;
+    1a78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  while(read(fd, &de, sizeof(de)) > 0){
+    1a7f:	e9 a7 00 00 00       	jmp    1b2b <concreate+0x214>
+    if(de.inum == 0)
+    1a84:	0f b7 45 ac          	movzwl -0x54(%ebp),%eax
+    1a88:	66 85 c0             	test   %ax,%ax
+    1a8b:	0f 84 99 00 00 00    	je     1b2a <concreate+0x213>
+      continue;
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    1a91:	0f b6 45 ae          	movzbl -0x52(%ebp),%eax
+    1a95:	3c 43                	cmp    $0x43,%al
+    1a97:	0f 85 8e 00 00 00    	jne    1b2b <concreate+0x214>
+    1a9d:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
+    1aa1:	84 c0                	test   %al,%al
+    1aa3:	0f 85 82 00 00 00    	jne    1b2b <concreate+0x214>
+      i = de.name[1] - '0';
+    1aa9:	0f b6 45 af          	movzbl -0x51(%ebp),%eax
+    1aad:	0f be c0             	movsbl %al,%eax
+    1ab0:	83 e8 30             	sub    $0x30,%eax
+    1ab3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      if(i < 0 || i >= sizeof(fa)){
+    1ab6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1aba:	78 08                	js     1ac4 <concreate+0x1ad>
+    1abc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1abf:	83 f8 27             	cmp    $0x27,%eax
+    1ac2:	76 23                	jbe    1ae7 <concreate+0x1d0>
+        printf(1, "concreate weird file %s\n", de.name);
+    1ac4:	8d 45 ac             	lea    -0x54(%ebp),%eax
+    1ac7:	83 c0 02             	add    $0x2,%eax
+    1aca:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1ace:	c7 44 24 04 39 4d 00 	movl   $0x4d39,0x4(%esp)
+    1ad5:	00 
+    1ad6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1add:	e8 9f 25 00 00       	call   4081 <printf>
+        exit();
+    1ae2:	e8 f5 23 00 00       	call   3edc <exit>
+      }
+      if(fa[i]){
+    1ae7:	8d 55 bd             	lea    -0x43(%ebp),%edx
+    1aea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1aed:	01 d0                	add    %edx,%eax
+    1aef:	0f b6 00             	movzbl (%eax),%eax
+    1af2:	84 c0                	test   %al,%al
+    1af4:	74 23                	je     1b19 <concreate+0x202>
+        printf(1, "concreate duplicate file %s\n", de.name);
+    1af6:	8d 45 ac             	lea    -0x54(%ebp),%eax
+    1af9:	83 c0 02             	add    $0x2,%eax
+    1afc:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1b00:	c7 44 24 04 52 4d 00 	movl   $0x4d52,0x4(%esp)
+    1b07:	00 
+    1b08:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1b0f:	e8 6d 25 00 00       	call   4081 <printf>
+        exit();
+    1b14:	e8 c3 23 00 00       	call   3edc <exit>
+      }
+      fa[i] = 1;
+    1b19:	8d 55 bd             	lea    -0x43(%ebp),%edx
+    1b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1b1f:	01 d0                	add    %edx,%eax
+    1b21:	c6 00 01             	movb   $0x1,(%eax)
+      n++;
+    1b24:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    1b28:	eb 01                	jmp    1b2b <concreate+0x214>
+  memset(fa, 0, sizeof(fa));
+  fd = open(".", 0);
+  n = 0;
+  while(read(fd, &de, sizeof(de)) > 0){
+    if(de.inum == 0)
+      continue;
+    1b2a:	90                   	nop
+  }
+
+  memset(fa, 0, sizeof(fa));
+  fd = open(".", 0);
+  n = 0;
+  while(read(fd, &de, sizeof(de)) > 0){
+    1b2b:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+    1b32:	00 
+    1b33:	8d 45 ac             	lea    -0x54(%ebp),%eax
+    1b36:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1b3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1b3d:	89 04 24             	mov    %eax,(%esp)
+    1b40:	e8 af 23 00 00       	call   3ef4 <read>
+    1b45:	85 c0                	test   %eax,%eax
+    1b47:	0f 8f 37 ff ff ff    	jg     1a84 <concreate+0x16d>
+      }
+      fa[i] = 1;
+      n++;
+    }
+  }
+  close(fd);
+    1b4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1b50:	89 04 24             	mov    %eax,(%esp)
+    1b53:	e8 ac 23 00 00       	call   3f04 <close>
+
+  if(n != 40){
+    1b58:	83 7d f0 28          	cmpl   $0x28,-0x10(%ebp)
+    1b5c:	74 19                	je     1b77 <concreate+0x260>
+    printf(1, "concreate not enough files in directory listing\n");
+    1b5e:	c7 44 24 04 70 4d 00 	movl   $0x4d70,0x4(%esp)
+    1b65:	00 
+    1b66:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1b6d:	e8 0f 25 00 00       	call   4081 <printf>
+    exit();
+    1b72:	e8 65 23 00 00       	call   3edc <exit>
+  }
+
+  for(i = 0; i < 40; i++){
+    1b77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1b7e:	e9 2d 01 00 00       	jmp    1cb0 <concreate+0x399>
+    file[1] = '0' + i;
+    1b83:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1b86:	83 c0 30             	add    $0x30,%eax
+    1b89:	88 45 e6             	mov    %al,-0x1a(%ebp)
+    pid = fork();
+    1b8c:	e8 43 23 00 00       	call   3ed4 <fork>
+    1b91:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(pid < 0){
+    1b94:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1b98:	79 19                	jns    1bb3 <concreate+0x29c>
+      printf(1, "fork failed\n");
+    1b9a:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+    1ba1:	00 
+    1ba2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1ba9:	e8 d3 24 00 00       	call   4081 <printf>
+      exit();
+    1bae:	e8 29 23 00 00       	call   3edc <exit>
+    }
+    if(((i % 3) == 0 && pid == 0) ||
+    1bb3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    1bb6:	ba 56 55 55 55       	mov    $0x55555556,%edx
+    1bbb:	89 c8                	mov    %ecx,%eax
+    1bbd:	f7 ea                	imul   %edx
+    1bbf:	89 c8                	mov    %ecx,%eax
+    1bc1:	c1 f8 1f             	sar    $0x1f,%eax
+    1bc4:	29 c2                	sub    %eax,%edx
+    1bc6:	89 d0                	mov    %edx,%eax
+    1bc8:	01 c0                	add    %eax,%eax
+    1bca:	01 d0                	add    %edx,%eax
+    1bcc:	89 ca                	mov    %ecx,%edx
+    1bce:	29 c2                	sub    %eax,%edx
+    1bd0:	85 d2                	test   %edx,%edx
+    1bd2:	75 06                	jne    1bda <concreate+0x2c3>
+    1bd4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1bd8:	74 28                	je     1c02 <concreate+0x2eb>
+       ((i % 3) == 1 && pid != 0)){
+    1bda:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    1bdd:	ba 56 55 55 55       	mov    $0x55555556,%edx
+    1be2:	89 c8                	mov    %ecx,%eax
+    1be4:	f7 ea                	imul   %edx
+    1be6:	89 c8                	mov    %ecx,%eax
+    1be8:	c1 f8 1f             	sar    $0x1f,%eax
+    1beb:	29 c2                	sub    %eax,%edx
+    1bed:	89 d0                	mov    %edx,%eax
+    1bef:	01 c0                	add    %eax,%eax
+    1bf1:	01 d0                	add    %edx,%eax
+    1bf3:	89 ca                	mov    %ecx,%edx
+    1bf5:	29 c2                	sub    %eax,%edx
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit();
+    }
+    if(((i % 3) == 0 && pid == 0) ||
+    1bf7:	83 fa 01             	cmp    $0x1,%edx
+    1bfa:	75 74                	jne    1c70 <concreate+0x359>
+       ((i % 3) == 1 && pid != 0)){
+    1bfc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1c00:	74 6e                	je     1c70 <concreate+0x359>
+      close(open(file, 0));
+    1c02:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1c09:	00 
+    1c0a:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c0d:	89 04 24             	mov    %eax,(%esp)
+    1c10:	e8 07 23 00 00       	call   3f1c <open>
+    1c15:	89 04 24             	mov    %eax,(%esp)
+    1c18:	e8 e7 22 00 00       	call   3f04 <close>
+      close(open(file, 0));
+    1c1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1c24:	00 
+    1c25:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c28:	89 04 24             	mov    %eax,(%esp)
+    1c2b:	e8 ec 22 00 00       	call   3f1c <open>
+    1c30:	89 04 24             	mov    %eax,(%esp)
+    1c33:	e8 cc 22 00 00       	call   3f04 <close>
+      close(open(file, 0));
+    1c38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1c3f:	00 
+    1c40:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c43:	89 04 24             	mov    %eax,(%esp)
+    1c46:	e8 d1 22 00 00       	call   3f1c <open>
+    1c4b:	89 04 24             	mov    %eax,(%esp)
+    1c4e:	e8 b1 22 00 00       	call   3f04 <close>
+      close(open(file, 0));
+    1c53:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1c5a:	00 
+    1c5b:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c5e:	89 04 24             	mov    %eax,(%esp)
+    1c61:	e8 b6 22 00 00       	call   3f1c <open>
+    1c66:	89 04 24             	mov    %eax,(%esp)
+    1c69:	e8 96 22 00 00       	call   3f04 <close>
+    1c6e:	eb 2c                	jmp    1c9c <concreate+0x385>
+    } else {
+      unlink(file);
+    1c70:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c73:	89 04 24             	mov    %eax,(%esp)
+    1c76:	e8 b1 22 00 00       	call   3f2c <unlink>
+      unlink(file);
+    1c7b:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c7e:	89 04 24             	mov    %eax,(%esp)
+    1c81:	e8 a6 22 00 00       	call   3f2c <unlink>
+      unlink(file);
+    1c86:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c89:	89 04 24             	mov    %eax,(%esp)
+    1c8c:	e8 9b 22 00 00       	call   3f2c <unlink>
+      unlink(file);
+    1c91:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c94:	89 04 24             	mov    %eax,(%esp)
+    1c97:	e8 90 22 00 00       	call   3f2c <unlink>
+    }
+    if(pid == 0)
+    1c9c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1ca0:	75 05                	jne    1ca7 <concreate+0x390>
+      exit();
+    1ca2:	e8 35 22 00 00       	call   3edc <exit>
+    else
+      wait();
+    1ca7:	e8 38 22 00 00       	call   3ee4 <wait>
+  if(n != 40){
+    printf(1, "concreate not enough files in directory listing\n");
+    exit();
+  }
+
+  for(i = 0; i < 40; i++){
+    1cac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1cb0:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
+    1cb4:	0f 8e c9 fe ff ff    	jle    1b83 <concreate+0x26c>
+      exit();
+    else
+      wait();
+  }
+
+  printf(1, "concreate ok\n");
+    1cba:	c7 44 24 04 a1 4d 00 	movl   $0x4da1,0x4(%esp)
+    1cc1:	00 
+    1cc2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1cc9:	e8 b3 23 00 00       	call   4081 <printf>
+}
+    1cce:	c9                   	leave  
+    1ccf:	c3                   	ret    
+
+00001cd0 <linkunlink>:
+
+// another concurrent link/unlink/create test,
+// to look for deadlocks.
+void
+linkunlink()
+{
+    1cd0:	55                   	push   %ebp
+    1cd1:	89 e5                	mov    %esp,%ebp
+    1cd3:	83 ec 28             	sub    $0x28,%esp
+  int pid, i;
+
+  printf(1, "linkunlink test\n");
+    1cd6:	c7 44 24 04 af 4d 00 	movl   $0x4daf,0x4(%esp)
+    1cdd:	00 
+    1cde:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1ce5:	e8 97 23 00 00       	call   4081 <printf>
+
+  unlink("x");
+    1cea:	c7 04 24 2b 49 00 00 	movl   $0x492b,(%esp)
+    1cf1:	e8 36 22 00 00       	call   3f2c <unlink>
+  pid = fork();
+    1cf6:	e8 d9 21 00 00       	call   3ed4 <fork>
+    1cfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(pid < 0){
+    1cfe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1d02:	79 19                	jns    1d1d <linkunlink+0x4d>
+    printf(1, "fork failed\n");
+    1d04:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+    1d0b:	00 
+    1d0c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1d13:	e8 69 23 00 00       	call   4081 <printf>
+    exit();
+    1d18:	e8 bf 21 00 00       	call   3edc <exit>
+  }
+
+  unsigned int x = (pid ? 1 : 97);
+    1d1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1d21:	74 07                	je     1d2a <linkunlink+0x5a>
+    1d23:	b8 01 00 00 00       	mov    $0x1,%eax
+    1d28:	eb 05                	jmp    1d2f <linkunlink+0x5f>
+    1d2a:	b8 61 00 00 00       	mov    $0x61,%eax
+    1d2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(i = 0; i < 100; i++){
+    1d32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1d39:	e9 8e 00 00 00       	jmp    1dcc <linkunlink+0xfc>
+    x = x * 1103515245 + 12345;
+    1d3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1d41:	69 c0 6d 4e c6 41    	imul   $0x41c64e6d,%eax,%eax
+    1d47:	05 39 30 00 00       	add    $0x3039,%eax
+    1d4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if((x % 3) == 0){
+    1d4f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+    1d52:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
+    1d57:	89 c8                	mov    %ecx,%eax
+    1d59:	f7 e2                	mul    %edx
+    1d5b:	d1 ea                	shr    %edx
+    1d5d:	89 d0                	mov    %edx,%eax
+    1d5f:	01 c0                	add    %eax,%eax
+    1d61:	01 d0                	add    %edx,%eax
+    1d63:	89 ca                	mov    %ecx,%edx
+    1d65:	29 c2                	sub    %eax,%edx
+    1d67:	85 d2                	test   %edx,%edx
+    1d69:	75 1e                	jne    1d89 <linkunlink+0xb9>
+      close(open("x", O_RDWR | O_CREATE));
+    1d6b:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    1d72:	00 
+    1d73:	c7 04 24 2b 49 00 00 	movl   $0x492b,(%esp)
+    1d7a:	e8 9d 21 00 00       	call   3f1c <open>
+    1d7f:	89 04 24             	mov    %eax,(%esp)
+    1d82:	e8 7d 21 00 00       	call   3f04 <close>
+    1d87:	eb 3f                	jmp    1dc8 <linkunlink+0xf8>
+    } else if((x % 3) == 1){
+    1d89:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+    1d8c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
+    1d91:	89 c8                	mov    %ecx,%eax
+    1d93:	f7 e2                	mul    %edx
+    1d95:	d1 ea                	shr    %edx
+    1d97:	89 d0                	mov    %edx,%eax
+    1d99:	01 c0                	add    %eax,%eax
+    1d9b:	01 d0                	add    %edx,%eax
+    1d9d:	89 ca                	mov    %ecx,%edx
+    1d9f:	29 c2                	sub    %eax,%edx
+    1da1:	83 fa 01             	cmp    $0x1,%edx
+    1da4:	75 16                	jne    1dbc <linkunlink+0xec>
+      link("cat", "x");
+    1da6:	c7 44 24 04 2b 49 00 	movl   $0x492b,0x4(%esp)
+    1dad:	00 
+    1dae:	c7 04 24 c0 4d 00 00 	movl   $0x4dc0,(%esp)
+    1db5:	e8 82 21 00 00       	call   3f3c <link>
+    1dba:	eb 0c                	jmp    1dc8 <linkunlink+0xf8>
+    } else {
+      unlink("x");
+    1dbc:	c7 04 24 2b 49 00 00 	movl   $0x492b,(%esp)
+    1dc3:	e8 64 21 00 00       	call   3f2c <unlink>
+    printf(1, "fork failed\n");
+    exit();
+  }
+
+  unsigned int x = (pid ? 1 : 97);
+  for(i = 0; i < 100; i++){
+    1dc8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1dcc:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+    1dd0:	0f 8e 68 ff ff ff    	jle    1d3e <linkunlink+0x6e>
+    } else {
+      unlink("x");
+    }
+  }
+
+  if(pid)
+    1dd6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1dda:	74 1b                	je     1df7 <linkunlink+0x127>
+    wait();
+    1ddc:	e8 03 21 00 00       	call   3ee4 <wait>
+  else 
+    exit();
+
+  printf(1, "linkunlink ok\n");
+    1de1:	c7 44 24 04 c4 4d 00 	movl   $0x4dc4,0x4(%esp)
+    1de8:	00 
+    1de9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1df0:	e8 8c 22 00 00       	call   4081 <printf>
+    1df5:	eb 05                	jmp    1dfc <linkunlink+0x12c>
+  }
+
+  if(pid)
+    wait();
+  else 
+    exit();
+    1df7:	e8 e0 20 00 00       	call   3edc <exit>
+
+  printf(1, "linkunlink ok\n");
+}
+    1dfc:	c9                   	leave  
+    1dfd:	c3                   	ret    
+
+00001dfe <bigdir>:
+
+// directory that uses indirect blocks
+void
+bigdir(void)
+{
+    1dfe:	55                   	push   %ebp
+    1dff:	89 e5                	mov    %esp,%ebp
+    1e01:	83 ec 38             	sub    $0x38,%esp
+  int i, fd;
+  char name[10];
+
+  printf(1, "bigdir test\n");
+    1e04:	c7 44 24 04 d3 4d 00 	movl   $0x4dd3,0x4(%esp)
+    1e0b:	00 
+    1e0c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1e13:	e8 69 22 00 00       	call   4081 <printf>
+  unlink("bd");
+    1e18:	c7 04 24 e0 4d 00 00 	movl   $0x4de0,(%esp)
+    1e1f:	e8 08 21 00 00       	call   3f2c <unlink>
+
+  fd = open("bd", O_CREATE);
+    1e24:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    1e2b:	00 
+    1e2c:	c7 04 24 e0 4d 00 00 	movl   $0x4de0,(%esp)
+    1e33:	e8 e4 20 00 00       	call   3f1c <open>
+    1e38:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(fd < 0){
+    1e3b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    1e3f:	79 19                	jns    1e5a <bigdir+0x5c>
+    printf(1, "bigdir create failed\n");
+    1e41:	c7 44 24 04 e3 4d 00 	movl   $0x4de3,0x4(%esp)
+    1e48:	00 
+    1e49:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1e50:	e8 2c 22 00 00       	call   4081 <printf>
+    exit();
+    1e55:	e8 82 20 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    1e5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1e5d:	89 04 24             	mov    %eax,(%esp)
+    1e60:	e8 9f 20 00 00       	call   3f04 <close>
+
+  for(i = 0; i < 500; i++){
+    1e65:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1e6c:	eb 6a                	jmp    1ed8 <bigdir+0xda>
+    name[0] = 'x';
+    1e6e:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
+    name[1] = '0' + (i / 64);
+    1e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1e75:	89 c2                	mov    %eax,%edx
+    1e77:	c1 fa 1f             	sar    $0x1f,%edx
+    1e7a:	c1 ea 1a             	shr    $0x1a,%edx
+    1e7d:	01 d0                	add    %edx,%eax
+    1e7f:	c1 f8 06             	sar    $0x6,%eax
+    1e82:	83 c0 30             	add    $0x30,%eax
+    1e85:	88 45 e7             	mov    %al,-0x19(%ebp)
+    name[2] = '0' + (i % 64);
+    1e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1e8b:	89 c2                	mov    %eax,%edx
+    1e8d:	c1 fa 1f             	sar    $0x1f,%edx
+    1e90:	c1 ea 1a             	shr    $0x1a,%edx
+    1e93:	01 d0                	add    %edx,%eax
+    1e95:	83 e0 3f             	and    $0x3f,%eax
+    1e98:	29 d0                	sub    %edx,%eax
+    1e9a:	83 c0 30             	add    $0x30,%eax
+    1e9d:	88 45 e8             	mov    %al,-0x18(%ebp)
+    name[3] = '\0';
+    1ea0:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+    if(link("bd", name) != 0){
+    1ea4:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    1ea7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1eab:	c7 04 24 e0 4d 00 00 	movl   $0x4de0,(%esp)
+    1eb2:	e8 85 20 00 00       	call   3f3c <link>
+    1eb7:	85 c0                	test   %eax,%eax
+    1eb9:	74 19                	je     1ed4 <bigdir+0xd6>
+      printf(1, "bigdir link failed\n");
+    1ebb:	c7 44 24 04 f9 4d 00 	movl   $0x4df9,0x4(%esp)
+    1ec2:	00 
+    1ec3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1eca:	e8 b2 21 00 00       	call   4081 <printf>
+      exit();
+    1ecf:	e8 08 20 00 00       	call   3edc <exit>
+    printf(1, "bigdir create failed\n");
+    exit();
+  }
+  close(fd);
+
+  for(i = 0; i < 500; i++){
+    1ed4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1ed8:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
+    1edf:	7e 8d                	jle    1e6e <bigdir+0x70>
+      printf(1, "bigdir link failed\n");
+      exit();
+    }
+  }
+
+  unlink("bd");
+    1ee1:	c7 04 24 e0 4d 00 00 	movl   $0x4de0,(%esp)
+    1ee8:	e8 3f 20 00 00       	call   3f2c <unlink>
+  for(i = 0; i < 500; i++){
+    1eed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1ef4:	eb 62                	jmp    1f58 <bigdir+0x15a>
+    name[0] = 'x';
+    1ef6:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
+    name[1] = '0' + (i / 64);
+    1efa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1efd:	89 c2                	mov    %eax,%edx
+    1eff:	c1 fa 1f             	sar    $0x1f,%edx
+    1f02:	c1 ea 1a             	shr    $0x1a,%edx
+    1f05:	01 d0                	add    %edx,%eax
+    1f07:	c1 f8 06             	sar    $0x6,%eax
+    1f0a:	83 c0 30             	add    $0x30,%eax
+    1f0d:	88 45 e7             	mov    %al,-0x19(%ebp)
+    name[2] = '0' + (i % 64);
+    1f10:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1f13:	89 c2                	mov    %eax,%edx
+    1f15:	c1 fa 1f             	sar    $0x1f,%edx
+    1f18:	c1 ea 1a             	shr    $0x1a,%edx
+    1f1b:	01 d0                	add    %edx,%eax
+    1f1d:	83 e0 3f             	and    $0x3f,%eax
+    1f20:	29 d0                	sub    %edx,%eax
+    1f22:	83 c0 30             	add    $0x30,%eax
+    1f25:	88 45 e8             	mov    %al,-0x18(%ebp)
+    name[3] = '\0';
+    1f28:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+    if(unlink(name) != 0){
+    1f2c:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    1f2f:	89 04 24             	mov    %eax,(%esp)
+    1f32:	e8 f5 1f 00 00       	call   3f2c <unlink>
+    1f37:	85 c0                	test   %eax,%eax
+    1f39:	74 19                	je     1f54 <bigdir+0x156>
+      printf(1, "bigdir unlink failed");
+    1f3b:	c7 44 24 04 0d 4e 00 	movl   $0x4e0d,0x4(%esp)
+    1f42:	00 
+    1f43:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1f4a:	e8 32 21 00 00       	call   4081 <printf>
+      exit();
+    1f4f:	e8 88 1f 00 00       	call   3edc <exit>
+      exit();
+    }
+  }
+
+  unlink("bd");
+  for(i = 0; i < 500; i++){
+    1f54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1f58:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
+    1f5f:	7e 95                	jle    1ef6 <bigdir+0xf8>
+      printf(1, "bigdir unlink failed");
+      exit();
+    }
+  }
+
+  printf(1, "bigdir ok\n");
+    1f61:	c7 44 24 04 22 4e 00 	movl   $0x4e22,0x4(%esp)
+    1f68:	00 
+    1f69:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1f70:	e8 0c 21 00 00       	call   4081 <printf>
+}
+    1f75:	c9                   	leave  
+    1f76:	c3                   	ret    
+
+00001f77 <subdir>:
+
+void
+subdir(void)
+{
+    1f77:	55                   	push   %ebp
+    1f78:	89 e5                	mov    %esp,%ebp
+    1f7a:	83 ec 28             	sub    $0x28,%esp
+  int fd, cc;
+
+  printf(1, "subdir test\n");
+    1f7d:	c7 44 24 04 2d 4e 00 	movl   $0x4e2d,0x4(%esp)
+    1f84:	00 
+    1f85:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1f8c:	e8 f0 20 00 00       	call   4081 <printf>
+
+  unlink("ff");
+    1f91:	c7 04 24 3a 4e 00 00 	movl   $0x4e3a,(%esp)
+    1f98:	e8 8f 1f 00 00       	call   3f2c <unlink>
+  if(mkdir("dd") != 0){
+    1f9d:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    1fa4:	e8 9b 1f 00 00       	call   3f44 <mkdir>
+    1fa9:	85 c0                	test   %eax,%eax
+    1fab:	74 19                	je     1fc6 <subdir+0x4f>
+    printf(1, "subdir mkdir dd failed\n");
+    1fad:	c7 44 24 04 40 4e 00 	movl   $0x4e40,0x4(%esp)
+    1fb4:	00 
+    1fb5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1fbc:	e8 c0 20 00 00       	call   4081 <printf>
+    exit();
+    1fc1:	e8 16 1f 00 00       	call   3edc <exit>
+  }
+
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    1fc6:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    1fcd:	00 
+    1fce:	c7 04 24 58 4e 00 00 	movl   $0x4e58,(%esp)
+    1fd5:	e8 42 1f 00 00       	call   3f1c <open>
+    1fda:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    1fdd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1fe1:	79 19                	jns    1ffc <subdir+0x85>
+    printf(1, "create dd/ff failed\n");
+    1fe3:	c7 44 24 04 5e 4e 00 	movl   $0x4e5e,0x4(%esp)
+    1fea:	00 
+    1feb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1ff2:	e8 8a 20 00 00       	call   4081 <printf>
+    exit();
+    1ff7:	e8 e0 1e 00 00       	call   3edc <exit>
+  }
+  write(fd, "ff", 2);
+    1ffc:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
+    2003:	00 
+    2004:	c7 44 24 04 3a 4e 00 	movl   $0x4e3a,0x4(%esp)
+    200b:	00 
+    200c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    200f:	89 04 24             	mov    %eax,(%esp)
+    2012:	e8 e5 1e 00 00       	call   3efc <write>
+  close(fd);
+    2017:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    201a:	89 04 24             	mov    %eax,(%esp)
+    201d:	e8 e2 1e 00 00       	call   3f04 <close>
+  
+  if(unlink("dd") >= 0){
+    2022:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    2029:	e8 fe 1e 00 00       	call   3f2c <unlink>
+    202e:	85 c0                	test   %eax,%eax
+    2030:	78 19                	js     204b <subdir+0xd4>
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    2032:	c7 44 24 04 74 4e 00 	movl   $0x4e74,0x4(%esp)
+    2039:	00 
+    203a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2041:	e8 3b 20 00 00       	call   4081 <printf>
+    exit();
+    2046:	e8 91 1e 00 00       	call   3edc <exit>
+  }
+
+  if(mkdir("/dd/dd") != 0){
+    204b:	c7 04 24 9a 4e 00 00 	movl   $0x4e9a,(%esp)
+    2052:	e8 ed 1e 00 00       	call   3f44 <mkdir>
+    2057:	85 c0                	test   %eax,%eax
+    2059:	74 19                	je     2074 <subdir+0xfd>
+    printf(1, "subdir mkdir dd/dd failed\n");
+    205b:	c7 44 24 04 a1 4e 00 	movl   $0x4ea1,0x4(%esp)
+    2062:	00 
+    2063:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    206a:	e8 12 20 00 00       	call   4081 <printf>
+    exit();
+    206f:	e8 68 1e 00 00       	call   3edc <exit>
+  }
+
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    2074:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    207b:	00 
+    207c:	c7 04 24 bc 4e 00 00 	movl   $0x4ebc,(%esp)
+    2083:	e8 94 1e 00 00       	call   3f1c <open>
+    2088:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    208b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    208f:	79 19                	jns    20aa <subdir+0x133>
+    printf(1, "create dd/dd/ff failed\n");
+    2091:	c7 44 24 04 c5 4e 00 	movl   $0x4ec5,0x4(%esp)
+    2098:	00 
+    2099:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    20a0:	e8 dc 1f 00 00       	call   4081 <printf>
+    exit();
+    20a5:	e8 32 1e 00 00       	call   3edc <exit>
+  }
+  write(fd, "FF", 2);
+    20aa:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
+    20b1:	00 
+    20b2:	c7 44 24 04 dd 4e 00 	movl   $0x4edd,0x4(%esp)
+    20b9:	00 
+    20ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    20bd:	89 04 24             	mov    %eax,(%esp)
+    20c0:	e8 37 1e 00 00       	call   3efc <write>
+  close(fd);
+    20c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    20c8:	89 04 24             	mov    %eax,(%esp)
+    20cb:	e8 34 1e 00 00       	call   3f04 <close>
+
+  fd = open("dd/dd/../ff", 0);
+    20d0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    20d7:	00 
+    20d8:	c7 04 24 e0 4e 00 00 	movl   $0x4ee0,(%esp)
+    20df:	e8 38 1e 00 00       	call   3f1c <open>
+    20e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    20e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    20eb:	79 19                	jns    2106 <subdir+0x18f>
+    printf(1, "open dd/dd/../ff failed\n");
+    20ed:	c7 44 24 04 ec 4e 00 	movl   $0x4eec,0x4(%esp)
+    20f4:	00 
+    20f5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    20fc:	e8 80 1f 00 00       	call   4081 <printf>
+    exit();
+    2101:	e8 d6 1d 00 00       	call   3edc <exit>
+  }
+  cc = read(fd, buf, sizeof(buf));
+    2106:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    210d:	00 
+    210e:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    2115:	00 
+    2116:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2119:	89 04 24             	mov    %eax,(%esp)
+    211c:	e8 d3 1d 00 00       	call   3ef4 <read>
+    2121:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(cc != 2 || buf[0] != 'f'){
+    2124:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+    2128:	75 0b                	jne    2135 <subdir+0x1be>
+    212a:	0f b6 05 00 8b 00 00 	movzbl 0x8b00,%eax
+    2131:	3c 66                	cmp    $0x66,%al
+    2133:	74 19                	je     214e <subdir+0x1d7>
+    printf(1, "dd/dd/../ff wrong content\n");
+    2135:	c7 44 24 04 05 4f 00 	movl   $0x4f05,0x4(%esp)
+    213c:	00 
+    213d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2144:	e8 38 1f 00 00       	call   4081 <printf>
+    exit();
+    2149:	e8 8e 1d 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    214e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2151:	89 04 24             	mov    %eax,(%esp)
+    2154:	e8 ab 1d 00 00       	call   3f04 <close>
+
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    2159:	c7 44 24 04 20 4f 00 	movl   $0x4f20,0x4(%esp)
+    2160:	00 
+    2161:	c7 04 24 bc 4e 00 00 	movl   $0x4ebc,(%esp)
+    2168:	e8 cf 1d 00 00       	call   3f3c <link>
+    216d:	85 c0                	test   %eax,%eax
+    216f:	74 19                	je     218a <subdir+0x213>
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    2171:	c7 44 24 04 2c 4f 00 	movl   $0x4f2c,0x4(%esp)
+    2178:	00 
+    2179:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2180:	e8 fc 1e 00 00       	call   4081 <printf>
+    exit();
+    2185:	e8 52 1d 00 00       	call   3edc <exit>
+  }
+
+  if(unlink("dd/dd/ff") != 0){
+    218a:	c7 04 24 bc 4e 00 00 	movl   $0x4ebc,(%esp)
+    2191:	e8 96 1d 00 00       	call   3f2c <unlink>
+    2196:	85 c0                	test   %eax,%eax
+    2198:	74 19                	je     21b3 <subdir+0x23c>
+    printf(1, "unlink dd/dd/ff failed\n");
+    219a:	c7 44 24 04 4d 4f 00 	movl   $0x4f4d,0x4(%esp)
+    21a1:	00 
+    21a2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    21a9:	e8 d3 1e 00 00       	call   4081 <printf>
+    exit();
+    21ae:	e8 29 1d 00 00       	call   3edc <exit>
+  }
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    21b3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    21ba:	00 
+    21bb:	c7 04 24 bc 4e 00 00 	movl   $0x4ebc,(%esp)
+    21c2:	e8 55 1d 00 00       	call   3f1c <open>
+    21c7:	85 c0                	test   %eax,%eax
+    21c9:	78 19                	js     21e4 <subdir+0x26d>
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    21cb:	c7 44 24 04 68 4f 00 	movl   $0x4f68,0x4(%esp)
+    21d2:	00 
+    21d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    21da:	e8 a2 1e 00 00       	call   4081 <printf>
+    exit();
+    21df:	e8 f8 1c 00 00       	call   3edc <exit>
+  }
+
+  if(chdir("dd") != 0){
+    21e4:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    21eb:	e8 5c 1d 00 00       	call   3f4c <chdir>
+    21f0:	85 c0                	test   %eax,%eax
+    21f2:	74 19                	je     220d <subdir+0x296>
+    printf(1, "chdir dd failed\n");
+    21f4:	c7 44 24 04 8c 4f 00 	movl   $0x4f8c,0x4(%esp)
+    21fb:	00 
+    21fc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2203:	e8 79 1e 00 00       	call   4081 <printf>
+    exit();
+    2208:	e8 cf 1c 00 00       	call   3edc <exit>
+  }
+  if(chdir("dd/../../dd") != 0){
+    220d:	c7 04 24 9d 4f 00 00 	movl   $0x4f9d,(%esp)
+    2214:	e8 33 1d 00 00       	call   3f4c <chdir>
+    2219:	85 c0                	test   %eax,%eax
+    221b:	74 19                	je     2236 <subdir+0x2bf>
+    printf(1, "chdir dd/../../dd failed\n");
+    221d:	c7 44 24 04 a9 4f 00 	movl   $0x4fa9,0x4(%esp)
+    2224:	00 
+    2225:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    222c:	e8 50 1e 00 00       	call   4081 <printf>
+    exit();
+    2231:	e8 a6 1c 00 00       	call   3edc <exit>
+  }
+  if(chdir("dd/../../../dd") != 0){
+    2236:	c7 04 24 c3 4f 00 00 	movl   $0x4fc3,(%esp)
+    223d:	e8 0a 1d 00 00       	call   3f4c <chdir>
+    2242:	85 c0                	test   %eax,%eax
+    2244:	74 19                	je     225f <subdir+0x2e8>
+    printf(1, "chdir dd/../../dd failed\n");
+    2246:	c7 44 24 04 a9 4f 00 	movl   $0x4fa9,0x4(%esp)
+    224d:	00 
+    224e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2255:	e8 27 1e 00 00       	call   4081 <printf>
+    exit();
+    225a:	e8 7d 1c 00 00       	call   3edc <exit>
+  }
+  if(chdir("./..") != 0){
+    225f:	c7 04 24 d2 4f 00 00 	movl   $0x4fd2,(%esp)
+    2266:	e8 e1 1c 00 00       	call   3f4c <chdir>
+    226b:	85 c0                	test   %eax,%eax
+    226d:	74 19                	je     2288 <subdir+0x311>
+    printf(1, "chdir ./.. failed\n");
+    226f:	c7 44 24 04 d7 4f 00 	movl   $0x4fd7,0x4(%esp)
+    2276:	00 
+    2277:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    227e:	e8 fe 1d 00 00       	call   4081 <printf>
+    exit();
+    2283:	e8 54 1c 00 00       	call   3edc <exit>
+  }
+
+  fd = open("dd/dd/ffff", 0);
+    2288:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    228f:	00 
+    2290:	c7 04 24 20 4f 00 00 	movl   $0x4f20,(%esp)
+    2297:	e8 80 1c 00 00       	call   3f1c <open>
+    229c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    22a3:	79 19                	jns    22be <subdir+0x347>
+    printf(1, "open dd/dd/ffff failed\n");
+    22a5:	c7 44 24 04 ea 4f 00 	movl   $0x4fea,0x4(%esp)
+    22ac:	00 
+    22ad:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    22b4:	e8 c8 1d 00 00       	call   4081 <printf>
+    exit();
+    22b9:	e8 1e 1c 00 00       	call   3edc <exit>
+  }
+  if(read(fd, buf, sizeof(buf)) != 2){
+    22be:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    22c5:	00 
+    22c6:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    22cd:	00 
+    22ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    22d1:	89 04 24             	mov    %eax,(%esp)
+    22d4:	e8 1b 1c 00 00       	call   3ef4 <read>
+    22d9:	83 f8 02             	cmp    $0x2,%eax
+    22dc:	74 19                	je     22f7 <subdir+0x380>
+    printf(1, "read dd/dd/ffff wrong len\n");
+    22de:	c7 44 24 04 02 50 00 	movl   $0x5002,0x4(%esp)
+    22e5:	00 
+    22e6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    22ed:	e8 8f 1d 00 00       	call   4081 <printf>
+    exit();
+    22f2:	e8 e5 1b 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    22f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    22fa:	89 04 24             	mov    %eax,(%esp)
+    22fd:	e8 02 1c 00 00       	call   3f04 <close>
+
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    2302:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2309:	00 
+    230a:	c7 04 24 bc 4e 00 00 	movl   $0x4ebc,(%esp)
+    2311:	e8 06 1c 00 00       	call   3f1c <open>
+    2316:	85 c0                	test   %eax,%eax
+    2318:	78 19                	js     2333 <subdir+0x3bc>
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    231a:	c7 44 24 04 20 50 00 	movl   $0x5020,0x4(%esp)
+    2321:	00 
+    2322:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2329:	e8 53 1d 00 00       	call   4081 <printf>
+    exit();
+    232e:	e8 a9 1b 00 00       	call   3edc <exit>
+  }
+
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    2333:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    233a:	00 
+    233b:	c7 04 24 45 50 00 00 	movl   $0x5045,(%esp)
+    2342:	e8 d5 1b 00 00       	call   3f1c <open>
+    2347:	85 c0                	test   %eax,%eax
+    2349:	78 19                	js     2364 <subdir+0x3ed>
+    printf(1, "create dd/ff/ff succeeded!\n");
+    234b:	c7 44 24 04 4e 50 00 	movl   $0x504e,0x4(%esp)
+    2352:	00 
+    2353:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    235a:	e8 22 1d 00 00       	call   4081 <printf>
+    exit();
+    235f:	e8 78 1b 00 00       	call   3edc <exit>
+  }
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    2364:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    236b:	00 
+    236c:	c7 04 24 6a 50 00 00 	movl   $0x506a,(%esp)
+    2373:	e8 a4 1b 00 00       	call   3f1c <open>
+    2378:	85 c0                	test   %eax,%eax
+    237a:	78 19                	js     2395 <subdir+0x41e>
+    printf(1, "create dd/xx/ff succeeded!\n");
+    237c:	c7 44 24 04 73 50 00 	movl   $0x5073,0x4(%esp)
+    2383:	00 
+    2384:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    238b:	e8 f1 1c 00 00       	call   4081 <printf>
+    exit();
+    2390:	e8 47 1b 00 00       	call   3edc <exit>
+  }
+  if(open("dd", O_CREATE) >= 0){
+    2395:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    239c:	00 
+    239d:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    23a4:	e8 73 1b 00 00       	call   3f1c <open>
+    23a9:	85 c0                	test   %eax,%eax
+    23ab:	78 19                	js     23c6 <subdir+0x44f>
+    printf(1, "create dd succeeded!\n");
+    23ad:	c7 44 24 04 8f 50 00 	movl   $0x508f,0x4(%esp)
+    23b4:	00 
+    23b5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    23bc:	e8 c0 1c 00 00       	call   4081 <printf>
+    exit();
+    23c1:	e8 16 1b 00 00       	call   3edc <exit>
+  }
+  if(open("dd", O_RDWR) >= 0){
+    23c6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    23cd:	00 
+    23ce:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    23d5:	e8 42 1b 00 00       	call   3f1c <open>
+    23da:	85 c0                	test   %eax,%eax
+    23dc:	78 19                	js     23f7 <subdir+0x480>
+    printf(1, "open dd rdwr succeeded!\n");
+    23de:	c7 44 24 04 a5 50 00 	movl   $0x50a5,0x4(%esp)
+    23e5:	00 
+    23e6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    23ed:	e8 8f 1c 00 00       	call   4081 <printf>
+    exit();
+    23f2:	e8 e5 1a 00 00       	call   3edc <exit>
+  }
+  if(open("dd", O_WRONLY) >= 0){
+    23f7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+    23fe:	00 
+    23ff:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    2406:	e8 11 1b 00 00       	call   3f1c <open>
+    240b:	85 c0                	test   %eax,%eax
+    240d:	78 19                	js     2428 <subdir+0x4b1>
+    printf(1, "open dd wronly succeeded!\n");
+    240f:	c7 44 24 04 be 50 00 	movl   $0x50be,0x4(%esp)
+    2416:	00 
+    2417:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    241e:	e8 5e 1c 00 00       	call   4081 <printf>
+    exit();
+    2423:	e8 b4 1a 00 00       	call   3edc <exit>
+  }
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    2428:	c7 44 24 04 d9 50 00 	movl   $0x50d9,0x4(%esp)
+    242f:	00 
+    2430:	c7 04 24 45 50 00 00 	movl   $0x5045,(%esp)
+    2437:	e8 00 1b 00 00       	call   3f3c <link>
+    243c:	85 c0                	test   %eax,%eax
+    243e:	75 19                	jne    2459 <subdir+0x4e2>
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    2440:	c7 44 24 04 e4 50 00 	movl   $0x50e4,0x4(%esp)
+    2447:	00 
+    2448:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    244f:	e8 2d 1c 00 00       	call   4081 <printf>
+    exit();
+    2454:	e8 83 1a 00 00       	call   3edc <exit>
+  }
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    2459:	c7 44 24 04 d9 50 00 	movl   $0x50d9,0x4(%esp)
+    2460:	00 
+    2461:	c7 04 24 6a 50 00 00 	movl   $0x506a,(%esp)
+    2468:	e8 cf 1a 00 00       	call   3f3c <link>
+    246d:	85 c0                	test   %eax,%eax
+    246f:	75 19                	jne    248a <subdir+0x513>
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    2471:	c7 44 24 04 08 51 00 	movl   $0x5108,0x4(%esp)
+    2478:	00 
+    2479:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2480:	e8 fc 1b 00 00       	call   4081 <printf>
+    exit();
+    2485:	e8 52 1a 00 00       	call   3edc <exit>
+  }
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    248a:	c7 44 24 04 20 4f 00 	movl   $0x4f20,0x4(%esp)
+    2491:	00 
+    2492:	c7 04 24 58 4e 00 00 	movl   $0x4e58,(%esp)
+    2499:	e8 9e 1a 00 00       	call   3f3c <link>
+    249e:	85 c0                	test   %eax,%eax
+    24a0:	75 19                	jne    24bb <subdir+0x544>
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    24a2:	c7 44 24 04 2c 51 00 	movl   $0x512c,0x4(%esp)
+    24a9:	00 
+    24aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    24b1:	e8 cb 1b 00 00       	call   4081 <printf>
+    exit();
+    24b6:	e8 21 1a 00 00       	call   3edc <exit>
+  }
+  if(mkdir("dd/ff/ff") == 0){
+    24bb:	c7 04 24 45 50 00 00 	movl   $0x5045,(%esp)
+    24c2:	e8 7d 1a 00 00       	call   3f44 <mkdir>
+    24c7:	85 c0                	test   %eax,%eax
+    24c9:	75 19                	jne    24e4 <subdir+0x56d>
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    24cb:	c7 44 24 04 4e 51 00 	movl   $0x514e,0x4(%esp)
+    24d2:	00 
+    24d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    24da:	e8 a2 1b 00 00       	call   4081 <printf>
+    exit();
+    24df:	e8 f8 19 00 00       	call   3edc <exit>
+  }
+  if(mkdir("dd/xx/ff") == 0){
+    24e4:	c7 04 24 6a 50 00 00 	movl   $0x506a,(%esp)
+    24eb:	e8 54 1a 00 00       	call   3f44 <mkdir>
+    24f0:	85 c0                	test   %eax,%eax
+    24f2:	75 19                	jne    250d <subdir+0x596>
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    24f4:	c7 44 24 04 69 51 00 	movl   $0x5169,0x4(%esp)
+    24fb:	00 
+    24fc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2503:	e8 79 1b 00 00       	call   4081 <printf>
+    exit();
+    2508:	e8 cf 19 00 00       	call   3edc <exit>
+  }
+  if(mkdir("dd/dd/ffff") == 0){
+    250d:	c7 04 24 20 4f 00 00 	movl   $0x4f20,(%esp)
+    2514:	e8 2b 1a 00 00       	call   3f44 <mkdir>
+    2519:	85 c0                	test   %eax,%eax
+    251b:	75 19                	jne    2536 <subdir+0x5bf>
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    251d:	c7 44 24 04 84 51 00 	movl   $0x5184,0x4(%esp)
+    2524:	00 
+    2525:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    252c:	e8 50 1b 00 00       	call   4081 <printf>
+    exit();
+    2531:	e8 a6 19 00 00       	call   3edc <exit>
+  }
+  if(unlink("dd/xx/ff") == 0){
+    2536:	c7 04 24 6a 50 00 00 	movl   $0x506a,(%esp)
+    253d:	e8 ea 19 00 00       	call   3f2c <unlink>
+    2542:	85 c0                	test   %eax,%eax
+    2544:	75 19                	jne    255f <subdir+0x5e8>
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    2546:	c7 44 24 04 a1 51 00 	movl   $0x51a1,0x4(%esp)
+    254d:	00 
+    254e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2555:	e8 27 1b 00 00       	call   4081 <printf>
+    exit();
+    255a:	e8 7d 19 00 00       	call   3edc <exit>
+  }
+  if(unlink("dd/ff/ff") == 0){
+    255f:	c7 04 24 45 50 00 00 	movl   $0x5045,(%esp)
+    2566:	e8 c1 19 00 00       	call   3f2c <unlink>
+    256b:	85 c0                	test   %eax,%eax
+    256d:	75 19                	jne    2588 <subdir+0x611>
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    256f:	c7 44 24 04 bd 51 00 	movl   $0x51bd,0x4(%esp)
+    2576:	00 
+    2577:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    257e:	e8 fe 1a 00 00       	call   4081 <printf>
+    exit();
+    2583:	e8 54 19 00 00       	call   3edc <exit>
+  }
+  if(chdir("dd/ff") == 0){
+    2588:	c7 04 24 58 4e 00 00 	movl   $0x4e58,(%esp)
+    258f:	e8 b8 19 00 00       	call   3f4c <chdir>
+    2594:	85 c0                	test   %eax,%eax
+    2596:	75 19                	jne    25b1 <subdir+0x63a>
+    printf(1, "chdir dd/ff succeeded!\n");
+    2598:	c7 44 24 04 d9 51 00 	movl   $0x51d9,0x4(%esp)
+    259f:	00 
+    25a0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    25a7:	e8 d5 1a 00 00       	call   4081 <printf>
+    exit();
+    25ac:	e8 2b 19 00 00       	call   3edc <exit>
+  }
+  if(chdir("dd/xx") == 0){
+    25b1:	c7 04 24 f1 51 00 00 	movl   $0x51f1,(%esp)
+    25b8:	e8 8f 19 00 00       	call   3f4c <chdir>
+    25bd:	85 c0                	test   %eax,%eax
+    25bf:	75 19                	jne    25da <subdir+0x663>
+    printf(1, "chdir dd/xx succeeded!\n");
+    25c1:	c7 44 24 04 f7 51 00 	movl   $0x51f7,0x4(%esp)
+    25c8:	00 
+    25c9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    25d0:	e8 ac 1a 00 00       	call   4081 <printf>
+    exit();
+    25d5:	e8 02 19 00 00       	call   3edc <exit>
+  }
+
+  if(unlink("dd/dd/ffff") != 0){
+    25da:	c7 04 24 20 4f 00 00 	movl   $0x4f20,(%esp)
+    25e1:	e8 46 19 00 00       	call   3f2c <unlink>
+    25e6:	85 c0                	test   %eax,%eax
+    25e8:	74 19                	je     2603 <subdir+0x68c>
+    printf(1, "unlink dd/dd/ff failed\n");
+    25ea:	c7 44 24 04 4d 4f 00 	movl   $0x4f4d,0x4(%esp)
+    25f1:	00 
+    25f2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    25f9:	e8 83 1a 00 00       	call   4081 <printf>
+    exit();
+    25fe:	e8 d9 18 00 00       	call   3edc <exit>
+  }
+  if(unlink("dd/ff") != 0){
+    2603:	c7 04 24 58 4e 00 00 	movl   $0x4e58,(%esp)
+    260a:	e8 1d 19 00 00       	call   3f2c <unlink>
+    260f:	85 c0                	test   %eax,%eax
+    2611:	74 19                	je     262c <subdir+0x6b5>
+    printf(1, "unlink dd/ff failed\n");
+    2613:	c7 44 24 04 0f 52 00 	movl   $0x520f,0x4(%esp)
+    261a:	00 
+    261b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2622:	e8 5a 1a 00 00       	call   4081 <printf>
+    exit();
+    2627:	e8 b0 18 00 00       	call   3edc <exit>
+  }
+  if(unlink("dd") == 0){
+    262c:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    2633:	e8 f4 18 00 00       	call   3f2c <unlink>
+    2638:	85 c0                	test   %eax,%eax
+    263a:	75 19                	jne    2655 <subdir+0x6de>
+    printf(1, "unlink non-empty dd succeeded!\n");
+    263c:	c7 44 24 04 24 52 00 	movl   $0x5224,0x4(%esp)
+    2643:	00 
+    2644:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    264b:	e8 31 1a 00 00       	call   4081 <printf>
+    exit();
+    2650:	e8 87 18 00 00       	call   3edc <exit>
+  }
+  if(unlink("dd/dd") < 0){
+    2655:	c7 04 24 44 52 00 00 	movl   $0x5244,(%esp)
+    265c:	e8 cb 18 00 00       	call   3f2c <unlink>
+    2661:	85 c0                	test   %eax,%eax
+    2663:	79 19                	jns    267e <subdir+0x707>
+    printf(1, "unlink dd/dd failed\n");
+    2665:	c7 44 24 04 4a 52 00 	movl   $0x524a,0x4(%esp)
+    266c:	00 
+    266d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2674:	e8 08 1a 00 00       	call   4081 <printf>
+    exit();
+    2679:	e8 5e 18 00 00       	call   3edc <exit>
+  }
+  if(unlink("dd") < 0){
+    267e:	c7 04 24 3d 4e 00 00 	movl   $0x4e3d,(%esp)
+    2685:	e8 a2 18 00 00       	call   3f2c <unlink>
+    268a:	85 c0                	test   %eax,%eax
+    268c:	79 19                	jns    26a7 <subdir+0x730>
+    printf(1, "unlink dd failed\n");
+    268e:	c7 44 24 04 5f 52 00 	movl   $0x525f,0x4(%esp)
+    2695:	00 
+    2696:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    269d:	e8 df 19 00 00       	call   4081 <printf>
+    exit();
+    26a2:	e8 35 18 00 00       	call   3edc <exit>
+  }
+
+  printf(1, "subdir ok\n");
+    26a7:	c7 44 24 04 71 52 00 	movl   $0x5271,0x4(%esp)
+    26ae:	00 
+    26af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    26b6:	e8 c6 19 00 00       	call   4081 <printf>
+}
+    26bb:	c9                   	leave  
+    26bc:	c3                   	ret    
+
+000026bd <bigwrite>:
+
+// test writes that are larger than the log.
+void
+bigwrite(void)
+{
+    26bd:	55                   	push   %ebp
+    26be:	89 e5                	mov    %esp,%ebp
+    26c0:	83 ec 28             	sub    $0x28,%esp
+  int fd, sz;
+
+  printf(1, "bigwrite test\n");
+    26c3:	c7 44 24 04 7c 52 00 	movl   $0x527c,0x4(%esp)
+    26ca:	00 
+    26cb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    26d2:	e8 aa 19 00 00       	call   4081 <printf>
+
+  unlink("bigwrite");
+    26d7:	c7 04 24 8b 52 00 00 	movl   $0x528b,(%esp)
+    26de:	e8 49 18 00 00       	call   3f2c <unlink>
+  for(sz = 499; sz < 12*512; sz += 471){
+    26e3:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%ebp)
+    26ea:	e9 b3 00 00 00       	jmp    27a2 <bigwrite+0xe5>
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    26ef:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    26f6:	00 
+    26f7:	c7 04 24 8b 52 00 00 	movl   $0x528b,(%esp)
+    26fe:	e8 19 18 00 00       	call   3f1c <open>
+    2703:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(fd < 0){
+    2706:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    270a:	79 19                	jns    2725 <bigwrite+0x68>
+      printf(1, "cannot create bigwrite\n");
+    270c:	c7 44 24 04 94 52 00 	movl   $0x5294,0x4(%esp)
+    2713:	00 
+    2714:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    271b:	e8 61 19 00 00       	call   4081 <printf>
+      exit();
+    2720:	e8 b7 17 00 00       	call   3edc <exit>
+    }
+    int i;
+    for(i = 0; i < 2; i++){
+    2725:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    272c:	eb 50                	jmp    277e <bigwrite+0xc1>
+      int cc = write(fd, buf, sz);
+    272e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2731:	89 44 24 08          	mov    %eax,0x8(%esp)
+    2735:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    273c:	00 
+    273d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    2740:	89 04 24             	mov    %eax,(%esp)
+    2743:	e8 b4 17 00 00       	call   3efc <write>
+    2748:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if(cc != sz){
+    274b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    274e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    2751:	74 27                	je     277a <bigwrite+0xbd>
+        printf(1, "write(%d) ret %d\n", sz, cc);
+    2753:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    2756:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    275a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    275d:	89 44 24 08          	mov    %eax,0x8(%esp)
+    2761:	c7 44 24 04 ac 52 00 	movl   $0x52ac,0x4(%esp)
+    2768:	00 
+    2769:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2770:	e8 0c 19 00 00       	call   4081 <printf>
+        exit();
+    2775:	e8 62 17 00 00       	call   3edc <exit>
+    if(fd < 0){
+      printf(1, "cannot create bigwrite\n");
+      exit();
+    }
+    int i;
+    for(i = 0; i < 2; i++){
+    277a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    277e:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
+    2782:	7e aa                	jle    272e <bigwrite+0x71>
+      if(cc != sz){
+        printf(1, "write(%d) ret %d\n", sz, cc);
+        exit();
+      }
+    }
+    close(fd);
+    2784:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    2787:	89 04 24             	mov    %eax,(%esp)
+    278a:	e8 75 17 00 00       	call   3f04 <close>
+    unlink("bigwrite");
+    278f:	c7 04 24 8b 52 00 00 	movl   $0x528b,(%esp)
+    2796:	e8 91 17 00 00       	call   3f2c <unlink>
+  int fd, sz;
+
+  printf(1, "bigwrite test\n");
+
+  unlink("bigwrite");
+  for(sz = 499; sz < 12*512; sz += 471){
+    279b:	81 45 f4 d7 01 00 00 	addl   $0x1d7,-0xc(%ebp)
+    27a2:	81 7d f4 ff 17 00 00 	cmpl   $0x17ff,-0xc(%ebp)
+    27a9:	0f 8e 40 ff ff ff    	jle    26ef <bigwrite+0x32>
+    }
+    close(fd);
+    unlink("bigwrite");
+  }
+
+  printf(1, "bigwrite ok\n");
+    27af:	c7 44 24 04 be 52 00 	movl   $0x52be,0x4(%esp)
+    27b6:	00 
+    27b7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    27be:	e8 be 18 00 00       	call   4081 <printf>
+}
+    27c3:	c9                   	leave  
+    27c4:	c3                   	ret    
+
+000027c5 <bigfile>:
+
+void
+bigfile(void)
+{
+    27c5:	55                   	push   %ebp
+    27c6:	89 e5                	mov    %esp,%ebp
+    27c8:	83 ec 28             	sub    $0x28,%esp
+  int fd, i, total, cc;
+
+  printf(1, "bigfile test\n");
+    27cb:	c7 44 24 04 cb 52 00 	movl   $0x52cb,0x4(%esp)
+    27d2:	00 
+    27d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    27da:	e8 a2 18 00 00       	call   4081 <printf>
+
+  unlink("bigfile");
+    27df:	c7 04 24 d9 52 00 00 	movl   $0x52d9,(%esp)
+    27e6:	e8 41 17 00 00       	call   3f2c <unlink>
+  fd = open("bigfile", O_CREATE | O_RDWR);
+    27eb:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    27f2:	00 
+    27f3:	c7 04 24 d9 52 00 00 	movl   $0x52d9,(%esp)
+    27fa:	e8 1d 17 00 00       	call   3f1c <open>
+    27ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+    2802:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    2806:	79 19                	jns    2821 <bigfile+0x5c>
+    printf(1, "cannot create bigfile");
+    2808:	c7 44 24 04 e1 52 00 	movl   $0x52e1,0x4(%esp)
+    280f:	00 
+    2810:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2817:	e8 65 18 00 00       	call   4081 <printf>
+    exit();
+    281c:	e8 bb 16 00 00       	call   3edc <exit>
+  }
+  for(i = 0; i < 20; i++){
+    2821:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    2828:	eb 5a                	jmp    2884 <bigfile+0xbf>
+    memset(buf, i, 600);
+    282a:	c7 44 24 08 58 02 00 	movl   $0x258,0x8(%esp)
+    2831:	00 
+    2832:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2835:	89 44 24 04          	mov    %eax,0x4(%esp)
+    2839:	c7 04 24 00 8b 00 00 	movl   $0x8b00,(%esp)
+    2840:	e8 f0 14 00 00       	call   3d35 <memset>
+    if(write(fd, buf, 600) != 600){
+    2845:	c7 44 24 08 58 02 00 	movl   $0x258,0x8(%esp)
+    284c:	00 
+    284d:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    2854:	00 
+    2855:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    2858:	89 04 24             	mov    %eax,(%esp)
+    285b:	e8 9c 16 00 00       	call   3efc <write>
+    2860:	3d 58 02 00 00       	cmp    $0x258,%eax
+    2865:	74 19                	je     2880 <bigfile+0xbb>
+      printf(1, "write bigfile failed\n");
+    2867:	c7 44 24 04 f7 52 00 	movl   $0x52f7,0x4(%esp)
+    286e:	00 
+    286f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2876:	e8 06 18 00 00       	call   4081 <printf>
+      exit();
+    287b:	e8 5c 16 00 00       	call   3edc <exit>
+  fd = open("bigfile", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "cannot create bigfile");
+    exit();
+  }
+  for(i = 0; i < 20; i++){
+    2880:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    2884:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    2888:	7e a0                	jle    282a <bigfile+0x65>
+    if(write(fd, buf, 600) != 600){
+      printf(1, "write bigfile failed\n");
+      exit();
+    }
+  }
+  close(fd);
+    288a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    288d:	89 04 24             	mov    %eax,(%esp)
+    2890:	e8 6f 16 00 00       	call   3f04 <close>
+
+  fd = open("bigfile", 0);
+    2895:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    289c:	00 
+    289d:	c7 04 24 d9 52 00 00 	movl   $0x52d9,(%esp)
+    28a4:	e8 73 16 00 00       	call   3f1c <open>
+    28a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+    28ac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    28b0:	79 19                	jns    28cb <bigfile+0x106>
+    printf(1, "cannot open bigfile\n");
+    28b2:	c7 44 24 04 0d 53 00 	movl   $0x530d,0x4(%esp)
+    28b9:	00 
+    28ba:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    28c1:	e8 bb 17 00 00       	call   4081 <printf>
+    exit();
+    28c6:	e8 11 16 00 00       	call   3edc <exit>
+  }
+  total = 0;
+    28cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  for(i = 0; ; i++){
+    28d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    cc = read(fd, buf, 300);
+    28d9:	c7 44 24 08 2c 01 00 	movl   $0x12c,0x8(%esp)
+    28e0:	00 
+    28e1:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    28e8:	00 
+    28e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    28ec:	89 04 24             	mov    %eax,(%esp)
+    28ef:	e8 00 16 00 00       	call   3ef4 <read>
+    28f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(cc < 0){
+    28f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    28fb:	79 19                	jns    2916 <bigfile+0x151>
+      printf(1, "read bigfile failed\n");
+    28fd:	c7 44 24 04 22 53 00 	movl   $0x5322,0x4(%esp)
+    2904:	00 
+    2905:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    290c:	e8 70 17 00 00       	call   4081 <printf>
+      exit();
+    2911:	e8 c6 15 00 00       	call   3edc <exit>
+    }
+    if(cc == 0)
+    2916:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    291a:	74 7e                	je     299a <bigfile+0x1d5>
+      break;
+    if(cc != 300){
+    291c:	81 7d e8 2c 01 00 00 	cmpl   $0x12c,-0x18(%ebp)
+    2923:	74 19                	je     293e <bigfile+0x179>
+      printf(1, "short read bigfile\n");
+    2925:	c7 44 24 04 37 53 00 	movl   $0x5337,0x4(%esp)
+    292c:	00 
+    292d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2934:	e8 48 17 00 00       	call   4081 <printf>
+      exit();
+    2939:	e8 9e 15 00 00       	call   3edc <exit>
+    }
+    if(buf[0] != i/2 || buf[299] != i/2){
+    293e:	0f b6 05 00 8b 00 00 	movzbl 0x8b00,%eax
+    2945:	0f be d0             	movsbl %al,%edx
+    2948:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    294b:	89 c1                	mov    %eax,%ecx
+    294d:	c1 e9 1f             	shr    $0x1f,%ecx
+    2950:	01 c8                	add    %ecx,%eax
+    2952:	d1 f8                	sar    %eax
+    2954:	39 c2                	cmp    %eax,%edx
+    2956:	75 1a                	jne    2972 <bigfile+0x1ad>
+    2958:	0f b6 05 2b 8c 00 00 	movzbl 0x8c2b,%eax
+    295f:	0f be d0             	movsbl %al,%edx
+    2962:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2965:	89 c1                	mov    %eax,%ecx
+    2967:	c1 e9 1f             	shr    $0x1f,%ecx
+    296a:	01 c8                	add    %ecx,%eax
+    296c:	d1 f8                	sar    %eax
+    296e:	39 c2                	cmp    %eax,%edx
+    2970:	74 19                	je     298b <bigfile+0x1c6>
+      printf(1, "read bigfile wrong data\n");
+    2972:	c7 44 24 04 4b 53 00 	movl   $0x534b,0x4(%esp)
+    2979:	00 
+    297a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2981:	e8 fb 16 00 00       	call   4081 <printf>
+      exit();
+    2986:	e8 51 15 00 00       	call   3edc <exit>
+    }
+    total += cc;
+    298b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    298e:	01 45 f0             	add    %eax,-0x10(%ebp)
+  if(fd < 0){
+    printf(1, "cannot open bigfile\n");
+    exit();
+  }
+  total = 0;
+  for(i = 0; ; i++){
+    2991:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(buf[0] != i/2 || buf[299] != i/2){
+      printf(1, "read bigfile wrong data\n");
+      exit();
+    }
+    total += cc;
+  }
+    2995:	e9 3f ff ff ff       	jmp    28d9 <bigfile+0x114>
+    if(cc < 0){
+      printf(1, "read bigfile failed\n");
+      exit();
+    }
+    if(cc == 0)
+      break;
+    299a:	90                   	nop
+      printf(1, "read bigfile wrong data\n");
+      exit();
+    }
+    total += cc;
+  }
+  close(fd);
+    299b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    299e:	89 04 24             	mov    %eax,(%esp)
+    29a1:	e8 5e 15 00 00       	call   3f04 <close>
+  if(total != 20*600){
+    29a6:	81 7d f0 e0 2e 00 00 	cmpl   $0x2ee0,-0x10(%ebp)
+    29ad:	74 19                	je     29c8 <bigfile+0x203>
+    printf(1, "read bigfile wrong total\n");
+    29af:	c7 44 24 04 64 53 00 	movl   $0x5364,0x4(%esp)
+    29b6:	00 
+    29b7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    29be:	e8 be 16 00 00       	call   4081 <printf>
+    exit();
+    29c3:	e8 14 15 00 00       	call   3edc <exit>
+  }
+  unlink("bigfile");
+    29c8:	c7 04 24 d9 52 00 00 	movl   $0x52d9,(%esp)
+    29cf:	e8 58 15 00 00       	call   3f2c <unlink>
+
+  printf(1, "bigfile test ok\n");
+    29d4:	c7 44 24 04 7e 53 00 	movl   $0x537e,0x4(%esp)
+    29db:	00 
+    29dc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    29e3:	e8 99 16 00 00       	call   4081 <printf>
+}
+    29e8:	c9                   	leave  
+    29e9:	c3                   	ret    
+
+000029ea <fourteen>:
+
+void
+fourteen(void)
+{
+    29ea:	55                   	push   %ebp
+    29eb:	89 e5                	mov    %esp,%ebp
+    29ed:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+
+  // DIRSIZ is 14.
+  printf(1, "fourteen test\n");
+    29f0:	c7 44 24 04 8f 53 00 	movl   $0x538f,0x4(%esp)
+    29f7:	00 
+    29f8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    29ff:	e8 7d 16 00 00       	call   4081 <printf>
+
+  if(mkdir("12345678901234") != 0){
+    2a04:	c7 04 24 9e 53 00 00 	movl   $0x539e,(%esp)
+    2a0b:	e8 34 15 00 00       	call   3f44 <mkdir>
+    2a10:	85 c0                	test   %eax,%eax
+    2a12:	74 19                	je     2a2d <fourteen+0x43>
+    printf(1, "mkdir 12345678901234 failed\n");
+    2a14:	c7 44 24 04 ad 53 00 	movl   $0x53ad,0x4(%esp)
+    2a1b:	00 
+    2a1c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2a23:	e8 59 16 00 00       	call   4081 <printf>
+    exit();
+    2a28:	e8 af 14 00 00       	call   3edc <exit>
+  }
+  if(mkdir("12345678901234/123456789012345") != 0){
+    2a2d:	c7 04 24 cc 53 00 00 	movl   $0x53cc,(%esp)
+    2a34:	e8 0b 15 00 00       	call   3f44 <mkdir>
+    2a39:	85 c0                	test   %eax,%eax
+    2a3b:	74 19                	je     2a56 <fourteen+0x6c>
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    2a3d:	c7 44 24 04 ec 53 00 	movl   $0x53ec,0x4(%esp)
+    2a44:	00 
+    2a45:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2a4c:	e8 30 16 00 00       	call   4081 <printf>
+    exit();
+    2a51:	e8 86 14 00 00       	call   3edc <exit>
+  }
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+    2a56:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    2a5d:	00 
+    2a5e:	c7 04 24 1c 54 00 00 	movl   $0x541c,(%esp)
+    2a65:	e8 b2 14 00 00       	call   3f1c <open>
+    2a6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2a6d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2a71:	79 19                	jns    2a8c <fourteen+0xa2>
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    2a73:	c7 44 24 04 4c 54 00 	movl   $0x544c,0x4(%esp)
+    2a7a:	00 
+    2a7b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2a82:	e8 fa 15 00 00       	call   4081 <printf>
+    exit();
+    2a87:	e8 50 14 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    2a8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2a8f:	89 04 24             	mov    %eax,(%esp)
+    2a92:	e8 6d 14 00 00       	call   3f04 <close>
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+    2a97:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2a9e:	00 
+    2a9f:	c7 04 24 8c 54 00 00 	movl   $0x548c,(%esp)
+    2aa6:	e8 71 14 00 00       	call   3f1c <open>
+    2aab:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2aae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2ab2:	79 19                	jns    2acd <fourteen+0xe3>
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    2ab4:	c7 44 24 04 bc 54 00 	movl   $0x54bc,0x4(%esp)
+    2abb:	00 
+    2abc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ac3:	e8 b9 15 00 00       	call   4081 <printf>
+    exit();
+    2ac8:	e8 0f 14 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    2acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2ad0:	89 04 24             	mov    %eax,(%esp)
+    2ad3:	e8 2c 14 00 00       	call   3f04 <close>
+
+  if(mkdir("12345678901234/12345678901234") == 0){
+    2ad8:	c7 04 24 f6 54 00 00 	movl   $0x54f6,(%esp)
+    2adf:	e8 60 14 00 00       	call   3f44 <mkdir>
+    2ae4:	85 c0                	test   %eax,%eax
+    2ae6:	75 19                	jne    2b01 <fourteen+0x117>
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    2ae8:	c7 44 24 04 14 55 00 	movl   $0x5514,0x4(%esp)
+    2aef:	00 
+    2af0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2af7:	e8 85 15 00 00       	call   4081 <printf>
+    exit();
+    2afc:	e8 db 13 00 00       	call   3edc <exit>
+  }
+  if(mkdir("123456789012345/12345678901234") == 0){
+    2b01:	c7 04 24 44 55 00 00 	movl   $0x5544,(%esp)
+    2b08:	e8 37 14 00 00       	call   3f44 <mkdir>
+    2b0d:	85 c0                	test   %eax,%eax
+    2b0f:	75 19                	jne    2b2a <fourteen+0x140>
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    2b11:	c7 44 24 04 64 55 00 	movl   $0x5564,0x4(%esp)
+    2b18:	00 
+    2b19:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2b20:	e8 5c 15 00 00       	call   4081 <printf>
+    exit();
+    2b25:	e8 b2 13 00 00       	call   3edc <exit>
+  }
+
+  printf(1, "fourteen ok\n");
+    2b2a:	c7 44 24 04 95 55 00 	movl   $0x5595,0x4(%esp)
+    2b31:	00 
+    2b32:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2b39:	e8 43 15 00 00       	call   4081 <printf>
+}
+    2b3e:	c9                   	leave  
+    2b3f:	c3                   	ret    
+
+00002b40 <rmdot>:
+
+void
+rmdot(void)
+{
+    2b40:	55                   	push   %ebp
+    2b41:	89 e5                	mov    %esp,%ebp
+    2b43:	83 ec 18             	sub    $0x18,%esp
+  printf(1, "rmdot test\n");
+    2b46:	c7 44 24 04 a2 55 00 	movl   $0x55a2,0x4(%esp)
+    2b4d:	00 
+    2b4e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2b55:	e8 27 15 00 00       	call   4081 <printf>
+  if(mkdir("dots") != 0){
+    2b5a:	c7 04 24 ae 55 00 00 	movl   $0x55ae,(%esp)
+    2b61:	e8 de 13 00 00       	call   3f44 <mkdir>
+    2b66:	85 c0                	test   %eax,%eax
+    2b68:	74 19                	je     2b83 <rmdot+0x43>
+    printf(1, "mkdir dots failed\n");
+    2b6a:	c7 44 24 04 b3 55 00 	movl   $0x55b3,0x4(%esp)
+    2b71:	00 
+    2b72:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2b79:	e8 03 15 00 00       	call   4081 <printf>
+    exit();
+    2b7e:	e8 59 13 00 00       	call   3edc <exit>
+  }
+  if(chdir("dots") != 0){
+    2b83:	c7 04 24 ae 55 00 00 	movl   $0x55ae,(%esp)
+    2b8a:	e8 bd 13 00 00       	call   3f4c <chdir>
+    2b8f:	85 c0                	test   %eax,%eax
+    2b91:	74 19                	je     2bac <rmdot+0x6c>
+    printf(1, "chdir dots failed\n");
+    2b93:	c7 44 24 04 c6 55 00 	movl   $0x55c6,0x4(%esp)
+    2b9a:	00 
+    2b9b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ba2:	e8 da 14 00 00       	call   4081 <printf>
+    exit();
+    2ba7:	e8 30 13 00 00       	call   3edc <exit>
+  }
+  if(unlink(".") == 0){
+    2bac:	c7 04 24 df 4c 00 00 	movl   $0x4cdf,(%esp)
+    2bb3:	e8 74 13 00 00       	call   3f2c <unlink>
+    2bb8:	85 c0                	test   %eax,%eax
+    2bba:	75 19                	jne    2bd5 <rmdot+0x95>
+    printf(1, "rm . worked!\n");
+    2bbc:	c7 44 24 04 d9 55 00 	movl   $0x55d9,0x4(%esp)
+    2bc3:	00 
+    2bc4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2bcb:	e8 b1 14 00 00       	call   4081 <printf>
+    exit();
+    2bd0:	e8 07 13 00 00       	call   3edc <exit>
+  }
+  if(unlink("..") == 0){
+    2bd5:	c7 04 24 72 48 00 00 	movl   $0x4872,(%esp)
+    2bdc:	e8 4b 13 00 00       	call   3f2c <unlink>
+    2be1:	85 c0                	test   %eax,%eax
+    2be3:	75 19                	jne    2bfe <rmdot+0xbe>
+    printf(1, "rm .. worked!\n");
+    2be5:	c7 44 24 04 e7 55 00 	movl   $0x55e7,0x4(%esp)
+    2bec:	00 
+    2bed:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2bf4:	e8 88 14 00 00       	call   4081 <printf>
+    exit();
+    2bf9:	e8 de 12 00 00       	call   3edc <exit>
+  }
+  if(chdir("/") != 0){
+    2bfe:	c7 04 24 c6 44 00 00 	movl   $0x44c6,(%esp)
+    2c05:	e8 42 13 00 00       	call   3f4c <chdir>
+    2c0a:	85 c0                	test   %eax,%eax
+    2c0c:	74 19                	je     2c27 <rmdot+0xe7>
+    printf(1, "chdir / failed\n");
+    2c0e:	c7 44 24 04 c8 44 00 	movl   $0x44c8,0x4(%esp)
+    2c15:	00 
+    2c16:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c1d:	e8 5f 14 00 00       	call   4081 <printf>
+    exit();
+    2c22:	e8 b5 12 00 00       	call   3edc <exit>
+  }
+  if(unlink("dots/.") == 0){
+    2c27:	c7 04 24 f6 55 00 00 	movl   $0x55f6,(%esp)
+    2c2e:	e8 f9 12 00 00       	call   3f2c <unlink>
+    2c33:	85 c0                	test   %eax,%eax
+    2c35:	75 19                	jne    2c50 <rmdot+0x110>
+    printf(1, "unlink dots/. worked!\n");
+    2c37:	c7 44 24 04 fd 55 00 	movl   $0x55fd,0x4(%esp)
+    2c3e:	00 
+    2c3f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c46:	e8 36 14 00 00       	call   4081 <printf>
+    exit();
+    2c4b:	e8 8c 12 00 00       	call   3edc <exit>
+  }
+  if(unlink("dots/..") == 0){
+    2c50:	c7 04 24 14 56 00 00 	movl   $0x5614,(%esp)
+    2c57:	e8 d0 12 00 00       	call   3f2c <unlink>
+    2c5c:	85 c0                	test   %eax,%eax
+    2c5e:	75 19                	jne    2c79 <rmdot+0x139>
+    printf(1, "unlink dots/.. worked!\n");
+    2c60:	c7 44 24 04 1c 56 00 	movl   $0x561c,0x4(%esp)
+    2c67:	00 
+    2c68:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c6f:	e8 0d 14 00 00       	call   4081 <printf>
+    exit();
+    2c74:	e8 63 12 00 00       	call   3edc <exit>
+  }
+  if(unlink("dots") != 0){
+    2c79:	c7 04 24 ae 55 00 00 	movl   $0x55ae,(%esp)
+    2c80:	e8 a7 12 00 00       	call   3f2c <unlink>
+    2c85:	85 c0                	test   %eax,%eax
+    2c87:	74 19                	je     2ca2 <rmdot+0x162>
+    printf(1, "unlink dots failed!\n");
+    2c89:	c7 44 24 04 34 56 00 	movl   $0x5634,0x4(%esp)
+    2c90:	00 
+    2c91:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c98:	e8 e4 13 00 00       	call   4081 <printf>
+    exit();
+    2c9d:	e8 3a 12 00 00       	call   3edc <exit>
+  }
+  printf(1, "rmdot ok\n");
+    2ca2:	c7 44 24 04 49 56 00 	movl   $0x5649,0x4(%esp)
+    2ca9:	00 
+    2caa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2cb1:	e8 cb 13 00 00       	call   4081 <printf>
+}
+    2cb6:	c9                   	leave  
+    2cb7:	c3                   	ret    
+
+00002cb8 <dirfile>:
+
+void
+dirfile(void)
+{
+    2cb8:	55                   	push   %ebp
+    2cb9:	89 e5                	mov    %esp,%ebp
+    2cbb:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+
+  printf(1, "dir vs file\n");
+    2cbe:	c7 44 24 04 53 56 00 	movl   $0x5653,0x4(%esp)
+    2cc5:	00 
+    2cc6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ccd:	e8 af 13 00 00       	call   4081 <printf>
+
+  fd = open("dirfile", O_CREATE);
+    2cd2:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    2cd9:	00 
+    2cda:	c7 04 24 60 56 00 00 	movl   $0x5660,(%esp)
+    2ce1:	e8 36 12 00 00       	call   3f1c <open>
+    2ce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2ce9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2ced:	79 19                	jns    2d08 <dirfile+0x50>
+    printf(1, "create dirfile failed\n");
+    2cef:	c7 44 24 04 68 56 00 	movl   $0x5668,0x4(%esp)
+    2cf6:	00 
+    2cf7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2cfe:	e8 7e 13 00 00       	call   4081 <printf>
+    exit();
+    2d03:	e8 d4 11 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    2d08:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2d0b:	89 04 24             	mov    %eax,(%esp)
+    2d0e:	e8 f1 11 00 00       	call   3f04 <close>
+  if(chdir("dirfile") == 0){
+    2d13:	c7 04 24 60 56 00 00 	movl   $0x5660,(%esp)
+    2d1a:	e8 2d 12 00 00       	call   3f4c <chdir>
+    2d1f:	85 c0                	test   %eax,%eax
+    2d21:	75 19                	jne    2d3c <dirfile+0x84>
+    printf(1, "chdir dirfile succeeded!\n");
+    2d23:	c7 44 24 04 7f 56 00 	movl   $0x567f,0x4(%esp)
+    2d2a:	00 
+    2d2b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2d32:	e8 4a 13 00 00       	call   4081 <printf>
+    exit();
+    2d37:	e8 a0 11 00 00       	call   3edc <exit>
+  }
+  fd = open("dirfile/xx", 0);
+    2d3c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2d43:	00 
+    2d44:	c7 04 24 99 56 00 00 	movl   $0x5699,(%esp)
+    2d4b:	e8 cc 11 00 00       	call   3f1c <open>
+    2d50:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+    2d53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2d57:	78 19                	js     2d72 <dirfile+0xba>
+    printf(1, "create dirfile/xx succeeded!\n");
+    2d59:	c7 44 24 04 a4 56 00 	movl   $0x56a4,0x4(%esp)
+    2d60:	00 
+    2d61:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2d68:	e8 14 13 00 00       	call   4081 <printf>
+    exit();
+    2d6d:	e8 6a 11 00 00       	call   3edc <exit>
+  }
+  fd = open("dirfile/xx", O_CREATE);
+    2d72:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    2d79:	00 
+    2d7a:	c7 04 24 99 56 00 00 	movl   $0x5699,(%esp)
+    2d81:	e8 96 11 00 00       	call   3f1c <open>
+    2d86:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+    2d89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2d8d:	78 19                	js     2da8 <dirfile+0xf0>
+    printf(1, "create dirfile/xx succeeded!\n");
+    2d8f:	c7 44 24 04 a4 56 00 	movl   $0x56a4,0x4(%esp)
+    2d96:	00 
+    2d97:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2d9e:	e8 de 12 00 00       	call   4081 <printf>
+    exit();
+    2da3:	e8 34 11 00 00       	call   3edc <exit>
+  }
+  if(mkdir("dirfile/xx") == 0){
+    2da8:	c7 04 24 99 56 00 00 	movl   $0x5699,(%esp)
+    2daf:	e8 90 11 00 00       	call   3f44 <mkdir>
+    2db4:	85 c0                	test   %eax,%eax
+    2db6:	75 19                	jne    2dd1 <dirfile+0x119>
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    2db8:	c7 44 24 04 c2 56 00 	movl   $0x56c2,0x4(%esp)
+    2dbf:	00 
+    2dc0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2dc7:	e8 b5 12 00 00       	call   4081 <printf>
+    exit();
+    2dcc:	e8 0b 11 00 00       	call   3edc <exit>
+  }
+  if(unlink("dirfile/xx") == 0){
+    2dd1:	c7 04 24 99 56 00 00 	movl   $0x5699,(%esp)
+    2dd8:	e8 4f 11 00 00       	call   3f2c <unlink>
+    2ddd:	85 c0                	test   %eax,%eax
+    2ddf:	75 19                	jne    2dfa <dirfile+0x142>
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    2de1:	c7 44 24 04 df 56 00 	movl   $0x56df,0x4(%esp)
+    2de8:	00 
+    2de9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2df0:	e8 8c 12 00 00       	call   4081 <printf>
+    exit();
+    2df5:	e8 e2 10 00 00       	call   3edc <exit>
+  }
+  if(link("README", "dirfile/xx") == 0){
+    2dfa:	c7 44 24 04 99 56 00 	movl   $0x5699,0x4(%esp)
+    2e01:	00 
+    2e02:	c7 04 24 fd 56 00 00 	movl   $0x56fd,(%esp)
+    2e09:	e8 2e 11 00 00       	call   3f3c <link>
+    2e0e:	85 c0                	test   %eax,%eax
+    2e10:	75 19                	jne    2e2b <dirfile+0x173>
+    printf(1, "link to dirfile/xx succeeded!\n");
+    2e12:	c7 44 24 04 04 57 00 	movl   $0x5704,0x4(%esp)
+    2e19:	00 
+    2e1a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2e21:	e8 5b 12 00 00       	call   4081 <printf>
+    exit();
+    2e26:	e8 b1 10 00 00       	call   3edc <exit>
+  }
+  if(unlink("dirfile") != 0){
+    2e2b:	c7 04 24 60 56 00 00 	movl   $0x5660,(%esp)
+    2e32:	e8 f5 10 00 00       	call   3f2c <unlink>
+    2e37:	85 c0                	test   %eax,%eax
+    2e39:	74 19                	je     2e54 <dirfile+0x19c>
+    printf(1, "unlink dirfile failed!\n");
+    2e3b:	c7 44 24 04 23 57 00 	movl   $0x5723,0x4(%esp)
+    2e42:	00 
+    2e43:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2e4a:	e8 32 12 00 00       	call   4081 <printf>
+    exit();
+    2e4f:	e8 88 10 00 00       	call   3edc <exit>
+  }
+
+  fd = open(".", O_RDWR);
+    2e54:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    2e5b:	00 
+    2e5c:	c7 04 24 df 4c 00 00 	movl   $0x4cdf,(%esp)
+    2e63:	e8 b4 10 00 00       	call   3f1c <open>
+    2e68:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+    2e6b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2e6f:	78 19                	js     2e8a <dirfile+0x1d2>
+    printf(1, "open . for writing succeeded!\n");
+    2e71:	c7 44 24 04 3c 57 00 	movl   $0x573c,0x4(%esp)
+    2e78:	00 
+    2e79:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2e80:	e8 fc 11 00 00       	call   4081 <printf>
+    exit();
+    2e85:	e8 52 10 00 00       	call   3edc <exit>
+  }
+  fd = open(".", 0);
+    2e8a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2e91:	00 
+    2e92:	c7 04 24 df 4c 00 00 	movl   $0x4cdf,(%esp)
+    2e99:	e8 7e 10 00 00       	call   3f1c <open>
+    2e9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(write(fd, "x", 1) > 0){
+    2ea1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    2ea8:	00 
+    2ea9:	c7 44 24 04 2b 49 00 	movl   $0x492b,0x4(%esp)
+    2eb0:	00 
+    2eb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2eb4:	89 04 24             	mov    %eax,(%esp)
+    2eb7:	e8 40 10 00 00       	call   3efc <write>
+    2ebc:	85 c0                	test   %eax,%eax
+    2ebe:	7e 19                	jle    2ed9 <dirfile+0x221>
+    printf(1, "write . succeeded!\n");
+    2ec0:	c7 44 24 04 5b 57 00 	movl   $0x575b,0x4(%esp)
+    2ec7:	00 
+    2ec8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ecf:	e8 ad 11 00 00       	call   4081 <printf>
+    exit();
+    2ed4:	e8 03 10 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    2ed9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2edc:	89 04 24             	mov    %eax,(%esp)
+    2edf:	e8 20 10 00 00       	call   3f04 <close>
+
+  printf(1, "dir vs file OK\n");
+    2ee4:	c7 44 24 04 6f 57 00 	movl   $0x576f,0x4(%esp)
+    2eeb:	00 
+    2eec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ef3:	e8 89 11 00 00       	call   4081 <printf>
+}
+    2ef8:	c9                   	leave  
+    2ef9:	c3                   	ret    
+
+00002efa <iref>:
+
+// test that iput() is called at the end of _namei()
+void
+iref(void)
+{
+    2efa:	55                   	push   %ebp
+    2efb:	89 e5                	mov    %esp,%ebp
+    2efd:	83 ec 28             	sub    $0x28,%esp
+  int i, fd;
+
+  printf(1, "empty file name\n");
+    2f00:	c7 44 24 04 7f 57 00 	movl   $0x577f,0x4(%esp)
+    2f07:	00 
+    2f08:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2f0f:	e8 6d 11 00 00       	call   4081 <printf>
+
+  // the 50 is NINODE
+  for(i = 0; i < 50 + 1; i++){
+    2f14:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    2f1b:	e9 d2 00 00 00       	jmp    2ff2 <iref+0xf8>
+    if(mkdir("irefd") != 0){
+    2f20:	c7 04 24 90 57 00 00 	movl   $0x5790,(%esp)
+    2f27:	e8 18 10 00 00       	call   3f44 <mkdir>
+    2f2c:	85 c0                	test   %eax,%eax
+    2f2e:	74 19                	je     2f49 <iref+0x4f>
+      printf(1, "mkdir irefd failed\n");
+    2f30:	c7 44 24 04 96 57 00 	movl   $0x5796,0x4(%esp)
+    2f37:	00 
+    2f38:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2f3f:	e8 3d 11 00 00       	call   4081 <printf>
+      exit();
+    2f44:	e8 93 0f 00 00       	call   3edc <exit>
+    }
+    if(chdir("irefd") != 0){
+    2f49:	c7 04 24 90 57 00 00 	movl   $0x5790,(%esp)
+    2f50:	e8 f7 0f 00 00       	call   3f4c <chdir>
+    2f55:	85 c0                	test   %eax,%eax
+    2f57:	74 19                	je     2f72 <iref+0x78>
+      printf(1, "chdir irefd failed\n");
+    2f59:	c7 44 24 04 aa 57 00 	movl   $0x57aa,0x4(%esp)
+    2f60:	00 
+    2f61:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2f68:	e8 14 11 00 00       	call   4081 <printf>
+      exit();
+    2f6d:	e8 6a 0f 00 00       	call   3edc <exit>
+    }
+
+    mkdir("");
+    2f72:	c7 04 24 be 57 00 00 	movl   $0x57be,(%esp)
+    2f79:	e8 c6 0f 00 00       	call   3f44 <mkdir>
+    link("README", "");
+    2f7e:	c7 44 24 04 be 57 00 	movl   $0x57be,0x4(%esp)
+    2f85:	00 
+    2f86:	c7 04 24 fd 56 00 00 	movl   $0x56fd,(%esp)
+    2f8d:	e8 aa 0f 00 00       	call   3f3c <link>
+    fd = open("", O_CREATE);
+    2f92:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    2f99:	00 
+    2f9a:	c7 04 24 be 57 00 00 	movl   $0x57be,(%esp)
+    2fa1:	e8 76 0f 00 00       	call   3f1c <open>
+    2fa6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fd >= 0)
+    2fa9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    2fad:	78 0b                	js     2fba <iref+0xc0>
+      close(fd);
+    2faf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    2fb2:	89 04 24             	mov    %eax,(%esp)
+    2fb5:	e8 4a 0f 00 00       	call   3f04 <close>
+    fd = open("xx", O_CREATE);
+    2fba:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    2fc1:	00 
+    2fc2:	c7 04 24 bf 57 00 00 	movl   $0x57bf,(%esp)
+    2fc9:	e8 4e 0f 00 00       	call   3f1c <open>
+    2fce:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fd >= 0)
+    2fd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    2fd5:	78 0b                	js     2fe2 <iref+0xe8>
+      close(fd);
+    2fd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    2fda:	89 04 24             	mov    %eax,(%esp)
+    2fdd:	e8 22 0f 00 00       	call   3f04 <close>
+    unlink("xx");
+    2fe2:	c7 04 24 bf 57 00 00 	movl   $0x57bf,(%esp)
+    2fe9:	e8 3e 0f 00 00       	call   3f2c <unlink>
+  int i, fd;
+
+  printf(1, "empty file name\n");
+
+  // the 50 is NINODE
+  for(i = 0; i < 50 + 1; i++){
+    2fee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    2ff2:	83 7d f4 32          	cmpl   $0x32,-0xc(%ebp)
+    2ff6:	0f 8e 24 ff ff ff    	jle    2f20 <iref+0x26>
+    if(fd >= 0)
+      close(fd);
+    unlink("xx");
+  }
+
+  chdir("/");
+    2ffc:	c7 04 24 c6 44 00 00 	movl   $0x44c6,(%esp)
+    3003:	e8 44 0f 00 00       	call   3f4c <chdir>
+  printf(1, "empty file name OK\n");
+    3008:	c7 44 24 04 c2 57 00 	movl   $0x57c2,0x4(%esp)
+    300f:	00 
+    3010:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3017:	e8 65 10 00 00       	call   4081 <printf>
+}
+    301c:	c9                   	leave  
+    301d:	c3                   	ret    
+
+0000301e <forktest>:
+// test that fork fails gracefully
+// the forktest binary also does this, but it runs out of proc entries first.
+// inside the bigger usertests binary, we run out of memory first.
+void
+forktest(void)
+{
+    301e:	55                   	push   %ebp
+    301f:	89 e5                	mov    %esp,%ebp
+    3021:	83 ec 28             	sub    $0x28,%esp
+  int n, pid;
+
+  printf(1, "fork test\n");
+    3024:	c7 44 24 04 d6 57 00 	movl   $0x57d6,0x4(%esp)
+    302b:	00 
+    302c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3033:	e8 49 10 00 00       	call   4081 <printf>
+
+  for(n=0; n<1000; n++){
+    3038:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    303f:	eb 1d                	jmp    305e <forktest+0x40>
+    pid = fork();
+    3041:	e8 8e 0e 00 00       	call   3ed4 <fork>
+    3046:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(pid < 0)
+    3049:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    304d:	78 1a                	js     3069 <forktest+0x4b>
+      break;
+    if(pid == 0)
+    304f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3053:	75 05                	jne    305a <forktest+0x3c>
+      exit();
+    3055:	e8 82 0e 00 00       	call   3edc <exit>
+{
+  int n, pid;
+
+  printf(1, "fork test\n");
+
+  for(n=0; n<1000; n++){
+    305a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    305e:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+    3065:	7e da                	jle    3041 <forktest+0x23>
+    3067:	eb 01                	jmp    306a <forktest+0x4c>
+    pid = fork();
+    if(pid < 0)
+      break;
+    3069:	90                   	nop
+    if(pid == 0)
+      exit();
+  }
+  
+  if(n == 1000){
+    306a:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
+    3071:	75 3f                	jne    30b2 <forktest+0x94>
+    printf(1, "fork claimed to work 1000 times!\n");
+    3073:	c7 44 24 04 e4 57 00 	movl   $0x57e4,0x4(%esp)
+    307a:	00 
+    307b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3082:	e8 fa 0f 00 00       	call   4081 <printf>
+    exit();
+    3087:	e8 50 0e 00 00       	call   3edc <exit>
+  }
+  
+  for(; n > 0; n--){
+    if(wait() < 0){
+    308c:	e8 53 0e 00 00       	call   3ee4 <wait>
+    3091:	85 c0                	test   %eax,%eax
+    3093:	79 19                	jns    30ae <forktest+0x90>
+      printf(1, "wait stopped early\n");
+    3095:	c7 44 24 04 06 58 00 	movl   $0x5806,0x4(%esp)
+    309c:	00 
+    309d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    30a4:	e8 d8 0f 00 00       	call   4081 <printf>
+      exit();
+    30a9:	e8 2e 0e 00 00       	call   3edc <exit>
+  if(n == 1000){
+    printf(1, "fork claimed to work 1000 times!\n");
+    exit();
+  }
+  
+  for(; n > 0; n--){
+    30ae:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    30b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    30b6:	7f d4                	jg     308c <forktest+0x6e>
+      printf(1, "wait stopped early\n");
+      exit();
+    }
+  }
+  
+  if(wait() != -1){
+    30b8:	e8 27 0e 00 00       	call   3ee4 <wait>
+    30bd:	83 f8 ff             	cmp    $0xffffffff,%eax
+    30c0:	74 19                	je     30db <forktest+0xbd>
+    printf(1, "wait got too many\n");
+    30c2:	c7 44 24 04 1a 58 00 	movl   $0x581a,0x4(%esp)
+    30c9:	00 
+    30ca:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    30d1:	e8 ab 0f 00 00       	call   4081 <printf>
+    exit();
+    30d6:	e8 01 0e 00 00       	call   3edc <exit>
+  }
+  
+  printf(1, "fork test OK\n");
+    30db:	c7 44 24 04 2d 58 00 	movl   $0x582d,0x4(%esp)
+    30e2:	00 
+    30e3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    30ea:	e8 92 0f 00 00       	call   4081 <printf>
+}
+    30ef:	c9                   	leave  
+    30f0:	c3                   	ret    
+
+000030f1 <sbrktest>:
+
+void
+sbrktest(void)
+{
+    30f1:	55                   	push   %ebp
+    30f2:	89 e5                	mov    %esp,%ebp
+    30f4:	53                   	push   %ebx
+    30f5:	81 ec 84 00 00 00    	sub    $0x84,%esp
+  int fds[2], pid, pids[10], ppid;
+  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  uint amt;
+
+  printf(stdout, "sbrk test\n");
+    30fb:	a1 10 63 00 00       	mov    0x6310,%eax
+    3100:	c7 44 24 04 3b 58 00 	movl   $0x583b,0x4(%esp)
+    3107:	00 
+    3108:	89 04 24             	mov    %eax,(%esp)
+    310b:	e8 71 0f 00 00       	call   4081 <printf>
+  oldbrk = sbrk(0);
+    3110:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3117:	e8 48 0e 00 00       	call   3f64 <sbrk>
+    311c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+  // can one sbrk() less than a page?
+  a = sbrk(0);
+    311f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3126:	e8 39 0e 00 00       	call   3f64 <sbrk>
+    312b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  int i;
+  for(i = 0; i < 5000; i++){ 
+    312e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    3135:	eb 59                	jmp    3190 <sbrktest+0x9f>
+    b = sbrk(1);
+    3137:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    313e:	e8 21 0e 00 00       	call   3f64 <sbrk>
+    3143:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(b != a){
+    3146:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    3149:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    314c:	74 2f                	je     317d <sbrktest+0x8c>
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+    314e:	a1 10 63 00 00       	mov    0x6310,%eax
+    3153:	8b 55 e8             	mov    -0x18(%ebp),%edx
+    3156:	89 54 24 10          	mov    %edx,0x10(%esp)
+    315a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    315d:	89 54 24 0c          	mov    %edx,0xc(%esp)
+    3161:	8b 55 f0             	mov    -0x10(%ebp),%edx
+    3164:	89 54 24 08          	mov    %edx,0x8(%esp)
+    3168:	c7 44 24 04 46 58 00 	movl   $0x5846,0x4(%esp)
+    316f:	00 
+    3170:	89 04 24             	mov    %eax,(%esp)
+    3173:	e8 09 0f 00 00       	call   4081 <printf>
+      exit();
+    3178:	e8 5f 0d 00 00       	call   3edc <exit>
+    }
+    *b = 1;
+    317d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    3180:	c6 00 01             	movb   $0x1,(%eax)
+    a = b + 1;
+    3183:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    3186:	83 c0 01             	add    $0x1,%eax
+    3189:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  oldbrk = sbrk(0);
+
+  // can one sbrk() less than a page?
+  a = sbrk(0);
+  int i;
+  for(i = 0; i < 5000; i++){ 
+    318c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    3190:	81 7d f0 87 13 00 00 	cmpl   $0x1387,-0x10(%ebp)
+    3197:	7e 9e                	jle    3137 <sbrktest+0x46>
+      exit();
+    }
+    *b = 1;
+    a = b + 1;
+  }
+  pid = fork();
+    3199:	e8 36 0d 00 00       	call   3ed4 <fork>
+    319e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(pid < 0){
+    31a1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+    31a5:	79 1a                	jns    31c1 <sbrktest+0xd0>
+    printf(stdout, "sbrk test fork failed\n");
+    31a7:	a1 10 63 00 00       	mov    0x6310,%eax
+    31ac:	c7 44 24 04 61 58 00 	movl   $0x5861,0x4(%esp)
+    31b3:	00 
+    31b4:	89 04 24             	mov    %eax,(%esp)
+    31b7:	e8 c5 0e 00 00       	call   4081 <printf>
+    exit();
+    31bc:	e8 1b 0d 00 00       	call   3edc <exit>
+  }
+  c = sbrk(1);
+    31c1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    31c8:	e8 97 0d 00 00       	call   3f64 <sbrk>
+    31cd:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  c = sbrk(1);
+    31d0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    31d7:	e8 88 0d 00 00       	call   3f64 <sbrk>
+    31dc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(c != a + 1){
+    31df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    31e2:	83 c0 01             	add    $0x1,%eax
+    31e5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+    31e8:	74 1a                	je     3204 <sbrktest+0x113>
+    printf(stdout, "sbrk test failed post-fork\n");
+    31ea:	a1 10 63 00 00       	mov    0x6310,%eax
+    31ef:	c7 44 24 04 78 58 00 	movl   $0x5878,0x4(%esp)
+    31f6:	00 
+    31f7:	89 04 24             	mov    %eax,(%esp)
+    31fa:	e8 82 0e 00 00       	call   4081 <printf>
+    exit();
+    31ff:	e8 d8 0c 00 00       	call   3edc <exit>
+  }
+  if(pid == 0)
+    3204:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+    3208:	75 05                	jne    320f <sbrktest+0x11e>
+    exit();
+    320a:	e8 cd 0c 00 00       	call   3edc <exit>
+  wait();
+    320f:	e8 d0 0c 00 00       	call   3ee4 <wait>
+
+  // can one grow address space to something big?
+#define BIG (100*1024*1024)
+  a = sbrk(0);
+    3214:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    321b:	e8 44 0d 00 00       	call   3f64 <sbrk>
+    3220:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  amt = (BIG) - (uint)a;
+    3223:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3226:	ba 00 00 40 06       	mov    $0x6400000,%edx
+    322b:	89 d1                	mov    %edx,%ecx
+    322d:	29 c1                	sub    %eax,%ecx
+    322f:	89 c8                	mov    %ecx,%eax
+    3231:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  p = sbrk(amt);
+    3234:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    3237:	89 04 24             	mov    %eax,(%esp)
+    323a:	e8 25 0d 00 00       	call   3f64 <sbrk>
+    323f:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  if (p != a) { 
+    3242:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    3245:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    3248:	74 1a                	je     3264 <sbrktest+0x173>
+    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    324a:	a1 10 63 00 00       	mov    0x6310,%eax
+    324f:	c7 44 24 04 94 58 00 	movl   $0x5894,0x4(%esp)
+    3256:	00 
+    3257:	89 04 24             	mov    %eax,(%esp)
+    325a:	e8 22 0e 00 00       	call   4081 <printf>
+    exit();
+    325f:	e8 78 0c 00 00       	call   3edc <exit>
+  }
+  lastaddr = (char*) (BIG-1);
+    3264:	c7 45 d4 ff ff 3f 06 	movl   $0x63fffff,-0x2c(%ebp)
+  *lastaddr = 99;
+    326b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    326e:	c6 00 63             	movb   $0x63,(%eax)
+
+  // can one de-allocate?
+  a = sbrk(0);
+    3271:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3278:	e8 e7 0c 00 00       	call   3f64 <sbrk>
+    327d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c = sbrk(-4096);
+    3280:	c7 04 24 00 f0 ff ff 	movl   $0xfffff000,(%esp)
+    3287:	e8 d8 0c 00 00       	call   3f64 <sbrk>
+    328c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(c == (char*)0xffffffff){
+    328f:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
+    3293:	75 1a                	jne    32af <sbrktest+0x1be>
+    printf(stdout, "sbrk could not deallocate\n");
+    3295:	a1 10 63 00 00       	mov    0x6310,%eax
+    329a:	c7 44 24 04 d2 58 00 	movl   $0x58d2,0x4(%esp)
+    32a1:	00 
+    32a2:	89 04 24             	mov    %eax,(%esp)
+    32a5:	e8 d7 0d 00 00       	call   4081 <printf>
+    exit();
+    32aa:	e8 2d 0c 00 00       	call   3edc <exit>
+  }
+  c = sbrk(0);
+    32af:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    32b6:	e8 a9 0c 00 00       	call   3f64 <sbrk>
+    32bb:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(c != a - 4096){
+    32be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    32c1:	2d 00 10 00 00       	sub    $0x1000,%eax
+    32c6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+    32c9:	74 28                	je     32f3 <sbrktest+0x202>
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    32cb:	a1 10 63 00 00       	mov    0x6310,%eax
+    32d0:	8b 55 e0             	mov    -0x20(%ebp),%edx
+    32d3:	89 54 24 0c          	mov    %edx,0xc(%esp)
+    32d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    32da:	89 54 24 08          	mov    %edx,0x8(%esp)
+    32de:	c7 44 24 04 f0 58 00 	movl   $0x58f0,0x4(%esp)
+    32e5:	00 
+    32e6:	89 04 24             	mov    %eax,(%esp)
+    32e9:	e8 93 0d 00 00       	call   4081 <printf>
+    exit();
+    32ee:	e8 e9 0b 00 00       	call   3edc <exit>
+  }
+
+  // can one re-allocate that page?
+  a = sbrk(0);
+    32f3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    32fa:	e8 65 0c 00 00       	call   3f64 <sbrk>
+    32ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c = sbrk(4096);
+    3302:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+    3309:	e8 56 0c 00 00       	call   3f64 <sbrk>
+    330e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(c != a || sbrk(0) != a + 4096){
+    3311:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    3314:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    3317:	75 19                	jne    3332 <sbrktest+0x241>
+    3319:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3320:	e8 3f 0c 00 00       	call   3f64 <sbrk>
+    3325:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    3328:	81 c2 00 10 00 00    	add    $0x1000,%edx
+    332e:	39 d0                	cmp    %edx,%eax
+    3330:	74 28                	je     335a <sbrktest+0x269>
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    3332:	a1 10 63 00 00       	mov    0x6310,%eax
+    3337:	8b 55 e0             	mov    -0x20(%ebp),%edx
+    333a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+    333e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    3341:	89 54 24 08          	mov    %edx,0x8(%esp)
+    3345:	c7 44 24 04 28 59 00 	movl   $0x5928,0x4(%esp)
+    334c:	00 
+    334d:	89 04 24             	mov    %eax,(%esp)
+    3350:	e8 2c 0d 00 00       	call   4081 <printf>
+    exit();
+    3355:	e8 82 0b 00 00       	call   3edc <exit>
+  }
+  if(*lastaddr == 99){
+    335a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    335d:	0f b6 00             	movzbl (%eax),%eax
+    3360:	3c 63                	cmp    $0x63,%al
+    3362:	75 1a                	jne    337e <sbrktest+0x28d>
+    // should be zero
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    3364:	a1 10 63 00 00       	mov    0x6310,%eax
+    3369:	c7 44 24 04 50 59 00 	movl   $0x5950,0x4(%esp)
+    3370:	00 
+    3371:	89 04 24             	mov    %eax,(%esp)
+    3374:	e8 08 0d 00 00       	call   4081 <printf>
+    exit();
+    3379:	e8 5e 0b 00 00       	call   3edc <exit>
+  }
+
+  a = sbrk(0);
+    337e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3385:	e8 da 0b 00 00       	call   3f64 <sbrk>
+    338a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c = sbrk(-(sbrk(0) - oldbrk));
+    338d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
+    3390:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3397:	e8 c8 0b 00 00       	call   3f64 <sbrk>
+    339c:	89 da                	mov    %ebx,%edx
+    339e:	29 c2                	sub    %eax,%edx
+    33a0:	89 d0                	mov    %edx,%eax
+    33a2:	89 04 24             	mov    %eax,(%esp)
+    33a5:	e8 ba 0b 00 00       	call   3f64 <sbrk>
+    33aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(c != a){
+    33ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    33b0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    33b3:	74 28                	je     33dd <sbrktest+0x2ec>
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    33b5:	a1 10 63 00 00       	mov    0x6310,%eax
+    33ba:	8b 55 e0             	mov    -0x20(%ebp),%edx
+    33bd:	89 54 24 0c          	mov    %edx,0xc(%esp)
+    33c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    33c4:	89 54 24 08          	mov    %edx,0x8(%esp)
+    33c8:	c7 44 24 04 80 59 00 	movl   $0x5980,0x4(%esp)
+    33cf:	00 
+    33d0:	89 04 24             	mov    %eax,(%esp)
+    33d3:	e8 a9 0c 00 00       	call   4081 <printf>
+    exit();
+    33d8:	e8 ff 0a 00 00       	call   3edc <exit>
+  }
+  
+  // can we read the kernel's memory?
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    33dd:	c7 45 f4 00 00 00 80 	movl   $0x80000000,-0xc(%ebp)
+    33e4:	eb 7b                	jmp    3461 <sbrktest+0x370>
+    ppid = getpid();
+    33e6:	e8 71 0b 00 00       	call   3f5c <getpid>
+    33eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    pid = fork();
+    33ee:	e8 e1 0a 00 00       	call   3ed4 <fork>
+    33f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(pid < 0){
+    33f6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+    33fa:	79 1a                	jns    3416 <sbrktest+0x325>
+      printf(stdout, "fork failed\n");
+    33fc:	a1 10 63 00 00       	mov    0x6310,%eax
+    3401:	c7 44 24 04 f5 44 00 	movl   $0x44f5,0x4(%esp)
+    3408:	00 
+    3409:	89 04 24             	mov    %eax,(%esp)
+    340c:	e8 70 0c 00 00       	call   4081 <printf>
+      exit();
+    3411:	e8 c6 0a 00 00       	call   3edc <exit>
+    }
+    if(pid == 0){
+    3416:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+    341a:	75 39                	jne    3455 <sbrktest+0x364>
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+    341c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    341f:	0f b6 00             	movzbl (%eax),%eax
+    3422:	0f be d0             	movsbl %al,%edx
+    3425:	a1 10 63 00 00       	mov    0x6310,%eax
+    342a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+    342e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    3431:	89 54 24 08          	mov    %edx,0x8(%esp)
+    3435:	c7 44 24 04 a1 59 00 	movl   $0x59a1,0x4(%esp)
+    343c:	00 
+    343d:	89 04 24             	mov    %eax,(%esp)
+    3440:	e8 3c 0c 00 00       	call   4081 <printf>
+      kill(ppid);
+    3445:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    3448:	89 04 24             	mov    %eax,(%esp)
+    344b:	e8 bc 0a 00 00       	call   3f0c <kill>
+      exit();
+    3450:	e8 87 0a 00 00       	call   3edc <exit>
+    }
+    wait();
+    3455:	e8 8a 0a 00 00       	call   3ee4 <wait>
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    exit();
+  }
+  
+  // can we read the kernel's memory?
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    345a:	81 45 f4 50 c3 00 00 	addl   $0xc350,-0xc(%ebp)
+    3461:	81 7d f4 7f 84 1e 80 	cmpl   $0x801e847f,-0xc(%ebp)
+    3468:	0f 86 78 ff ff ff    	jbe    33e6 <sbrktest+0x2f5>
+    wait();
+  }
+
+  // if we run the system out of memory, does it clean up the last
+  // failed allocation?
+  if(pipe(fds) != 0){
+    346e:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    3471:	89 04 24             	mov    %eax,(%esp)
+    3474:	e8 73 0a 00 00       	call   3eec <pipe>
+    3479:	85 c0                	test   %eax,%eax
+    347b:	74 19                	je     3496 <sbrktest+0x3a5>
+    printf(1, "pipe() failed\n");
+    347d:	c7 44 24 04 c6 48 00 	movl   $0x48c6,0x4(%esp)
+    3484:	00 
+    3485:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    348c:	e8 f0 0b 00 00       	call   4081 <printf>
+    exit();
+    3491:	e8 46 0a 00 00       	call   3edc <exit>
+  }
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    3496:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    349d:	e9 89 00 00 00       	jmp    352b <sbrktest+0x43a>
+    if((pids[i] = fork()) == 0){
+    34a2:	e8 2d 0a 00 00       	call   3ed4 <fork>
+    34a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
+    34aa:	89 44 95 a0          	mov    %eax,-0x60(%ebp,%edx,4)
+    34ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    34b1:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    34b5:	85 c0                	test   %eax,%eax
+    34b7:	75 48                	jne    3501 <sbrktest+0x410>
+      // allocate a lot of memory
+      sbrk(BIG - (uint)sbrk(0));
+    34b9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    34c0:	e8 9f 0a 00 00       	call   3f64 <sbrk>
+    34c5:	ba 00 00 40 06       	mov    $0x6400000,%edx
+    34ca:	89 d1                	mov    %edx,%ecx
+    34cc:	29 c1                	sub    %eax,%ecx
+    34ce:	89 c8                	mov    %ecx,%eax
+    34d0:	89 04 24             	mov    %eax,(%esp)
+    34d3:	e8 8c 0a 00 00       	call   3f64 <sbrk>
+      write(fds[1], "x", 1);
+    34d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
+    34db:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    34e2:	00 
+    34e3:	c7 44 24 04 2b 49 00 	movl   $0x492b,0x4(%esp)
+    34ea:	00 
+    34eb:	89 04 24             	mov    %eax,(%esp)
+    34ee:	e8 09 0a 00 00       	call   3efc <write>
+      // sit around until killed
+      for(;;) sleep(1000);
+    34f3:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
+    34fa:	e8 6d 0a 00 00       	call   3f6c <sleep>
+    34ff:	eb f2                	jmp    34f3 <sbrktest+0x402>
+    }
+    if(pids[i] != -1)
+    3501:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    3504:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    3508:	83 f8 ff             	cmp    $0xffffffff,%eax
+    350b:	74 1a                	je     3527 <sbrktest+0x436>
+      read(fds[0], &scratch, 1);
+    350d:	8b 45 c8             	mov    -0x38(%ebp),%eax
+    3510:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    3517:	00 
+    3518:	8d 55 9f             	lea    -0x61(%ebp),%edx
+    351b:	89 54 24 04          	mov    %edx,0x4(%esp)
+    351f:	89 04 24             	mov    %eax,(%esp)
+    3522:	e8 cd 09 00 00       	call   3ef4 <read>
+  // failed allocation?
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit();
+  }
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    3527:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    352b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    352e:	83 f8 09             	cmp    $0x9,%eax
+    3531:	0f 86 6b ff ff ff    	jbe    34a2 <sbrktest+0x3b1>
+    if(pids[i] != -1)
+      read(fds[0], &scratch, 1);
+  }
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+    3537:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+    353e:	e8 21 0a 00 00       	call   3f64 <sbrk>
+    3543:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    3546:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    354d:	eb 27                	jmp    3576 <sbrktest+0x485>
+    if(pids[i] == -1)
+    354f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    3552:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    3556:	83 f8 ff             	cmp    $0xffffffff,%eax
+    3559:	74 16                	je     3571 <sbrktest+0x480>
+      continue;
+    kill(pids[i]);
+    355b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    355e:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    3562:	89 04 24             	mov    %eax,(%esp)
+    3565:	e8 a2 09 00 00       	call   3f0c <kill>
+    wait();
+    356a:	e8 75 09 00 00       	call   3ee4 <wait>
+    356f:	eb 01                	jmp    3572 <sbrktest+0x481>
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if(pids[i] == -1)
+      continue;
+    3571:	90                   	nop
+      read(fds[0], &scratch, 1);
+  }
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    3572:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    3576:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    3579:	83 f8 09             	cmp    $0x9,%eax
+    357c:	76 d1                	jbe    354f <sbrktest+0x45e>
+    if(pids[i] == -1)
+      continue;
+    kill(pids[i]);
+    wait();
+  }
+  if(c == (char*)0xffffffff){
+    357e:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
+    3582:	75 1a                	jne    359e <sbrktest+0x4ad>
+    printf(stdout, "failed sbrk leaked memory\n");
+    3584:	a1 10 63 00 00       	mov    0x6310,%eax
+    3589:	c7 44 24 04 ba 59 00 	movl   $0x59ba,0x4(%esp)
+    3590:	00 
+    3591:	89 04 24             	mov    %eax,(%esp)
+    3594:	e8 e8 0a 00 00       	call   4081 <printf>
+    exit();
+    3599:	e8 3e 09 00 00       	call   3edc <exit>
+  }
+
+  if(sbrk(0) > oldbrk)
+    359e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    35a5:	e8 ba 09 00 00       	call   3f64 <sbrk>
+    35aa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+    35ad:	76 1d                	jbe    35cc <sbrktest+0x4db>
+    sbrk(-(sbrk(0) - oldbrk));
+    35af:	8b 5d ec             	mov    -0x14(%ebp),%ebx
+    35b2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    35b9:	e8 a6 09 00 00       	call   3f64 <sbrk>
+    35be:	89 da                	mov    %ebx,%edx
+    35c0:	29 c2                	sub    %eax,%edx
+    35c2:	89 d0                	mov    %edx,%eax
+    35c4:	89 04 24             	mov    %eax,(%esp)
+    35c7:	e8 98 09 00 00       	call   3f64 <sbrk>
+
+  printf(stdout, "sbrk test OK\n");
+    35cc:	a1 10 63 00 00       	mov    0x6310,%eax
+    35d1:	c7 44 24 04 d5 59 00 	movl   $0x59d5,0x4(%esp)
+    35d8:	00 
+    35d9:	89 04 24             	mov    %eax,(%esp)
+    35dc:	e8 a0 0a 00 00       	call   4081 <printf>
+}
+    35e1:	81 c4 84 00 00 00    	add    $0x84,%esp
+    35e7:	5b                   	pop    %ebx
+    35e8:	5d                   	pop    %ebp
+    35e9:	c3                   	ret    
+
+000035ea <validateint>:
+
+void
+validateint(int *p)
+{
+    35ea:	55                   	push   %ebp
+    35eb:	89 e5                	mov    %esp,%ebp
+    35ed:	56                   	push   %esi
+    35ee:	53                   	push   %ebx
+    35ef:	83 ec 14             	sub    $0x14,%esp
+  int res;
+  asm("mov %%esp, %%ebx\n\t"
+    35f2:	c7 45 e4 0d 00 00 00 	movl   $0xd,-0x1c(%ebp)
+    35f9:	8b 55 08             	mov    0x8(%ebp),%edx
+    35fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    35ff:	89 d1                	mov    %edx,%ecx
+    3601:	89 e3                	mov    %esp,%ebx
+    3603:	89 cc                	mov    %ecx,%esp
+    3605:	cd 40                	int    $0x40
+    3607:	89 dc                	mov    %ebx,%esp
+    3609:	89 c6                	mov    %eax,%esi
+    360b:	89 75 f4             	mov    %esi,-0xc(%ebp)
+      "int %2\n\t"
+      "mov %%ebx, %%esp" :
+      "=a" (res) :
+      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+      "ebx");
+}
+    360e:	83 c4 14             	add    $0x14,%esp
+    3611:	5b                   	pop    %ebx
+    3612:	5e                   	pop    %esi
+    3613:	5d                   	pop    %ebp
+    3614:	c3                   	ret    
+
+00003615 <validatetest>:
+
+void
+validatetest(void)
+{
+    3615:	55                   	push   %ebp
+    3616:	89 e5                	mov    %esp,%ebp
+    3618:	83 ec 28             	sub    $0x28,%esp
+  int hi, pid;
+  uint p;
+
+  printf(stdout, "validate test\n");
+    361b:	a1 10 63 00 00       	mov    0x6310,%eax
+    3620:	c7 44 24 04 e3 59 00 	movl   $0x59e3,0x4(%esp)
+    3627:	00 
+    3628:	89 04 24             	mov    %eax,(%esp)
+    362b:	e8 51 0a 00 00       	call   4081 <printf>
+  hi = 1100*1024;
+    3630:	c7 45 f0 00 30 11 00 	movl   $0x113000,-0x10(%ebp)
+
+  for(p = 0; p <= (uint)hi; p += 4096){
+    3637:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    363e:	eb 7f                	jmp    36bf <validatetest+0xaa>
+    if((pid = fork()) == 0){
+    3640:	e8 8f 08 00 00       	call   3ed4 <fork>
+    3645:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    3648:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    364c:	75 10                	jne    365e <validatetest+0x49>
+      // try to crash the kernel by passing in a badly placed integer
+      validateint((int*)p);
+    364e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3651:	89 04 24             	mov    %eax,(%esp)
+    3654:	e8 91 ff ff ff       	call   35ea <validateint>
+      exit();
+    3659:	e8 7e 08 00 00       	call   3edc <exit>
+    }
+    sleep(0);
+    365e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3665:	e8 02 09 00 00       	call   3f6c <sleep>
+    sleep(0);
+    366a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3671:	e8 f6 08 00 00       	call   3f6c <sleep>
+    kill(pid);
+    3676:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    3679:	89 04 24             	mov    %eax,(%esp)
+    367c:	e8 8b 08 00 00       	call   3f0c <kill>
+    wait();
+    3681:	e8 5e 08 00 00       	call   3ee4 <wait>
+
+    // try to crash the kernel by passing in a bad string pointer
+    if(link("nosuchfile", (char*)p) != -1){
+    3686:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3689:	89 44 24 04          	mov    %eax,0x4(%esp)
+    368d:	c7 04 24 f2 59 00 00 	movl   $0x59f2,(%esp)
+    3694:	e8 a3 08 00 00       	call   3f3c <link>
+    3699:	83 f8 ff             	cmp    $0xffffffff,%eax
+    369c:	74 1a                	je     36b8 <validatetest+0xa3>
+      printf(stdout, "link should not succeed\n");
+    369e:	a1 10 63 00 00       	mov    0x6310,%eax
+    36a3:	c7 44 24 04 fd 59 00 	movl   $0x59fd,0x4(%esp)
+    36aa:	00 
+    36ab:	89 04 24             	mov    %eax,(%esp)
+    36ae:	e8 ce 09 00 00       	call   4081 <printf>
+      exit();
+    36b3:	e8 24 08 00 00       	call   3edc <exit>
+  uint p;
+
+  printf(stdout, "validate test\n");
+  hi = 1100*1024;
+
+  for(p = 0; p <= (uint)hi; p += 4096){
+    36b8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+    36bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    36c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    36c5:	0f 83 75 ff ff ff    	jae    3640 <validatetest+0x2b>
+      printf(stdout, "link should not succeed\n");
+      exit();
+    }
+  }
+
+  printf(stdout, "validate ok\n");
+    36cb:	a1 10 63 00 00       	mov    0x6310,%eax
+    36d0:	c7 44 24 04 16 5a 00 	movl   $0x5a16,0x4(%esp)
+    36d7:	00 
+    36d8:	89 04 24             	mov    %eax,(%esp)
+    36db:	e8 a1 09 00 00       	call   4081 <printf>
+}
+    36e0:	c9                   	leave  
+    36e1:	c3                   	ret    
+
+000036e2 <bsstest>:
+
+// does unintialized data start out zero?
+char uninit[10000];
+void
+bsstest(void)
+{
+    36e2:	55                   	push   %ebp
+    36e3:	89 e5                	mov    %esp,%ebp
+    36e5:	83 ec 28             	sub    $0x28,%esp
+  int i;
+
+  printf(stdout, "bss test\n");
+    36e8:	a1 10 63 00 00       	mov    0x6310,%eax
+    36ed:	c7 44 24 04 23 5a 00 	movl   $0x5a23,0x4(%esp)
+    36f4:	00 
+    36f5:	89 04 24             	mov    %eax,(%esp)
+    36f8:	e8 84 09 00 00       	call   4081 <printf>
+  for(i = 0; i < sizeof(uninit); i++){
+    36fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    3704:	eb 2d                	jmp    3733 <bsstest+0x51>
+    if(uninit[i] != '\0'){
+    3706:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3709:	05 e0 63 00 00       	add    $0x63e0,%eax
+    370e:	0f b6 00             	movzbl (%eax),%eax
+    3711:	84 c0                	test   %al,%al
+    3713:	74 1a                	je     372f <bsstest+0x4d>
+      printf(stdout, "bss test failed\n");
+    3715:	a1 10 63 00 00       	mov    0x6310,%eax
+    371a:	c7 44 24 04 2d 5a 00 	movl   $0x5a2d,0x4(%esp)
+    3721:	00 
+    3722:	89 04 24             	mov    %eax,(%esp)
+    3725:	e8 57 09 00 00       	call   4081 <printf>
+      exit();
+    372a:	e8 ad 07 00 00       	call   3edc <exit>
+bsstest(void)
+{
+  int i;
+
+  printf(stdout, "bss test\n");
+  for(i = 0; i < sizeof(uninit); i++){
+    372f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    3733:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3736:	3d 0f 27 00 00       	cmp    $0x270f,%eax
+    373b:	76 c9                	jbe    3706 <bsstest+0x24>
+    if(uninit[i] != '\0'){
+      printf(stdout, "bss test failed\n");
+      exit();
+    }
+  }
+  printf(stdout, "bss test ok\n");
+    373d:	a1 10 63 00 00       	mov    0x6310,%eax
+    3742:	c7 44 24 04 3e 5a 00 	movl   $0x5a3e,0x4(%esp)
+    3749:	00 
+    374a:	89 04 24             	mov    %eax,(%esp)
+    374d:	e8 2f 09 00 00       	call   4081 <printf>
+}
+    3752:	c9                   	leave  
+    3753:	c3                   	ret    
+
+00003754 <bigargtest>:
+// does exec return an error if the arguments
+// are larger than a page? or does it write
+// below the stack and wreck the instructions/data?
+void
+bigargtest(void)
+{
+    3754:	55                   	push   %ebp
+    3755:	89 e5                	mov    %esp,%ebp
+    3757:	83 ec 28             	sub    $0x28,%esp
+  int pid, fd;
+
+  unlink("bigarg-ok");
+    375a:	c7 04 24 4b 5a 00 00 	movl   $0x5a4b,(%esp)
+    3761:	e8 c6 07 00 00       	call   3f2c <unlink>
+  pid = fork();
+    3766:	e8 69 07 00 00       	call   3ed4 <fork>
+    376b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(pid == 0){
+    376e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3772:	0f 85 90 00 00 00    	jne    3808 <bigargtest+0xb4>
+    static char *args[MAXARG];
+    int i;
+    for(i = 0; i < MAXARG-1; i++)
+    3778:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    377f:	eb 12                	jmp    3793 <bigargtest+0x3f>
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    3781:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3784:	c7 04 85 40 63 00 00 	movl   $0x5a58,0x6340(,%eax,4)
+    378b:	58 5a 00 00 
+  unlink("bigarg-ok");
+  pid = fork();
+  if(pid == 0){
+    static char *args[MAXARG];
+    int i;
+    for(i = 0; i < MAXARG-1; i++)
+    378f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    3793:	83 7d f4 1e          	cmpl   $0x1e,-0xc(%ebp)
+    3797:	7e e8                	jle    3781 <bigargtest+0x2d>
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    args[MAXARG-1] = 0;
+    3799:	c7 05 bc 63 00 00 00 	movl   $0x0,0x63bc
+    37a0:	00 00 00 
+    printf(stdout, "bigarg test\n");
+    37a3:	a1 10 63 00 00       	mov    0x6310,%eax
+    37a8:	c7 44 24 04 35 5b 00 	movl   $0x5b35,0x4(%esp)
+    37af:	00 
+    37b0:	89 04 24             	mov    %eax,(%esp)
+    37b3:	e8 c9 08 00 00       	call   4081 <printf>
+    exec("echo", args);
+    37b8:	c7 44 24 04 40 63 00 	movl   $0x6340,0x4(%esp)
+    37bf:	00 
+    37c0:	c7 04 24 54 44 00 00 	movl   $0x4454,(%esp)
+    37c7:	e8 48 07 00 00       	call   3f14 <exec>
+    printf(stdout, "bigarg test ok\n");
+    37cc:	a1 10 63 00 00       	mov    0x6310,%eax
+    37d1:	c7 44 24 04 42 5b 00 	movl   $0x5b42,0x4(%esp)
+    37d8:	00 
+    37d9:	89 04 24             	mov    %eax,(%esp)
+    37dc:	e8 a0 08 00 00       	call   4081 <printf>
+    fd = open("bigarg-ok", O_CREATE);
+    37e1:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    37e8:	00 
+    37e9:	c7 04 24 4b 5a 00 00 	movl   $0x5a4b,(%esp)
+    37f0:	e8 27 07 00 00       	call   3f1c <open>
+    37f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    close(fd);
+    37f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    37fb:	89 04 24             	mov    %eax,(%esp)
+    37fe:	e8 01 07 00 00       	call   3f04 <close>
+    exit();
+    3803:	e8 d4 06 00 00       	call   3edc <exit>
+  } else if(pid < 0){
+    3808:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    380c:	79 1a                	jns    3828 <bigargtest+0xd4>
+    printf(stdout, "bigargtest: fork failed\n");
+    380e:	a1 10 63 00 00       	mov    0x6310,%eax
+    3813:	c7 44 24 04 52 5b 00 	movl   $0x5b52,0x4(%esp)
+    381a:	00 
+    381b:	89 04 24             	mov    %eax,(%esp)
+    381e:	e8 5e 08 00 00       	call   4081 <printf>
+    exit();
+    3823:	e8 b4 06 00 00       	call   3edc <exit>
+  }
+  wait();
+    3828:	e8 b7 06 00 00       	call   3ee4 <wait>
+  fd = open("bigarg-ok", 0);
+    382d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    3834:	00 
+    3835:	c7 04 24 4b 5a 00 00 	movl   $0x5a4b,(%esp)
+    383c:	e8 db 06 00 00       	call   3f1c <open>
+    3841:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+    3844:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    3848:	79 1a                	jns    3864 <bigargtest+0x110>
+    printf(stdout, "bigarg test failed!\n");
+    384a:	a1 10 63 00 00       	mov    0x6310,%eax
+    384f:	c7 44 24 04 6b 5b 00 	movl   $0x5b6b,0x4(%esp)
+    3856:	00 
+    3857:	89 04 24             	mov    %eax,(%esp)
+    385a:	e8 22 08 00 00       	call   4081 <printf>
+    exit();
+    385f:	e8 78 06 00 00       	call   3edc <exit>
+  }
+  close(fd);
+    3864:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    3867:	89 04 24             	mov    %eax,(%esp)
+    386a:	e8 95 06 00 00       	call   3f04 <close>
+  unlink("bigarg-ok");
+    386f:	c7 04 24 4b 5a 00 00 	movl   $0x5a4b,(%esp)
+    3876:	e8 b1 06 00 00       	call   3f2c <unlink>
+}
+    387b:	c9                   	leave  
+    387c:	c3                   	ret    
+
+0000387d <fsfull>:
+
+// what happens when the file system runs out of blocks?
+// answer: balloc panics, so this test is not useful.
+void
+fsfull()
+{
+    387d:	55                   	push   %ebp
+    387e:	89 e5                	mov    %esp,%ebp
+    3880:	53                   	push   %ebx
+    3881:	83 ec 74             	sub    $0x74,%esp
+  int nfiles;
+  int fsblocks = 0;
+    3884:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+
+  printf(1, "fsfull test\n");
+    388b:	c7 44 24 04 80 5b 00 	movl   $0x5b80,0x4(%esp)
+    3892:	00 
+    3893:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    389a:	e8 e2 07 00 00       	call   4081 <printf>
+
+  for(nfiles = 0; ; nfiles++){
+    389f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    char name[64];
+    name[0] = 'f';
+    38a6:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    38aa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    38ad:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    38b2:	89 c8                	mov    %ecx,%eax
+    38b4:	f7 ea                	imul   %edx
+    38b6:	c1 fa 06             	sar    $0x6,%edx
+    38b9:	89 c8                	mov    %ecx,%eax
+    38bb:	c1 f8 1f             	sar    $0x1f,%eax
+    38be:	89 d1                	mov    %edx,%ecx
+    38c0:	29 c1                	sub    %eax,%ecx
+    38c2:	89 c8                	mov    %ecx,%eax
+    38c4:	83 c0 30             	add    $0x30,%eax
+    38c7:	88 45 a5             	mov    %al,-0x5b(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    38ca:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    38cd:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    38d2:	89 d8                	mov    %ebx,%eax
+    38d4:	f7 ea                	imul   %edx
+    38d6:	c1 fa 06             	sar    $0x6,%edx
+    38d9:	89 d8                	mov    %ebx,%eax
+    38db:	c1 f8 1f             	sar    $0x1f,%eax
+    38de:	89 d1                	mov    %edx,%ecx
+    38e0:	29 c1                	sub    %eax,%ecx
+    38e2:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
+    38e8:	89 d9                	mov    %ebx,%ecx
+    38ea:	29 c1                	sub    %eax,%ecx
+    38ec:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    38f1:	89 c8                	mov    %ecx,%eax
+    38f3:	f7 ea                	imul   %edx
+    38f5:	c1 fa 05             	sar    $0x5,%edx
+    38f8:	89 c8                	mov    %ecx,%eax
+    38fa:	c1 f8 1f             	sar    $0x1f,%eax
+    38fd:	89 d1                	mov    %edx,%ecx
+    38ff:	29 c1                	sub    %eax,%ecx
+    3901:	89 c8                	mov    %ecx,%eax
+    3903:	83 c0 30             	add    $0x30,%eax
+    3906:	88 45 a6             	mov    %al,-0x5a(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    3909:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    390c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    3911:	89 d8                	mov    %ebx,%eax
+    3913:	f7 ea                	imul   %edx
+    3915:	c1 fa 05             	sar    $0x5,%edx
+    3918:	89 d8                	mov    %ebx,%eax
+    391a:	c1 f8 1f             	sar    $0x1f,%eax
+    391d:	89 d1                	mov    %edx,%ecx
+    391f:	29 c1                	sub    %eax,%ecx
+    3921:	6b c1 64             	imul   $0x64,%ecx,%eax
+    3924:	89 d9                	mov    %ebx,%ecx
+    3926:	29 c1                	sub    %eax,%ecx
+    3928:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    392d:	89 c8                	mov    %ecx,%eax
+    392f:	f7 ea                	imul   %edx
+    3931:	c1 fa 02             	sar    $0x2,%edx
+    3934:	89 c8                	mov    %ecx,%eax
+    3936:	c1 f8 1f             	sar    $0x1f,%eax
+    3939:	89 d1                	mov    %edx,%ecx
+    393b:	29 c1                	sub    %eax,%ecx
+    393d:	89 c8                	mov    %ecx,%eax
+    393f:	83 c0 30             	add    $0x30,%eax
+    3942:	88 45 a7             	mov    %al,-0x59(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    3945:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    3948:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    394d:	89 c8                	mov    %ecx,%eax
+    394f:	f7 ea                	imul   %edx
+    3951:	c1 fa 02             	sar    $0x2,%edx
+    3954:	89 c8                	mov    %ecx,%eax
+    3956:	c1 f8 1f             	sar    $0x1f,%eax
+    3959:	29 c2                	sub    %eax,%edx
+    395b:	89 d0                	mov    %edx,%eax
+    395d:	c1 e0 02             	shl    $0x2,%eax
+    3960:	01 d0                	add    %edx,%eax
+    3962:	01 c0                	add    %eax,%eax
+    3964:	89 ca                	mov    %ecx,%edx
+    3966:	29 c2                	sub    %eax,%edx
+    3968:	89 d0                	mov    %edx,%eax
+    396a:	83 c0 30             	add    $0x30,%eax
+    396d:	88 45 a8             	mov    %al,-0x58(%ebp)
+    name[5] = '\0';
+    3970:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
+    printf(1, "writing %s\n", name);
+    3974:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    3977:	89 44 24 08          	mov    %eax,0x8(%esp)
+    397b:	c7 44 24 04 8d 5b 00 	movl   $0x5b8d,0x4(%esp)
+    3982:	00 
+    3983:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    398a:	e8 f2 06 00 00       	call   4081 <printf>
+    int fd = open(name, O_CREATE|O_RDWR);
+    398f:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    3996:	00 
+    3997:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    399a:	89 04 24             	mov    %eax,(%esp)
+    399d:	e8 7a 05 00 00       	call   3f1c <open>
+    39a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(fd < 0){
+    39a5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    39a9:	79 20                	jns    39cb <fsfull+0x14e>
+      printf(1, "open %s failed\n", name);
+    39ab:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    39ae:	89 44 24 08          	mov    %eax,0x8(%esp)
+    39b2:	c7 44 24 04 99 5b 00 	movl   $0x5b99,0x4(%esp)
+    39b9:	00 
+    39ba:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    39c1:	e8 bb 06 00 00       	call   4081 <printf>
+    close(fd);
+    if(total == 0)
+      break;
+  }
+
+  while(nfiles >= 0){
+    39c6:	e9 51 01 00 00       	jmp    3b1c <fsfull+0x29f>
+    int fd = open(name, O_CREATE|O_RDWR);
+    if(fd < 0){
+      printf(1, "open %s failed\n", name);
+      break;
+    }
+    int total = 0;
+    39cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+    while(1){
+      int cc = write(fd, buf, 512);
+    39d2:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    39d9:	00 
+    39da:	c7 44 24 04 00 8b 00 	movl   $0x8b00,0x4(%esp)
+    39e1:	00 
+    39e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    39e5:	89 04 24             	mov    %eax,(%esp)
+    39e8:	e8 0f 05 00 00       	call   3efc <write>
+    39ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+      if(cc < 512)
+    39f0:	81 7d e4 ff 01 00 00 	cmpl   $0x1ff,-0x1c(%ebp)
+    39f7:	7e 0c                	jle    3a05 <fsfull+0x188>
+        break;
+      total += cc;
+    39f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    39fc:	01 45 ec             	add    %eax,-0x14(%ebp)
+      fsblocks++;
+    39ff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    }
+    3a03:	eb cd                	jmp    39d2 <fsfull+0x155>
+    }
+    int total = 0;
+    while(1){
+      int cc = write(fd, buf, 512);
+      if(cc < 512)
+        break;
+    3a05:	90                   	nop
+      total += cc;
+      fsblocks++;
+    }
+    printf(1, "wrote %d bytes\n", total);
+    3a06:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    3a09:	89 44 24 08          	mov    %eax,0x8(%esp)
+    3a0d:	c7 44 24 04 a9 5b 00 	movl   $0x5ba9,0x4(%esp)
+    3a14:	00 
+    3a15:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3a1c:	e8 60 06 00 00       	call   4081 <printf>
+    close(fd);
+    3a21:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    3a24:	89 04 24             	mov    %eax,(%esp)
+    3a27:	e8 d8 04 00 00       	call   3f04 <close>
+    if(total == 0)
+    3a2c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    3a30:	0f 84 e6 00 00 00    	je     3b1c <fsfull+0x29f>
+  int nfiles;
+  int fsblocks = 0;
+
+  printf(1, "fsfull test\n");
+
+  for(nfiles = 0; ; nfiles++){
+    3a36:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    }
+    printf(1, "wrote %d bytes\n", total);
+    close(fd);
+    if(total == 0)
+      break;
+  }
+    3a3a:	e9 67 fe ff ff       	jmp    38a6 <fsfull+0x29>
+
+  while(nfiles >= 0){
+    char name[64];
+    name[0] = 'f';
+    3a3f:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    3a43:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    3a46:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    3a4b:	89 c8                	mov    %ecx,%eax
+    3a4d:	f7 ea                	imul   %edx
+    3a4f:	c1 fa 06             	sar    $0x6,%edx
+    3a52:	89 c8                	mov    %ecx,%eax
+    3a54:	c1 f8 1f             	sar    $0x1f,%eax
+    3a57:	89 d1                	mov    %edx,%ecx
+    3a59:	29 c1                	sub    %eax,%ecx
+    3a5b:	89 c8                	mov    %ecx,%eax
+    3a5d:	83 c0 30             	add    $0x30,%eax
+    3a60:	88 45 a5             	mov    %al,-0x5b(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3a63:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    3a66:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    3a6b:	89 d8                	mov    %ebx,%eax
+    3a6d:	f7 ea                	imul   %edx
+    3a6f:	c1 fa 06             	sar    $0x6,%edx
+    3a72:	89 d8                	mov    %ebx,%eax
+    3a74:	c1 f8 1f             	sar    $0x1f,%eax
+    3a77:	89 d1                	mov    %edx,%ecx
+    3a79:	29 c1                	sub    %eax,%ecx
+    3a7b:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
+    3a81:	89 d9                	mov    %ebx,%ecx
+    3a83:	29 c1                	sub    %eax,%ecx
+    3a85:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    3a8a:	89 c8                	mov    %ecx,%eax
+    3a8c:	f7 ea                	imul   %edx
+    3a8e:	c1 fa 05             	sar    $0x5,%edx
+    3a91:	89 c8                	mov    %ecx,%eax
+    3a93:	c1 f8 1f             	sar    $0x1f,%eax
+    3a96:	89 d1                	mov    %edx,%ecx
+    3a98:	29 c1                	sub    %eax,%ecx
+    3a9a:	89 c8                	mov    %ecx,%eax
+    3a9c:	83 c0 30             	add    $0x30,%eax
+    3a9f:	88 45 a6             	mov    %al,-0x5a(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    3aa2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    3aa5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    3aaa:	89 d8                	mov    %ebx,%eax
+    3aac:	f7 ea                	imul   %edx
+    3aae:	c1 fa 05             	sar    $0x5,%edx
+    3ab1:	89 d8                	mov    %ebx,%eax
+    3ab3:	c1 f8 1f             	sar    $0x1f,%eax
+    3ab6:	89 d1                	mov    %edx,%ecx
+    3ab8:	29 c1                	sub    %eax,%ecx
+    3aba:	6b c1 64             	imul   $0x64,%ecx,%eax
+    3abd:	89 d9                	mov    %ebx,%ecx
+    3abf:	29 c1                	sub    %eax,%ecx
+    3ac1:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    3ac6:	89 c8                	mov    %ecx,%eax
+    3ac8:	f7 ea                	imul   %edx
+    3aca:	c1 fa 02             	sar    $0x2,%edx
+    3acd:	89 c8                	mov    %ecx,%eax
+    3acf:	c1 f8 1f             	sar    $0x1f,%eax
+    3ad2:	89 d1                	mov    %edx,%ecx
+    3ad4:	29 c1                	sub    %eax,%ecx
+    3ad6:	89 c8                	mov    %ecx,%eax
+    3ad8:	83 c0 30             	add    $0x30,%eax
+    3adb:	88 45 a7             	mov    %al,-0x59(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    3ade:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    3ae1:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    3ae6:	89 c8                	mov    %ecx,%eax
+    3ae8:	f7 ea                	imul   %edx
+    3aea:	c1 fa 02             	sar    $0x2,%edx
+    3aed:	89 c8                	mov    %ecx,%eax
+    3aef:	c1 f8 1f             	sar    $0x1f,%eax
+    3af2:	29 c2                	sub    %eax,%edx
+    3af4:	89 d0                	mov    %edx,%eax
+    3af6:	c1 e0 02             	shl    $0x2,%eax
+    3af9:	01 d0                	add    %edx,%eax
+    3afb:	01 c0                	add    %eax,%eax
+    3afd:	89 ca                	mov    %ecx,%edx
+    3aff:	29 c2                	sub    %eax,%edx
+    3b01:	89 d0                	mov    %edx,%eax
+    3b03:	83 c0 30             	add    $0x30,%eax
+    3b06:	88 45 a8             	mov    %al,-0x58(%ebp)
+    name[5] = '\0';
+    3b09:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
+    unlink(name);
+    3b0d:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    3b10:	89 04 24             	mov    %eax,(%esp)
+    3b13:	e8 14 04 00 00       	call   3f2c <unlink>
+    nfiles--;
+    3b18:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    close(fd);
+    if(total == 0)
+      break;
+  }
+
+  while(nfiles >= 0){
+    3b1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    3b20:	0f 89 19 ff ff ff    	jns    3a3f <fsfull+0x1c2>
+    name[5] = '\0';
+    unlink(name);
+    nfiles--;
+  }
+
+  printf(1, "fsfull test finished\n");
+    3b26:	c7 44 24 04 b9 5b 00 	movl   $0x5bb9,0x4(%esp)
+    3b2d:	00 
+    3b2e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3b35:	e8 47 05 00 00       	call   4081 <printf>
+}
+    3b3a:	83 c4 74             	add    $0x74,%esp
+    3b3d:	5b                   	pop    %ebx
+    3b3e:	5d                   	pop    %ebp
+    3b3f:	c3                   	ret    
+
+00003b40 <rand>:
+
+unsigned long randstate = 1;
+unsigned int
+rand()
+{
+    3b40:	55                   	push   %ebp
+    3b41:	89 e5                	mov    %esp,%ebp
+  randstate = randstate * 1664525 + 1013904223;
+    3b43:	a1 14 63 00 00       	mov    0x6314,%eax
+    3b48:	69 c0 0d 66 19 00    	imul   $0x19660d,%eax,%eax
+    3b4e:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
+    3b53:	a3 14 63 00 00       	mov    %eax,0x6314
+  return randstate;
+    3b58:	a1 14 63 00 00       	mov    0x6314,%eax
+}
+    3b5d:	5d                   	pop    %ebp
+    3b5e:	c3                   	ret    
+
+00003b5f <main>:
+
+int
+main(int argc, char *argv[])
+{
+    3b5f:	55                   	push   %ebp
+    3b60:	89 e5                	mov    %esp,%ebp
+    3b62:	83 e4 f0             	and    $0xfffffff0,%esp
+    3b65:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "usertests starting\n");
+    3b68:	c7 44 24 04 cf 5b 00 	movl   $0x5bcf,0x4(%esp)
+    3b6f:	00 
+    3b70:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3b77:	e8 05 05 00 00       	call   4081 <printf>
+
+  if(open("usertests.ran", 0) >= 0){
+    3b7c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    3b83:	00 
+    3b84:	c7 04 24 e3 5b 00 00 	movl   $0x5be3,(%esp)
+    3b8b:	e8 8c 03 00 00       	call   3f1c <open>
+    3b90:	85 c0                	test   %eax,%eax
+    3b92:	78 19                	js     3bad <main+0x4e>
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+    3b94:	c7 44 24 04 f4 5b 00 	movl   $0x5bf4,0x4(%esp)
+    3b9b:	00 
+    3b9c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3ba3:	e8 d9 04 00 00       	call   4081 <printf>
+    exit();
+    3ba8:	e8 2f 03 00 00       	call   3edc <exit>
+  }
+  close(open("usertests.ran", O_CREATE));
+    3bad:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    3bb4:	00 
+    3bb5:	c7 04 24 e3 5b 00 00 	movl   $0x5be3,(%esp)
+    3bbc:	e8 5b 03 00 00       	call   3f1c <open>
+    3bc1:	89 04 24             	mov    %eax,(%esp)
+    3bc4:	e8 3b 03 00 00       	call   3f04 <close>
+
+  createdelete();
+    3bc9:	e8 b3 d6 ff ff       	call   1281 <createdelete>
+  linkunlink();
+    3bce:	e8 fd e0 ff ff       	call   1cd0 <linkunlink>
+  concreate();
+    3bd3:	e8 3f dd ff ff       	call   1917 <concreate>
+  fourfiles();
+    3bd8:	e8 3c d4 ff ff       	call   1019 <fourfiles>
+  sharedfd();
+    3bdd:	e8 39 d2 ff ff       	call   e1b <sharedfd>
+
+  bigargtest();
+    3be2:	e8 6d fb ff ff       	call   3754 <bigargtest>
+  bigwrite();
+    3be7:	e8 d1 ea ff ff       	call   26bd <bigwrite>
+  bigargtest();
+    3bec:	e8 63 fb ff ff       	call   3754 <bigargtest>
+  bsstest();
+    3bf1:	e8 ec fa ff ff       	call   36e2 <bsstest>
+  sbrktest();
+    3bf6:	e8 f6 f4 ff ff       	call   30f1 <sbrktest>
+  validatetest();
+    3bfb:	e8 15 fa ff ff       	call   3615 <validatetest>
+
+  opentest();
+    3c00:	e8 c2 c6 ff ff       	call   2c7 <opentest>
+  writetest();
+    3c05:	e8 68 c7 ff ff       	call   372 <writetest>
+  writetest1();
+    3c0a:	e8 78 c9 ff ff       	call   587 <writetest1>
+  createtest();
+    3c0f:	e8 7c cb ff ff       	call   790 <createtest>
+
+  openiputtest();
+    3c14:	e8 ad c5 ff ff       	call   1c6 <openiputtest>
+  exitiputtest();
+    3c19:	e8 bc c4 ff ff       	call   da <exitiputtest>
+  iputtest();
+    3c1e:	e8 dd c3 ff ff       	call   0 <iputtest>
+
+  mem();
+    3c23:	e8 0e d1 ff ff       	call   d36 <mem>
+  pipe1();
+    3c28:	e8 44 cd ff ff       	call   971 <pipe1>
+  preempt();
+    3c2d:	e8 2d cf ff ff       	call   b5f <preempt>
+  exitwait();
+    3c32:	e8 81 d0 ff ff       	call   cb8 <exitwait>
+
+  rmdot();
+    3c37:	e8 04 ef ff ff       	call   2b40 <rmdot>
+  fourteen();
+    3c3c:	e8 a9 ed ff ff       	call   29ea <fourteen>
+  bigfile();
+    3c41:	e8 7f eb ff ff       	call   27c5 <bigfile>
+  subdir();
+    3c46:	e8 2c e3 ff ff       	call   1f77 <subdir>
+  linktest();
+    3c4b:	e8 7e da ff ff       	call   16ce <linktest>
+  unlinkread();
+    3c50:	e8 a4 d8 ff ff       	call   14f9 <unlinkread>
+  dirfile();
+    3c55:	e8 5e f0 ff ff       	call   2cb8 <dirfile>
+  iref();
+    3c5a:	e8 9b f2 ff ff       	call   2efa <iref>
+  forktest();
+    3c5f:	e8 ba f3 ff ff       	call   301e <forktest>
+  bigdir(); // slow
+    3c64:	e8 95 e1 ff ff       	call   1dfe <bigdir>
+  exectest();
+    3c69:	e8 b4 cc ff ff       	call   922 <exectest>
+
+  exit();
+    3c6e:	e8 69 02 00 00       	call   3edc <exit>
+    3c73:	90                   	nop
+
+00003c74 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+    3c74:	55                   	push   %ebp
+    3c75:	89 e5                	mov    %esp,%ebp
+    3c77:	57                   	push   %edi
+    3c78:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+    3c79:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    3c7c:	8b 55 10             	mov    0x10(%ebp),%edx
+    3c7f:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3c82:	89 cb                	mov    %ecx,%ebx
+    3c84:	89 df                	mov    %ebx,%edi
+    3c86:	89 d1                	mov    %edx,%ecx
+    3c88:	fc                   	cld    
+    3c89:	f3 aa                	rep stos %al,%es:(%edi)
+    3c8b:	89 ca                	mov    %ecx,%edx
+    3c8d:	89 fb                	mov    %edi,%ebx
+    3c8f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+    3c92:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+    3c95:	5b                   	pop    %ebx
+    3c96:	5f                   	pop    %edi
+    3c97:	5d                   	pop    %ebp
+    3c98:	c3                   	ret    
+
+00003c99 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    3c99:	55                   	push   %ebp
+    3c9a:	89 e5                	mov    %esp,%ebp
+    3c9c:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+    3c9f:	8b 45 08             	mov    0x8(%ebp),%eax
+    3ca2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+    3ca5:	90                   	nop
+    3ca6:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3ca9:	0f b6 10             	movzbl (%eax),%edx
+    3cac:	8b 45 08             	mov    0x8(%ebp),%eax
+    3caf:	88 10                	mov    %dl,(%eax)
+    3cb1:	8b 45 08             	mov    0x8(%ebp),%eax
+    3cb4:	0f b6 00             	movzbl (%eax),%eax
+    3cb7:	84 c0                	test   %al,%al
+    3cb9:	0f 95 c0             	setne  %al
+    3cbc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    3cc0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+    3cc4:	84 c0                	test   %al,%al
+    3cc6:	75 de                	jne    3ca6 <strcpy+0xd>
+    ;
+  return os;
+    3cc8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+    3ccb:	c9                   	leave  
+    3ccc:	c3                   	ret    
+
+00003ccd <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    3ccd:	55                   	push   %ebp
+    3cce:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+    3cd0:	eb 08                	jmp    3cda <strcmp+0xd>
+    p++, q++;
+    3cd2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    3cd6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+    3cda:	8b 45 08             	mov    0x8(%ebp),%eax
+    3cdd:	0f b6 00             	movzbl (%eax),%eax
+    3ce0:	84 c0                	test   %al,%al
+    3ce2:	74 10                	je     3cf4 <strcmp+0x27>
+    3ce4:	8b 45 08             	mov    0x8(%ebp),%eax
+    3ce7:	0f b6 10             	movzbl (%eax),%edx
+    3cea:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3ced:	0f b6 00             	movzbl (%eax),%eax
+    3cf0:	38 c2                	cmp    %al,%dl
+    3cf2:	74 de                	je     3cd2 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+    3cf4:	8b 45 08             	mov    0x8(%ebp),%eax
+    3cf7:	0f b6 00             	movzbl (%eax),%eax
+    3cfa:	0f b6 d0             	movzbl %al,%edx
+    3cfd:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3d00:	0f b6 00             	movzbl (%eax),%eax
+    3d03:	0f b6 c0             	movzbl %al,%eax
+    3d06:	89 d1                	mov    %edx,%ecx
+    3d08:	29 c1                	sub    %eax,%ecx
+    3d0a:	89 c8                	mov    %ecx,%eax
+}
+    3d0c:	5d                   	pop    %ebp
+    3d0d:	c3                   	ret    
+
+00003d0e <strlen>:
+
+uint
+strlen(char *s)
+{
+    3d0e:	55                   	push   %ebp
+    3d0f:	89 e5                	mov    %esp,%ebp
+    3d11:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+    3d14:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    3d1b:	eb 04                	jmp    3d21 <strlen+0x13>
+    3d1d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    3d21:	8b 55 fc             	mov    -0x4(%ebp),%edx
+    3d24:	8b 45 08             	mov    0x8(%ebp),%eax
+    3d27:	01 d0                	add    %edx,%eax
+    3d29:	0f b6 00             	movzbl (%eax),%eax
+    3d2c:	84 c0                	test   %al,%al
+    3d2e:	75 ed                	jne    3d1d <strlen+0xf>
+    ;
+  return n;
+    3d30:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+    3d33:	c9                   	leave  
+    3d34:	c3                   	ret    
+
+00003d35 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    3d35:	55                   	push   %ebp
+    3d36:	89 e5                	mov    %esp,%ebp
+    3d38:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+    3d3b:	8b 45 10             	mov    0x10(%ebp),%eax
+    3d3e:	89 44 24 08          	mov    %eax,0x8(%esp)
+    3d42:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3d45:	89 44 24 04          	mov    %eax,0x4(%esp)
+    3d49:	8b 45 08             	mov    0x8(%ebp),%eax
+    3d4c:	89 04 24             	mov    %eax,(%esp)
+    3d4f:	e8 20 ff ff ff       	call   3c74 <stosb>
+  return dst;
+    3d54:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+    3d57:	c9                   	leave  
+    3d58:	c3                   	ret    
+
+00003d59 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    3d59:	55                   	push   %ebp
+    3d5a:	89 e5                	mov    %esp,%ebp
+    3d5c:	83 ec 04             	sub    $0x4,%esp
+    3d5f:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3d62:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+    3d65:	eb 14                	jmp    3d7b <strchr+0x22>
+    if(*s == c)
+    3d67:	8b 45 08             	mov    0x8(%ebp),%eax
+    3d6a:	0f b6 00             	movzbl (%eax),%eax
+    3d6d:	3a 45 fc             	cmp    -0x4(%ebp),%al
+    3d70:	75 05                	jne    3d77 <strchr+0x1e>
+      return (char*)s;
+    3d72:	8b 45 08             	mov    0x8(%ebp),%eax
+    3d75:	eb 13                	jmp    3d8a <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+    3d77:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    3d7b:	8b 45 08             	mov    0x8(%ebp),%eax
+    3d7e:	0f b6 00             	movzbl (%eax),%eax
+    3d81:	84 c0                	test   %al,%al
+    3d83:	75 e2                	jne    3d67 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+    3d85:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+    3d8a:	c9                   	leave  
+    3d8b:	c3                   	ret    
+
+00003d8c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    3d8c:	55                   	push   %ebp
+    3d8d:	89 e5                	mov    %esp,%ebp
+    3d8f:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    3d92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    3d99:	eb 46                	jmp    3de1 <gets+0x55>
+    cc = read(0, &c, 1);
+    3d9b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    3da2:	00 
+    3da3:	8d 45 ef             	lea    -0x11(%ebp),%eax
+    3da6:	89 44 24 04          	mov    %eax,0x4(%esp)
+    3daa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3db1:	e8 3e 01 00 00       	call   3ef4 <read>
+    3db6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+    3db9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3dbd:	7e 2f                	jle    3dee <gets+0x62>
+      break;
+    buf[i++] = c;
+    3dbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    3dc2:	8b 45 08             	mov    0x8(%ebp),%eax
+    3dc5:	01 c2                	add    %eax,%edx
+    3dc7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    3dcb:	88 02                	mov    %al,(%edx)
+    3dcd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+    3dd1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    3dd5:	3c 0a                	cmp    $0xa,%al
+    3dd7:	74 16                	je     3def <gets+0x63>
+    3dd9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    3ddd:	3c 0d                	cmp    $0xd,%al
+    3ddf:	74 0e                	je     3def <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    3de1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3de4:	83 c0 01             	add    $0x1,%eax
+    3de7:	3b 45 0c             	cmp    0xc(%ebp),%eax
+    3dea:	7c af                	jl     3d9b <gets+0xf>
+    3dec:	eb 01                	jmp    3def <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    3dee:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+    3def:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    3df2:	8b 45 08             	mov    0x8(%ebp),%eax
+    3df5:	01 d0                	add    %edx,%eax
+    3df7:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+    3dfa:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+    3dfd:	c9                   	leave  
+    3dfe:	c3                   	ret    
+
+00003dff <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    3dff:	55                   	push   %ebp
+    3e00:	89 e5                	mov    %esp,%ebp
+    3e02:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    3e05:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    3e0c:	00 
+    3e0d:	8b 45 08             	mov    0x8(%ebp),%eax
+    3e10:	89 04 24             	mov    %eax,(%esp)
+    3e13:	e8 04 01 00 00       	call   3f1c <open>
+    3e18:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+    3e1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    3e1f:	79 07                	jns    3e28 <stat+0x29>
+    return -1;
+    3e21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    3e26:	eb 23                	jmp    3e4b <stat+0x4c>
+  r = fstat(fd, st);
+    3e28:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3e2b:	89 44 24 04          	mov    %eax,0x4(%esp)
+    3e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3e32:	89 04 24             	mov    %eax,(%esp)
+    3e35:	e8 fa 00 00 00       	call   3f34 <fstat>
+    3e3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+    3e3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3e40:	89 04 24             	mov    %eax,(%esp)
+    3e43:	e8 bc 00 00 00       	call   3f04 <close>
+  return r;
+    3e48:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+    3e4b:	c9                   	leave  
+    3e4c:	c3                   	ret    
+
+00003e4d <atoi>:
+
+int
+atoi(const char *s)
+{
+    3e4d:	55                   	push   %ebp
+    3e4e:	89 e5                	mov    %esp,%ebp
+    3e50:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+    3e53:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+    3e5a:	eb 23                	jmp    3e7f <atoi+0x32>
+    n = n*10 + *s++ - '0';
+    3e5c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+    3e5f:	89 d0                	mov    %edx,%eax
+    3e61:	c1 e0 02             	shl    $0x2,%eax
+    3e64:	01 d0                	add    %edx,%eax
+    3e66:	01 c0                	add    %eax,%eax
+    3e68:	89 c2                	mov    %eax,%edx
+    3e6a:	8b 45 08             	mov    0x8(%ebp),%eax
+    3e6d:	0f b6 00             	movzbl (%eax),%eax
+    3e70:	0f be c0             	movsbl %al,%eax
+    3e73:	01 d0                	add    %edx,%eax
+    3e75:	83 e8 30             	sub    $0x30,%eax
+    3e78:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    3e7b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    3e7f:	8b 45 08             	mov    0x8(%ebp),%eax
+    3e82:	0f b6 00             	movzbl (%eax),%eax
+    3e85:	3c 2f                	cmp    $0x2f,%al
+    3e87:	7e 0a                	jle    3e93 <atoi+0x46>
+    3e89:	8b 45 08             	mov    0x8(%ebp),%eax
+    3e8c:	0f b6 00             	movzbl (%eax),%eax
+    3e8f:	3c 39                	cmp    $0x39,%al
+    3e91:	7e c9                	jle    3e5c <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+    3e93:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+    3e96:	c9                   	leave  
+    3e97:	c3                   	ret    
+
+00003e98 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    3e98:	55                   	push   %ebp
+    3e99:	89 e5                	mov    %esp,%ebp
+    3e9b:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+    3e9e:	8b 45 08             	mov    0x8(%ebp),%eax
+    3ea1:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+    3ea4:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3ea7:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+    3eaa:	eb 13                	jmp    3ebf <memmove+0x27>
+    *dst++ = *src++;
+    3eac:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    3eaf:	0f b6 10             	movzbl (%eax),%edx
+    3eb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    3eb5:	88 10                	mov    %dl,(%eax)
+    3eb7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    3ebb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    3ebf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+    3ec3:	0f 9f c0             	setg   %al
+    3ec6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+    3eca:	84 c0                	test   %al,%al
+    3ecc:	75 de                	jne    3eac <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+    3ece:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+    3ed1:	c9                   	leave  
+    3ed2:	c3                   	ret    
+    3ed3:	90                   	nop
+
+00003ed4 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    3ed4:	b8 01 00 00 00       	mov    $0x1,%eax
+    3ed9:	cd 40                	int    $0x40
+    3edb:	c3                   	ret    
+
+00003edc <exit>:
+SYSCALL(exit)
+    3edc:	b8 02 00 00 00       	mov    $0x2,%eax
+    3ee1:	cd 40                	int    $0x40
+    3ee3:	c3                   	ret    
+
+00003ee4 <wait>:
+SYSCALL(wait)
+    3ee4:	b8 03 00 00 00       	mov    $0x3,%eax
+    3ee9:	cd 40                	int    $0x40
+    3eeb:	c3                   	ret    
+
+00003eec <pipe>:
+SYSCALL(pipe)
+    3eec:	b8 04 00 00 00       	mov    $0x4,%eax
+    3ef1:	cd 40                	int    $0x40
+    3ef3:	c3                   	ret    
+
+00003ef4 <read>:
+SYSCALL(read)
+    3ef4:	b8 05 00 00 00       	mov    $0x5,%eax
+    3ef9:	cd 40                	int    $0x40
+    3efb:	c3                   	ret    
+
+00003efc <write>:
+SYSCALL(write)
+    3efc:	b8 10 00 00 00       	mov    $0x10,%eax
+    3f01:	cd 40                	int    $0x40
+    3f03:	c3                   	ret    
+
+00003f04 <close>:
+SYSCALL(close)
+    3f04:	b8 15 00 00 00       	mov    $0x15,%eax
+    3f09:	cd 40                	int    $0x40
+    3f0b:	c3                   	ret    
+
+00003f0c <kill>:
+SYSCALL(kill)
+    3f0c:	b8 06 00 00 00       	mov    $0x6,%eax
+    3f11:	cd 40                	int    $0x40
+    3f13:	c3                   	ret    
+
+00003f14 <exec>:
+SYSCALL(exec)
+    3f14:	b8 07 00 00 00       	mov    $0x7,%eax
+    3f19:	cd 40                	int    $0x40
+    3f1b:	c3                   	ret    
+
+00003f1c <open>:
+SYSCALL(open)
+    3f1c:	b8 0f 00 00 00       	mov    $0xf,%eax
+    3f21:	cd 40                	int    $0x40
+    3f23:	c3                   	ret    
+
+00003f24 <mknod>:
+SYSCALL(mknod)
+    3f24:	b8 11 00 00 00       	mov    $0x11,%eax
+    3f29:	cd 40                	int    $0x40
+    3f2b:	c3                   	ret    
+
+00003f2c <unlink>:
+SYSCALL(unlink)
+    3f2c:	b8 12 00 00 00       	mov    $0x12,%eax
+    3f31:	cd 40                	int    $0x40
+    3f33:	c3                   	ret    
+
+00003f34 <fstat>:
+SYSCALL(fstat)
+    3f34:	b8 08 00 00 00       	mov    $0x8,%eax
+    3f39:	cd 40                	int    $0x40
+    3f3b:	c3                   	ret    
+
+00003f3c <link>:
+SYSCALL(link)
+    3f3c:	b8 13 00 00 00       	mov    $0x13,%eax
+    3f41:	cd 40                	int    $0x40
+    3f43:	c3                   	ret    
+
+00003f44 <mkdir>:
+SYSCALL(mkdir)
+    3f44:	b8 14 00 00 00       	mov    $0x14,%eax
+    3f49:	cd 40                	int    $0x40
+    3f4b:	c3                   	ret    
+
+00003f4c <chdir>:
+SYSCALL(chdir)
+    3f4c:	b8 09 00 00 00       	mov    $0x9,%eax
+    3f51:	cd 40                	int    $0x40
+    3f53:	c3                   	ret    
+
+00003f54 <dup>:
+SYSCALL(dup)
+    3f54:	b8 0a 00 00 00       	mov    $0xa,%eax
+    3f59:	cd 40                	int    $0x40
+    3f5b:	c3                   	ret    
+
+00003f5c <getpid>:
+SYSCALL(getpid)
+    3f5c:	b8 0b 00 00 00       	mov    $0xb,%eax
+    3f61:	cd 40                	int    $0x40
+    3f63:	c3                   	ret    
+
+00003f64 <sbrk>:
+SYSCALL(sbrk)
+    3f64:	b8 0c 00 00 00       	mov    $0xc,%eax
+    3f69:	cd 40                	int    $0x40
+    3f6b:	c3                   	ret    
+
+00003f6c <sleep>:
+SYSCALL(sleep)
+    3f6c:	b8 0d 00 00 00       	mov    $0xd,%eax
+    3f71:	cd 40                	int    $0x40
+    3f73:	c3                   	ret    
+
+00003f74 <uptime>:
+SYSCALL(uptime)
+    3f74:	b8 0e 00 00 00       	mov    $0xe,%eax
+    3f79:	cd 40                	int    $0x40
+    3f7b:	c3                   	ret    
+
+00003f7c <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+    3f7c:	b8 16 00 00 00       	mov    $0x16,%eax
+    3f81:	cd 40                	int    $0x40
+    3f83:	c3                   	ret    
+
+00003f84 <shutdown>:
+SYSCALL(shutdown)
+    3f84:	b8 17 00 00 00       	mov    $0x17,%eax
+    3f89:	cd 40                	int    $0x40
+    3f8b:	c3                   	ret    
+
+00003f8c <fork_winner>:
+SYSCALL(fork_winner)
+    3f8c:	b8 18 00 00 00       	mov    $0x18,%eax
+    3f91:	cd 40                	int    $0x40
+    3f93:	c3                   	ret    
+
+00003f94 <set_sched>:
+SYSCALL(set_sched)
+    3f94:	b8 19 00 00 00       	mov    $0x19,%eax
+    3f99:	cd 40                	int    $0x40
+    3f9b:	c3                   	ret    
+
+00003f9c <set_priority>:
+SYSCALL(set_priority)
+    3f9c:	b8 1a 00 00 00       	mov    $0x1a,%eax
+    3fa1:	cd 40                	int    $0x40
+    3fa3:	c3                   	ret    
+
+00003fa4 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+    3fa4:	55                   	push   %ebp
+    3fa5:	89 e5                	mov    %esp,%ebp
+    3fa7:	83 ec 28             	sub    $0x28,%esp
+    3faa:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3fad:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+    3fb0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    3fb7:	00 
+    3fb8:	8d 45 f4             	lea    -0xc(%ebp),%eax
+    3fbb:	89 44 24 04          	mov    %eax,0x4(%esp)
+    3fbf:	8b 45 08             	mov    0x8(%ebp),%eax
+    3fc2:	89 04 24             	mov    %eax,(%esp)
+    3fc5:	e8 32 ff ff ff       	call   3efc <write>
+}
+    3fca:	c9                   	leave  
+    3fcb:	c3                   	ret    
+
+00003fcc <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    3fcc:	55                   	push   %ebp
+    3fcd:	89 e5                	mov    %esp,%ebp
+    3fcf:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+    3fd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+    3fd9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+    3fdd:	74 17                	je     3ff6 <printint+0x2a>
+    3fdf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+    3fe3:	79 11                	jns    3ff6 <printint+0x2a>
+    neg = 1;
+    3fe5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+    3fec:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3fef:	f7 d8                	neg    %eax
+    3ff1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    3ff4:	eb 06                	jmp    3ffc <printint+0x30>
+  } else {
+    x = xx;
+    3ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3ff9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+    3ffc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+    4003:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    4006:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    4009:	ba 00 00 00 00       	mov    $0x0,%edx
+    400e:	f7 f1                	div    %ecx
+    4010:	89 d0                	mov    %edx,%eax
+    4012:	0f b6 80 18 63 00 00 	movzbl 0x6318(%eax),%eax
+    4019:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+    401c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    401f:	01 ca                	add    %ecx,%edx
+    4021:	88 02                	mov    %al,(%edx)
+    4023:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+    4027:	8b 55 10             	mov    0x10(%ebp),%edx
+    402a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    402d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    4030:	ba 00 00 00 00       	mov    $0x0,%edx
+    4035:	f7 75 d4             	divl   -0x2c(%ebp)
+    4038:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    403b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    403f:	75 c2                	jne    4003 <printint+0x37>
+  if(neg)
+    4041:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    4045:	74 2e                	je     4075 <printint+0xa9>
+    buf[i++] = '-';
+    4047:	8d 55 dc             	lea    -0x24(%ebp),%edx
+    404a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    404d:	01 d0                	add    %edx,%eax
+    404f:	c6 00 2d             	movb   $0x2d,(%eax)
+    4052:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+    4056:	eb 1d                	jmp    4075 <printint+0xa9>
+    putc(fd, buf[i]);
+    4058:	8d 55 dc             	lea    -0x24(%ebp),%edx
+    405b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    405e:	01 d0                	add    %edx,%eax
+    4060:	0f b6 00             	movzbl (%eax),%eax
+    4063:	0f be c0             	movsbl %al,%eax
+    4066:	89 44 24 04          	mov    %eax,0x4(%esp)
+    406a:	8b 45 08             	mov    0x8(%ebp),%eax
+    406d:	89 04 24             	mov    %eax,(%esp)
+    4070:	e8 2f ff ff ff       	call   3fa4 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+    4075:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    4079:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    407d:	79 d9                	jns    4058 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+    407f:	c9                   	leave  
+    4080:	c3                   	ret    
+
+00004081 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    4081:	55                   	push   %ebp
+    4082:	89 e5                	mov    %esp,%ebp
+    4084:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    4087:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+    408e:	8d 45 0c             	lea    0xc(%ebp),%eax
+    4091:	83 c0 04             	add    $0x4,%eax
+    4094:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+    4097:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    409e:	e9 7d 01 00 00       	jmp    4220 <printf+0x19f>
+    c = fmt[i] & 0xff;
+    40a3:	8b 55 0c             	mov    0xc(%ebp),%edx
+    40a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    40a9:	01 d0                	add    %edx,%eax
+    40ab:	0f b6 00             	movzbl (%eax),%eax
+    40ae:	0f be c0             	movsbl %al,%eax
+    40b1:	25 ff 00 00 00       	and    $0xff,%eax
+    40b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+    40b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    40bd:	75 2c                	jne    40eb <printf+0x6a>
+      if(c == '%'){
+    40bf:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    40c3:	75 0c                	jne    40d1 <printf+0x50>
+        state = '%';
+    40c5:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+    40cc:	e9 4b 01 00 00       	jmp    421c <printf+0x19b>
+      } else {
+        putc(fd, c);
+    40d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    40d4:	0f be c0             	movsbl %al,%eax
+    40d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    40db:	8b 45 08             	mov    0x8(%ebp),%eax
+    40de:	89 04 24             	mov    %eax,(%esp)
+    40e1:	e8 be fe ff ff       	call   3fa4 <putc>
+    40e6:	e9 31 01 00 00       	jmp    421c <printf+0x19b>
+      }
+    } else if(state == '%'){
+    40eb:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+    40ef:	0f 85 27 01 00 00    	jne    421c <printf+0x19b>
+      if(c == 'd'){
+    40f5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+    40f9:	75 2d                	jne    4128 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+    40fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    40fe:	8b 00                	mov    (%eax),%eax
+    4100:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+    4107:	00 
+    4108:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    410f:	00 
+    4110:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4114:	8b 45 08             	mov    0x8(%ebp),%eax
+    4117:	89 04 24             	mov    %eax,(%esp)
+    411a:	e8 ad fe ff ff       	call   3fcc <printint>
+        ap++;
+    411f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    4123:	e9 ed 00 00 00       	jmp    4215 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+    4128:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+    412c:	74 06                	je     4134 <printf+0xb3>
+    412e:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+    4132:	75 2d                	jne    4161 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+    4134:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    4137:	8b 00                	mov    (%eax),%eax
+    4139:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    4140:	00 
+    4141:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+    4148:	00 
+    4149:	89 44 24 04          	mov    %eax,0x4(%esp)
+    414d:	8b 45 08             	mov    0x8(%ebp),%eax
+    4150:	89 04 24             	mov    %eax,(%esp)
+    4153:	e8 74 fe ff ff       	call   3fcc <printint>
+        ap++;
+    4158:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    415c:	e9 b4 00 00 00       	jmp    4215 <printf+0x194>
+      } else if(c == 's'){
+    4161:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+    4165:	75 46                	jne    41ad <printf+0x12c>
+        s = (char*)*ap;
+    4167:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    416a:	8b 00                	mov    (%eax),%eax
+    416c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+    416f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+    4173:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    4177:	75 27                	jne    41a0 <printf+0x11f>
+          s = "(null)";
+    4179:	c7 45 f4 1e 5c 00 00 	movl   $0x5c1e,-0xc(%ebp)
+        while(*s != 0){
+    4180:	eb 1e                	jmp    41a0 <printf+0x11f>
+          putc(fd, *s);
+    4182:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4185:	0f b6 00             	movzbl (%eax),%eax
+    4188:	0f be c0             	movsbl %al,%eax
+    418b:	89 44 24 04          	mov    %eax,0x4(%esp)
+    418f:	8b 45 08             	mov    0x8(%ebp),%eax
+    4192:	89 04 24             	mov    %eax,(%esp)
+    4195:	e8 0a fe ff ff       	call   3fa4 <putc>
+          s++;
+    419a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    419e:	eb 01                	jmp    41a1 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+    41a0:	90                   	nop
+    41a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    41a4:	0f b6 00             	movzbl (%eax),%eax
+    41a7:	84 c0                	test   %al,%al
+    41a9:	75 d7                	jne    4182 <printf+0x101>
+    41ab:	eb 68                	jmp    4215 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    41ad:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+    41b1:	75 1d                	jne    41d0 <printf+0x14f>
+        putc(fd, *ap);
+    41b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    41b6:	8b 00                	mov    (%eax),%eax
+    41b8:	0f be c0             	movsbl %al,%eax
+    41bb:	89 44 24 04          	mov    %eax,0x4(%esp)
+    41bf:	8b 45 08             	mov    0x8(%ebp),%eax
+    41c2:	89 04 24             	mov    %eax,(%esp)
+    41c5:	e8 da fd ff ff       	call   3fa4 <putc>
+        ap++;
+    41ca:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    41ce:	eb 45                	jmp    4215 <printf+0x194>
+      } else if(c == '%'){
+    41d0:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    41d4:	75 17                	jne    41ed <printf+0x16c>
+        putc(fd, c);
+    41d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    41d9:	0f be c0             	movsbl %al,%eax
+    41dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    41e0:	8b 45 08             	mov    0x8(%ebp),%eax
+    41e3:	89 04 24             	mov    %eax,(%esp)
+    41e6:	e8 b9 fd ff ff       	call   3fa4 <putc>
+    41eb:	eb 28                	jmp    4215 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+    41ed:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+    41f4:	00 
+    41f5:	8b 45 08             	mov    0x8(%ebp),%eax
+    41f8:	89 04 24             	mov    %eax,(%esp)
+    41fb:	e8 a4 fd ff ff       	call   3fa4 <putc>
+        putc(fd, c);
+    4200:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    4203:	0f be c0             	movsbl %al,%eax
+    4206:	89 44 24 04          	mov    %eax,0x4(%esp)
+    420a:	8b 45 08             	mov    0x8(%ebp),%eax
+    420d:	89 04 24             	mov    %eax,(%esp)
+    4210:	e8 8f fd ff ff       	call   3fa4 <putc>
+      }
+      state = 0;
+    4215:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    421c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    4220:	8b 55 0c             	mov    0xc(%ebp),%edx
+    4223:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    4226:	01 d0                	add    %edx,%eax
+    4228:	0f b6 00             	movzbl (%eax),%eax
+    422b:	84 c0                	test   %al,%al
+    422d:	0f 85 70 fe ff ff    	jne    40a3 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+    4233:	c9                   	leave  
+    4234:	c3                   	ret    
+    4235:	90                   	nop
+    4236:	90                   	nop
+    4237:	90                   	nop
+
+00004238 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    4238:	55                   	push   %ebp
+    4239:	89 e5                	mov    %esp,%ebp
+    423b:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+    423e:	8b 45 08             	mov    0x8(%ebp),%eax
+    4241:	83 e8 08             	sub    $0x8,%eax
+    4244:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    4247:	a1 c8 63 00 00       	mov    0x63c8,%eax
+    424c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    424f:	eb 24                	jmp    4275 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    4251:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4254:	8b 00                	mov    (%eax),%eax
+    4256:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    4259:	77 12                	ja     426d <free+0x35>
+    425b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    425e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    4261:	77 24                	ja     4287 <free+0x4f>
+    4263:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4266:	8b 00                	mov    (%eax),%eax
+    4268:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+    426b:	77 1a                	ja     4287 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    426d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4270:	8b 00                	mov    (%eax),%eax
+    4272:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    4275:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    4278:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    427b:	76 d4                	jbe    4251 <free+0x19>
+    427d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4280:	8b 00                	mov    (%eax),%eax
+    4282:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+    4285:	76 ca                	jbe    4251 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    4287:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    428a:	8b 40 04             	mov    0x4(%eax),%eax
+    428d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    4294:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    4297:	01 c2                	add    %eax,%edx
+    4299:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    429c:	8b 00                	mov    (%eax),%eax
+    429e:	39 c2                	cmp    %eax,%edx
+    42a0:	75 24                	jne    42c6 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+    42a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    42a5:	8b 50 04             	mov    0x4(%eax),%edx
+    42a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42ab:	8b 00                	mov    (%eax),%eax
+    42ad:	8b 40 04             	mov    0x4(%eax),%eax
+    42b0:	01 c2                	add    %eax,%edx
+    42b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    42b5:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    42b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42bb:	8b 00                	mov    (%eax),%eax
+    42bd:	8b 10                	mov    (%eax),%edx
+    42bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    42c2:	89 10                	mov    %edx,(%eax)
+    42c4:	eb 0a                	jmp    42d0 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+    42c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42c9:	8b 10                	mov    (%eax),%edx
+    42cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    42ce:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+    42d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42d3:	8b 40 04             	mov    0x4(%eax),%eax
+    42d6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    42dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42e0:	01 d0                	add    %edx,%eax
+    42e2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+    42e5:	75 20                	jne    4307 <free+0xcf>
+    p->s.size += bp->s.size;
+    42e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42ea:	8b 50 04             	mov    0x4(%eax),%edx
+    42ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    42f0:	8b 40 04             	mov    0x4(%eax),%eax
+    42f3:	01 c2                	add    %eax,%edx
+    42f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    42f8:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    42fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    42fe:	8b 10                	mov    (%eax),%edx
+    4300:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4303:	89 10                	mov    %edx,(%eax)
+    4305:	eb 08                	jmp    430f <free+0xd7>
+  } else
+    p->s.ptr = bp;
+    4307:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    430a:	8b 55 f8             	mov    -0x8(%ebp),%edx
+    430d:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    430f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4312:	a3 c8 63 00 00       	mov    %eax,0x63c8
+}
+    4317:	c9                   	leave  
+    4318:	c3                   	ret    
+
+00004319 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+    4319:	55                   	push   %ebp
+    431a:	89 e5                	mov    %esp,%ebp
+    431c:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+    431f:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+    4326:	77 07                	ja     432f <morecore+0x16>
+    nu = 4096;
+    4328:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+    432f:	8b 45 08             	mov    0x8(%ebp),%eax
+    4332:	c1 e0 03             	shl    $0x3,%eax
+    4335:	89 04 24             	mov    %eax,(%esp)
+    4338:	e8 27 fc ff ff       	call   3f64 <sbrk>
+    433d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+    4340:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+    4344:	75 07                	jne    434d <morecore+0x34>
+    return 0;
+    4346:	b8 00 00 00 00       	mov    $0x0,%eax
+    434b:	eb 22                	jmp    436f <morecore+0x56>
+  hp = (Header*)p;
+    434d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4350:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+    4353:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    4356:	8b 55 08             	mov    0x8(%ebp),%edx
+    4359:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+    435c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    435f:	83 c0 08             	add    $0x8,%eax
+    4362:	89 04 24             	mov    %eax,(%esp)
+    4365:	e8 ce fe ff ff       	call   4238 <free>
+  return freep;
+    436a:	a1 c8 63 00 00       	mov    0x63c8,%eax
+}
+    436f:	c9                   	leave  
+    4370:	c3                   	ret    
+
+00004371 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+    4371:	55                   	push   %ebp
+    4372:	89 e5                	mov    %esp,%ebp
+    4374:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    4377:	8b 45 08             	mov    0x8(%ebp),%eax
+    437a:	83 c0 07             	add    $0x7,%eax
+    437d:	c1 e8 03             	shr    $0x3,%eax
+    4380:	83 c0 01             	add    $0x1,%eax
+    4383:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+    4386:	a1 c8 63 00 00       	mov    0x63c8,%eax
+    438b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    438e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    4392:	75 23                	jne    43b7 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+    4394:	c7 45 f0 c0 63 00 00 	movl   $0x63c0,-0x10(%ebp)
+    439b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    439e:	a3 c8 63 00 00       	mov    %eax,0x63c8
+    43a3:	a1 c8 63 00 00       	mov    0x63c8,%eax
+    43a8:	a3 c0 63 00 00       	mov    %eax,0x63c0
+    base.s.size = 0;
+    43ad:	c7 05 c4 63 00 00 00 	movl   $0x0,0x63c4
+    43b4:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    43b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    43ba:	8b 00                	mov    (%eax),%eax
+    43bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+    43bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    43c2:	8b 40 04             	mov    0x4(%eax),%eax
+    43c5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+    43c8:	72 4d                	jb     4417 <malloc+0xa6>
+      if(p->s.size == nunits)
+    43ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    43cd:	8b 40 04             	mov    0x4(%eax),%eax
+    43d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+    43d3:	75 0c                	jne    43e1 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+    43d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    43d8:	8b 10                	mov    (%eax),%edx
+    43da:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    43dd:	89 10                	mov    %edx,(%eax)
+    43df:	eb 26                	jmp    4407 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+    43e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    43e4:	8b 40 04             	mov    0x4(%eax),%eax
+    43e7:	89 c2                	mov    %eax,%edx
+    43e9:	2b 55 ec             	sub    -0x14(%ebp),%edx
+    43ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    43ef:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+    43f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    43f5:	8b 40 04             	mov    0x4(%eax),%eax
+    43f8:	c1 e0 03             	shl    $0x3,%eax
+    43fb:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+    43fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4401:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    4404:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+    4407:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    440a:	a3 c8 63 00 00       	mov    %eax,0x63c8
+      return (void*)(p + 1);
+    440f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4412:	83 c0 08             	add    $0x8,%eax
+    4415:	eb 38                	jmp    444f <malloc+0xde>
+    }
+    if(p == freep)
+    4417:	a1 c8 63 00 00       	mov    0x63c8,%eax
+    441c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+    441f:	75 1b                	jne    443c <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+    4421:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    4424:	89 04 24             	mov    %eax,(%esp)
+    4427:	e8 ed fe ff ff       	call   4319 <morecore>
+    442c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    442f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    4433:	75 07                	jne    443c <malloc+0xcb>
+        return 0;
+    4435:	b8 00 00 00 00       	mov    $0x0,%eax
+    443a:	eb 13                	jmp    444f <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    443c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    443f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    4442:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4445:	8b 00                	mov    (%eax),%eax
+    4447:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+    444a:	e9 70 ff ff ff       	jmp    43bf <malloc+0x4e>
+}
+    444f:	c9                   	leave  
+    4450:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/usertests.d cs550-16s-proj1-working/usertests.d
--- cs550-16s-proj1-base/usertests.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/usertests.d	2016-03-04 14:37:07.000000000 -0500
@@ -0,0 +1,2 @@
+usertests.o: usertests.c param.h types.h stat.h user.h fs.h fcntl.h \
+ syscall.h traps.h memlayout.h
Binary files cs550-16s-proj1-base/usertests.o and cs550-16s-proj1-working/usertests.o differ
diff -uNr cs550-16s-proj1-base/usertests.sym cs550-16s-proj1-working/usertests.sym
--- cs550-16s-proj1-base/usertests.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/usertests.sym	2016-03-04 14:37:08.000000000 -0500
@@ -0,0 +1,109 @@
+00000000 .text
+00004454 .rodata
+00005c28 .eh_frame
+000062fc .data
+00006340 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 usertests.c
+00006340 args.1395
+00000000 ulib.c
+00003c74 stosb
+00000000 printf.c
+00003fa4 putc
+00003fcc printint
+00006318 digits.1028
+00000000 umalloc.c
+000063c0 base
+000063c8 freep
+00004319 morecore
+00003c99 strcpy
+00000cb8 exitwait
+00004081 printf
+00006310 stdout
+00003754 bigargtest
+00003e98 memmove
+000001c6 openiputtest
+00003f24 mknod
+00003d8c gets
+00003f5c getpid
+00000971 pipe1
+00002efa iref
+00004371 malloc
+00003f6c sleep
+000000da exitiputtest
+0000387d fsfull
+00001dfe bigdir
+00003f9c set_priority
+0000301e forktest
+00000587 writetest1
+000026bd bigwrite
+00000e1b sharedfd
+00006314 randstate
+00003eec pipe
+000063e0 uninit
+00002cb8 dirfile
+00003efc write
+000036e2 bsstest
+000062fc echoargv
+00003f34 fstat
+00003f0c kill
+00003615 validatetest
+00002b40 rmdot
+00003f4c chdir
+00000922 exectest
+00003f14 exec
+00003ee4 wait
+00003b40 rand
+00003ef4 read
+00000b5f preempt
+00003f2c unlink
+00000d36 mem
+00003ed4 fork
+00003f64 sbrk
+00003f74 uptime
+0000632c __bss_start
+00003d35 memset
+00000790 createtest
+00003b5f main
+00001281 createdelete
+00003f7c enable_sched_trace
+00003ccd strcmp
+00003f84 shutdown
+00000372 writetest
+00003f54 dup
+000030f1 sbrktest
+000002c7 opentest
+00001f77 subdir
+000016ce linktest
+00008b00 buf
+00000848 dirtest
+00000000 iputtest
+00003f94 set_sched
+00003dff stat
+000027c5 bigfile
+0000632c _edata
+0000ab04 _end
+000014f9 unlinkread
+00003f3c link
+00003edc exit
+00003e4d atoi
+00003f8c fork_winner
+00001cd0 linkunlink
+0000ab00 name
+00003d0e strlen
+00003f1c open
+00003d59 strchr
+00001917 concreate
+000029ea fourteen
+000035ea validateint
+00001019 fourfiles
+00003f44 mkdir
+00003f04 close
+00004238 free
Binary files cs550-16s-proj1-base/usys.o and cs550-16s-proj1-working/usys.o differ
diff -uNr cs550-16s-proj1-base/usys.S cs550-16s-proj1-working/usys.S
--- cs550-16s-proj1-base/usys.S	2016-02-15 19:35:48.000000000 -0500
+++ cs550-16s-proj1-working/usys.S	2016-03-04 14:36:43.000000000 -0500
@@ -30,3 +30,7 @@
 SYSCALL(sleep)
 SYSCALL(uptime)
 SYSCALL(enable_sched_trace)
+SYSCALL(shutdown)
+SYSCALL(fork_winner)
+SYSCALL(set_sched)
+SYSCALL(set_priority)
Binary files cs550-16s-proj1-base/vectors.o and cs550-16s-proj1-working/vectors.o differ
diff -uNr cs550-16s-proj1-base/vectors.S cs550-16s-proj1-working/vectors.S
--- cs550-16s-proj1-base/vectors.S	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/vectors.S	2016-03-04 14:37:28.000000000 -0500
@@ -0,0 +1,1537 @@
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+  pushl $0
+  jmp alltraps
+.globl vector1
+vector1:
+  pushl $0
+  pushl $1
+  jmp alltraps
+.globl vector2
+vector2:
+  pushl $0
+  pushl $2
+  jmp alltraps
+.globl vector3
+vector3:
+  pushl $0
+  pushl $3
+  jmp alltraps
+.globl vector4
+vector4:
+  pushl $0
+  pushl $4
+  jmp alltraps
+.globl vector5
+vector5:
+  pushl $0
+  pushl $5
+  jmp alltraps
+.globl vector6
+vector6:
+  pushl $0
+  pushl $6
+  jmp alltraps
+.globl vector7
+vector7:
+  pushl $0
+  pushl $7
+  jmp alltraps
+.globl vector8
+vector8:
+  pushl $8
+  jmp alltraps
+.globl vector9
+vector9:
+  pushl $0
+  pushl $9
+  jmp alltraps
+.globl vector10
+vector10:
+  pushl $10
+  jmp alltraps
+.globl vector11
+vector11:
+  pushl $11
+  jmp alltraps
+.globl vector12
+vector12:
+  pushl $12
+  jmp alltraps
+.globl vector13
+vector13:
+  pushl $13
+  jmp alltraps
+.globl vector14
+vector14:
+  pushl $14
+  jmp alltraps
+.globl vector15
+vector15:
+  pushl $0
+  pushl $15
+  jmp alltraps
+.globl vector16
+vector16:
+  pushl $0
+  pushl $16
+  jmp alltraps
+.globl vector17
+vector17:
+  pushl $17
+  jmp alltraps
+.globl vector18
+vector18:
+  pushl $0
+  pushl $18
+  jmp alltraps
+.globl vector19
+vector19:
+  pushl $0
+  pushl $19
+  jmp alltraps
+.globl vector20
+vector20:
+  pushl $0
+  pushl $20
+  jmp alltraps
+.globl vector21
+vector21:
+  pushl $0
+  pushl $21
+  jmp alltraps
+.globl vector22
+vector22:
+  pushl $0
+  pushl $22
+  jmp alltraps
+.globl vector23
+vector23:
+  pushl $0
+  pushl $23
+  jmp alltraps
+.globl vector24
+vector24:
+  pushl $0
+  pushl $24
+  jmp alltraps
+.globl vector25
+vector25:
+  pushl $0
+  pushl $25
+  jmp alltraps
+.globl vector26
+vector26:
+  pushl $0
+  pushl $26
+  jmp alltraps
+.globl vector27
+vector27:
+  pushl $0
+  pushl $27
+  jmp alltraps
+.globl vector28
+vector28:
+  pushl $0
+  pushl $28
+  jmp alltraps
+.globl vector29
+vector29:
+  pushl $0
+  pushl $29
+  jmp alltraps
+.globl vector30
+vector30:
+  pushl $0
+  pushl $30
+  jmp alltraps
+.globl vector31
+vector31:
+  pushl $0
+  pushl $31
+  jmp alltraps
+.globl vector32
+vector32:
+  pushl $0
+  pushl $32
+  jmp alltraps
+.globl vector33
+vector33:
+  pushl $0
+  pushl $33
+  jmp alltraps
+.globl vector34
+vector34:
+  pushl $0
+  pushl $34
+  jmp alltraps
+.globl vector35
+vector35:
+  pushl $0
+  pushl $35
+  jmp alltraps
+.globl vector36
+vector36:
+  pushl $0
+  pushl $36
+  jmp alltraps
+.globl vector37
+vector37:
+  pushl $0
+  pushl $37
+  jmp alltraps
+.globl vector38
+vector38:
+  pushl $0
+  pushl $38
+  jmp alltraps
+.globl vector39
+vector39:
+  pushl $0
+  pushl $39
+  jmp alltraps
+.globl vector40
+vector40:
+  pushl $0
+  pushl $40
+  jmp alltraps
+.globl vector41
+vector41:
+  pushl $0
+  pushl $41
+  jmp alltraps
+.globl vector42
+vector42:
+  pushl $0
+  pushl $42
+  jmp alltraps
+.globl vector43
+vector43:
+  pushl $0
+  pushl $43
+  jmp alltraps
+.globl vector44
+vector44:
+  pushl $0
+  pushl $44
+  jmp alltraps
+.globl vector45
+vector45:
+  pushl $0
+  pushl $45
+  jmp alltraps
+.globl vector46
+vector46:
+  pushl $0
+  pushl $46
+  jmp alltraps
+.globl vector47
+vector47:
+  pushl $0
+  pushl $47
+  jmp alltraps
+.globl vector48
+vector48:
+  pushl $0
+  pushl $48
+  jmp alltraps
+.globl vector49
+vector49:
+  pushl $0
+  pushl $49
+  jmp alltraps
+.globl vector50
+vector50:
+  pushl $0
+  pushl $50
+  jmp alltraps
+.globl vector51
+vector51:
+  pushl $0
+  pushl $51
+  jmp alltraps
+.globl vector52
+vector52:
+  pushl $0
+  pushl $52
+  jmp alltraps
+.globl vector53
+vector53:
+  pushl $0
+  pushl $53
+  jmp alltraps
+.globl vector54
+vector54:
+  pushl $0
+  pushl $54
+  jmp alltraps
+.globl vector55
+vector55:
+  pushl $0
+  pushl $55
+  jmp alltraps
+.globl vector56
+vector56:
+  pushl $0
+  pushl $56
+  jmp alltraps
+.globl vector57
+vector57:
+  pushl $0
+  pushl $57
+  jmp alltraps
+.globl vector58
+vector58:
+  pushl $0
+  pushl $58
+  jmp alltraps
+.globl vector59
+vector59:
+  pushl $0
+  pushl $59
+  jmp alltraps
+.globl vector60
+vector60:
+  pushl $0
+  pushl $60
+  jmp alltraps
+.globl vector61
+vector61:
+  pushl $0
+  pushl $61
+  jmp alltraps
+.globl vector62
+vector62:
+  pushl $0
+  pushl $62
+  jmp alltraps
+.globl vector63
+vector63:
+  pushl $0
+  pushl $63
+  jmp alltraps
+.globl vector64
+vector64:
+  pushl $0
+  pushl $64
+  jmp alltraps
+.globl vector65
+vector65:
+  pushl $0
+  pushl $65
+  jmp alltraps
+.globl vector66
+vector66:
+  pushl $0
+  pushl $66
+  jmp alltraps
+.globl vector67
+vector67:
+  pushl $0
+  pushl $67
+  jmp alltraps
+.globl vector68
+vector68:
+  pushl $0
+  pushl $68
+  jmp alltraps
+.globl vector69
+vector69:
+  pushl $0
+  pushl $69
+  jmp alltraps
+.globl vector70
+vector70:
+  pushl $0
+  pushl $70
+  jmp alltraps
+.globl vector71
+vector71:
+  pushl $0
+  pushl $71
+  jmp alltraps
+.globl vector72
+vector72:
+  pushl $0
+  pushl $72
+  jmp alltraps
+.globl vector73
+vector73:
+  pushl $0
+  pushl $73
+  jmp alltraps
+.globl vector74
+vector74:
+  pushl $0
+  pushl $74
+  jmp alltraps
+.globl vector75
+vector75:
+  pushl $0
+  pushl $75
+  jmp alltraps
+.globl vector76
+vector76:
+  pushl $0
+  pushl $76
+  jmp alltraps
+.globl vector77
+vector77:
+  pushl $0
+  pushl $77
+  jmp alltraps
+.globl vector78
+vector78:
+  pushl $0
+  pushl $78
+  jmp alltraps
+.globl vector79
+vector79:
+  pushl $0
+  pushl $79
+  jmp alltraps
+.globl vector80
+vector80:
+  pushl $0
+  pushl $80
+  jmp alltraps
+.globl vector81
+vector81:
+  pushl $0
+  pushl $81
+  jmp alltraps
+.globl vector82
+vector82:
+  pushl $0
+  pushl $82
+  jmp alltraps
+.globl vector83
+vector83:
+  pushl $0
+  pushl $83
+  jmp alltraps
+.globl vector84
+vector84:
+  pushl $0
+  pushl $84
+  jmp alltraps
+.globl vector85
+vector85:
+  pushl $0
+  pushl $85
+  jmp alltraps
+.globl vector86
+vector86:
+  pushl $0
+  pushl $86
+  jmp alltraps
+.globl vector87
+vector87:
+  pushl $0
+  pushl $87
+  jmp alltraps
+.globl vector88
+vector88:
+  pushl $0
+  pushl $88
+  jmp alltraps
+.globl vector89
+vector89:
+  pushl $0
+  pushl $89
+  jmp alltraps
+.globl vector90
+vector90:
+  pushl $0
+  pushl $90
+  jmp alltraps
+.globl vector91
+vector91:
+  pushl $0
+  pushl $91
+  jmp alltraps
+.globl vector92
+vector92:
+  pushl $0
+  pushl $92
+  jmp alltraps
+.globl vector93
+vector93:
+  pushl $0
+  pushl $93
+  jmp alltraps
+.globl vector94
+vector94:
+  pushl $0
+  pushl $94
+  jmp alltraps
+.globl vector95
+vector95:
+  pushl $0
+  pushl $95
+  jmp alltraps
+.globl vector96
+vector96:
+  pushl $0
+  pushl $96
+  jmp alltraps
+.globl vector97
+vector97:
+  pushl $0
+  pushl $97
+  jmp alltraps
+.globl vector98
+vector98:
+  pushl $0
+  pushl $98
+  jmp alltraps
+.globl vector99
+vector99:
+  pushl $0
+  pushl $99
+  jmp alltraps
+.globl vector100
+vector100:
+  pushl $0
+  pushl $100
+  jmp alltraps
+.globl vector101
+vector101:
+  pushl $0
+  pushl $101
+  jmp alltraps
+.globl vector102
+vector102:
+  pushl $0
+  pushl $102
+  jmp alltraps
+.globl vector103
+vector103:
+  pushl $0
+  pushl $103
+  jmp alltraps
+.globl vector104
+vector104:
+  pushl $0
+  pushl $104
+  jmp alltraps
+.globl vector105
+vector105:
+  pushl $0
+  pushl $105
+  jmp alltraps
+.globl vector106
+vector106:
+  pushl $0
+  pushl $106
+  jmp alltraps
+.globl vector107
+vector107:
+  pushl $0
+  pushl $107
+  jmp alltraps
+.globl vector108
+vector108:
+  pushl $0
+  pushl $108
+  jmp alltraps
+.globl vector109
+vector109:
+  pushl $0
+  pushl $109
+  jmp alltraps
+.globl vector110
+vector110:
+  pushl $0
+  pushl $110
+  jmp alltraps
+.globl vector111
+vector111:
+  pushl $0
+  pushl $111
+  jmp alltraps
+.globl vector112
+vector112:
+  pushl $0
+  pushl $112
+  jmp alltraps
+.globl vector113
+vector113:
+  pushl $0
+  pushl $113
+  jmp alltraps
+.globl vector114
+vector114:
+  pushl $0
+  pushl $114
+  jmp alltraps
+.globl vector115
+vector115:
+  pushl $0
+  pushl $115
+  jmp alltraps
+.globl vector116
+vector116:
+  pushl $0
+  pushl $116
+  jmp alltraps
+.globl vector117
+vector117:
+  pushl $0
+  pushl $117
+  jmp alltraps
+.globl vector118
+vector118:
+  pushl $0
+  pushl $118
+  jmp alltraps
+.globl vector119
+vector119:
+  pushl $0
+  pushl $119
+  jmp alltraps
+.globl vector120
+vector120:
+  pushl $0
+  pushl $120
+  jmp alltraps
+.globl vector121
+vector121:
+  pushl $0
+  pushl $121
+  jmp alltraps
+.globl vector122
+vector122:
+  pushl $0
+  pushl $122
+  jmp alltraps
+.globl vector123
+vector123:
+  pushl $0
+  pushl $123
+  jmp alltraps
+.globl vector124
+vector124:
+  pushl $0
+  pushl $124
+  jmp alltraps
+.globl vector125
+vector125:
+  pushl $0
+  pushl $125
+  jmp alltraps
+.globl vector126
+vector126:
+  pushl $0
+  pushl $126
+  jmp alltraps
+.globl vector127
+vector127:
+  pushl $0
+  pushl $127
+  jmp alltraps
+.globl vector128
+vector128:
+  pushl $0
+  pushl $128
+  jmp alltraps
+.globl vector129
+vector129:
+  pushl $0
+  pushl $129
+  jmp alltraps
+.globl vector130
+vector130:
+  pushl $0
+  pushl $130
+  jmp alltraps
+.globl vector131
+vector131:
+  pushl $0
+  pushl $131
+  jmp alltraps
+.globl vector132
+vector132:
+  pushl $0
+  pushl $132
+  jmp alltraps
+.globl vector133
+vector133:
+  pushl $0
+  pushl $133
+  jmp alltraps
+.globl vector134
+vector134:
+  pushl $0
+  pushl $134
+  jmp alltraps
+.globl vector135
+vector135:
+  pushl $0
+  pushl $135
+  jmp alltraps
+.globl vector136
+vector136:
+  pushl $0
+  pushl $136
+  jmp alltraps
+.globl vector137
+vector137:
+  pushl $0
+  pushl $137
+  jmp alltraps
+.globl vector138
+vector138:
+  pushl $0
+  pushl $138
+  jmp alltraps
+.globl vector139
+vector139:
+  pushl $0
+  pushl $139
+  jmp alltraps
+.globl vector140
+vector140:
+  pushl $0
+  pushl $140
+  jmp alltraps
+.globl vector141
+vector141:
+  pushl $0
+  pushl $141
+  jmp alltraps
+.globl vector142
+vector142:
+  pushl $0
+  pushl $142
+  jmp alltraps
+.globl vector143
+vector143:
+  pushl $0
+  pushl $143
+  jmp alltraps
+.globl vector144
+vector144:
+  pushl $0
+  pushl $144
+  jmp alltraps
+.globl vector145
+vector145:
+  pushl $0
+  pushl $145
+  jmp alltraps
+.globl vector146
+vector146:
+  pushl $0
+  pushl $146
+  jmp alltraps
+.globl vector147
+vector147:
+  pushl $0
+  pushl $147
+  jmp alltraps
+.globl vector148
+vector148:
+  pushl $0
+  pushl $148
+  jmp alltraps
+.globl vector149
+vector149:
+  pushl $0
+  pushl $149
+  jmp alltraps
+.globl vector150
+vector150:
+  pushl $0
+  pushl $150
+  jmp alltraps
+.globl vector151
+vector151:
+  pushl $0
+  pushl $151
+  jmp alltraps
+.globl vector152
+vector152:
+  pushl $0
+  pushl $152
+  jmp alltraps
+.globl vector153
+vector153:
+  pushl $0
+  pushl $153
+  jmp alltraps
+.globl vector154
+vector154:
+  pushl $0
+  pushl $154
+  jmp alltraps
+.globl vector155
+vector155:
+  pushl $0
+  pushl $155
+  jmp alltraps
+.globl vector156
+vector156:
+  pushl $0
+  pushl $156
+  jmp alltraps
+.globl vector157
+vector157:
+  pushl $0
+  pushl $157
+  jmp alltraps
+.globl vector158
+vector158:
+  pushl $0
+  pushl $158
+  jmp alltraps
+.globl vector159
+vector159:
+  pushl $0
+  pushl $159
+  jmp alltraps
+.globl vector160
+vector160:
+  pushl $0
+  pushl $160
+  jmp alltraps
+.globl vector161
+vector161:
+  pushl $0
+  pushl $161
+  jmp alltraps
+.globl vector162
+vector162:
+  pushl $0
+  pushl $162
+  jmp alltraps
+.globl vector163
+vector163:
+  pushl $0
+  pushl $163
+  jmp alltraps
+.globl vector164
+vector164:
+  pushl $0
+  pushl $164
+  jmp alltraps
+.globl vector165
+vector165:
+  pushl $0
+  pushl $165
+  jmp alltraps
+.globl vector166
+vector166:
+  pushl $0
+  pushl $166
+  jmp alltraps
+.globl vector167
+vector167:
+  pushl $0
+  pushl $167
+  jmp alltraps
+.globl vector168
+vector168:
+  pushl $0
+  pushl $168
+  jmp alltraps
+.globl vector169
+vector169:
+  pushl $0
+  pushl $169
+  jmp alltraps
+.globl vector170
+vector170:
+  pushl $0
+  pushl $170
+  jmp alltraps
+.globl vector171
+vector171:
+  pushl $0
+  pushl $171
+  jmp alltraps
+.globl vector172
+vector172:
+  pushl $0
+  pushl $172
+  jmp alltraps
+.globl vector173
+vector173:
+  pushl $0
+  pushl $173
+  jmp alltraps
+.globl vector174
+vector174:
+  pushl $0
+  pushl $174
+  jmp alltraps
+.globl vector175
+vector175:
+  pushl $0
+  pushl $175
+  jmp alltraps
+.globl vector176
+vector176:
+  pushl $0
+  pushl $176
+  jmp alltraps
+.globl vector177
+vector177:
+  pushl $0
+  pushl $177
+  jmp alltraps
+.globl vector178
+vector178:
+  pushl $0
+  pushl $178
+  jmp alltraps
+.globl vector179
+vector179:
+  pushl $0
+  pushl $179
+  jmp alltraps
+.globl vector180
+vector180:
+  pushl $0
+  pushl $180
+  jmp alltraps
+.globl vector181
+vector181:
+  pushl $0
+  pushl $181
+  jmp alltraps
+.globl vector182
+vector182:
+  pushl $0
+  pushl $182
+  jmp alltraps
+.globl vector183
+vector183:
+  pushl $0
+  pushl $183
+  jmp alltraps
+.globl vector184
+vector184:
+  pushl $0
+  pushl $184
+  jmp alltraps
+.globl vector185
+vector185:
+  pushl $0
+  pushl $185
+  jmp alltraps
+.globl vector186
+vector186:
+  pushl $0
+  pushl $186
+  jmp alltraps
+.globl vector187
+vector187:
+  pushl $0
+  pushl $187
+  jmp alltraps
+.globl vector188
+vector188:
+  pushl $0
+  pushl $188
+  jmp alltraps
+.globl vector189
+vector189:
+  pushl $0
+  pushl $189
+  jmp alltraps
+.globl vector190
+vector190:
+  pushl $0
+  pushl $190
+  jmp alltraps
+.globl vector191
+vector191:
+  pushl $0
+  pushl $191
+  jmp alltraps
+.globl vector192
+vector192:
+  pushl $0
+  pushl $192
+  jmp alltraps
+.globl vector193
+vector193:
+  pushl $0
+  pushl $193
+  jmp alltraps
+.globl vector194
+vector194:
+  pushl $0
+  pushl $194
+  jmp alltraps
+.globl vector195
+vector195:
+  pushl $0
+  pushl $195
+  jmp alltraps
+.globl vector196
+vector196:
+  pushl $0
+  pushl $196
+  jmp alltraps
+.globl vector197
+vector197:
+  pushl $0
+  pushl $197
+  jmp alltraps
+.globl vector198
+vector198:
+  pushl $0
+  pushl $198
+  jmp alltraps
+.globl vector199
+vector199:
+  pushl $0
+  pushl $199
+  jmp alltraps
+.globl vector200
+vector200:
+  pushl $0
+  pushl $200
+  jmp alltraps
+.globl vector201
+vector201:
+  pushl $0
+  pushl $201
+  jmp alltraps
+.globl vector202
+vector202:
+  pushl $0
+  pushl $202
+  jmp alltraps
+.globl vector203
+vector203:
+  pushl $0
+  pushl $203
+  jmp alltraps
+.globl vector204
+vector204:
+  pushl $0
+  pushl $204
+  jmp alltraps
+.globl vector205
+vector205:
+  pushl $0
+  pushl $205
+  jmp alltraps
+.globl vector206
+vector206:
+  pushl $0
+  pushl $206
+  jmp alltraps
+.globl vector207
+vector207:
+  pushl $0
+  pushl $207
+  jmp alltraps
+.globl vector208
+vector208:
+  pushl $0
+  pushl $208
+  jmp alltraps
+.globl vector209
+vector209:
+  pushl $0
+  pushl $209
+  jmp alltraps
+.globl vector210
+vector210:
+  pushl $0
+  pushl $210
+  jmp alltraps
+.globl vector211
+vector211:
+  pushl $0
+  pushl $211
+  jmp alltraps
+.globl vector212
+vector212:
+  pushl $0
+  pushl $212
+  jmp alltraps
+.globl vector213
+vector213:
+  pushl $0
+  pushl $213
+  jmp alltraps
+.globl vector214
+vector214:
+  pushl $0
+  pushl $214
+  jmp alltraps
+.globl vector215
+vector215:
+  pushl $0
+  pushl $215
+  jmp alltraps
+.globl vector216
+vector216:
+  pushl $0
+  pushl $216
+  jmp alltraps
+.globl vector217
+vector217:
+  pushl $0
+  pushl $217
+  jmp alltraps
+.globl vector218
+vector218:
+  pushl $0
+  pushl $218
+  jmp alltraps
+.globl vector219
+vector219:
+  pushl $0
+  pushl $219
+  jmp alltraps
+.globl vector220
+vector220:
+  pushl $0
+  pushl $220
+  jmp alltraps
+.globl vector221
+vector221:
+  pushl $0
+  pushl $221
+  jmp alltraps
+.globl vector222
+vector222:
+  pushl $0
+  pushl $222
+  jmp alltraps
+.globl vector223
+vector223:
+  pushl $0
+  pushl $223
+  jmp alltraps
+.globl vector224
+vector224:
+  pushl $0
+  pushl $224
+  jmp alltraps
+.globl vector225
+vector225:
+  pushl $0
+  pushl $225
+  jmp alltraps
+.globl vector226
+vector226:
+  pushl $0
+  pushl $226
+  jmp alltraps
+.globl vector227
+vector227:
+  pushl $0
+  pushl $227
+  jmp alltraps
+.globl vector228
+vector228:
+  pushl $0
+  pushl $228
+  jmp alltraps
+.globl vector229
+vector229:
+  pushl $0
+  pushl $229
+  jmp alltraps
+.globl vector230
+vector230:
+  pushl $0
+  pushl $230
+  jmp alltraps
+.globl vector231
+vector231:
+  pushl $0
+  pushl $231
+  jmp alltraps
+.globl vector232
+vector232:
+  pushl $0
+  pushl $232
+  jmp alltraps
+.globl vector233
+vector233:
+  pushl $0
+  pushl $233
+  jmp alltraps
+.globl vector234
+vector234:
+  pushl $0
+  pushl $234
+  jmp alltraps
+.globl vector235
+vector235:
+  pushl $0
+  pushl $235
+  jmp alltraps
+.globl vector236
+vector236:
+  pushl $0
+  pushl $236
+  jmp alltraps
+.globl vector237
+vector237:
+  pushl $0
+  pushl $237
+  jmp alltraps
+.globl vector238
+vector238:
+  pushl $0
+  pushl $238
+  jmp alltraps
+.globl vector239
+vector239:
+  pushl $0
+  pushl $239
+  jmp alltraps
+.globl vector240
+vector240:
+  pushl $0
+  pushl $240
+  jmp alltraps
+.globl vector241
+vector241:
+  pushl $0
+  pushl $241
+  jmp alltraps
+.globl vector242
+vector242:
+  pushl $0
+  pushl $242
+  jmp alltraps
+.globl vector243
+vector243:
+  pushl $0
+  pushl $243
+  jmp alltraps
+.globl vector244
+vector244:
+  pushl $0
+  pushl $244
+  jmp alltraps
+.globl vector245
+vector245:
+  pushl $0
+  pushl $245
+  jmp alltraps
+.globl vector246
+vector246:
+  pushl $0
+  pushl $246
+  jmp alltraps
+.globl vector247
+vector247:
+  pushl $0
+  pushl $247
+  jmp alltraps
+.globl vector248
+vector248:
+  pushl $0
+  pushl $248
+  jmp alltraps
+.globl vector249
+vector249:
+  pushl $0
+  pushl $249
+  jmp alltraps
+.globl vector250
+vector250:
+  pushl $0
+  pushl $250
+  jmp alltraps
+.globl vector251
+vector251:
+  pushl $0
+  pushl $251
+  jmp alltraps
+.globl vector252
+vector252:
+  pushl $0
+  pushl $252
+  jmp alltraps
+.globl vector253
+vector253:
+  pushl $0
+  pushl $253
+  jmp alltraps
+.globl vector254
+vector254:
+  pushl $0
+  pushl $254
+  jmp alltraps
+.globl vector255
+vector255:
+  pushl $0
+  pushl $255
+  jmp alltraps
+
+# vector table
+.data
+.globl vectors
+vectors:
+  .long vector0
+  .long vector1
+  .long vector2
+  .long vector3
+  .long vector4
+  .long vector5
+  .long vector6
+  .long vector7
+  .long vector8
+  .long vector9
+  .long vector10
+  .long vector11
+  .long vector12
+  .long vector13
+  .long vector14
+  .long vector15
+  .long vector16
+  .long vector17
+  .long vector18
+  .long vector19
+  .long vector20
+  .long vector21
+  .long vector22
+  .long vector23
+  .long vector24
+  .long vector25
+  .long vector26
+  .long vector27
+  .long vector28
+  .long vector29
+  .long vector30
+  .long vector31
+  .long vector32
+  .long vector33
+  .long vector34
+  .long vector35
+  .long vector36
+  .long vector37
+  .long vector38
+  .long vector39
+  .long vector40
+  .long vector41
+  .long vector42
+  .long vector43
+  .long vector44
+  .long vector45
+  .long vector46
+  .long vector47
+  .long vector48
+  .long vector49
+  .long vector50
+  .long vector51
+  .long vector52
+  .long vector53
+  .long vector54
+  .long vector55
+  .long vector56
+  .long vector57
+  .long vector58
+  .long vector59
+  .long vector60
+  .long vector61
+  .long vector62
+  .long vector63
+  .long vector64
+  .long vector65
+  .long vector66
+  .long vector67
+  .long vector68
+  .long vector69
+  .long vector70
+  .long vector71
+  .long vector72
+  .long vector73
+  .long vector74
+  .long vector75
+  .long vector76
+  .long vector77
+  .long vector78
+  .long vector79
+  .long vector80
+  .long vector81
+  .long vector82
+  .long vector83
+  .long vector84
+  .long vector85
+  .long vector86
+  .long vector87
+  .long vector88
+  .long vector89
+  .long vector90
+  .long vector91
+  .long vector92
+  .long vector93
+  .long vector94
+  .long vector95
+  .long vector96
+  .long vector97
+  .long vector98
+  .long vector99
+  .long vector100
+  .long vector101
+  .long vector102
+  .long vector103
+  .long vector104
+  .long vector105
+  .long vector106
+  .long vector107
+  .long vector108
+  .long vector109
+  .long vector110
+  .long vector111
+  .long vector112
+  .long vector113
+  .long vector114
+  .long vector115
+  .long vector116
+  .long vector117
+  .long vector118
+  .long vector119
+  .long vector120
+  .long vector121
+  .long vector122
+  .long vector123
+  .long vector124
+  .long vector125
+  .long vector126
+  .long vector127
+  .long vector128
+  .long vector129
+  .long vector130
+  .long vector131
+  .long vector132
+  .long vector133
+  .long vector134
+  .long vector135
+  .long vector136
+  .long vector137
+  .long vector138
+  .long vector139
+  .long vector140
+  .long vector141
+  .long vector142
+  .long vector143
+  .long vector144
+  .long vector145
+  .long vector146
+  .long vector147
+  .long vector148
+  .long vector149
+  .long vector150
+  .long vector151
+  .long vector152
+  .long vector153
+  .long vector154
+  .long vector155
+  .long vector156
+  .long vector157
+  .long vector158
+  .long vector159
+  .long vector160
+  .long vector161
+  .long vector162
+  .long vector163
+  .long vector164
+  .long vector165
+  .long vector166
+  .long vector167
+  .long vector168
+  .long vector169
+  .long vector170
+  .long vector171
+  .long vector172
+  .long vector173
+  .long vector174
+  .long vector175
+  .long vector176
+  .long vector177
+  .long vector178
+  .long vector179
+  .long vector180
+  .long vector181
+  .long vector182
+  .long vector183
+  .long vector184
+  .long vector185
+  .long vector186
+  .long vector187
+  .long vector188
+  .long vector189
+  .long vector190
+  .long vector191
+  .long vector192
+  .long vector193
+  .long vector194
+  .long vector195
+  .long vector196
+  .long vector197
+  .long vector198
+  .long vector199
+  .long vector200
+  .long vector201
+  .long vector202
+  .long vector203
+  .long vector204
+  .long vector205
+  .long vector206
+  .long vector207
+  .long vector208
+  .long vector209
+  .long vector210
+  .long vector211
+  .long vector212
+  .long vector213
+  .long vector214
+  .long vector215
+  .long vector216
+  .long vector217
+  .long vector218
+  .long vector219
+  .long vector220
+  .long vector221
+  .long vector222
+  .long vector223
+  .long vector224
+  .long vector225
+  .long vector226
+  .long vector227
+  .long vector228
+  .long vector229
+  .long vector230
+  .long vector231
+  .long vector232
+  .long vector233
+  .long vector234
+  .long vector235
+  .long vector236
+  .long vector237
+  .long vector238
+  .long vector239
+  .long vector240
+  .long vector241
+  .long vector242
+  .long vector243
+  .long vector244
+  .long vector245
+  .long vector246
+  .long vector247
+  .long vector248
+  .long vector249
+  .long vector250
+  .long vector251
+  .long vector252
+  .long vector253
+  .long vector254
+  .long vector255
diff -uNr cs550-16s-proj1-base/vm.d cs550-16s-proj1-working/vm.d
--- cs550-16s-proj1-base/vm.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/vm.d	2016-03-04 15:55:04.848532311 -0500
@@ -0,0 +1 @@
+vm.o: vm.c param.h types.h defs.h x86.h memlayout.h mmu.h proc.h elf.h
Binary files cs550-16s-proj1-base/vm.o and cs550-16s-proj1-working/vm.o differ
Binary files cs550-16s-proj1-base/_wc and cs550-16s-proj1-working/_wc differ
diff -uNr cs550-16s-proj1-base/wc.asm cs550-16s-proj1-working/wc.asm
--- cs550-16s-proj1-base/wc.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/wc.asm	2016-03-04 14:37:09.000000000 -0500
@@ -0,0 +1,1365 @@
+
+_wc:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <wc>:
+
+char buf[512];
+
+void
+wc(int fd, char *name)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 ec 48             	sub    $0x48,%esp
+  int i, n;
+  int l, w, c, inword;
+
+  l = w = c = 0;
+   6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+   d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  13:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  16:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  inword = 0;
+  19:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  20:	eb 68                	jmp    8a <wc+0x8a>
+    for(i=0; i<n; i++){
+  22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  29:	eb 57                	jmp    82 <wc+0x82>
+      c++;
+  2b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+      if(buf[i] == '\n')
+  2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  32:	05 a0 0c 00 00       	add    $0xca0,%eax
+  37:	0f b6 00             	movzbl (%eax),%eax
+  3a:	3c 0a                	cmp    $0xa,%al
+  3c:	75 04                	jne    42 <wc+0x42>
+        l++;
+  3e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+      if(strchr(" \r\t\n\v", buf[i]))
+  42:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  45:	05 a0 0c 00 00       	add    $0xca0,%eax
+  4a:	0f b6 00             	movzbl (%eax),%eax
+  4d:	0f be c0             	movsbl %al,%eax
+  50:	89 44 24 04          	mov    %eax,0x4(%esp)
+  54:	c7 04 24 b9 09 00 00 	movl   $0x9b9,(%esp)
+  5b:	e8 61 02 00 00       	call   2c1 <strchr>
+  60:	85 c0                	test   %eax,%eax
+  62:	74 09                	je     6d <wc+0x6d>
+        inword = 0;
+  64:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  6b:	eb 11                	jmp    7e <wc+0x7e>
+      else if(!inword){
+  6d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  71:	75 0b                	jne    7e <wc+0x7e>
+        w++;
+  73:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+        inword = 1;
+  77:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+  int l, w, c, inword;
+
+  l = w = c = 0;
+  inword = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    for(i=0; i<n; i++){
+  7e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  82:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  85:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+  88:	7c a1                	jl     2b <wc+0x2b>
+  int i, n;
+  int l, w, c, inword;
+
+  l = w = c = 0;
+  inword = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  8a:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+  91:	00 
+  92:	c7 44 24 04 a0 0c 00 	movl   $0xca0,0x4(%esp)
+  99:	00 
+  9a:	8b 45 08             	mov    0x8(%ebp),%eax
+  9d:	89 04 24             	mov    %eax,(%esp)
+  a0:	e8 b7 03 00 00       	call   45c <read>
+  a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  a8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  ac:	0f 8f 70 ff ff ff    	jg     22 <wc+0x22>
+        w++;
+        inword = 1;
+      }
+    }
+  }
+  if(n < 0){
+  b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  b6:	79 19                	jns    d1 <wc+0xd1>
+    printf(1, "wc: read error\n");
+  b8:	c7 44 24 04 bf 09 00 	movl   $0x9bf,0x4(%esp)
+  bf:	00 
+  c0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  c7:	e8 1d 05 00 00       	call   5e9 <printf>
+    exit();
+  cc:	e8 73 03 00 00       	call   444 <exit>
+  }
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+  d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  d4:	89 44 24 14          	mov    %eax,0x14(%esp)
+  d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  db:	89 44 24 10          	mov    %eax,0x10(%esp)
+  df:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  e9:	89 44 24 08          	mov    %eax,0x8(%esp)
+  ed:	c7 44 24 04 cf 09 00 	movl   $0x9cf,0x4(%esp)
+  f4:	00 
+  f5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  fc:	e8 e8 04 00 00       	call   5e9 <printf>
+}
+ 101:	c9                   	leave  
+ 102:	c3                   	ret    
+
+00000103 <main>:
+
+int
+main(int argc, char *argv[])
+{
+ 103:	55                   	push   %ebp
+ 104:	89 e5                	mov    %esp,%ebp
+ 106:	83 e4 f0             	and    $0xfffffff0,%esp
+ 109:	83 ec 20             	sub    $0x20,%esp
+  int fd, i;
+
+  if(argc <= 1){
+ 10c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+ 110:	7f 19                	jg     12b <main+0x28>
+    wc(0, "");
+ 112:	c7 44 24 04 dc 09 00 	movl   $0x9dc,0x4(%esp)
+ 119:	00 
+ 11a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 121:	e8 da fe ff ff       	call   0 <wc>
+    exit();
+ 126:	e8 19 03 00 00       	call   444 <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+ 12b:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
+ 132:	00 
+ 133:	e9 8f 00 00 00       	jmp    1c7 <main+0xc4>
+    if((fd = open(argv[i], 0)) < 0){
+ 138:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 13c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 143:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 146:	01 d0                	add    %edx,%eax
+ 148:	8b 00                	mov    (%eax),%eax
+ 14a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 151:	00 
+ 152:	89 04 24             	mov    %eax,(%esp)
+ 155:	e8 2a 03 00 00       	call   484 <open>
+ 15a:	89 44 24 18          	mov    %eax,0x18(%esp)
+ 15e:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
+ 163:	79 2f                	jns    194 <main+0x91>
+      printf(1, "wc: cannot open %s\n", argv[i]);
+ 165:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 169:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 170:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 173:	01 d0                	add    %edx,%eax
+ 175:	8b 00                	mov    (%eax),%eax
+ 177:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 17b:	c7 44 24 04 dd 09 00 	movl   $0x9dd,0x4(%esp)
+ 182:	00 
+ 183:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+ 18a:	e8 5a 04 00 00       	call   5e9 <printf>
+      exit();
+ 18f:	e8 b0 02 00 00       	call   444 <exit>
+    }
+    wc(fd, argv[i]);
+ 194:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 198:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 19f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1a2:	01 d0                	add    %edx,%eax
+ 1a4:	8b 00                	mov    (%eax),%eax
+ 1a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1aa:	8b 44 24 18          	mov    0x18(%esp),%eax
+ 1ae:	89 04 24             	mov    %eax,(%esp)
+ 1b1:	e8 4a fe ff ff       	call   0 <wc>
+    close(fd);
+ 1b6:	8b 44 24 18          	mov    0x18(%esp),%eax
+ 1ba:	89 04 24             	mov    %eax,(%esp)
+ 1bd:	e8 aa 02 00 00       	call   46c <close>
+  if(argc <= 1){
+    wc(0, "");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+ 1c2:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
+ 1c7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
+ 1cb:	3b 45 08             	cmp    0x8(%ebp),%eax
+ 1ce:	0f 8c 64 ff ff ff    	jl     138 <main+0x35>
+      exit();
+    }
+    wc(fd, argv[i]);
+    close(fd);
+  }
+  exit();
+ 1d4:	e8 6b 02 00 00       	call   444 <exit>
+ 1d9:	90                   	nop
+ 1da:	90                   	nop
+ 1db:	90                   	nop
+
+000001dc <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 1dc:	55                   	push   %ebp
+ 1dd:	89 e5                	mov    %esp,%ebp
+ 1df:	57                   	push   %edi
+ 1e0:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 1e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 1e4:	8b 55 10             	mov    0x10(%ebp),%edx
+ 1e7:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1ea:	89 cb                	mov    %ecx,%ebx
+ 1ec:	89 df                	mov    %ebx,%edi
+ 1ee:	89 d1                	mov    %edx,%ecx
+ 1f0:	fc                   	cld    
+ 1f1:	f3 aa                	rep stos %al,%es:(%edi)
+ 1f3:	89 ca                	mov    %ecx,%edx
+ 1f5:	89 fb                	mov    %edi,%ebx
+ 1f7:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 1fa:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 1fd:	5b                   	pop    %ebx
+ 1fe:	5f                   	pop    %edi
+ 1ff:	5d                   	pop    %ebp
+ 200:	c3                   	ret    
+
+00000201 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+ 201:	55                   	push   %ebp
+ 202:	89 e5                	mov    %esp,%ebp
+ 204:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 207:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 20d:	90                   	nop
+ 20e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 211:	0f b6 10             	movzbl (%eax),%edx
+ 214:	8b 45 08             	mov    0x8(%ebp),%eax
+ 217:	88 10                	mov    %dl,(%eax)
+ 219:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21c:	0f b6 00             	movzbl (%eax),%eax
+ 21f:	84 c0                	test   %al,%al
+ 221:	0f 95 c0             	setne  %al
+ 224:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 228:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ 22c:	84 c0                	test   %al,%al
+ 22e:	75 de                	jne    20e <strcpy+0xd>
+    ;
+  return os;
+ 230:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 233:	c9                   	leave  
+ 234:	c3                   	ret    
+
+00000235 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 235:	55                   	push   %ebp
+ 236:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 238:	eb 08                	jmp    242 <strcmp+0xd>
+    p++, q++;
+ 23a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 23e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+ 242:	8b 45 08             	mov    0x8(%ebp),%eax
+ 245:	0f b6 00             	movzbl (%eax),%eax
+ 248:	84 c0                	test   %al,%al
+ 24a:	74 10                	je     25c <strcmp+0x27>
+ 24c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 24f:	0f b6 10             	movzbl (%eax),%edx
+ 252:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 255:	0f b6 00             	movzbl (%eax),%eax
+ 258:	38 c2                	cmp    %al,%dl
+ 25a:	74 de                	je     23a <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+ 25c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 25f:	0f b6 00             	movzbl (%eax),%eax
+ 262:	0f b6 d0             	movzbl %al,%edx
+ 265:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 268:	0f b6 00             	movzbl (%eax),%eax
+ 26b:	0f b6 c0             	movzbl %al,%eax
+ 26e:	89 d1                	mov    %edx,%ecx
+ 270:	29 c1                	sub    %eax,%ecx
+ 272:	89 c8                	mov    %ecx,%eax
+}
+ 274:	5d                   	pop    %ebp
+ 275:	c3                   	ret    
+
+00000276 <strlen>:
+
+uint
+strlen(char *s)
+{
+ 276:	55                   	push   %ebp
+ 277:	89 e5                	mov    %esp,%ebp
+ 279:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 27c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 283:	eb 04                	jmp    289 <strlen+0x13>
+ 285:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 289:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 28c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28f:	01 d0                	add    %edx,%eax
+ 291:	0f b6 00             	movzbl (%eax),%eax
+ 294:	84 c0                	test   %al,%al
+ 296:	75 ed                	jne    285 <strlen+0xf>
+    ;
+  return n;
+ 298:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 29b:	c9                   	leave  
+ 29c:	c3                   	ret    
+
+0000029d <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 29d:	55                   	push   %ebp
+ 29e:	89 e5                	mov    %esp,%ebp
+ 2a0:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+ 2a3:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2a6:	89 44 24 08          	mov    %eax,0x8(%esp)
+ 2aa:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2ad:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 2b1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b4:	89 04 24             	mov    %eax,(%esp)
+ 2b7:	e8 20 ff ff ff       	call   1dc <stosb>
+  return dst;
+ 2bc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2bf:	c9                   	leave  
+ 2c0:	c3                   	ret    
+
+000002c1 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 2c1:	55                   	push   %ebp
+ 2c2:	89 e5                	mov    %esp,%ebp
+ 2c4:	83 ec 04             	sub    $0x4,%esp
+ 2c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2ca:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 2cd:	eb 14                	jmp    2e3 <strchr+0x22>
+    if(*s == c)
+ 2cf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2d2:	0f b6 00             	movzbl (%eax),%eax
+ 2d5:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 2d8:	75 05                	jne    2df <strchr+0x1e>
+      return (char*)s;
+ 2da:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2dd:	eb 13                	jmp    2f2 <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 2df:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 2e3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2e6:	0f b6 00             	movzbl (%eax),%eax
+ 2e9:	84 c0                	test   %al,%al
+ 2eb:	75 e2                	jne    2cf <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 2ed:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 2f2:	c9                   	leave  
+ 2f3:	c3                   	ret    
+
+000002f4 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 2f4:	55                   	push   %ebp
+ 2f5:	89 e5                	mov    %esp,%ebp
+ 2f7:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 301:	eb 46                	jmp    349 <gets+0x55>
+    cc = read(0, &c, 1);
+ 303:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 30a:	00 
+ 30b:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 30e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 312:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 319:	e8 3e 01 00 00       	call   45c <read>
+ 31e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 321:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 325:	7e 2f                	jle    356 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 327:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 32a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 32d:	01 c2                	add    %eax,%edx
+ 32f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 333:	88 02                	mov    %al,(%edx)
+ 335:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 339:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 33d:	3c 0a                	cmp    $0xa,%al
+ 33f:	74 16                	je     357 <gets+0x63>
+ 341:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 345:	3c 0d                	cmp    $0xd,%al
+ 347:	74 0e                	je     357 <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 349:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 34c:	83 c0 01             	add    $0x1,%eax
+ 34f:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 352:	7c af                	jl     303 <gets+0xf>
+ 354:	eb 01                	jmp    357 <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 356:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 357:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 35a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 35d:	01 d0                	add    %edx,%eax
+ 35f:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 362:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 365:	c9                   	leave  
+ 366:	c3                   	ret    
+
+00000367 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 367:	55                   	push   %ebp
+ 368:	89 e5                	mov    %esp,%ebp
+ 36a:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 36d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 374:	00 
+ 375:	8b 45 08             	mov    0x8(%ebp),%eax
+ 378:	89 04 24             	mov    %eax,(%esp)
+ 37b:	e8 04 01 00 00       	call   484 <open>
+ 380:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 383:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 387:	79 07                	jns    390 <stat+0x29>
+    return -1;
+ 389:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 38e:	eb 23                	jmp    3b3 <stat+0x4c>
+  r = fstat(fd, st);
+ 390:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 393:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 397:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 39a:	89 04 24             	mov    %eax,(%esp)
+ 39d:	e8 fa 00 00 00       	call   49c <fstat>
+ 3a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 3a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 3a8:	89 04 24             	mov    %eax,(%esp)
+ 3ab:	e8 bc 00 00 00       	call   46c <close>
+  return r;
+ 3b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 3b3:	c9                   	leave  
+ 3b4:	c3                   	ret    
+
+000003b5 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 3b5:	55                   	push   %ebp
+ 3b6:	89 e5                	mov    %esp,%ebp
+ 3b8:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 3bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 3c2:	eb 23                	jmp    3e7 <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 3c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 3c7:	89 d0                	mov    %edx,%eax
+ 3c9:	c1 e0 02             	shl    $0x2,%eax
+ 3cc:	01 d0                	add    %edx,%eax
+ 3ce:	01 c0                	add    %eax,%eax
+ 3d0:	89 c2                	mov    %eax,%edx
+ 3d2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3d5:	0f b6 00             	movzbl (%eax),%eax
+ 3d8:	0f be c0             	movsbl %al,%eax
+ 3db:	01 d0                	add    %edx,%eax
+ 3dd:	83 e8 30             	sub    $0x30,%eax
+ 3e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 3e3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 3e7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3ea:	0f b6 00             	movzbl (%eax),%eax
+ 3ed:	3c 2f                	cmp    $0x2f,%al
+ 3ef:	7e 0a                	jle    3fb <atoi+0x46>
+ 3f1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3f4:	0f b6 00             	movzbl (%eax),%eax
+ 3f7:	3c 39                	cmp    $0x39,%al
+ 3f9:	7e c9                	jle    3c4 <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 3fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3fe:	c9                   	leave  
+ 3ff:	c3                   	ret    
+
+00000400 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 400:	55                   	push   %ebp
+ 401:	89 e5                	mov    %esp,%ebp
+ 403:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 406:	8b 45 08             	mov    0x8(%ebp),%eax
+ 409:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 40c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 40f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 412:	eb 13                	jmp    427 <memmove+0x27>
+    *dst++ = *src++;
+ 414:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 417:	0f b6 10             	movzbl (%eax),%edx
+ 41a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 41d:	88 10                	mov    %dl,(%eax)
+ 41f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 423:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 427:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 42b:	0f 9f c0             	setg   %al
+ 42e:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 432:	84 c0                	test   %al,%al
+ 434:	75 de                	jne    414 <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 436:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 439:	c9                   	leave  
+ 43a:	c3                   	ret    
+ 43b:	90                   	nop
+
+0000043c <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 43c:	b8 01 00 00 00       	mov    $0x1,%eax
+ 441:	cd 40                	int    $0x40
+ 443:	c3                   	ret    
+
+00000444 <exit>:
+SYSCALL(exit)
+ 444:	b8 02 00 00 00       	mov    $0x2,%eax
+ 449:	cd 40                	int    $0x40
+ 44b:	c3                   	ret    
+
+0000044c <wait>:
+SYSCALL(wait)
+ 44c:	b8 03 00 00 00       	mov    $0x3,%eax
+ 451:	cd 40                	int    $0x40
+ 453:	c3                   	ret    
+
+00000454 <pipe>:
+SYSCALL(pipe)
+ 454:	b8 04 00 00 00       	mov    $0x4,%eax
+ 459:	cd 40                	int    $0x40
+ 45b:	c3                   	ret    
+
+0000045c <read>:
+SYSCALL(read)
+ 45c:	b8 05 00 00 00       	mov    $0x5,%eax
+ 461:	cd 40                	int    $0x40
+ 463:	c3                   	ret    
+
+00000464 <write>:
+SYSCALL(write)
+ 464:	b8 10 00 00 00       	mov    $0x10,%eax
+ 469:	cd 40                	int    $0x40
+ 46b:	c3                   	ret    
+
+0000046c <close>:
+SYSCALL(close)
+ 46c:	b8 15 00 00 00       	mov    $0x15,%eax
+ 471:	cd 40                	int    $0x40
+ 473:	c3                   	ret    
+
+00000474 <kill>:
+SYSCALL(kill)
+ 474:	b8 06 00 00 00       	mov    $0x6,%eax
+ 479:	cd 40                	int    $0x40
+ 47b:	c3                   	ret    
+
+0000047c <exec>:
+SYSCALL(exec)
+ 47c:	b8 07 00 00 00       	mov    $0x7,%eax
+ 481:	cd 40                	int    $0x40
+ 483:	c3                   	ret    
+
+00000484 <open>:
+SYSCALL(open)
+ 484:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 489:	cd 40                	int    $0x40
+ 48b:	c3                   	ret    
+
+0000048c <mknod>:
+SYSCALL(mknod)
+ 48c:	b8 11 00 00 00       	mov    $0x11,%eax
+ 491:	cd 40                	int    $0x40
+ 493:	c3                   	ret    
+
+00000494 <unlink>:
+SYSCALL(unlink)
+ 494:	b8 12 00 00 00       	mov    $0x12,%eax
+ 499:	cd 40                	int    $0x40
+ 49b:	c3                   	ret    
+
+0000049c <fstat>:
+SYSCALL(fstat)
+ 49c:	b8 08 00 00 00       	mov    $0x8,%eax
+ 4a1:	cd 40                	int    $0x40
+ 4a3:	c3                   	ret    
+
+000004a4 <link>:
+SYSCALL(link)
+ 4a4:	b8 13 00 00 00       	mov    $0x13,%eax
+ 4a9:	cd 40                	int    $0x40
+ 4ab:	c3                   	ret    
+
+000004ac <mkdir>:
+SYSCALL(mkdir)
+ 4ac:	b8 14 00 00 00       	mov    $0x14,%eax
+ 4b1:	cd 40                	int    $0x40
+ 4b3:	c3                   	ret    
+
+000004b4 <chdir>:
+SYSCALL(chdir)
+ 4b4:	b8 09 00 00 00       	mov    $0x9,%eax
+ 4b9:	cd 40                	int    $0x40
+ 4bb:	c3                   	ret    
+
+000004bc <dup>:
+SYSCALL(dup)
+ 4bc:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 4c1:	cd 40                	int    $0x40
+ 4c3:	c3                   	ret    
+
+000004c4 <getpid>:
+SYSCALL(getpid)
+ 4c4:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 4c9:	cd 40                	int    $0x40
+ 4cb:	c3                   	ret    
+
+000004cc <sbrk>:
+SYSCALL(sbrk)
+ 4cc:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 4d1:	cd 40                	int    $0x40
+ 4d3:	c3                   	ret    
+
+000004d4 <sleep>:
+SYSCALL(sleep)
+ 4d4:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 4d9:	cd 40                	int    $0x40
+ 4db:	c3                   	ret    
+
+000004dc <uptime>:
+SYSCALL(uptime)
+ 4dc:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 4e1:	cd 40                	int    $0x40
+ 4e3:	c3                   	ret    
+
+000004e4 <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 4e4:	b8 16 00 00 00       	mov    $0x16,%eax
+ 4e9:	cd 40                	int    $0x40
+ 4eb:	c3                   	ret    
+
+000004ec <shutdown>:
+SYSCALL(shutdown)
+ 4ec:	b8 17 00 00 00       	mov    $0x17,%eax
+ 4f1:	cd 40                	int    $0x40
+ 4f3:	c3                   	ret    
+
+000004f4 <fork_winner>:
+SYSCALL(fork_winner)
+ 4f4:	b8 18 00 00 00       	mov    $0x18,%eax
+ 4f9:	cd 40                	int    $0x40
+ 4fb:	c3                   	ret    
+
+000004fc <set_sched>:
+SYSCALL(set_sched)
+ 4fc:	b8 19 00 00 00       	mov    $0x19,%eax
+ 501:	cd 40                	int    $0x40
+ 503:	c3                   	ret    
+
+00000504 <set_priority>:
+SYSCALL(set_priority)
+ 504:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 509:	cd 40                	int    $0x40
+ 50b:	c3                   	ret    
+
+0000050c <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 50c:	55                   	push   %ebp
+ 50d:	89 e5                	mov    %esp,%ebp
+ 50f:	83 ec 28             	sub    $0x28,%esp
+ 512:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 515:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 518:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 51f:	00 
+ 520:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 523:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 527:	8b 45 08             	mov    0x8(%ebp),%eax
+ 52a:	89 04 24             	mov    %eax,(%esp)
+ 52d:	e8 32 ff ff ff       	call   464 <write>
+}
+ 532:	c9                   	leave  
+ 533:	c3                   	ret    
+
+00000534 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 534:	55                   	push   %ebp
+ 535:	89 e5                	mov    %esp,%ebp
+ 537:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 53a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 541:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 545:	74 17                	je     55e <printint+0x2a>
+ 547:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 54b:	79 11                	jns    55e <printint+0x2a>
+    neg = 1;
+ 54d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 554:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 557:	f7 d8                	neg    %eax
+ 559:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 55c:	eb 06                	jmp    564 <printint+0x30>
+  } else {
+    x = xx;
+ 55e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 561:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 564:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 56b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 56e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 571:	ba 00 00 00 00       	mov    $0x0,%edx
+ 576:	f7 f1                	div    %ecx
+ 578:	89 d0                	mov    %edx,%eax
+ 57a:	0f b6 80 54 0c 00 00 	movzbl 0xc54(%eax),%eax
+ 581:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 584:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 587:	01 ca                	add    %ecx,%edx
+ 589:	88 02                	mov    %al,(%edx)
+ 58b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 58f:	8b 55 10             	mov    0x10(%ebp),%edx
+ 592:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 595:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 598:	ba 00 00 00 00       	mov    $0x0,%edx
+ 59d:	f7 75 d4             	divl   -0x2c(%ebp)
+ 5a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 5a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 5a7:	75 c2                	jne    56b <printint+0x37>
+  if(neg)
+ 5a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 5ad:	74 2e                	je     5dd <printint+0xa9>
+    buf[i++] = '-';
+ 5af:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 5b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5b5:	01 d0                	add    %edx,%eax
+ 5b7:	c6 00 2d             	movb   $0x2d,(%eax)
+ 5ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 5be:	eb 1d                	jmp    5dd <printint+0xa9>
+    putc(fd, buf[i]);
+ 5c0:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 5c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5c6:	01 d0                	add    %edx,%eax
+ 5c8:	0f b6 00             	movzbl (%eax),%eax
+ 5cb:	0f be c0             	movsbl %al,%eax
+ 5ce:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5d2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5d5:	89 04 24             	mov    %eax,(%esp)
+ 5d8:	e8 2f ff ff ff       	call   50c <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 5dd:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 5e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 5e5:	79 d9                	jns    5c0 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 5e7:	c9                   	leave  
+ 5e8:	c3                   	ret    
+
+000005e9 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 5e9:	55                   	push   %ebp
+ 5ea:	89 e5                	mov    %esp,%ebp
+ 5ec:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 5ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 5f6:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 5f9:	83 c0 04             	add    $0x4,%eax
+ 5fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 5ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 606:	e9 7d 01 00 00       	jmp    788 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 60b:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 60e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 611:	01 d0                	add    %edx,%eax
+ 613:	0f b6 00             	movzbl (%eax),%eax
+ 616:	0f be c0             	movsbl %al,%eax
+ 619:	25 ff 00 00 00       	and    $0xff,%eax
+ 61e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 621:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 625:	75 2c                	jne    653 <printf+0x6a>
+      if(c == '%'){
+ 627:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 62b:	75 0c                	jne    639 <printf+0x50>
+        state = '%';
+ 62d:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 634:	e9 4b 01 00 00       	jmp    784 <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 639:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 63c:	0f be c0             	movsbl %al,%eax
+ 63f:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 643:	8b 45 08             	mov    0x8(%ebp),%eax
+ 646:	89 04 24             	mov    %eax,(%esp)
+ 649:	e8 be fe ff ff       	call   50c <putc>
+ 64e:	e9 31 01 00 00       	jmp    784 <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 653:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 657:	0f 85 27 01 00 00    	jne    784 <printf+0x19b>
+      if(c == 'd'){
+ 65d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 661:	75 2d                	jne    690 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 663:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 666:	8b 00                	mov    (%eax),%eax
+ 668:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 66f:	00 
+ 670:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 677:	00 
+ 678:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 67c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 67f:	89 04 24             	mov    %eax,(%esp)
+ 682:	e8 ad fe ff ff       	call   534 <printint>
+        ap++;
+ 687:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 68b:	e9 ed 00 00 00       	jmp    77d <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 690:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 694:	74 06                	je     69c <printf+0xb3>
+ 696:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 69a:	75 2d                	jne    6c9 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 69c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 69f:	8b 00                	mov    (%eax),%eax
+ 6a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 6a8:	00 
+ 6a9:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 6b0:	00 
+ 6b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6b5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6b8:	89 04 24             	mov    %eax,(%esp)
+ 6bb:	e8 74 fe ff ff       	call   534 <printint>
+        ap++;
+ 6c0:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 6c4:	e9 b4 00 00 00       	jmp    77d <printf+0x194>
+      } else if(c == 's'){
+ 6c9:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 6cd:	75 46                	jne    715 <printf+0x12c>
+        s = (char*)*ap;
+ 6cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 6d2:	8b 00                	mov    (%eax),%eax
+ 6d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 6d7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 6db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 6df:	75 27                	jne    708 <printf+0x11f>
+          s = "(null)";
+ 6e1:	c7 45 f4 f1 09 00 00 	movl   $0x9f1,-0xc(%ebp)
+        while(*s != 0){
+ 6e8:	eb 1e                	jmp    708 <printf+0x11f>
+          putc(fd, *s);
+ 6ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6ed:	0f b6 00             	movzbl (%eax),%eax
+ 6f0:	0f be c0             	movsbl %al,%eax
+ 6f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 6f7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6fa:	89 04 24             	mov    %eax,(%esp)
+ 6fd:	e8 0a fe ff ff       	call   50c <putc>
+          s++;
+ 702:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 706:	eb 01                	jmp    709 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 708:	90                   	nop
+ 709:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 70c:	0f b6 00             	movzbl (%eax),%eax
+ 70f:	84 c0                	test   %al,%al
+ 711:	75 d7                	jne    6ea <printf+0x101>
+ 713:	eb 68                	jmp    77d <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 715:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 719:	75 1d                	jne    738 <printf+0x14f>
+        putc(fd, *ap);
+ 71b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 71e:	8b 00                	mov    (%eax),%eax
+ 720:	0f be c0             	movsbl %al,%eax
+ 723:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 727:	8b 45 08             	mov    0x8(%ebp),%eax
+ 72a:	89 04 24             	mov    %eax,(%esp)
+ 72d:	e8 da fd ff ff       	call   50c <putc>
+        ap++;
+ 732:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 736:	eb 45                	jmp    77d <printf+0x194>
+      } else if(c == '%'){
+ 738:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 73c:	75 17                	jne    755 <printf+0x16c>
+        putc(fd, c);
+ 73e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 741:	0f be c0             	movsbl %al,%eax
+ 744:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 748:	8b 45 08             	mov    0x8(%ebp),%eax
+ 74b:	89 04 24             	mov    %eax,(%esp)
+ 74e:	e8 b9 fd ff ff       	call   50c <putc>
+ 753:	eb 28                	jmp    77d <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 755:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 75c:	00 
+ 75d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 760:	89 04 24             	mov    %eax,(%esp)
+ 763:	e8 a4 fd ff ff       	call   50c <putc>
+        putc(fd, c);
+ 768:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 76b:	0f be c0             	movsbl %al,%eax
+ 76e:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 772:	8b 45 08             	mov    0x8(%ebp),%eax
+ 775:	89 04 24             	mov    %eax,(%esp)
+ 778:	e8 8f fd ff ff       	call   50c <putc>
+      }
+      state = 0;
+ 77d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 784:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 788:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 78e:	01 d0                	add    %edx,%eax
+ 790:	0f b6 00             	movzbl (%eax),%eax
+ 793:	84 c0                	test   %al,%al
+ 795:	0f 85 70 fe ff ff    	jne    60b <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 79b:	c9                   	leave  
+ 79c:	c3                   	ret    
+ 79d:	90                   	nop
+ 79e:	90                   	nop
+ 79f:	90                   	nop
+
+000007a0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7a0:	55                   	push   %ebp
+ 7a1:	89 e5                	mov    %esp,%ebp
+ 7a3:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 7a6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7a9:	83 e8 08             	sub    $0x8,%eax
+ 7ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7af:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 7b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 7b7:	eb 24                	jmp    7dd <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7bc:	8b 00                	mov    (%eax),%eax
+ 7be:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7c1:	77 12                	ja     7d5 <free+0x35>
+ 7c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7c6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7c9:	77 24                	ja     7ef <free+0x4f>
+ 7cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7ce:	8b 00                	mov    (%eax),%eax
+ 7d0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 7d3:	77 1a                	ja     7ef <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7d8:	8b 00                	mov    (%eax),%eax
+ 7da:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 7dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7e0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7e3:	76 d4                	jbe    7b9 <free+0x19>
+ 7e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7e8:	8b 00                	mov    (%eax),%eax
+ 7ea:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 7ed:	76 ca                	jbe    7b9 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 7ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7f2:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 7fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7ff:	01 c2                	add    %eax,%edx
+ 801:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 804:	8b 00                	mov    (%eax),%eax
+ 806:	39 c2                	cmp    %eax,%edx
+ 808:	75 24                	jne    82e <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 80a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 80d:	8b 50 04             	mov    0x4(%eax),%edx
+ 810:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 813:	8b 00                	mov    (%eax),%eax
+ 815:	8b 40 04             	mov    0x4(%eax),%eax
+ 818:	01 c2                	add    %eax,%edx
+ 81a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 81d:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 820:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 823:	8b 00                	mov    (%eax),%eax
+ 825:	8b 10                	mov    (%eax),%edx
+ 827:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 82a:	89 10                	mov    %edx,(%eax)
+ 82c:	eb 0a                	jmp    838 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 82e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 831:	8b 10                	mov    (%eax),%edx
+ 833:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 836:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 838:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 83b:	8b 40 04             	mov    0x4(%eax),%eax
+ 83e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 845:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 848:	01 d0                	add    %edx,%eax
+ 84a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 84d:	75 20                	jne    86f <free+0xcf>
+    p->s.size += bp->s.size;
+ 84f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 852:	8b 50 04             	mov    0x4(%eax),%edx
+ 855:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 858:	8b 40 04             	mov    0x4(%eax),%eax
+ 85b:	01 c2                	add    %eax,%edx
+ 85d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 860:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 863:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 866:	8b 10                	mov    (%eax),%edx
+ 868:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 86b:	89 10                	mov    %edx,(%eax)
+ 86d:	eb 08                	jmp    877 <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 86f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 872:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 875:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 877:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 87a:	a3 88 0c 00 00       	mov    %eax,0xc88
+}
+ 87f:	c9                   	leave  
+ 880:	c3                   	ret    
+
+00000881 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 881:	55                   	push   %ebp
+ 882:	89 e5                	mov    %esp,%ebp
+ 884:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 887:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 88e:	77 07                	ja     897 <morecore+0x16>
+    nu = 4096;
+ 890:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 897:	8b 45 08             	mov    0x8(%ebp),%eax
+ 89a:	c1 e0 03             	shl    $0x3,%eax
+ 89d:	89 04 24             	mov    %eax,(%esp)
+ 8a0:	e8 27 fc ff ff       	call   4cc <sbrk>
+ 8a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 8a8:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 8ac:	75 07                	jne    8b5 <morecore+0x34>
+    return 0;
+ 8ae:	b8 00 00 00 00       	mov    $0x0,%eax
+ 8b3:	eb 22                	jmp    8d7 <morecore+0x56>
+  hp = (Header*)p;
+ 8b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 8bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8be:	8b 55 08             	mov    0x8(%ebp),%edx
+ 8c1:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 8c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8c7:	83 c0 08             	add    $0x8,%eax
+ 8ca:	89 04 24             	mov    %eax,(%esp)
+ 8cd:	e8 ce fe ff ff       	call   7a0 <free>
+  return freep;
+ 8d2:	a1 88 0c 00 00       	mov    0xc88,%eax
+}
+ 8d7:	c9                   	leave  
+ 8d8:	c3                   	ret    
+
+000008d9 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 8d9:	55                   	push   %ebp
+ 8da:	89 e5                	mov    %esp,%ebp
+ 8dc:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 8df:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8e2:	83 c0 07             	add    $0x7,%eax
+ 8e5:	c1 e8 03             	shr    $0x3,%eax
+ 8e8:	83 c0 01             	add    $0x1,%eax
+ 8eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 8ee:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 8f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 8fa:	75 23                	jne    91f <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 8fc:	c7 45 f0 80 0c 00 00 	movl   $0xc80,-0x10(%ebp)
+ 903:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 906:	a3 88 0c 00 00       	mov    %eax,0xc88
+ 90b:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 910:	a3 80 0c 00 00       	mov    %eax,0xc80
+    base.s.size = 0;
+ 915:	c7 05 84 0c 00 00 00 	movl   $0x0,0xc84
+ 91c:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 91f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 922:	8b 00                	mov    (%eax),%eax
+ 924:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 927:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 92a:	8b 40 04             	mov    0x4(%eax),%eax
+ 92d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 930:	72 4d                	jb     97f <malloc+0xa6>
+      if(p->s.size == nunits)
+ 932:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 935:	8b 40 04             	mov    0x4(%eax),%eax
+ 938:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 93b:	75 0c                	jne    949 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 93d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 940:	8b 10                	mov    (%eax),%edx
+ 942:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 945:	89 10                	mov    %edx,(%eax)
+ 947:	eb 26                	jmp    96f <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 949:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 94c:	8b 40 04             	mov    0x4(%eax),%eax
+ 94f:	89 c2                	mov    %eax,%edx
+ 951:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 954:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 957:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 95a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 95d:	8b 40 04             	mov    0x4(%eax),%eax
+ 960:	c1 e0 03             	shl    $0x3,%eax
+ 963:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 966:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 969:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 96c:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 96f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 972:	a3 88 0c 00 00       	mov    %eax,0xc88
+      return (void*)(p + 1);
+ 977:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 97a:	83 c0 08             	add    $0x8,%eax
+ 97d:	eb 38                	jmp    9b7 <malloc+0xde>
+    }
+    if(p == freep)
+ 97f:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 984:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 987:	75 1b                	jne    9a4 <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 989:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 98c:	89 04 24             	mov    %eax,(%esp)
+ 98f:	e8 ed fe ff ff       	call   881 <morecore>
+ 994:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 997:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 99b:	75 07                	jne    9a4 <malloc+0xcb>
+        return 0;
+ 99d:	b8 00 00 00 00       	mov    $0x0,%eax
+ 9a2:	eb 13                	jmp    9b7 <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 9a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 9aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 9ad:	8b 00                	mov    (%eax),%eax
+ 9af:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 9b2:	e9 70 ff ff ff       	jmp    927 <malloc+0x4e>
+}
+ 9b7:	c9                   	leave  
+ 9b8:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/wc.d cs550-16s-proj1-working/wc.d
--- cs550-16s-proj1-base/wc.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/wc.d	2016-03-04 14:37:08.000000000 -0500
@@ -0,0 +1 @@
+wc.o: wc.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/wc.o and cs550-16s-proj1-working/wc.o differ
diff -uNr cs550-16s-proj1-base/wc.sym cs550-16s-proj1-working/wc.sym
--- cs550-16s-proj1-base/wc.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/wc.sym	2016-03-04 14:37:09.000000000 -0500
@@ -0,0 +1,67 @@
+00000000 .text
+000009b9 .rodata
+000009f8 .eh_frame
+00000c54 .data
+00000c80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 wc.c
+00000000 ulib.c
+000001dc stosb
+00000000 printf.c
+0000050c putc
+00000534 printint
+00000c54 digits.1028
+00000000 umalloc.c
+00000c80 base
+00000c88 freep
+00000881 morecore
+00000201 strcpy
+000005e9 printf
+00000400 memmove
+0000048c mknod
+000002f4 gets
+000004c4 getpid
+000008d9 malloc
+000004d4 sleep
+00000504 set_priority
+00000454 pipe
+00000464 write
+0000049c fstat
+00000474 kill
+000004b4 chdir
+0000047c exec
+0000044c wait
+0000045c read
+00000494 unlink
+00000000 wc
+0000043c fork
+000004cc sbrk
+000004dc uptime
+00000c68 __bss_start
+0000029d memset
+00000103 main
+000004e4 enable_sched_trace
+00000235 strcmp
+000004ec shutdown
+000004bc dup
+00000ca0 buf
+000004fc set_sched
+00000367 stat
+00000c68 _edata
+00000ea0 _end
+000004a4 link
+00000444 exit
+000003b5 atoi
+000004f4 fork_winner
+00000276 strlen
+00000484 open
+000002c1 strchr
+000004ac mkdir
+0000046c close
+000007a0 free
diff -uNr cs550-16s-proj1-base/x86.h cs550-16s-proj1-working/x86.h
--- cs550-16s-proj1-base/x86.h	2016-02-15 15:37:10.000000000 -0500
+++ cs550-16s-proj1-working/x86.h	2016-03-04 14:36:43.000000000 -0500
@@ -144,13 +144,6 @@
   asm volatile("movl %0,%%cr3" : : "r" (val));
 }
 
-// CS550: to solve the 100%-CPU-utilization-when-idling problem - "hlt" instruction puts CPU to sleep
-static inline void
-halt()
-{
-    asm volatile("hlt" : : :"memory");
-}
-
 //PAGEBREAK: 36
 // Layout of the trap frame built on the stack by the
 // hardware and by trapasm.S, and passed to trap().
Binary files cs550-16s-proj1-base/xv6.img and cs550-16s-proj1-working/xv6.img differ
Binary files cs550-16s-proj1-base/_zombie and cs550-16s-proj1-working/_zombie differ
diff -uNr cs550-16s-proj1-base/zombie.asm cs550-16s-proj1-working/zombie.asm
--- cs550-16s-proj1-base/zombie.asm	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/zombie.asm	2016-03-04 14:37:10.000000000 -0500
@@ -0,0 +1,1183 @@
+
+_zombie:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+   0:	55                   	push   %ebp
+   1:	89 e5                	mov    %esp,%ebp
+   3:	83 e4 f0             	and    $0xfffffff0,%esp
+   6:	83 ec 10             	sub    $0x10,%esp
+  if(fork() > 0)
+   9:	e8 76 02 00 00       	call   284 <fork>
+   e:	85 c0                	test   %eax,%eax
+  10:	7e 0c                	jle    1e <main+0x1e>
+    sleep(5);  // Let child exit before parent.
+  12:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+  19:	e8 fe 02 00 00       	call   31c <sleep>
+  exit();
+  1e:	e8 69 02 00 00       	call   28c <exit>
+  23:	90                   	nop
+
+00000024 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  24:	55                   	push   %ebp
+  25:	89 e5                	mov    %esp,%ebp
+  27:	57                   	push   %edi
+  28:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  29:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  2c:	8b 55 10             	mov    0x10(%ebp),%edx
+  2f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  32:	89 cb                	mov    %ecx,%ebx
+  34:	89 df                	mov    %ebx,%edi
+  36:	89 d1                	mov    %edx,%ecx
+  38:	fc                   	cld    
+  39:	f3 aa                	rep stos %al,%es:(%edi)
+  3b:	89 ca                	mov    %ecx,%edx
+  3d:	89 fb                	mov    %edi,%ebx
+  3f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  42:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  45:	5b                   	pop    %ebx
+  46:	5f                   	pop    %edi
+  47:	5d                   	pop    %ebp
+  48:	c3                   	ret    
+
+00000049 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+  49:	55                   	push   %ebp
+  4a:	89 e5                	mov    %esp,%ebp
+  4c:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  4f:	8b 45 08             	mov    0x8(%ebp),%eax
+  52:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  55:	90                   	nop
+  56:	8b 45 0c             	mov    0xc(%ebp),%eax
+  59:	0f b6 10             	movzbl (%eax),%edx
+  5c:	8b 45 08             	mov    0x8(%ebp),%eax
+  5f:	88 10                	mov    %dl,(%eax)
+  61:	8b 45 08             	mov    0x8(%ebp),%eax
+  64:	0f b6 00             	movzbl (%eax),%eax
+  67:	84 c0                	test   %al,%al
+  69:	0f 95 c0             	setne  %al
+  6c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  70:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  74:	84 c0                	test   %al,%al
+  76:	75 de                	jne    56 <strcpy+0xd>
+    ;
+  return os;
+  78:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  7b:	c9                   	leave  
+  7c:	c3                   	ret    
+
+0000007d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  7d:	55                   	push   %ebp
+  7e:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  80:	eb 08                	jmp    8a <strcmp+0xd>
+    p++, q++;
+  82:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  86:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+  8a:	8b 45 08             	mov    0x8(%ebp),%eax
+  8d:	0f b6 00             	movzbl (%eax),%eax
+  90:	84 c0                	test   %al,%al
+  92:	74 10                	je     a4 <strcmp+0x27>
+  94:	8b 45 08             	mov    0x8(%ebp),%eax
+  97:	0f b6 10             	movzbl (%eax),%edx
+  9a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  9d:	0f b6 00             	movzbl (%eax),%eax
+  a0:	38 c2                	cmp    %al,%dl
+  a2:	74 de                	je     82 <strcmp+0x5>
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+  a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  a7:	0f b6 00             	movzbl (%eax),%eax
+  aa:	0f b6 d0             	movzbl %al,%edx
+  ad:	8b 45 0c             	mov    0xc(%ebp),%eax
+  b0:	0f b6 00             	movzbl (%eax),%eax
+  b3:	0f b6 c0             	movzbl %al,%eax
+  b6:	89 d1                	mov    %edx,%ecx
+  b8:	29 c1                	sub    %eax,%ecx
+  ba:	89 c8                	mov    %ecx,%eax
+}
+  bc:	5d                   	pop    %ebp
+  bd:	c3                   	ret    
+
+000000be <strlen>:
+
+uint
+strlen(char *s)
+{
+  be:	55                   	push   %ebp
+  bf:	89 e5                	mov    %esp,%ebp
+  c1:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+  c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  cb:	eb 04                	jmp    d1 <strlen+0x13>
+  cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  d1:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  d7:	01 d0                	add    %edx,%eax
+  d9:	0f b6 00             	movzbl (%eax),%eax
+  dc:	84 c0                	test   %al,%al
+  de:	75 ed                	jne    cd <strlen+0xf>
+    ;
+  return n;
+  e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  e3:	c9                   	leave  
+  e4:	c3                   	ret    
+
+000000e5 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  e5:	55                   	push   %ebp
+  e6:	89 e5                	mov    %esp,%ebp
+  e8:	83 ec 0c             	sub    $0xc,%esp
+  stosb(dst, c, n);
+  eb:	8b 45 10             	mov    0x10(%ebp),%eax
+  ee:	89 44 24 08          	mov    %eax,0x8(%esp)
+  f2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  f9:	8b 45 08             	mov    0x8(%ebp),%eax
+  fc:	89 04 24             	mov    %eax,(%esp)
+  ff:	e8 20 ff ff ff       	call   24 <stosb>
+  return dst;
+ 104:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 107:	c9                   	leave  
+ 108:	c3                   	ret    
+
+00000109 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 109:	55                   	push   %ebp
+ 10a:	89 e5                	mov    %esp,%ebp
+ 10c:	83 ec 04             	sub    $0x4,%esp
+ 10f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 112:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 115:	eb 14                	jmp    12b <strchr+0x22>
+    if(*s == c)
+ 117:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11a:	0f b6 00             	movzbl (%eax),%eax
+ 11d:	3a 45 fc             	cmp    -0x4(%ebp),%al
+ 120:	75 05                	jne    127 <strchr+0x1e>
+      return (char*)s;
+ 122:	8b 45 08             	mov    0x8(%ebp),%eax
+ 125:	eb 13                	jmp    13a <strchr+0x31>
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+ 127:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 12b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 12e:	0f b6 00             	movzbl (%eax),%eax
+ 131:	84 c0                	test   %al,%al
+ 133:	75 e2                	jne    117 <strchr+0xe>
+    if(*s == c)
+      return (char*)s;
+  return 0;
+ 135:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 13a:	c9                   	leave  
+ 13b:	c3                   	ret    
+
+0000013c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 13c:	55                   	push   %ebp
+ 13d:	89 e5                	mov    %esp,%ebp
+ 13f:	83 ec 28             	sub    $0x28,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 142:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 149:	eb 46                	jmp    191 <gets+0x55>
+    cc = read(0, &c, 1);
+ 14b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 152:	00 
+ 153:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 156:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 15a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+ 161:	e8 3e 01 00 00       	call   2a4 <read>
+ 166:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 169:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 16d:	7e 2f                	jle    19e <gets+0x62>
+      break;
+    buf[i++] = c;
+ 16f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 172:	8b 45 08             	mov    0x8(%ebp),%eax
+ 175:	01 c2                	add    %eax,%edx
+ 177:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 17b:	88 02                	mov    %al,(%edx)
+ 17d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(c == '\n' || c == '\r')
+ 181:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 185:	3c 0a                	cmp    $0xa,%al
+ 187:	74 16                	je     19f <gets+0x63>
+ 189:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 18d:	3c 0d                	cmp    $0xd,%al
+ 18f:	74 0e                	je     19f <gets+0x63>
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 191:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 194:	83 c0 01             	add    $0x1,%eax
+ 197:	3b 45 0c             	cmp    0xc(%ebp),%eax
+ 19a:	7c af                	jl     14b <gets+0xf>
+ 19c:	eb 01                	jmp    19f <gets+0x63>
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+ 19e:	90                   	nop
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+ 19f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1a2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1a5:	01 d0                	add    %edx,%eax
+ 1a7:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 1aa:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1ad:	c9                   	leave  
+ 1ae:	c3                   	ret    
+
+000001af <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+ 1af:	55                   	push   %ebp
+ 1b0:	89 e5                	mov    %esp,%ebp
+ 1b2:	83 ec 28             	sub    $0x28,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1b5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+ 1bc:	00 
+ 1bd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1c0:	89 04 24             	mov    %eax,(%esp)
+ 1c3:	e8 04 01 00 00       	call   2cc <open>
+ 1c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 1cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 1cf:	79 07                	jns    1d8 <stat+0x29>
+    return -1;
+ 1d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 1d6:	eb 23                	jmp    1fb <stat+0x4c>
+  r = fstat(fd, st);
+ 1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1db:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 1df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1e2:	89 04 24             	mov    %eax,(%esp)
+ 1e5:	e8 fa 00 00 00       	call   2e4 <fstat>
+ 1ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 1ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1f0:	89 04 24             	mov    %eax,(%esp)
+ 1f3:	e8 bc 00 00 00       	call   2b4 <close>
+  return r;
+ 1f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 1fb:	c9                   	leave  
+ 1fc:	c3                   	ret    
+
+000001fd <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1fd:	55                   	push   %ebp
+ 1fe:	89 e5                	mov    %esp,%ebp
+ 200:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 203:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 20a:	eb 23                	jmp    22f <atoi+0x32>
+    n = n*10 + *s++ - '0';
+ 20c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 20f:	89 d0                	mov    %edx,%eax
+ 211:	c1 e0 02             	shl    $0x2,%eax
+ 214:	01 d0                	add    %edx,%eax
+ 216:	01 c0                	add    %eax,%eax
+ 218:	89 c2                	mov    %eax,%edx
+ 21a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21d:	0f b6 00             	movzbl (%eax),%eax
+ 220:	0f be c0             	movsbl %al,%eax
+ 223:	01 d0                	add    %edx,%eax
+ 225:	83 e8 30             	sub    $0x30,%eax
+ 228:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 22b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 22f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 232:	0f b6 00             	movzbl (%eax),%eax
+ 235:	3c 2f                	cmp    $0x2f,%al
+ 237:	7e 0a                	jle    243 <atoi+0x46>
+ 239:	8b 45 08             	mov    0x8(%ebp),%eax
+ 23c:	0f b6 00             	movzbl (%eax),%eax
+ 23f:	3c 39                	cmp    $0x39,%al
+ 241:	7e c9                	jle    20c <atoi+0xf>
+    n = n*10 + *s++ - '0';
+  return n;
+ 243:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 246:	c9                   	leave  
+ 247:	c3                   	ret    
+
+00000248 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+ 248:	55                   	push   %ebp
+ 249:	89 e5                	mov    %esp,%ebp
+ 24b:	83 ec 10             	sub    $0x10,%esp
+  char *dst, *src;
+  
+  dst = vdst;
+ 24e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 251:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 254:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 257:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 25a:	eb 13                	jmp    26f <memmove+0x27>
+    *dst++ = *src++;
+ 25c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 25f:	0f b6 10             	movzbl (%eax),%edx
+ 262:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 265:	88 10                	mov    %dl,(%eax)
+ 267:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 26b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+{
+  char *dst, *src;
+  
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 26f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+ 273:	0f 9f c0             	setg   %al
+ 276:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ 27a:	84 c0                	test   %al,%al
+ 27c:	75 de                	jne    25c <memmove+0x14>
+    *dst++ = *src++;
+  return vdst;
+ 27e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 281:	c9                   	leave  
+ 282:	c3                   	ret    
+ 283:	90                   	nop
+
+00000284 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 284:	b8 01 00 00 00       	mov    $0x1,%eax
+ 289:	cd 40                	int    $0x40
+ 28b:	c3                   	ret    
+
+0000028c <exit>:
+SYSCALL(exit)
+ 28c:	b8 02 00 00 00       	mov    $0x2,%eax
+ 291:	cd 40                	int    $0x40
+ 293:	c3                   	ret    
+
+00000294 <wait>:
+SYSCALL(wait)
+ 294:	b8 03 00 00 00       	mov    $0x3,%eax
+ 299:	cd 40                	int    $0x40
+ 29b:	c3                   	ret    
+
+0000029c <pipe>:
+SYSCALL(pipe)
+ 29c:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2a1:	cd 40                	int    $0x40
+ 2a3:	c3                   	ret    
+
+000002a4 <read>:
+SYSCALL(read)
+ 2a4:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2a9:	cd 40                	int    $0x40
+ 2ab:	c3                   	ret    
+
+000002ac <write>:
+SYSCALL(write)
+ 2ac:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2b1:	cd 40                	int    $0x40
+ 2b3:	c3                   	ret    
+
+000002b4 <close>:
+SYSCALL(close)
+ 2b4:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2b9:	cd 40                	int    $0x40
+ 2bb:	c3                   	ret    
+
+000002bc <kill>:
+SYSCALL(kill)
+ 2bc:	b8 06 00 00 00       	mov    $0x6,%eax
+ 2c1:	cd 40                	int    $0x40
+ 2c3:	c3                   	ret    
+
+000002c4 <exec>:
+SYSCALL(exec)
+ 2c4:	b8 07 00 00 00       	mov    $0x7,%eax
+ 2c9:	cd 40                	int    $0x40
+ 2cb:	c3                   	ret    
+
+000002cc <open>:
+SYSCALL(open)
+ 2cc:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 2d1:	cd 40                	int    $0x40
+ 2d3:	c3                   	ret    
+
+000002d4 <mknod>:
+SYSCALL(mknod)
+ 2d4:	b8 11 00 00 00       	mov    $0x11,%eax
+ 2d9:	cd 40                	int    $0x40
+ 2db:	c3                   	ret    
+
+000002dc <unlink>:
+SYSCALL(unlink)
+ 2dc:	b8 12 00 00 00       	mov    $0x12,%eax
+ 2e1:	cd 40                	int    $0x40
+ 2e3:	c3                   	ret    
+
+000002e4 <fstat>:
+SYSCALL(fstat)
+ 2e4:	b8 08 00 00 00       	mov    $0x8,%eax
+ 2e9:	cd 40                	int    $0x40
+ 2eb:	c3                   	ret    
+
+000002ec <link>:
+SYSCALL(link)
+ 2ec:	b8 13 00 00 00       	mov    $0x13,%eax
+ 2f1:	cd 40                	int    $0x40
+ 2f3:	c3                   	ret    
+
+000002f4 <mkdir>:
+SYSCALL(mkdir)
+ 2f4:	b8 14 00 00 00       	mov    $0x14,%eax
+ 2f9:	cd 40                	int    $0x40
+ 2fb:	c3                   	ret    
+
+000002fc <chdir>:
+SYSCALL(chdir)
+ 2fc:	b8 09 00 00 00       	mov    $0x9,%eax
+ 301:	cd 40                	int    $0x40
+ 303:	c3                   	ret    
+
+00000304 <dup>:
+SYSCALL(dup)
+ 304:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 309:	cd 40                	int    $0x40
+ 30b:	c3                   	ret    
+
+0000030c <getpid>:
+SYSCALL(getpid)
+ 30c:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 311:	cd 40                	int    $0x40
+ 313:	c3                   	ret    
+
+00000314 <sbrk>:
+SYSCALL(sbrk)
+ 314:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 319:	cd 40                	int    $0x40
+ 31b:	c3                   	ret    
+
+0000031c <sleep>:
+SYSCALL(sleep)
+ 31c:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 321:	cd 40                	int    $0x40
+ 323:	c3                   	ret    
+
+00000324 <uptime>:
+SYSCALL(uptime)
+ 324:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 329:	cd 40                	int    $0x40
+ 32b:	c3                   	ret    
+
+0000032c <enable_sched_trace>:
+SYSCALL(enable_sched_trace)
+ 32c:	b8 16 00 00 00       	mov    $0x16,%eax
+ 331:	cd 40                	int    $0x40
+ 333:	c3                   	ret    
+
+00000334 <shutdown>:
+SYSCALL(shutdown)
+ 334:	b8 17 00 00 00       	mov    $0x17,%eax
+ 339:	cd 40                	int    $0x40
+ 33b:	c3                   	ret    
+
+0000033c <fork_winner>:
+SYSCALL(fork_winner)
+ 33c:	b8 18 00 00 00       	mov    $0x18,%eax
+ 341:	cd 40                	int    $0x40
+ 343:	c3                   	ret    
+
+00000344 <set_sched>:
+SYSCALL(set_sched)
+ 344:	b8 19 00 00 00       	mov    $0x19,%eax
+ 349:	cd 40                	int    $0x40
+ 34b:	c3                   	ret    
+
+0000034c <set_priority>:
+SYSCALL(set_priority)
+ 34c:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 351:	cd 40                	int    $0x40
+ 353:	c3                   	ret    
+
+00000354 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 354:	55                   	push   %ebp
+ 355:	89 e5                	mov    %esp,%ebp
+ 357:	83 ec 28             	sub    $0x28,%esp
+ 35a:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 35d:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 360:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+ 367:	00 
+ 368:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 36b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 36f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 372:	89 04 24             	mov    %eax,(%esp)
+ 375:	e8 32 ff ff ff       	call   2ac <write>
+}
+ 37a:	c9                   	leave  
+ 37b:	c3                   	ret    
+
+0000037c <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 37c:	55                   	push   %ebp
+ 37d:	89 e5                	mov    %esp,%ebp
+ 37f:	83 ec 48             	sub    $0x48,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 382:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 389:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 38d:	74 17                	je     3a6 <printint+0x2a>
+ 38f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 393:	79 11                	jns    3a6 <printint+0x2a>
+    neg = 1;
+ 395:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 39c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 39f:	f7 d8                	neg    %eax
+ 3a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3a4:	eb 06                	jmp    3ac <printint+0x30>
+  } else {
+    x = xx;
+ 3a6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 3ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 3b3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 3b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3b9:	ba 00 00 00 00       	mov    $0x0,%edx
+ 3be:	f7 f1                	div    %ecx
+ 3c0:	89 d0                	mov    %edx,%eax
+ 3c2:	0f b6 80 44 0a 00 00 	movzbl 0xa44(%eax),%eax
+ 3c9:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+ 3cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 3cf:	01 ca                	add    %ecx,%edx
+ 3d1:	88 02                	mov    %al,(%edx)
+ 3d3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  }while((x /= base) != 0);
+ 3d7:	8b 55 10             	mov    0x10(%ebp),%edx
+ 3da:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+ 3dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3e0:	ba 00 00 00 00       	mov    $0x0,%edx
+ 3e5:	f7 75 d4             	divl   -0x2c(%ebp)
+ 3e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 3ef:	75 c2                	jne    3b3 <printint+0x37>
+  if(neg)
+ 3f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 3f5:	74 2e                	je     425 <printint+0xa9>
+    buf[i++] = '-';
+ 3f7:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 3fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 3fd:	01 d0                	add    %edx,%eax
+ 3ff:	c6 00 2d             	movb   $0x2d,(%eax)
+ 402:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  while(--i >= 0)
+ 406:	eb 1d                	jmp    425 <printint+0xa9>
+    putc(fd, buf[i]);
+ 408:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 40b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 40e:	01 d0                	add    %edx,%eax
+ 410:	0f b6 00             	movzbl (%eax),%eax
+ 413:	0f be c0             	movsbl %al,%eax
+ 416:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 41a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 41d:	89 04 24             	mov    %eax,(%esp)
+ 420:	e8 2f ff ff ff       	call   354 <putc>
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+ 425:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 429:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 42d:	79 d9                	jns    408 <printint+0x8c>
+    putc(fd, buf[i]);
+}
+ 42f:	c9                   	leave  
+ 430:	c3                   	ret    
+
+00000431 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+ 431:	55                   	push   %ebp
+ 432:	89 e5                	mov    %esp,%ebp
+ 434:	83 ec 38             	sub    $0x38,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 437:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 43e:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 441:	83 c0 04             	add    $0x4,%eax
+ 444:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 447:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 44e:	e9 7d 01 00 00       	jmp    5d0 <printf+0x19f>
+    c = fmt[i] & 0xff;
+ 453:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 456:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 459:	01 d0                	add    %edx,%eax
+ 45b:	0f b6 00             	movzbl (%eax),%eax
+ 45e:	0f be c0             	movsbl %al,%eax
+ 461:	25 ff 00 00 00       	and    $0xff,%eax
+ 466:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 469:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 46d:	75 2c                	jne    49b <printf+0x6a>
+      if(c == '%'){
+ 46f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 473:	75 0c                	jne    481 <printf+0x50>
+        state = '%';
+ 475:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 47c:	e9 4b 01 00 00       	jmp    5cc <printf+0x19b>
+      } else {
+        putc(fd, c);
+ 481:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 484:	0f be c0             	movsbl %al,%eax
+ 487:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 48b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 48e:	89 04 24             	mov    %eax,(%esp)
+ 491:	e8 be fe ff ff       	call   354 <putc>
+ 496:	e9 31 01 00 00       	jmp    5cc <printf+0x19b>
+      }
+    } else if(state == '%'){
+ 49b:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 49f:	0f 85 27 01 00 00    	jne    5cc <printf+0x19b>
+      if(c == 'd'){
+ 4a5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 4a9:	75 2d                	jne    4d8 <printf+0xa7>
+        printint(fd, *ap, 10, 1);
+ 4ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4ae:	8b 00                	mov    (%eax),%eax
+ 4b0:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+ 4b7:	00 
+ 4b8:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+ 4bf:	00 
+ 4c0:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4c4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4c7:	89 04 24             	mov    %eax,(%esp)
+ 4ca:	e8 ad fe ff ff       	call   37c <printint>
+        ap++;
+ 4cf:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 4d3:	e9 ed 00 00 00       	jmp    5c5 <printf+0x194>
+      } else if(c == 'x' || c == 'p'){
+ 4d8:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 4dc:	74 06                	je     4e4 <printf+0xb3>
+ 4de:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 4e2:	75 2d                	jne    511 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+ 4e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4e7:	8b 00                	mov    (%eax),%eax
+ 4e9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+ 4f0:	00 
+ 4f1:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+ 4f8:	00 
+ 4f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 4fd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 500:	89 04 24             	mov    %eax,(%esp)
+ 503:	e8 74 fe ff ff       	call   37c <printint>
+        ap++;
+ 508:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 50c:	e9 b4 00 00 00       	jmp    5c5 <printf+0x194>
+      } else if(c == 's'){
+ 511:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 515:	75 46                	jne    55d <printf+0x12c>
+        s = (char*)*ap;
+ 517:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 51a:	8b 00                	mov    (%eax),%eax
+ 51c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 51f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 523:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 527:	75 27                	jne    550 <printf+0x11f>
+          s = "(null)";
+ 529:	c7 45 f4 01 08 00 00 	movl   $0x801,-0xc(%ebp)
+        while(*s != 0){
+ 530:	eb 1e                	jmp    550 <printf+0x11f>
+          putc(fd, *s);
+ 532:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 535:	0f b6 00             	movzbl (%eax),%eax
+ 538:	0f be c0             	movsbl %al,%eax
+ 53b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 53f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 542:	89 04 24             	mov    %eax,(%esp)
+ 545:	e8 0a fe ff ff       	call   354 <putc>
+          s++;
+ 54a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 54e:	eb 01                	jmp    551 <printf+0x120>
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+ 550:	90                   	nop
+ 551:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 554:	0f b6 00             	movzbl (%eax),%eax
+ 557:	84 c0                	test   %al,%al
+ 559:	75 d7                	jne    532 <printf+0x101>
+ 55b:	eb 68                	jmp    5c5 <printf+0x194>
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 55d:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 561:	75 1d                	jne    580 <printf+0x14f>
+        putc(fd, *ap);
+ 563:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 566:	8b 00                	mov    (%eax),%eax
+ 568:	0f be c0             	movsbl %al,%eax
+ 56b:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 56f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 572:	89 04 24             	mov    %eax,(%esp)
+ 575:	e8 da fd ff ff       	call   354 <putc>
+        ap++;
+ 57a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 57e:	eb 45                	jmp    5c5 <printf+0x194>
+      } else if(c == '%'){
+ 580:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 584:	75 17                	jne    59d <printf+0x16c>
+        putc(fd, c);
+ 586:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 589:	0f be c0             	movsbl %al,%eax
+ 58c:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 590:	8b 45 08             	mov    0x8(%ebp),%eax
+ 593:	89 04 24             	mov    %eax,(%esp)
+ 596:	e8 b9 fd ff ff       	call   354 <putc>
+ 59b:	eb 28                	jmp    5c5 <printf+0x194>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 59d:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+ 5a4:	00 
+ 5a5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5a8:	89 04 24             	mov    %eax,(%esp)
+ 5ab:	e8 a4 fd ff ff       	call   354 <putc>
+        putc(fd, c);
+ 5b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5b3:	0f be c0             	movsbl %al,%eax
+ 5b6:	89 44 24 04          	mov    %eax,0x4(%esp)
+ 5ba:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5bd:	89 04 24             	mov    %eax,(%esp)
+ 5c0:	e8 8f fd ff ff       	call   354 <putc>
+      }
+      state = 0;
+ 5c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 5cc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 5d0:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 5d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 5d6:	01 d0                	add    %edx,%eax
+ 5d8:	0f b6 00             	movzbl (%eax),%eax
+ 5db:	84 c0                	test   %al,%al
+ 5dd:	0f 85 70 fe ff ff    	jne    453 <printf+0x22>
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
+ 5e3:	c9                   	leave  
+ 5e4:	c3                   	ret    
+ 5e5:	90                   	nop
+ 5e6:	90                   	nop
+ 5e7:	90                   	nop
+
+000005e8 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 5e8:	55                   	push   %ebp
+ 5e9:	89 e5                	mov    %esp,%ebp
+ 5eb:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 5ee:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5f1:	83 e8 08             	sub    $0x8,%eax
+ 5f4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 5f7:	a1 60 0a 00 00       	mov    0xa60,%eax
+ 5fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 5ff:	eb 24                	jmp    625 <free+0x3d>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 601:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 604:	8b 00                	mov    (%eax),%eax
+ 606:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 609:	77 12                	ja     61d <free+0x35>
+ 60b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 60e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 611:	77 24                	ja     637 <free+0x4f>
+ 613:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 616:	8b 00                	mov    (%eax),%eax
+ 618:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 61b:	77 1a                	ja     637 <free+0x4f>
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 61d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 620:	8b 00                	mov    (%eax),%eax
+ 622:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 625:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 628:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 62b:	76 d4                	jbe    601 <free+0x19>
+ 62d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 630:	8b 00                	mov    (%eax),%eax
+ 632:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 635:	76 ca                	jbe    601 <free+0x19>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 637:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 63a:	8b 40 04             	mov    0x4(%eax),%eax
+ 63d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 644:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 647:	01 c2                	add    %eax,%edx
+ 649:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 64c:	8b 00                	mov    (%eax),%eax
+ 64e:	39 c2                	cmp    %eax,%edx
+ 650:	75 24                	jne    676 <free+0x8e>
+    bp->s.size += p->s.ptr->s.size;
+ 652:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 655:	8b 50 04             	mov    0x4(%eax),%edx
+ 658:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65b:	8b 00                	mov    (%eax),%eax
+ 65d:	8b 40 04             	mov    0x4(%eax),%eax
+ 660:	01 c2                	add    %eax,%edx
+ 662:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 665:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 668:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 66b:	8b 00                	mov    (%eax),%eax
+ 66d:	8b 10                	mov    (%eax),%edx
+ 66f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 672:	89 10                	mov    %edx,(%eax)
+ 674:	eb 0a                	jmp    680 <free+0x98>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 676:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 679:	8b 10                	mov    (%eax),%edx
+ 67b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 67e:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 680:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 683:	8b 40 04             	mov    0x4(%eax),%eax
+ 686:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 68d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 690:	01 d0                	add    %edx,%eax
+ 692:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+ 695:	75 20                	jne    6b7 <free+0xcf>
+    p->s.size += bp->s.size;
+ 697:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 69a:	8b 50 04             	mov    0x4(%eax),%edx
+ 69d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6a0:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a3:	01 c2                	add    %eax,%edx
+ 6a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a8:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ae:	8b 10                	mov    (%eax),%edx
+ 6b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b3:	89 10                	mov    %edx,(%eax)
+ 6b5:	eb 08                	jmp    6bf <free+0xd7>
+  } else
+    p->s.ptr = bp;
+ 6b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ba:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 6bd:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 6bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c2:	a3 60 0a 00 00       	mov    %eax,0xa60
+}
+ 6c7:	c9                   	leave  
+ 6c8:	c3                   	ret    
+
+000006c9 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 6c9:	55                   	push   %ebp
+ 6ca:	89 e5                	mov    %esp,%ebp
+ 6cc:	83 ec 28             	sub    $0x28,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 6cf:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 6d6:	77 07                	ja     6df <morecore+0x16>
+    nu = 4096;
+ 6d8:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 6df:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6e2:	c1 e0 03             	shl    $0x3,%eax
+ 6e5:	89 04 24             	mov    %eax,(%esp)
+ 6e8:	e8 27 fc ff ff       	call   314 <sbrk>
+ 6ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 6f0:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 6f4:	75 07                	jne    6fd <morecore+0x34>
+    return 0;
+ 6f6:	b8 00 00 00 00       	mov    $0x0,%eax
+ 6fb:	eb 22                	jmp    71f <morecore+0x56>
+  hp = (Header*)p;
+ 6fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 700:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 703:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 706:	8b 55 08             	mov    0x8(%ebp),%edx
+ 709:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 70c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 70f:	83 c0 08             	add    $0x8,%eax
+ 712:	89 04 24             	mov    %eax,(%esp)
+ 715:	e8 ce fe ff ff       	call   5e8 <free>
+  return freep;
+ 71a:	a1 60 0a 00 00       	mov    0xa60,%eax
+}
+ 71f:	c9                   	leave  
+ 720:	c3                   	ret    
+
+00000721 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 721:	55                   	push   %ebp
+ 722:	89 e5                	mov    %esp,%ebp
+ 724:	83 ec 28             	sub    $0x28,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 727:	8b 45 08             	mov    0x8(%ebp),%eax
+ 72a:	83 c0 07             	add    $0x7,%eax
+ 72d:	c1 e8 03             	shr    $0x3,%eax
+ 730:	83 c0 01             	add    $0x1,%eax
+ 733:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 736:	a1 60 0a 00 00       	mov    0xa60,%eax
+ 73b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 73e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 742:	75 23                	jne    767 <malloc+0x46>
+    base.s.ptr = freep = prevp = &base;
+ 744:	c7 45 f0 58 0a 00 00 	movl   $0xa58,-0x10(%ebp)
+ 74b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 74e:	a3 60 0a 00 00       	mov    %eax,0xa60
+ 753:	a1 60 0a 00 00       	mov    0xa60,%eax
+ 758:	a3 58 0a 00 00       	mov    %eax,0xa58
+    base.s.size = 0;
+ 75d:	c7 05 5c 0a 00 00 00 	movl   $0x0,0xa5c
+ 764:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 767:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 76a:	8b 00                	mov    (%eax),%eax
+ 76c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 76f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 772:	8b 40 04             	mov    0x4(%eax),%eax
+ 775:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 778:	72 4d                	jb     7c7 <malloc+0xa6>
+      if(p->s.size == nunits)
+ 77a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 77d:	8b 40 04             	mov    0x4(%eax),%eax
+ 780:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+ 783:	75 0c                	jne    791 <malloc+0x70>
+        prevp->s.ptr = p->s.ptr;
+ 785:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 788:	8b 10                	mov    (%eax),%edx
+ 78a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 78d:	89 10                	mov    %edx,(%eax)
+ 78f:	eb 26                	jmp    7b7 <malloc+0x96>
+      else {
+        p->s.size -= nunits;
+ 791:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 794:	8b 40 04             	mov    0x4(%eax),%eax
+ 797:	89 c2                	mov    %eax,%edx
+ 799:	2b 55 ec             	sub    -0x14(%ebp),%edx
+ 79c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 79f:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7a5:	8b 40 04             	mov    0x4(%eax),%eax
+ 7a8:	c1 e0 03             	shl    $0x3,%eax
+ 7ab:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 7ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7b1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 7b4:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 7b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7ba:	a3 60 0a 00 00       	mov    %eax,0xa60
+      return (void*)(p + 1);
+ 7bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7c2:	83 c0 08             	add    $0x8,%eax
+ 7c5:	eb 38                	jmp    7ff <malloc+0xde>
+    }
+    if(p == freep)
+ 7c7:	a1 60 0a 00 00       	mov    0xa60,%eax
+ 7cc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 7cf:	75 1b                	jne    7ec <malloc+0xcb>
+      if((p = morecore(nunits)) == 0)
+ 7d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 7d4:	89 04 24             	mov    %eax,(%esp)
+ 7d7:	e8 ed fe ff ff       	call   6c9 <morecore>
+ 7dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 7df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 7e3:	75 07                	jne    7ec <malloc+0xcb>
+        return 0;
+ 7e5:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7ea:	eb 13                	jmp    7ff <malloc+0xde>
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f5:	8b 00                	mov    (%eax),%eax
+ 7f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+ 7fa:	e9 70 ff ff ff       	jmp    76f <malloc+0x4e>
+}
+ 7ff:	c9                   	leave  
+ 800:	c3                   	ret    
diff -uNr cs550-16s-proj1-base/zombie.d cs550-16s-proj1-working/zombie.d
--- cs550-16s-proj1-base/zombie.d	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/zombie.d	2016-03-04 14:37:10.000000000 -0500
@@ -0,0 +1 @@
+zombie.o: zombie.c types.h stat.h user.h
Binary files cs550-16s-proj1-base/zombie.o and cs550-16s-proj1-working/zombie.o differ
diff -uNr cs550-16s-proj1-base/zombie.sym cs550-16s-proj1-working/zombie.sym
--- cs550-16s-proj1-base/zombie.sym	1969-12-31 19:00:00.000000000 -0500
+++ cs550-16s-proj1-working/zombie.sym	2016-03-04 14:37:10.000000000 -0500
@@ -0,0 +1,65 @@
+00000000 .text
+00000801 .rodata
+00000808 .eh_frame
+00000a44 .data
+00000a58 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 zombie.c
+00000000 ulib.c
+00000024 stosb
+00000000 printf.c
+00000354 putc
+0000037c printint
+00000a44 digits.1028
+00000000 umalloc.c
+00000a58 base
+00000a60 freep
+000006c9 morecore
+00000049 strcpy
+00000431 printf
+00000248 memmove
+000002d4 mknod
+0000013c gets
+0000030c getpid
+00000721 malloc
+0000031c sleep
+0000034c set_priority
+0000029c pipe
+000002ac write
+000002e4 fstat
+000002bc kill
+000002fc chdir
+000002c4 exec
+00000294 wait
+000002a4 read
+000002dc unlink
+00000284 fork
+00000314 sbrk
+00000324 uptime
+00000a58 __bss_start
+000000e5 memset
+00000000 main
+0000032c enable_sched_trace
+0000007d strcmp
+00000334 shutdown
+00000304 dup
+00000344 set_sched
+000001af stat
+00000a58 _edata
+00000a64 _end
+000002ec link
+0000028c exit
+000001fd atoi
+0000033c fork_winner
+000000be strlen
+000002cc open
+00000109 strchr
+000002f4 mkdir
+000002b4 close
+000005e8 free
